<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-01-21T03:10:11.438Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【2021】总结</title>
    <link href="http://yoursite.com/2022/01/18/362/"/>
    <id>http://yoursite.com/2022/01/18/362/</id>
    <published>2022-01-18T02:01:22.437Z</published>
    <updated>2022-01-21T03:10:11.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2021总结"><a href="#2021总结" class="headerlink" title="2021总结"></a>2021总结</h3><p>过往的年终总结如下:</p><ul><li><a href="http://mikemeng.org/2020/01/02/118/" target="_blank" rel="noopener">2019年总结</a></li><li><a href="http://mikemeng.org/2020/07/05/177/" target="_blank" rel="noopener">2020年下半年计划</a></li><li><a href="https://mike-box.github.io/2021/01/03/239/" target="_blank" rel="noopener">2020年年终总结</a><h4 id="生活流水账"><a href="#生活流水账" class="headerlink" title="生活流水账"></a>生活流水账</h4><h4 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h4></li></ul><h4 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h4><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><h4 id="读书学习"><a href="#读书学习" class="headerlink" title="读书学习"></a>读书学习</h4><h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2021总结&quot;&gt;&lt;a href=&quot;#2021总结&quot; class=&quot;headerlink&quot; title=&quot;2021总结&quot;&gt;&lt;/a&gt;2021总结&lt;/h3&gt;&lt;p&gt;过往的年终总结如下:&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://mikemeng.org/20
      
    
    </summary>
    
    
      <category term="职场" scheme="http://yoursite.com/categories/%E8%81%8C%E5%9C%BA/"/>
    
    
      <category term="职场经验" scheme="http://yoursite.com/tags/%E8%81%8C%E5%9C%BA%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>【Clickhouse】 Clickhouse学习记录(一)</title>
    <link href="http://yoursite.com/2022/01/18/361/"/>
    <id>http://yoursite.com/2022/01/18/361/</id>
    <published>2022-01-18T01:53:06.343Z</published>
    <updated>2022-01-21T02:59:27.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="clickhouse学习记录（一）"><a href="#clickhouse学习记录（一）" class="headerlink" title="clickhouse学习记录（一）"></a>clickhouse学习记录（一）</h1><p>最近因为工作原因,开始尝试学习<code>clickhouse</code>数据库, 将会逐渐将<code>clickhouse</code>的一些学习总结记录下来, 作为自己的学习历程.</p><h2 id="clickhouse的简介"><a href="#clickhouse的简介" class="headerlink" title="clickhouse的简介"></a>clickhouse的简介</h2><p><strong>项目起源</strong><br><code>clickhouse</code>是由俄罗斯的一家互联网公司 <code>Yandex</code> 开发的,  <code>Yandex</code> 主要从事互联网分析，<code>Yandex</code> 使用 <code>clickhouse</code> 从事海量的互联网的流量分析，<code>clickhouse</code> 作为 <code>Yandex</code> 公司内部使用的项目, 后来走向开源． <code>clickhouse</code> 作为 <code>OLAP</code> 领域的流行, 主要得益于其出色的性能.<br>数据库领域有两个概念:</p><a id="more"></a><ul><li><p><code>OLTP</code>: on-line transaction processing翻译为联机事务处理, <code>OLTP</code>是主要从事事务处理, 包括数据库常见的增删改.<code>OLTP</code>主要用来记录某类业务事件的发生，如购买行为，当行为产生后，系统会记录是谁在何时何地做了何事，这样的一行（或多行）数据会以增删改的方式在数据库中进行数据的更新处理操作，要求实时性高、稳定性强、确保数据及时更新成功，像公司常见的业务系统如<code>ERP</code>，<code>CRM</code>，<code>OA</code>等系统都属于<code>OLTP</code>.</p></li><li><p><code>OLAP</code>: On-Line Analytical Processing翻译为联机分析处理, <code>OLAP</code>是主要侧重于数据分析和查询, 主要侧重的功能是数据库的查询.当数据积累到一定的程度，我们需要对过去发生的事情做一个总结分析时，就需要把过去一段时间内产生的数据拿出来进行统计分析，从中获取我们想要的信息，为公司做决策提供支持，这时候就是在做<code>OLAP</code>了。</p></li><li><p>数据仓库: 因为<code>OLTP</code>所产生的业务数据分散在不同的业务系统中，而<code>OLAP</code>往往需要将不同的业务数据集中到一起进行统一综合的分析，这时候就需要根据业务分析需求做对应的数据清洗后存储在数据仓库中，然后由数据仓库来统一提供<code>OLAP</code>分析。所以我们常说<code>OLTP</code>是数据库的应用，<code>OLAP</code>是数据仓库的应用。<br>详细可以参考知乎的<a href="https://www.zhihu.com/question/24110442/answer/851671343" target="_blank" rel="noopener">回答</a></p></li></ul><p><strong>clickhouse的特性</strong><br><code>clickhouse</code> 采用列式存储, 所有的数据都是以列为单位进行组织和存储的, <code>clickhouse</code>的最大的特色就是以性能著称, 官方的文档也给出了相关的<a href="https://clickhouse.com/benchmark/dbms/" target="_blank" rel="noopener">性能对比</a>.<code>clickhouse</code>的特性:</p><ul><li>以列为存储, 同一列的数据格式统一, 方便使用数据压缩算法. 目前<code>clickhouse</code> 使用的<code>LZ4</code> 压缩算法. 数据压缩可以带来两个好处, 数据存储的空间较小从而读写磁盘花费时间较短, 网络传输中也会较少缓存时间.</li><li><code>ClickHouse</code>允许在运行时创建表和数据库、加载数据和运行查询，而无需重新配置或重启服务。具有完成的数据库管理系统的功能.</li><li>多核心并行处理, 充分利用<code>CPU</code>的资源, 设计时针对具体的硬件进行充分优化, 从而提升性能. 看到字符串搜索中竟然用到了<code>intel hyperscan</code>, 这个是<code>dpi</code>设备里面常用的字符串搜索算法. 支持<code>CPU</code> 的<code>SIMD</code>指令, 可以向量执行数据的处理和读取.</li><li>支持多服务器分布式处理, 支持分布式查询, 可以进行负载均衡.</li><li>实时的数据更新, 为了使查询能够快速在主键中进行范围查找，数据总是以增量的方式有序的存储在<code>MergeTree</code>中。因此，数据可以持续不断地高效的写入到表中，并且写入的过程中不会存在任何加锁的行为。</li><li><code>click house</code>中的很多优化技巧都值得仔细学习和琢磨. </li></ul><h3 id="clickhouse的不足之处"><a href="#clickhouse的不足之处" class="headerlink" title="clickhouse的不足之处"></a>clickhouse的不足之处</h3><p><code>clickhouse</code> 主要用于数据分析, 也有许多缺点.</p><ul><li>不支持事务<code>ACID</code>。</li><li>缺少高频率，低延迟的修改或删除已存在数据的能力,以行进行更新数据的话性能较差.。</li><li>稀疏索引使得<code>ClickHouse</code>不适合通过其键检索单行的点查询。<h3 id="clickhouse的发展现状"><a href="#clickhouse的发展现状" class="headerlink" title="clickhouse的发展现状"></a>clickhouse的发展现状</h3><code>click</code> 以其出色的性能, 目前在很多很多<code>BI</code>领域得到应用, 还有许多广告流量，<code>web</code>分析, 电子商务等领域. 以下为常见的几个学习的资源库:</li><li><code>clickhouse</code>文档: <a href="https://clickhouse.com/docs/zh/" target="_blank" rel="noopener">https://clickhouse.com/docs/zh/</a></li><li><code>clickhouse</code>repo: <a href="https://github.com/ClickHouse/ClickHouse" target="_blank" rel="noopener">https://github.com/ClickHouse/ClickHouse</a></li><li><code>clickhouse</code>中文社区: <a href="http://www.clickhouse.com.cn/" target="_blank" rel="noopener">http://www.clickhouse.com.cn/</a></li><li><code>clickhouse</code>官方:<a href="https://clickhouse.com/" target="_blank" rel="noopener">https://clickhouse.com/</a></li></ul><h2 id="clickhouse的安装部署"><a href="#clickhouse的安装部署" class="headerlink" title="clickhouse的安装部署"></a>clickhouse的安装部署</h2><ul><li><code>server</code>安装:官方提供的<code>guide</code>有许多种安装方式, 强烈推荐使用<code>apt-get</code>或者<code>yum</code>这种标准安装包的形式来安装,会自动更新和下载各种库, 自己可以下载源码,然后编译到本地进行安装, 机器性能太差, 编译实践太长, 中间容易经历各种坑,新手强烈不推荐. 安装过程踩过的坑是, 直接下载官方提供的编译好的库和程序, <code>windows</code>自带的<code>wsl</code>安装后反正各种莫名奇妙的问题，各种莫名奇妙的<code>abort</code>退出, 也找不到问题原因所在, 反而远程的<code>VPS</code>安装一次就顺利.</li><li><code>config</code> 文件说明: 默认的<code>config</code> 文件会存放在<code>/etc/clickhouse-server/config.xml</code>目录下, 安装完成之后需要进行修改, 当然默认的<code>clickhouse server</code> 只监听在本地<code>127.0.0.1</code>, 需要进行修改使得它可以接受所有外部的主机发起的<code>tcp</code>请求. 高级的配置文件参数定义可以参考官方的文档:<a href="https://clickhouse.com/docs/zh/operations/configuration-files/" target="_blank" rel="noopener">配置文件</a>. <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--允许所有的ipv6的请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen_host</span>&gt;</span>::<span class="tag">&lt;/<span class="name">listen_host</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--允许所有的ipv4的请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen_host</span>&gt;</span>0.0.0.0<span class="tag">&lt;/<span class="name">listen_host</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>server</code>启动与测试: 直接执行<code>clickhouse-server</code>时, 会提示要求创建<code>clickhouse:clickhouse</code>账户, 建议直接使用脚本启动服务，<code>root</code>账户启动即可，需要修改配置文件，默认要求使用<code>clickhouse</code>的用户名.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service clickhouse-server start</span><br></pre></td></tr></table></figure><p>查看进程：<br><img src="https://s2.loli.net/2022/01/18/iqTxDBH9Jw4okfU.png" alt><br>查看端口：<br><img src="https://s2.loli.net/2022/01/18/Zq2fsLAWYcuOQiH.png" alt></p></li><li><p><code>vps firewall</code>设置: 直接将<code>centos</code>的防火墙关掉, 由于是远程<code>VPS</code>需要设置端口号, 允许<code>clickhouse</code>服务通行:<br><img src="https://s2.loli.net/2022/01/18/IvoVqjZEpU69GMC.png" alt></p><h2 id="clickhouse的使用测试"><a href="#clickhouse的使用测试" class="headerlink" title="clickhouse的使用测试"></a>clickhouse的使用测试</h2><p>我们可以通过<code>clickhouse</code>自带的<code>clickhouse-client</code>程序来本地或者远程访问<code>clickhouse server</code>, 尝试以下数据库的基本操作:</p></li><li>连接数据库<code>server</code>: <code>clickhouse-client</code>默认就会连接本地的<code>clickhouse</code>的数据库<code>server</code>, 我们尝试连接远程的<code>vps</code>, <code>clickhouse-client --host=x.x.x.x</code>即可连接指定<code>ip</code>的数据库。<code>clickhouse-client --query=&#39;xx&#39;</code>即可执行<code>query</code>中<code>sql</code>语句.</li><li>创建数据库: 创建<code>test</code>数据库, <code>clickhouse-client --query=&#39;CREATE DATABASE IF NOT EXISTS test&#39;</code>.</li><li>创建表项: 创建<code>numbers</code>表项, <code>clickhouse-client --query=&#39;CREATE TABLE IF NOT EXISTS test.numbers (id UInt64, name String) ENGINE = Memory&#39;</code>.</li><li>插入表项: 插入<code>numbers</code>行, <code>clickhouse-client --query=&#39;INSERT INTO test.numbers VALUES (100, &#39;mengmingliang&#39;)&#39;</code>.</li><li>删除表项: 删除<code>numbers</code>行, <code>clickhouse-client --query=&#39;INSERT INTO test.numbers VALUES (100, &#39;mengmingliang&#39;)&#39;</code>.</li><li>查询表项: 查询基本的表，<code>clickhouse-client --query=&#39;SELECT id, name FROM test.numbers&#39;</code>;</li><li>删除数据表项: 删除<code>numbers</code>表, <code>DROP TABLE test.numbers</code>.</li></ul><h2 id="clickhouse-client的连接接口测试"><a href="#clickhouse-client的连接接口测试" class="headerlink" title="clickhouse client的连接接口测试"></a>clickhouse client的连接接口测试</h2><p><code>clickhouse</code>提供了多种通用的接口用来连接和操作数据, 提供了<code>http</code>和<code>tcp</code>的两种访问接口形式，<code>http</code>的访问端口为<code>8123</code>, <code>tcp</code>的端口为<code>9000</code>, 我们可以在浏览器中输入<code>http://localhost:8123</code>就会打印出<code>ok</code>, 浏览器中输入<code>http://localhost:8123/?query=SELECT%201</code>就会返回查询结果. <code>http</code>的接口主要用于<code>Java</code>的开发,我们可以使用标准的<code>jdbc</code>来访问数据库, HTTP接口比原生接口受到更多的限制，但它具有更好的兼容性.<code>tcp</code>端口主要用于服务器间的通讯查询和管理，同时也支持数据库的查询，比<code>http</code>的接口会更加灵活使用, 官方目前只提供了标准的<code>C++</code>接口, 这种接口目前没有标准, 但是我能想到的是很容易对这些接口来进行扩展, 从而来对<code>clickhouse</code>增加新的功能和特性,这点确实不错, 为程序的灵活性做了更多的扩展.</p><ul><li>通过<code>C++</code>接口测试: 我们可以下载官方提供的标准的<code>C++</code>的接口<a href="https://github.com/ClickHouse/clickhouse-cpp" target="_blank" rel="noopener">CPP</a>, 下载之后进行编译, 需要注意的是由于<code>clickhouse</code>是用<code>C++17</code>的标准编写的, 需要升级本地的<code>gcc</code>程序支持<code>C++ 17</code>.编译完成之后发现支持静态链接库, 手动写个简单<code>makefile</code>, 测试跑了一遍, 还算比较正常. 下一步需要走读和分析一下<code>clinet</code>的代码, 熟悉一下原理, 尝试一下后面是否有扩展的可能性, 示例代码放在<a href="https://github.com/mike-box/datdabasestudy/tree/main/clickhouse/proj" target="_blank" rel="noopener">github</a>.</li><li>通过<code>Python</code>接口测试: <code>python</code>的接口不是官方团队提供是, 是由第三方提供的代码, 目前尝试了一下<code>clickhouse-driver</code>这个第三方的库, 很多功能都没有深入尝试, 后面有时间时需要进行深入的探索.</li><li>通过<code>DBeaver</code>接口测试: 下载尝试了一下通过可户端去连接<code>clickhouse</code>, 用<code>Gui</code>的客户端确实方便很多, 可以通过标准的<code>jdbc</code>接口去连接数据库, 需要下载<code>clickhouse</code>的驱动,我们可以很方便的访问数据库.可以直接执行标准的<code>sql</code>语句. 可以直接通过接口导入和导出数据, 确实比用纯粹的程序实现要方便许多.<br><img src="https://s2.loli.net/2022/01/18/hjsSX97RMxn6tHK.png" alt></li></ul><h2 id="clickhouse-client的高级特性尝试"><a href="#clickhouse-client的高级特性尝试" class="headerlink" title="clickhouse client的高级特性尝试"></a>clickhouse client的高级特性尝试</h2><ol><li>创建数据库: <code>CREATE DATABASE IF NOT EXISTS db_name [ENGINE = engine]</code><ul><li><code>Ordinary</code>：默认引擎，在绝大多数情况下我们都会使用默认引擎，使用时无须刻意声明。在此数据库下可以使用任意类型的表引擎。</li><li><code>Dictionary</code>：字典引擎，此类数据库会自动为所有数据字典创建它们的数据表，关于数据字典的详细介绍会在第5章展开。</li><li><code>Memory</code>：内存引擎，用于存放临时数据。此类数据库下的数据表只会停留在内存中，不会涉及任何磁盘操作，当服务重启后数据会被清除。</li><li><code>Lazy</code>：日志引擎，此类数据库下只能使用<code>Log</code>系列的表引擎，关于<code>Log</code>表引擎的详细介绍会在第8章展开。</li><li><code>MySQL</code>：<code>MySQL</code>引擎，此类数据库下会自动拉取远端<code>MySQL</code>中的数据，并为它们创建<code>MySQL</code>表引擎的数据表</li></ul></li></ol><h2 id="进一步打算"><a href="#进一步打算" class="headerlink" title="进一步打算"></a>进一步打算</h2><ul><li><ol><li>学习<code>SQL</code>的高级语法基础知识以及数据库的高级一些理论知识，进行理论基础知识补充。</li></ol></li><li><ol><li><code>clickhouse</code>中文社区中找一些经典的入门资料进行学习，学习相关书籍<a href="https://read.douban.com/reader/ebook/149635956/" target="_blank" rel="noopener">clickhouse原理解析与应用实践</a>。</li></ol></li><li><ol><li>熟悉和掌握实际业务中常用的<code>clickhouse</code>的高级特性和功能，并掌握背后的相关原理。</li></ol></li><li><ol><li>相关业务知识和语言技能的掌握，熟悉相关的<code>JAVA/C++</code> 关于操作数据库的接口<code>api</code>函数的使用。</li></ol></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;clickhouse学习记录（一）&quot;&gt;&lt;a href=&quot;#clickhouse学习记录（一）&quot; class=&quot;headerlink&quot; title=&quot;clickhouse学习记录（一）&quot;&gt;&lt;/a&gt;clickhouse学习记录（一）&lt;/h1&gt;&lt;p&gt;最近因为工作原因,开始尝试学习&lt;code&gt;clickhouse&lt;/code&gt;数据库, 将会逐渐将&lt;code&gt;clickhouse&lt;/code&gt;的一些学习总结记录下来, 作为自己的学习历程.&lt;/p&gt;&lt;h2 id=&quot;clickhouse的简介&quot;&gt;&lt;a href=&quot;#clickhouse的简介&quot; class=&quot;headerlink&quot; title=&quot;clickhouse的简介&quot;&gt;&lt;/a&gt;clickhouse的简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;项目起源&lt;/strong&gt;&lt;br&gt;&lt;code&gt;clickhouse&lt;/code&gt;是由俄罗斯的一家互联网公司 &lt;code&gt;Yandex&lt;/code&gt; 开发的,  &lt;code&gt;Yandex&lt;/code&gt; 主要从事互联网分析，&lt;code&gt;Yandex&lt;/code&gt; 使用 &lt;code&gt;clickhouse&lt;/code&gt; 从事海量的互联网的流量分析，&lt;code&gt;clickhouse&lt;/code&gt; 作为 &lt;code&gt;Yandex&lt;/code&gt; 公司内部使用的项目, 后来走向开源． &lt;code&gt;clickhouse&lt;/code&gt; 作为 &lt;code&gt;OLAP&lt;/code&gt; 领域的流行, 主要得益于其出色的性能.&lt;br&gt;数据库领域有两个概念:&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="clickhouse" scheme="http://yoursite.com/tags/clickhouse/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 276</title>
    <link href="http://yoursite.com/2022/01/16/360/"/>
    <id>http://yoursite.com/2022/01/16/360/</id>
    <published>2022-01-16T05:30:52.450Z</published>
    <updated>2022-01-16T15:42:56.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-276"><a href="#leetcode-biweekly-contest-276" class="headerlink" title="leetcode  biweekly contest 276"></a>leetcode  biweekly contest 276</h1><p>今天的最后的一题没有做出来，只能说智商不够，关键的一点信息忽略之后就导致整个题目没有做出来, 但是我觉得还是练习题目太少的原因.</p><h2 id="5980-将字符串拆分为若干长度为-k-的组"><a href="#5980-将字符串拆分为若干长度为-k-的组" class="headerlink" title="5980. 将字符串拆分为若干长度为 k 的组"></a>5980. 将字符串拆分为若干长度为 k 的组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>字符串 <code>s</code> 可以按下述步骤划分为若干长度为 <code>k</code> 的组：</p><p>第一组由字符串中的前 <code>k</code> 个字符组成，第二组由接下来的 <code>k</code> 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。<br>对于最后一组，如果字符串剩下的字符 不足 <code>k</code> 个，需使用字符 <code>fill</code> 来补全这一组字符。<br>注意，在去除最后一个组的填充字符 <code>fill</code>（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。</p><a id="more"></a><p>给你一个字符串 <code>s</code> ，以及每组的长度 <code>k</code> 和一个用于填充的字符 <code>fill</code> ，按上述步骤处理之后，返回一个字符串数组，该数组表示 <code>s</code> 分组后 每个组的组成情况 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcdefghi"</span>, k = <span class="number">3</span>, fill = <span class="string">"x"</span></span><br><span class="line">输出：[<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>]</span><br><span class="line">解释：</span><br><span class="line">前 <span class="number">3</span> 个字符是 <span class="string">"abc"</span> ，形成第一组。</span><br><span class="line">接下来 <span class="number">3</span> 个字符是 <span class="string">"def"</span> ，形成第二组。</span><br><span class="line">最后 <span class="number">3</span> 个字符是 <span class="string">"ghi"</span> ，形成第三组。</span><br><span class="line">由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。</span><br><span class="line">因此，形成 <span class="number">3</span> 组，分别是 <span class="string">"abc"</span>、<span class="string">"def"</span> 和 <span class="string">"ghi"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcdefghij"</span>, k = <span class="number">3</span>, <span class="built_in">fill</span> = <span class="string">"x"</span></span><br><span class="line">输出：[<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jxx"</span>]</span><br><span class="line">解释：</span><br><span class="line">与前一个例子类似，形成前三组 <span class="string">"abc"</span>、<span class="string">"def"</span> 和 <span class="string">"ghi"</span> 。</span><br><span class="line">对于最后一组，字符串中仅剩下字符 <span class="string">'j'</span> 可以用。为了补全这一组，使用填充字符 <span class="string">'x'</span> 两次。</span><br><span class="line">因此，形成 <span class="number">4</span> 组，分别是 <span class="string">"abc"</span>、<span class="string">"def"</span>、<span class="string">"ghi"</span> 和 <span class="string">"jxx"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅由小写英文字母组成</li><li><code>1 &lt;= k &lt;= 100</code></li><li><code>fill</code> 是一个小写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-276/problems/divide-a-string-into-groups-of-size-k/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-276/problems/divide-a-string-into-groups-of-size-k/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接遍历</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们首先将元素字符串 $s$ 补齐操作, 使得 $s$ 的长度能够被 $k$ 整除, 然后按照长度 $k$ 进行依次分割即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(n + k)$，其中$n$ 为字符串的长度, $k$ 为分割的长度.</li><li>空间复杂度为 $O(k)$, 其中$k$ 为原始数组增加 $k.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; divideString(<span class="built_in">string</span> s, <span class="keyword">int</span> k, <span class="keyword">char</span> fill) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rest = s.size()%k;</span><br><span class="line">        <span class="keyword">if</span>(rest &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - rest; ++i) &#123;</span><br><span class="line">                s.push_back(fill);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(pos = <span class="number">0</span>; pos &lt; s.size(); pos += k) &#123;</span><br><span class="line">            ans.emplace_back(s.substr(pos, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="5194-得到目标值的最少行动次数"><a href="#5194-得到目标值的最少行动次数" class="headerlink" title="5194. 得到目标值的最少行动次数"></a>5194. 得到目标值的最少行动次数</h3><p>你正在玩一个整数游戏。从整数 <code>1</code> 开始，期望得到整数 <code>target</code> 。</p><p>在一次行动中，你可以做下述两种操作之一：</p><ul><li>递增，将当前整数的值加 <code>1</code>（即， <code>x = x + 1</code>）。</li><li>加倍，使当前整数的值翻倍（即，<code>x = 2 * x</code>）。</li><li>在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 <code>maxDoubles</code> 次。</li></ul><p>给你两个整数 <code>target</code> 和 <code>maxDoubles</code> ，返回从 <code>1</code>开始得到 <code>target</code> 需要的最少行动次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">5</span>, maxDoubles = <span class="number">0</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一直递增 <span class="number">1</span> 直到得到 target 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">19</span>, maxDoubles = <span class="number">2</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：最初，x = <span class="number">1</span> 。</span><br><span class="line">递增 <span class="number">3</span> 次，x = <span class="number">4</span> 。</span><br><span class="line">加倍 <span class="number">1</span> 次，x = <span class="number">8</span> 。</span><br><span class="line">递增 <span class="number">1</span> 次，x = <span class="number">9</span> 。</span><br><span class="line">加倍 <span class="number">1</span> 次，x = <span class="number">18</span> 。</span><br><span class="line">递增 <span class="number">1</span> 次，x = <span class="number">19</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">10</span>, maxDoubles = <span class="number">4</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">最初，x = <span class="number">1</span> 。 </span><br><span class="line">递增 <span class="number">1</span> 次，x = <span class="number">2</span> 。 </span><br><span class="line">加倍 <span class="number">1</span> 次，x = <span class="number">4</span> 。 </span><br><span class="line">递增 <span class="number">1</span> 次，x = <span class="number">5</span> 。 </span><br><span class="line">加倍 <span class="number">1</span> 次，x = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>0 &lt;= maxDoubles &lt;= 100</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-276/problems/minimum-moves-to-reach-target-score/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-276/problems/minimum-moves-to-reach-target-score/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>当然我们从 $1$ 往 $target$ 进行变化, 不太好变化, 但是我们可以换一种思路, 从 $target$ 往 $1$ 变换的最小步数, 就比较容易.</li><li>贪心的进行变换, 每次如果 $target$ 是偶数, 则我们优先进行除 $2$ 操作, 否则我们则进行减 $1$ 操作, 将 $target$ 变为奇数, 重复上述操作直到 $target$ 变为 $1$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(\log n)$, 其中 $n$ 为给定的目标值 $target$。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> maxDoubles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(target &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">if</span>(maxDoubles &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target%<span class="number">2</span>)&#123;</span><br><span class="line">                    target /= <span class="number">2</span>;</span><br><span class="line">                    ans += <span class="number">2</span>;</span><br><span class="line">                    maxDoubles--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    target /= <span class="number">2</span>;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                    maxDoubles--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ans + target - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5982-解决智力问题"><a href="#5982-解决智力问题" class="headerlink" title="5982. 解决智力问题"></a>5982. 解决智力问题</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的二维整数数组 <code>questions</code> ，其中 <code>questions[i] = [pointsi, brainpoweri]</code> 。</p><p>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 <code>0</code> 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 <code>i</code> 将让你 获得  <code>pointsi</code> 的分数，但是你将 无法 解决接下来的 <code>brainpoweri</code> 个问题（即只能跳过接下来的 <code>brainpoweri</code> 个问题）。如果你跳过问题 <code>i</code>，你可以对下一个问题决定使用哪种操作。</p><ul><li>比方说，给你 <code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>：</li><li>如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。</li><li>如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。<br>请你返回这场考试里你能获得的 最高 分数。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：questions = [[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：解决问题 <span class="number">0</span> 和 <span class="number">3</span> 得到最高分。</span><br><span class="line">- 解决问题 <span class="number">0</span> ：获得 <span class="number">3</span> 分，但接下来 <span class="number">2</span> 个问题都不能解决。</span><br><span class="line">- 不能解决问题 <span class="number">1</span> 和 <span class="number">2</span></span><br><span class="line">- 解决问题 <span class="number">3</span> ：获得 <span class="number">2</span> 分</span><br><span class="line">总得分为：<span class="number">3</span> + <span class="number">2</span> = <span class="number">5</span> 。没有别的办法获得 <span class="number">5</span> 分或者多于 <span class="number">5</span> 分。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：questions = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：解决问题 <span class="number">1</span> 和 <span class="number">4</span> 得到最高分。</span><br><span class="line">- 跳过问题 <span class="number">0</span></span><br><span class="line">- 解决问题 <span class="number">1</span> ：获得 <span class="number">2</span> 分，但接下来 <span class="number">2</span> 个问题都不能解决。</span><br><span class="line">- 不能解决问题 <span class="number">2</span> 和 <span class="number">3</span></span><br><span class="line">- 解决问题 <span class="number">4</span> ：获得 <span class="number">5</span> 分</span><br><span class="line">总得分为：<span class="number">2</span> + <span class="number">5</span> = <span class="number">7</span> 。没有别的办法获得 <span class="number">7</span> 分或者多于 <span class="number">7</span> 分。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= questions.length &lt;= 105</code></li><li><code>questions[i].length == 2</code></li><li><code>1 &lt;= pointsi, brainpoweri &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-palindrome-by-concatenating-two-letter-words" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindrome-by-concatenating-two-letter-words</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>比较简单的动态规划公式, 我们设 $dp[i]$ 表示从 $i$ 个题目开始所能获得的最大分数，则我们知道:</li></ol><ul><li>如果第 $i$ 开始,要么选择第 $i$ 个题, 然后跳过 $brainpower_i$ 个题目, 下一个可能选择的题目应该是从 $ i + 1 + brainpower_i$ 个题目开始, 则此时$dp[i] = points_i + dp[i + 1 + brainpower_i]$.</li><li>如果第 $i$ 开始,要么选择不选择第 $i$ 个题, 则此时我们从第 $i + 1$ 个题目开始做选择, 则此时 $dp[i] = dp[i + 1]$.<script type="math/tex; mode=display">dp[i] = max(dp[i+1], points_i + dp[i + 1 + brainpower_i])</script></li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(N)$ 其中 $N$ 为数组的长度。</li><li>空间复杂度分析: $O(N)$ ，其中$N$ 为数组的长度。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mostPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; questions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = questions.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n);</span><br><span class="line">        dp[n - <span class="number">1</span>] = questions[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = questions[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> y = questions[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i + y + <span class="number">1</span> &gt;= n) &#123;</span><br><span class="line">                dp[i] = max(dp[i + <span class="number">1</span>], x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = max(dp[i + <span class="number">1</span>], x + dp[i + y + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5983-同时运行-N-台电脑的最长时间"><a href="#5983-同时运行-N-台电脑的最长时间" class="headerlink" title="5983. 同时运行 N 台电脑的最长时间"></a>5983. 同时运行 N 台电脑的最长时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你有 <code>n</code> 台电脑。给你整数 n 和一个下标从 <code>0</code> 开始的整数数组 <code>batteries</code> ，其中第 i 个电池可以让一台电脑 运行<code>batteries[i]</code> 分钟。你想使用这些电池让 全部 <code>n</code> 台电脑 同时 运行。</p><ul><li><p>一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p></li><li><p>注意，你不能给电池充电。</p></li><li>请你返回你可以让 n 台电脑同时运行的 最长 分钟数。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, batteries = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">一开始，将第一台电脑与电池 <span class="number">0</span> 连接，第二台电脑与电池 <span class="number">1</span> 连接。</span><br><span class="line"><span class="number">2</span> 分钟后，将第二台电脑与电池 <span class="number">1</span> 断开连接，并连接电池 <span class="number">2</span> 。注意，电池 <span class="number">0</span> 还可以供电 <span class="number">1</span> 分钟。</span><br><span class="line">在第 <span class="number">3</span> 分钟结尾，你需要将第一台电脑与电池 <span class="number">0</span> 断开连接，然后连接电池 <span class="number">1</span> 。</span><br><span class="line">在第 <span class="number">4</span> 分钟结尾，电池 <span class="number">1</span> 也被耗尽，第一台电脑无法继续运行。</span><br><span class="line">我们最多能同时让两台电脑同时运行 <span class="number">4</span> 分钟，所以我们返回 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, batteries = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">一开始，将第一台电脑与电池 <span class="number">0</span> 连接，第二台电脑与电池 <span class="number">2</span> 连接。</span><br><span class="line">一分钟后，电池 <span class="number">0</span> 和电池 <span class="number">2</span> 同时耗尽，所以你需要将它们断开连接，并将电池 <span class="number">1</span> 和第一台电脑连接，电池 <span class="number">3</span> 和第二台电脑连接。</span><br><span class="line"><span class="number">1</span> 分钟后，电池 <span class="number">1</span> 和电池 <span class="number">3</span> 也耗尽了，所以两台电脑都无法继续运行。</span><br><span class="line">我们最多能让两台电脑同时运行 <span class="number">2</span> 分钟，所以我们返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= batteries.length &lt;= 105</code></li><li><code>1 &lt;= batteries[i] &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-running-time-of-n-computers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-running-time-of-n-computers</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>二分查找 + 贪心</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目竟然没有做出来, 其实拿到这个题目本身来看, 就根据数据的提示来说, 应该就是利用二分查找, 无奈当时想到了二分, 但是没有想到怎么利用来判别合法. 我们首先应该观察到返回结果的数据范围处在 $[0,10^9]$ 数量级, 这是自然而然应该想到利用二分法来判定, 因为此种数量级下只有二分法可以判定得到结果. 我们首先可以得到如下判断:</li></ol><ul><li>如果电池的数量 $m &lt; n$, 则此时无论电池以何种排序, 都不能满足给所有的电脑 供电.</li><li>如果电池的数量 $m = n$, 则此时可以连续运行的天数为$\min(batteries[i]) \quad i \in [0,n-1]$.</li></ul><ol><li>最终的是我们每次尝试目标值为 $x$ 后, 如何判定 $x$ 是否合法? 这个是本题目最难的地方. 我们需要注意到关键信息, 也即每个电池每天只能给一台电脑供电, 不可能出现一个电池在同一天给多个电脑同时的供电的情况, 这也就意味着假如系统可以同时并行给 $n$ 个电脑供电 $x$ 天时, 意味着第 $i$ 个电池也最多可以供电 $min(batteries[i], x)$, 即使第 $i$ 个电池的容量大于 $x$ ,那么最多也只能供香 $x$ 天. 我们知道 $n$ 台电脑连续工作 $x$ 天, 总共需要的总的电量为 $n \times x$，此时我们不管如何电池以何种顺序供电，只要保证可以供电的总电量大于等于 $n \times x$ 即可, 第 $i$ 个电池的能够提供的电量为 $power_i = \min (batteries[i], x)$, 我们每次检验是否满足提供所需的电量即可.</li><li>实际上我们可以利用贪心的策略来选择每天供电的供电的电池, 比如我们每天贪心的选择 从 $m$ 个电池选择 $n$ 个电量最大的电池来给 $n$ 个电池进行供电, 然后将这 $n$ 个电池的容量都减 $1$. 后面依次遵循这种规则来选择, 直到剩余的电池容量不能满足同时给 $n$ 个电脑供电为止.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：时间复杂度为 $O(n \times \log \frac{\sum_{i=0}^{m-1}batteries[i]}{n})$ , 其中 $n$ 表示电脑的数目, $m$ 表示电池数组的数目, 我们需要利用二分查找, 并行天数最大范围为 $[0,\frac{\sum_{i=0}^{m-1}batteries[i]}{n}]$. 每次进行判定是否合法时需要 $O(n)$ 的时间复杂度, 因此总的时间复杂度为 $O(n \times \log \frac{\sum_{i=0}^{m-1}batteries[i]}{n})$.</li><li>空间复杂度分析: $O(1)$.</li></ul></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxRunTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; batteries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = batteries.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : batteries) sum += v;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r = sum / n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = l + ((r - l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : batteries) &#123;</span><br><span class="line">                curr += min(mid, (<span class="keyword">long</span> <span class="keyword">long</span>)v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr &gt;= n * mid) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-276&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-276&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 276&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 276&lt;/h1&gt;&lt;p&gt;今天的最后的一题没有做出来，只能说智商不够，关键的一点信息忽略之后就导致整个题目没有做出来, 但是我觉得还是练习题目太少的原因.&lt;/p&gt;&lt;h2 id=&quot;5980-将字符串拆分为若干长度为-k-的组&quot;&gt;&lt;a href=&quot;#5980-将字符串拆分为若干长度为-k-的组&quot; class=&quot;headerlink&quot; title=&quot;5980. 将字符串拆分为若干长度为 k 的组&quot;&gt;&lt;/a&gt;5980. 将字符串拆分为若干长度为 k 的组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;字符串 &lt;code&gt;s&lt;/code&gt; 可以按下述步骤划分为若干长度为 &lt;code&gt;k&lt;/code&gt; 的组：&lt;/p&gt;&lt;p&gt;第一组由字符串中的前 &lt;code&gt;k&lt;/code&gt; 个字符组成，第二组由接下来的 &lt;code&gt;k&lt;/code&gt; 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。&lt;br&gt;对于最后一组，如果字符串剩下的字符 不足 &lt;code&gt;k&lt;/code&gt; 个，需使用字符 &lt;code&gt;fill&lt;/code&gt; 来补全这一组字符。&lt;br&gt;注意，在去除最后一个组的填充字符 &lt;code&gt;fill&lt;/code&gt;（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab8 Lock</title>
    <link href="http://yoursite.com/2022/01/11/359/"/>
    <id>http://yoursite.com/2022/01/11/359/</id>
    <published>2022-01-11T13:07:32.507Z</published>
    <updated>2022-01-12T03:54:44.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h1><p>感觉<code>lock lab</code>是自我感觉还算是比较难的<code>lab</code>了, 第二个练习想了很久才想到如何写出正确的代码,特别是中间又莫名出现了 <code>panic: freeing free blocks</code>, 找了很长时间都没有找到问题所在, 还好的是最终解决该问题, 将文件系统 <code>fs</code> 删除后就莫名奇妙好了, 所有的 <code>testcase</code> 全部都可以通过了, 后面需要继续研究一下 <code>lock free</code> 队列的实现.</p><a id="more"></a><ul><li>本章终点讲述操作系统中 <code>sleep</code> 和 <code>wakeup</code> 的实现原理, 感觉还是挺有趣的实现, 当然本质上 <code>sleep</code>的实现原理非常简单, 即将当前线程设置为<code>sleeping</code>状态, 并标记当前线程的 $chan$, 然后将当前线程切换出去, 线程调度程序在运行时,发现当前线程的状态不是 <code>runable</code>时就不会将该线程调度到 <code>cpu</code> 核心上, 从而实现了该线程的睡眠.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sleep(<span class="keyword">void</span> *chan, struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won't miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it's okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>我们同时也可以观察一下系统调用程序中 <code>sleep</code> 函数的实现, 原理实际上也是调用 <code>sleep lock</code>来实现, 当前如果等待的时间小于 <code>sleep</code> 睡眠的时间,如果当前进程被唤醒，则继续执行 <code>sleep</code>, 否则则释放 <code>ticklocks</code>,　此时进行就可以从调度程序中被唤醒. <code>sleep</code> 系统调用都是标记在<code>ticks</code>中，我们可以看到时间中断中，每次会将标记为<code>ticks</code>的进程进行唤醒，从而实现时间计数．<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sleep(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">clockintr()</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>关于<code>wake</code>的原理实现也非常简单,即将进程的状态由<code>sleeping</code>设置为 <code>runable</code>即可, 此时在进行进程调度时,该进程即可就唤醒,加载到 <code>CPU</code>核心中运行.<code>wakeup</code>时需要传入 <code>chan</code> 参数标记.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">wakeup(<span class="keyword">void</span> *chan)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>lecture</code>中还提到了<code>lost wakeup</code>的问题, 很多细节问题真心值得深入的去思考这些细节实现. 还是认真的学习视频感觉比较.</li><li>本章的<code>lab</code>主要以如何减少<code>lock</code>冲突的出发点去优化代码, 同时如何避免死锁的问题去寻求解决办法, 总的来说还算是比较有意思的<code>lab</code>.</li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>本次<code>lab</code>的几个程序倒是感觉不是太难，实现代码倒是不多，但是很多值得思考的地方,整个<a href="https://github.com/mike-box/MIT6.S081/tree/main/" target="_blank" rel="noopener">MIT 6.S081</a>的课程总结全部放到github上了.<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-lock-handin" target="_blank" rel="noopener">git repo</a></p><h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">The program user/kalloctest stresses xv6's <span class="keyword">memory</span> allocator: three processes grow and shrink their address spaces, resulting in many calls to kalloc and kfree. kalloc and kfree obtain kmem.lock. kalloctest prints (as <span class="string">"#fetch-and-add"</span>) the number of loop iterations in acquire due to attempts to acquire a lock that another core already holds, <span class="keyword">for</span> the kmem lock and a few other locks. The number of loop iterations in acquire is a rough measure of lock contention. The output of kalloctest looks similar to this before you complete the lab:</span><br><span class="line"></span><br><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add <span class="number">83375</span> #acquire() <span class="number">433015</span></span><br><span class="line">lock: bcache: #fetch-and-add <span class="number">0</span> #acquire() <span class="number">1260</span></span><br><span class="line">--- top <span class="number">5</span> contended locks:</span><br><span class="line">lock: kmem: #fetch-and-add <span class="number">83375</span> #acquire() <span class="number">433015</span></span><br><span class="line">lock: <span class="keyword">proc</span>: #fetch-and-add 23737 #acquire() 130718</span><br><span class="line">lock:<span class="title"> virtio_disk:</span> #fetch-and-add 11159 #acquire() 114</span><br><span class="line">lock:<span class="title"> proc:</span> #fetch-and-add 5937 #acquire() 130786</span><br><span class="line">lock:<span class="title"> proc:</span> #fetch-and-add 4080 #acquire() 130786</span><br><span class="line">tot= 83375</span><br><span class="line">test1<span class="title"> FAIL</span></span><br><span class="line"><span class="title">acquire</span> maintains,<span class="title"> for</span> each<span class="title"> lock,</span> the<span class="title"> count</span> of<span class="title"> calls</span> to<span class="title"> acquire</span> for<span class="title"> that</span> lock,<span class="title"> and</span> the<span class="title"> number</span> of<span class="title"> times</span> the<span class="title"> loop</span> in<span class="title"> acquire</span> tried<span class="title"> but</span> failed<span class="title"> to</span> set<span class="title"> the</span> lock.<span class="title"> kalloctest</span> calls<span class="title"> a</span> system<span class="title"> call</span> that<span class="title"> causes</span> the<span class="title"> kernel</span> to<span class="title"> print</span> those<span class="title"> counts</span> for<span class="title"> the</span> kmem<span class="title"> and</span> bcache<span class="title"> locks</span> (which<span class="title"> are</span> the<span class="title"> focus</span> of<span class="title"> this</span> lab)<span class="title"> and</span> for<span class="title"> the</span> 5<span class="title"> most</span> contended<span class="title"> locks.</span> If<span class="title"> there</span> is<span class="title"> lock</span> contention<span class="title"> the</span> number<span class="title"> of</span> acquire<span class="title"> loop</span> iterations<span class="title"> will</span> be<span class="title"> large.</span> The<span class="title"> system</span> call<span class="title"> returns</span> the<span class="title"> sum</span> of<span class="title"> the</span> number<span class="title"> of</span> loop<span class="title"> iterations</span> for<span class="title"> the</span> kmem<span class="title"> and</span> bcache<span class="title"> locks.</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">For</span> this<span class="title"> lab,</span> you<span class="title"> must</span> use<span class="title"> a</span> dedicated<span class="title"> unloaded</span> machine<span class="title"> with</span> multiple<span class="title"> cores.</span> If<span class="title"> you</span> use<span class="title"> a</span> machine<span class="title"> that</span> is<span class="title"> doing</span> other<span class="title"> things,</span> the<span class="title"> counts</span> that<span class="title"> kalloctest</span> prints<span class="title"> will</span> be<span class="title"> nonsense.</span> You<span class="title"> can</span> use<span class="title"> a</span> dedicated<span class="title"> Athena</span> workstation,<span class="title"> or</span> your<span class="title"> own</span> laptop,<span class="title"> but</span> don't<span class="title"> use</span> a<span class="title"> dialup</span> machine.</span><br><span class="line"></span><br><span class="line">The<span class="title"> root</span> cause<span class="title"> of</span> lock<span class="title"> contention</span> in<span class="title"> kalloctest</span> is<span class="title"> that</span> kalloc()<span class="title"> has</span> a<span class="title"> single</span> free<span class="title"> list,</span> protected<span class="title"> by</span> a<span class="title"> single</span> lock.<span class="title"> To</span> remove<span class="title"> lock</span> contention,<span class="title"> you</span> will<span class="title"> have</span> to<span class="title"> redesign</span> the<span class="title"> memory</span> allocator<span class="title"> to</span> avoid<span class="title"> a</span> single<span class="title"> lock</span> and<span class="title"> list.</span> The<span class="title"> basic</span> idea<span class="title"> is</span> to<span class="title"> maintain</span> a<span class="title"> free</span> list<span class="title"> per</span> CPU,<span class="title"> each</span> list<span class="title"> with</span> its<span class="title"> own</span> lock.<span class="title"> Allocations</span> and<span class="title"> frees</span> on<span class="title"> different</span> CPUs<span class="title"> can</span> run<span class="title"> in</span> parallel,<span class="title"> because</span> each<span class="title"> CPU</span> will<span class="title"> operate</span> on<span class="title"> a</span> different<span class="title"> list.</span> The<span class="title"> main</span> challenge<span class="title"> will</span> be<span class="title"> to</span> deal<span class="title"> with</span> the<span class="title"> case</span> in<span class="title"> which</span> one<span class="title"> CPU's</span> free<span class="title"> list</span> is<span class="title"> empty,</span> but<span class="title"> another</span> CPU's<span class="title"> list</span> has<span class="title"> free</span> memory;<span class="title"> in</span> that<span class="title"> case,</span> the<span class="title"> one</span> CPU<span class="title"> must</span> "steal"<span class="title"> part</span> of<span class="title"> the</span> other<span class="title"> CPU's</span> free<span class="title"> list.</span> Stealing<span class="title"> may</span> introduce<span class="title"> lock</span> contention,<span class="title"> but</span> that<span class="title"> will</span> hopefully<span class="title"> be</span> infrequent.</span><br></pre></td></tr></table></figure><ul><li>题目提示由于目前实现的<code>kalloc</code>所有的线程都共享一把锁, 此时如何所有的线程在<code>heap</code>上申请时会造成冲突, 从而都在锁上进行自旋, 从而进行等待,题目要求优化<code>kalloc</code>,减少<code>lock accquire</code>时的冲突. 题目也给了思路, 就是为每个线程建立一个<code>memory pool</code>, 每个线程的内存申请都发生在自身的<code>memory pool</code>, 当如果自身的<code>memory pool</code>用完时,则从其他线程的<code>memory pool</code>中进行<code>steal</code>操作.</li><li>本身比较简单, 但是需要注意的几个细节:<ul><li><code>kalloc</code>模块对外提供的接口不变, 每次进行<code>alloc</code>操作时, 首先需要获取当前线程的<code>cpuid</code>的信息, 可以通过寄存器读取即可获取,<code>xv6</code>中已经封装好接口<code>cpuid()</code>,但是调用该接口时,需要关闭中断, 读取完成后, 还需要开启中断.</li><li>进行<code>steal</code>操作时, 需要防止死锁.</li><li>初始化时, 可以将所有未使用的内存都挂载在<code>cpu 0</code>上.</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li><code>memory</code>初始化:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">  <span class="keyword">int</span>  freesize;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125; kmem[NCPU];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kinit()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i) &#123;</span><br><span class="line">  <span class="built_in">snprintf</span>(kmem[i].name, <span class="number">16</span>, <span class="string">"%s%d"</span>, <span class="string">"kmem"</span>, i);</span><br><span class="line">initlock(&amp;kmem[i].lock, kmem[i].name);</span><br><span class="line">kmem[i].freelist = <span class="number">0</span>;</span><br><span class="line">kmem[i].freesize = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="comment">// we wiil alloc each cup heap lock and list</span></span><br><span class="line">  freerange(end, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>kfree</code>操作:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kfree(<span class="keyword">void</span> *pa)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">"kfree"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//add this block to the free list</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> hart = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem[hart].lock);</span><br><span class="line">  r-&gt;next = kmem[hart].freelist;</span><br><span class="line">  kmem[hart].freelist = r;</span><br><span class="line">  release(&amp;kmem[hart].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>kalloc</code>操作:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">kalloc(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//add this block to the free list</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> hart = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;kmem[hart].lock);</span><br><span class="line">  r = kmem[hart].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">  kmem[hart].freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem[hart].lock);</span><br><span class="line">  <span class="keyword">if</span>(r == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// we steal memory from other cpus</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i) &#123;</span><br><span class="line">acquire(&amp;kmem[i].lock);</span><br><span class="line">r = kmem[i].freelist;</span><br><span class="line"><span class="keyword">if</span>(r) &#123;</span><br><span class="line">kmem[i].freelist = r-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">release(&amp;kmem[i].lock);</span><br><span class="line"><span class="keyword">if</span>(r) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">This half <span class="keyword">of</span> the assignment <span class="keyword">is</span> independent <span class="keyword">from</span> the first half; you can <span class="keyword">work</span> <span class="keyword">on</span> this half (<span class="keyword">and</span> pass the tests) whether <span class="keyword">or</span> <span class="keyword">not</span> you have completed the first half.</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> multiple processes use the file <span class="keyword">system</span> intensively, they will likely contend <span class="keyword">for</span> bcache.<span class="keyword">lock</span>, which protects the disk block <span class="keyword">cache</span> in kernel/bio.c. bcachetest creates several processes that repeatedly read different files in order to generate contention on bcache.lock; its output looks like this (before you complete this lab):</span><br><span class="line"></span><br><span class="line">$ bcachetest</span><br><span class="line">start test0</span><br><span class="line">test0 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add <span class="number">0</span> #acquire() <span class="number">33035</span></span><br><span class="line"><span class="keyword">lock</span>: bcache: #<span class="keyword">fetch</span>-<span class="keyword">and</span>-<span class="keyword">add</span> <span class="number">16142</span> #acquire() <span class="number">65978</span></span><br><span class="line"><span class="comment">--- top 5 contended locks:</span></span><br><span class="line"><span class="keyword">lock</span>: virtio_disk: #<span class="keyword">fetch</span>-<span class="keyword">and</span>-<span class="keyword">add</span> <span class="number">162870</span> #acquire() <span class="number">1188</span></span><br><span class="line"><span class="keyword">lock</span>: proc: #<span class="keyword">fetch</span>-<span class="keyword">and</span>-<span class="keyword">add</span> <span class="number">51936</span> #acquire() <span class="number">73732</span></span><br><span class="line"><span class="keyword">lock</span>: bcache: #<span class="keyword">fetch</span>-<span class="keyword">and</span>-<span class="keyword">add</span> <span class="number">16142</span> #acquire() <span class="number">65978</span></span><br><span class="line"><span class="keyword">lock</span>: uart: #<span class="keyword">fetch</span>-<span class="keyword">and</span>-<span class="keyword">add</span> <span class="number">7505</span> #acquire() <span class="number">117</span></span><br><span class="line"><span class="keyword">lock</span>: proc: #<span class="keyword">fetch</span>-<span class="keyword">and</span>-<span class="keyword">add</span> <span class="number">6937</span> #acquire() <span class="number">73420</span></span><br><span class="line">tot= <span class="number">16142</span></span><br><span class="line">test0: FAIL</span><br><span class="line"><span class="keyword">start</span> test1</span><br><span class="line">test1 OK</span><br><span class="line">You will likely see different output, but the number <span class="keyword">of</span> acquire <span class="keyword">loop</span> iterations <span class="keyword">for</span> the bcache <span class="keyword">lock</span> will be high. <span class="keyword">If</span> you look at the code <span class="keyword">in</span> kernel/bio.c, you<span class="string">'ll see that bcache.lock protects the list of cached block buffers, the reference count (b-&gt;refcnt) in each block buffer, and the identities of the cached blocks (b-&gt;dev and b-&gt;blockno).</span></span><br></pre></td></tr></table></figure><ul><li>这个题目要求实现磁盘的<code>cache</code>的优化, 之前所有的设备请求都挂在一个链式的<code>cahce</code>上.所有针对磁盘的<code>block</code>请求读写全部共享一把锁, 这就必然会造成锁的请求冲突, 从而影响读写效率, 现在要求对读写的<code>cache buffer</code>进行优化, 从而降低锁的请求冲突, 从而提升效率.细节实现如下:<ul><li>题目中最关键的提示使用<code>hash table</code>,对应于不同的<code>block</code>请求通过<code>hash</code>映射到不同的<code>buffer</code>中, 从而降低锁的冲突. 当<code>hash</code>对应的<code>bucket</code>用完时, 则需要从别的<code>bucket</code>中未使用的<code>buffer</code>中<code>steal</code>一些.实际采用链式<code>hash</code>即可, 即每个<code>bucket</code>存储的是<code>buffer</code>的<code>list</code>.</li><li>题目中最需要值得处理的细节是, 即同一个<code>dev</code>和<code>block</code>对应的<code>buffer</code>具有唯一性, 这样保证不同的线程读取或者写入的<code>blcok</code>的<code>cache buffer</code>是同一个, 这样就能保证原子性, 否则则会出现读写不一致的问题, 这点也是本<code>lab</code>比较难处理的地方.</li><li>具体实现时, 我们需要对<code>hash table</code>的每个<code>bucket</code>进行加锁操作, 当对该<code>bucket</code>操作时, 则需要获取锁, 操作完成后, 需要释放该锁.但是如何保证每个唯一的<code>dev</code>和<code>block</code>对应的唯一性的<code>buffer</code>,则需要处理稍微麻烦一些, 首先我们查找该<code>block</code>对应的<code>bucket</code>是否对应其含有的<code>dev</code>和<code>block</code>, 如果已经含有表示其已经进行缓存了, 则直接进行返回查找到的<code>buffer</code>即可; 否则我们先获取全局锁，再获取该<code>bucket</code>对应的锁, 再次再该<code>bucket</code>中进行查找一遍, 是否有存在该<code>block</code>对应的<code>buffer</code>缓存, 这样做的目的是为了防止, <code>bucket</code>释放锁到获取全局锁之间的这段时间中, 是否有其他的线程将该<code>block</code>对应的<code>buffer</code>进行了更新, 从而保证<code>block</code>对应的<code>buffer</code>的唯一性.我们在所有的<code>bucket</code>中找到一个最久且未使用的<code>buffer</code>分配给该<code>block</code>, 然后将该<code>buffer</code>移动到该<code>block</code>对应的<code>bucket</code>中.这样就完成了<code>steal</code>的操作.</li><li>我们查找时优先从该<code>bucket</code>找到一个未使用的<code>buffer</code>, 如果未找到则从其他的<code>bucket</code>中进行查找即可.</li><li>题目中很容易出的问题是会报<code>panic: freeing free block</code>的错误, 这个可能是之前的代码错误导致文件系统<code>fs</code>中的<code>block</code>存在错误, 解决办法是执行<code>maka clean</code>操作, 从新编译一遍文件系统<code>fs</code>即可.</li></ul></li></ul><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><ul><li>从新定义<code>bcache</code>的结构, 采用<code>hashtable</code>的方式存储<code>buf</code>信息.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HASH_BUCKETS 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="keyword">extern</span> uint ticks;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="comment">// hash table </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">hashlock</span>[<span class="title">MAX_HASH_BUCKETS</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">hashtable</span>[<span class="title">MAX_HASH_BUCKETS</span>];</span></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure></li><li>初始化<code>bcache</code>操作, 此时我们需要初始化每个<code>bucket</code>对应的锁,并初始化每个<code>bucket</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">binit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"><span class="comment">// init buffer lock and init free list buffer</span></span><br><span class="line"><span class="comment">// initial the hash table and hash lock</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_HASH_BUCKETS; ++i) &#123;</span><br><span class="line">initlock(&amp;bcache.hashlock[i], <span class="string">"hashlock"</span>);</span><br><span class="line"><span class="comment">// Create linked list of buffers</span></span><br><span class="line">bcache.hashtable[i].prev = &amp;bcache.hashtable[i];</span><br><span class="line">bcache.hashtable[i].next = &amp;bcache.hashtable[i];</span><br><span class="line">&#125;</span><br><span class="line">initlock(&amp;bcache.lock, <span class="string">"bcache"</span>);</span><br><span class="line"><span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf + NBUF; b++)&#123;</span><br><span class="line">initsleeplock(&amp;b-&gt;lock, <span class="string">"bufferlock"</span>);</span><br><span class="line">b-&gt;timestamp = <span class="number">0</span>;</span><br><span class="line">b-&gt;dev = <span class="number">-1</span>;</span><br><span class="line">b-&gt;blockno = <span class="number">-1</span>;</span><br><span class="line">b-&gt;refcnt = <span class="number">0</span>;</span><br><span class="line">b-&gt;next = bcache.hashtable[<span class="number">0</span>].next;</span><br><span class="line">b-&gt;prev = &amp;bcache.hashtable[<span class="number">0</span>];</span><br><span class="line">bcache.hashtable[<span class="number">0</span>].next-&gt;prev = b;</span><br><span class="line">bcache.hashtable[<span class="number">0</span>].next = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找<code>block</code>对应的<code>buffer</code>时, 操作稍微麻烦一些.　我们首先在<code>bucket</code>中进行查找, 然后获取全局锁, 从其他的<code>bucket</code>中的查找一个未使用的<code>buffer</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>*</span></span><br><span class="line"><span class="class"><span class="title">bget</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">uint</span> <span class="title">blockno</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> * <span class="title">lrub</span> = 0;</span></span><br><span class="line">  <span class="keyword">int</span> minticks = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> no = bhash(blockno);</span><br><span class="line">  </span><br><span class="line">  acquire(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.hashtable[no].next; b != &amp;bcache.hashtable[no]; b = b-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.hashlock[no]);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.hashlock[no]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  acquire(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.hashtable[no].next; b != &amp;bcache.hashtable[no]; b = b-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.hashlock[no]);</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; minticks &gt;= b-&gt;timestamp) &#123;</span><br><span class="line">lrub = b;</span><br><span class="line">minticks = b-&gt;timestamp;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lrub) &#123;</span><br><span class="line">  lrub-&gt;dev = dev;</span><br><span class="line">lrub-&gt;blockno = blockno;</span><br><span class="line">    lrub-&gt;valid = <span class="number">0</span>;</span><br><span class="line">lrub-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">release(&amp;bcache.hashlock[no]);</span><br><span class="line">release(&amp;bcache.lock);</span><br><span class="line">    acquiresleep(&amp;lrub-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> lrub;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we steal a buffer block from other buckets</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_HASH_BUCKETS; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> newno = bhash(no + i);</span><br><span class="line">acquire(&amp;bcache.hashlock[newno]);</span><br><span class="line">  <span class="keyword">for</span> (b = bcache.hashtable[newno].prev; b != &amp;bcache.hashtable[newno]; b = b-&gt;prev)&#123;</span><br><span class="line"><span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; minticks &gt;= b-&gt;timestamp) &#123;</span><br><span class="line">lrub = b;</span><br><span class="line">minticks = b-&gt;timestamp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lrub) &#123;</span><br><span class="line">  lrub-&gt;dev = dev;</span><br><span class="line">lrub-&gt;blockno = blockno;</span><br><span class="line">    lrub-&gt;valid = <span class="number">0</span>;</span><br><span class="line">lrub-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">lrub-&gt;next-&gt;prev = lrub-&gt;prev;</span><br><span class="line">lrub-&gt;prev-&gt;next = lrub-&gt;next;</span><br><span class="line">lrub-&gt;next = bcache.hashtable[no].next;</span><br><span class="line">lrub-&gt;prev = &amp;bcache.hashtable[no];</span><br><span class="line">bcache.hashtable[no].next-&gt;prev = lrub;</span><br><span class="line">    bcache.hashtable[no].next = lrub;</span><br><span class="line">release(&amp;bcache.hashlock[newno]);</span><br><span class="line">release(&amp;bcache.hashlock[no]);</span><br><span class="line">release(&amp;bcache.lock);</span><br><span class="line">    acquiresleep(&amp;lrub-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> lrub;</span><br><span class="line">&#125;</span><br><span class="line">  release(&amp;bcache.hashlock[newno]);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.hashlock[no]);</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we check the the cache again and the one block must atomic  </span></span><br><span class="line">  panic(<span class="string">"bget: no buffers"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>释放<code>buffer</code>时, 则我们需要记录该<code>buffer</code>的<code>timestamp</code>,用于<code>lru</code>算法.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">brelse(struct buf *b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">"brelse"</span>);</span><br><span class="line">  </span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line">  <span class="keyword">int</span> no = bhash(b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.hashlock[no]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line"> b-&gt;timestamp = btime();</span><br><span class="line">  &#125; </span><br><span class="line">  release(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="comment">// bdegub();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bhash</span><span class="params">(<span class="keyword">int</span> blockno)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> blockno%MAX_HASH_BUCKETS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">btime</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul><li>通过这一章的学习，其实给了许多可以思考的地方，从本质上思考锁的作用和原理，以及<code>sleep</code>和<code>wakeup</code>的实现原理，非常简洁而又优雅的实现方式.</li><li>下一步计划:</li><li><ul><li>完成<code>option chanllenge</code>的<code>project</code>;</li></ul></li><li><ul><li>仔细研究一下无锁队列的实现，在<code>xv6</code>中添加无锁队列;</li></ul></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lock&quot;&gt;&lt;a href=&quot;#lock&quot; class=&quot;headerlink&quot; title=&quot;lock&quot;&gt;&lt;/a&gt;lock&lt;/h1&gt;&lt;p&gt;感觉&lt;code&gt;lock lab&lt;/code&gt;是自我感觉还算是比较难的&lt;code&gt;lab&lt;/code&gt;了, 第二个练习想了很久才想到如何写出正确的代码,特别是中间又莫名出现了 &lt;code&gt;panic: freeing free blocks&lt;/code&gt;, 找了很长时间都没有找到问题所在, 还好的是最终解决该问题, 将文件系统 &lt;code&gt;fs&lt;/code&gt; 删除后就莫名奇妙好了, 所有的 &lt;code&gt;testcase&lt;/code&gt; 全部都可以通过了, 后面需要继续研究一下 &lt;code&gt;lock free&lt;/code&gt; 队列的实现.&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 69</title>
    <link href="http://yoursite.com/2022/01/09/358/"/>
    <id>http://yoursite.com/2022/01/09/358/</id>
    <published>2022-01-09T03:54:45.229Z</published>
    <updated>2022-01-11T13:06:55.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-69"><a href="#leetcode-biweekly-contest-69" class="headerlink" title="leetcode  biweekly contest 69"></a>leetcode  biweekly contest 69</h1><p>双周赛的题目最后一题,果真难度比较大, 虽然没有参加, 但是感觉还是挺难的题目.</p><h3 id="5960-将标题首字母大写"><a href="#5960-将标题首字母大写" class="headerlink" title="5960. 将标题首字母大写"></a>5960. 将标题首字母大写</h3><p>给你一个字符串 <code>title</code> ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 大写 ：</p><p>如果单词的长度为 <code>1</code>或者<code>2</code> ，所有字母变成小写。<br>否则，将单词首字母大写，剩余字母变成小写。<br>请你返回 大写后 的 <code>title</code>。</p><a id="more"></a><p>示例 1：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">title</span> = "capiTalIze tHe <span class="built_in">titLe</span>"</span><br><span class="line">输出："Capitalize The <span class="built_in">Title</span>"</span><br><span class="line">解释：</span><br><span class="line">由于所有单词的长度都至少为 <span class="number">3</span> ，将每个单词首字母大写，剩余字母变为小写。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：title = <span class="string">"First leTTeR of EACH Word"</span></span><br><span class="line">输出：<span class="string">"First Letter of Each Word"</span></span><br><span class="line">解释：</span><br><span class="line">单词 <span class="string">"of"</span> 长度为 <span class="number">2</span> ，所以它保持完全小写。</span><br><span class="line">其他单词长度都至少为 <span class="number">3</span> ，所以其他单词首字母大写，剩余字母小写。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：title = <span class="string">"i lOve leetcode"</span></span><br><span class="line">输出：<span class="string">"i Love Leetcode"</span></span><br><span class="line">解释：</span><br><span class="line">单词 <span class="string">"i"</span> 长度为 <span class="number">1</span> ，所以它保留小写。</span><br><span class="line">其他单词长度都至少为 <span class="number">3</span> ，所以其他单词首字母大写，剩余字母小写。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= title.length &lt;= 100</code></li><li><code>title</code> 由单个空格隔开的单词组成，且不含有任何前导或后缀空格。</li><li>每个单词由大写和小写英文字母组成，且都是 非空 的。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/capitalize-the-title" target="_blank" rel="noopener">https://leetcode-cn.com/problems/capitalize-the-title</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测与分词</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们将句子分成单词,然后检测每个单词即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n)$, 其中 $n$ 为字符串的长度。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">capitalizeTitle</span><span class="params">(self, title: str)</span> -&gt; str:</span></span><br><span class="line">        arr = title.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            arr[i] = arr[i].lower()</span><br><span class="line">            <span class="keyword">if</span> len(arr[i]) &gt; <span class="number">2</span>:</span><br><span class="line">                arr[i] = arr[i].title()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(arr)</span><br></pre></td></tr></table></figure><h2 id="5961-链表最大孪生和"><a href="#5961-链表最大孪生和" class="headerlink" title="5961. 链表最大孪生和"></a>5961. 链表最大孪生和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个大小为 <code>n</code> 且 <code>n</code> 为 偶数 的链表中，对于 <code>0 &lt;= i &lt;= (n / 2) - 1</code> 的<code>i</code>，第 <code>i</code>个节点（下标从 0 开始）的孪生节点为第 <code>(n-1-i)</code> 个节点 。</p><p>比方说，<code>n = 4</code>那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n = 4 的链表中所有的孪生节点。<br>孪生和 定义为一个节点和它孪生节点两者值之和。</p><p>给你一个长度为偶数的链表的头节点 <code>head</code> ，请你返回链表的 最大孪生和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">节点 <span class="number">0</span> 和节点 <span class="number">1</span> 分别是节点 <span class="number">3</span> 和 <span class="number">2</span> 的孪生节点。孪生和都为 <span class="number">6</span> 。</span><br><span class="line">链表中没有其他孪生节点。</span><br><span class="line">所以，链表的最大孪生和是 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">链表中的孪生节点为：</span><br><span class="line">- 节点 <span class="number">0</span> 是节点 <span class="number">3</span> 的孪生节点，孪生和为 <span class="number">4</span> + <span class="number">3</span> = <span class="number">7</span> 。</span><br><span class="line">- 节点 <span class="number">1</span> 是节点 <span class="number">2</span> 的孪生节点，孪生和为 <span class="number">2</span> + <span class="number">2</span> = <span class="number">4</span> 。</span><br><span class="line">所以，最大孪生和为 max(<span class="number">7</span>, <span class="number">4</span>) = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">100000</span>]</span><br><span class="line">输出：<span class="number">100001</span></span><br><span class="line">解释：</span><br><span class="line">链表中只有一对孪生节点，孪生和为 <span class="number">1</span> + <span class="number">100000</span> = <span class="number">100001</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表的节点数目是 <code>[2, 105]</code> 中的 偶数 。</li><li><code>1 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-twin-sum-of-a-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-twin-sum-of-a-linked-list</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 链表</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>将连边转化为数组，然后进行数组遍历即可，当然递归也可以，比较麻烦</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(n)$，其中$n$ 为链表的长度.</li><li>空间复杂度为 $O(n)$, 其中$n$ 为链表的长度.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pairSum</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            arr.emplace_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size()/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">            ans = max(ans, arr[i] + arr[n<span class="number">-1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5962-连接两字母单词得到的最长回文串"><a href="#5962-连接两字母单词得到的最长回文串" class="headerlink" title="5962. 连接两字母单词得到的最长回文串"></a>5962. 连接两字母单词得到的最长回文串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>words</code> 。<code>words</code> 中每个元素都是一个包含 两个 小写英文字母的单词。</p><p>请你从 <code>words</code> 中选择一些元素并按 任意顺序 连接它们，并得到一个 尽可能长的回文串 。每个元素 至多 只能使用一次。</p><p>请你返回你能得到的最长回文串的 长度 。如果没办法得到任何一个回文串，请你返回 <code>0</code>。</p><p>回文串 指的是从前往后和从后往前读一样的字符串。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"lc"</span>,<span class="string">"cl"</span>,<span class="string">"gg"</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：一个最长的回文串为 <span class="string">"lc"</span> + <span class="string">"gg"</span> + <span class="string">"cl"</span> = <span class="string">"lcggcl"</span> ，长度为 <span class="number">6</span> 。</span><br><span class="line"><span class="string">"clgglc"</span> 是另一个可以得到的最长回文串。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"ab"</span>,<span class="string">"ty"</span>,<span class="string">"yt"</span>,<span class="string">"lc"</span>,<span class="string">"cl"</span>,<span class="string">"ab"</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：最长回文串是 <span class="string">"ty"</span> + <span class="string">"lc"</span> + <span class="string">"cl"</span> + <span class="string">"yt"</span> = <span class="string">"tylcclyt"</span> ，长度为 <span class="number">8</span> 。</span><br><span class="line"><span class="string">"lcyttycl"</span> 是另一个可以得到的最长回文串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"cc"</span>,<span class="string">"ll"</span>,<span class="string">"xx"</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长回文串是 <span class="string">"cc"</span> ，长度为 <span class="number">2</span> 。</span><br><span class="line"><span class="string">"ll"</span> 是另一个可以得到的最长回文串。<span class="string">"xx"</span> 也是。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 105</code></li><li><code>words[i].length == 2</code></li><li><code>words[i]</code> 仅包含小写英文字母。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-palindrome-by-concatenating-two-letter-words" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindrome-by-concatenating-two-letter-words</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目比较简单, 但是实际处理稍微麻烦一些, 如理如下:</li></ol><ul><li>首先对所有的字符串进行 $hash$ 统计, 然后找到所有互为回文串的字符串 $s, t$, 即 $ s = reverse(t)$, 此时分为两种情况, 一种情况为 $s == t$ 和 $s \neq t$, 需要分别处理, 我们找到互为回文串对的数目, 必将其从 $hash$ 统计中取出掉, 最终得统计长度为 $length$.</li><li>最后我们在剩余的 $hash$ 统计中查找是否存在 $s == t$ , 如果存在我们将 $length = length + 2$, 返回 $length$ 即可.</li><li>感觉这个题目出的不好, 挺奇怪的题目, 应该加大难度一些.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(N)$ 其中 $N$ 为字符串的长度。</li><li>空间复杂度分析: $O(N)$ 为字符串的长度。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w : words)&#123;</span><br><span class="line">            cnt[w]++;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt) &#123;</span><br><span class="line">            <span class="built_in">string</span> x = v.first;</span><br><span class="line">            <span class="keyword">int</span> val = v.second;</span><br><span class="line">            <span class="built_in">string</span> y = x;</span><br><span class="line">            swap(y[<span class="number">0</span>], y[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(x == y) &#123;</span><br><span class="line">                <span class="keyword">if</span>(val&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    ans += (val - <span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">                    cnt[x] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += val*<span class="number">2</span>;</span><br><span class="line">                    cnt[x] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                val = min(val, cnt[y]);</span><br><span class="line">                cnt[x] -= val;</span><br><span class="line">                cnt[y] -= val;</span><br><span class="line">                ans += val*<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt) &#123;</span><br><span class="line">            <span class="built_in">string</span> x = v.first;</span><br><span class="line">            <span class="keyword">int</span> val = v.second;</span><br><span class="line">            <span class="built_in">string</span> y = x;</span><br><span class="line">            swap(y[<span class="number">0</span>], y[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (x == y &amp;&amp; val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5931-用邮票贴满网格图"><a href="#5931-用邮票贴满网格图" class="headerlink" title="5931. 用邮票贴满网格图"></a>5931. 用邮票贴满网格图</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，每个格子要么为 <code>0</code> （空）要么为 <code>1</code> （被占据）。</p><p>给你邮票的尺寸为 <code>stampHeight x stampWidth</code> 。我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：</p><ul><li>覆盖所有 空 格子。</li><li>不覆盖任何 被占据 的格子。</li><li>我们可以放入任意数目的邮票。</li><li>邮票可以相互有 重叠 部分。</li><li>邮票不允许 旋转 。</li><li>邮票必须完全在矩阵 内 。</li><li>如果在满足上述要求的前提下，可以放入邮票，请返回 <code>true</code> ，否则返回 <code>false</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]], stampHeight = <span class="number">4</span>, stampWidth = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：我们放入两个有重叠部分的邮票（图中标号为 <span class="number">1</span> 和 <span class="number">2</span>），它们能覆盖所有与空格子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]], stampHeight = <span class="number">2</span>, stampWidth = <span class="number">2</span> </span><br><span class="line">输出：<span class="literal">false</span> </span><br><span class="line">解释：没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[r].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 2 * 105</code></li><li><code>grid[r][c]</code> 要么是 <code>0</code>，要么是<code>1</code>。</li><li><code>1 &lt;= stampHeight, stampWidth &lt;= 105</code><br>。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stamping-the-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stamping-the-grid</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>前缀和或者线段树</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>很久没有看到比较新颖的题型和题目了，这个题目感觉出的很好,很少见到这样比较新颖的题目了，最重要的时间复杂度没有降下来.</li></ol><ul><li>首先分析一下题目,对于两点$(x,y),(x+stampHeight, y + stampWidth)$组成的矩形 需要判断邮票是否可以放下, 此时我们只需要检测矩形 $(x,y),(x+stampHeight, y + stampWidth)$ 内是否存在被占据的格子，由于空格子为$0$, 非空格子为$1$,如果该矩形内单元和大于 $0$,则表示矩形内一定存在被占据的格子, 否则不存在被占据的格子, 此时我们自然而然想到利用前缀和，可以直接在 $O(1)$ 的时间复杂度内判断是否该矩形是否可以被覆盖.</li><li>接下来我们自然而然想到找到所有可能被覆盖的矩形,然后判断这些矩形是否包含所有的空格子的点, 当然我们可以利用二分查找或者线段树查找之类的优化算法来判断,但是实现起来非常麻烦, 特别是涉及到二维的线段树判定, 比如我们可以找到所有横坐标区间在 $[x_1,x_2]$ 的节点, 然后在这些节点中再找到纵坐标在 $[y_1,y_2]$的节点,然后更新树.</li><li>对于每个坐标 $(x,y)$,我们只需要判断在矩形范围内 $(x - stampHeight + 1, y - stampWidth + 1)$ 范围内存在可以以该点 $(i,j)$ 为左上方顶点的矩形即可表示坐标 $(x,y)$ 可以被覆盖掉. 因此我们再用一次矩阵的前缀和即可.</li><li>对于每个坐标 $(x,y)$, </li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：时间复杂度为 $O(n \times m)$ , 其中 $n$ 表示矩阵的长度, $m$ 表示矩阵的宽度.</li><li>空间复杂度分析: $O(n \times m)$, 其中 $n$ 表示矩阵的长度, $m$ 表示矩阵的宽度.</li></ul></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possibleToStamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> stampHeight, <span class="keyword">int</span> stampWidth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sum(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; paint(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; psum(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                sum[i+<span class="number">1</span>][j+<span class="number">1</span>] = sum[i + <span class="number">1</span>][j] + sum[i][j + <span class="number">1</span>] - sum[i][j] + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> query = [](<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> matrix[x][y] - matrix[i][y] - matrix[x][j] + matrix[i][j];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m - stampHeight; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n - stampWidth; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span> &amp;&amp; query(sum, i, j, i + stampHeight, j + stampWidth) == <span class="number">0</span>)&#123;</span><br><span class="line">                    paint[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                psum[i + <span class="number">1</span>][j + <span class="number">1</span>] = psum[i + <span class="number">1</span>][j] + psum[i][j + <span class="number">1</span>] - psum[i][j] + paint[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = max(<span class="number">0</span>, i - stampHeight + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">int</span> y = max(<span class="number">0</span>, j - stampWidth + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(query(psum, x, y, i + <span class="number">1</span>, j + <span class="number">1</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-69&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-69&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 69&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 69&lt;/h1&gt;&lt;p&gt;双周赛的题目最后一题,果真难度比较大, 虽然没有参加, 但是感觉还是挺难的题目.&lt;/p&gt;&lt;h3 id=&quot;5960-将标题首字母大写&quot;&gt;&lt;a href=&quot;#5960-将标题首字母大写&quot; class=&quot;headerlink&quot; title=&quot;5960. 将标题首字母大写&quot;&gt;&lt;/a&gt;5960. 将标题首字母大写&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;title&lt;/code&gt; ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 大写 ：&lt;/p&gt;&lt;p&gt;如果单词的长度为 &lt;code&gt;1&lt;/code&gt;或者&lt;code&gt;2&lt;/code&gt; ，所有字母变成小写。&lt;br&gt;否则，将单词首字母大写，剩余字母变成小写。&lt;br&gt;请你返回 大写后 的 &lt;code&gt;title&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Weekly Contest 275</title>
    <link href="http://yoursite.com/2022/01/09/357/"/>
    <id>http://yoursite.com/2022/01/09/357/</id>
    <published>2022-01-09T03:10:32.078Z</published>
    <updated>2022-01-09T03:44:41.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-275"><a href="#leetcode-contest-275" class="headerlink" title="leetcode  contest 275"></a>leetcode  contest 275</h1><p>周赛题目放水的一次, 最后一题竟然是华为笔试的原题，感觉简单的不可思议。双周赛的难度反而比较难.<br><img src="https://s2.loli.net/2022/01/09/IXzeamP4V1CKhTF.png" alt></p><h3 id="5976-检查是否每一行每一列都包含全部整数"><a href="#5976-检查是否每一行每一列都包含全部整数" class="headerlink" title="5976. 检查是否每一行每一列都包含全部整数"></a>5976. 检查是否每一行每一列都包含全部整数</h3><p>对一个大小为<code>n x n</code> 的矩阵而言，如果其每一行和每一列都包含从<code>1</code> 到 <code>n</code> 的 全部 整数（含 <code>1</code> 和 <code>n</code>），则认为该矩阵是一个 有效 矩阵。</p><a id="more"></a><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>matrix</code> ，请你判断矩阵是否为一个有效矩阵：如果是，返回 <code>true</code> ；否则，返回 false 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：在此例中，n = <span class="number">3</span> ，每一行和每一列都包含数字 <span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span> 。</span><br><span class="line">因此，返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：在此例中，n = <span class="number">3</span> ，但第一行和第一列不包含数字 <span class="number">2</span> 和 <span class="number">3</span> 。</span><br><span class="line">因此，返回 <span class="literal">false</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == matrix.length == matrix[i].length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= matrix[i][j] &lt;= n`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-275/problems/check-if-every-row-and-column-contains-all-numbers/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  暴力检测</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 检测每一行，每一列是否都满足 $<span class="number">1.</span>..n$.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度分析: 时间复杂度为 $O(n^<span class="number">2</span>)$, 其中 $n$ 为矩阵的行数</span><br><span class="line">+ 空间复杂度分析: 空间复杂度为 $O(n)$。</span><br><span class="line"></span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> checkValid(vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            vector&lt;<span class="built_in">int</span>&gt; arr = matrix[i];</span><br><span class="line">            sort(arr.begin(),arr.end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] != j + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;<span class="built_in">int</span>&gt; brr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                brr.emplace_back(matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            sort(brr.begin(),brr.end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(brr[j] != j + <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5977-最少交换次数来组合所有的-1-II"><a href="#5977-最少交换次数来组合所有的-1-II" class="headerlink" title="5977. 最少交换次数来组合所有的 1 II"></a>5977. 最少交换次数来组合所有的 1 II</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>交换 定义为选中一个数组中的两个 互不相同 的位置并交换二者的值。</p><p>环形 数组是一个数组，可以认为 第一个 元素和 最后一个 元素 相邻 。</p><p>给你一个 二进制环形 数组 <code>nums</code> ，返回在 任意位置 将数组中的所有 <code>1</code> 聚集在一起需要的最少交换次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：这里列出一些能够将所有 <span class="number">1</span> 聚集在一起的方案：</span><br><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>] 交换 <span class="number">1</span> 次。</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] 交换 <span class="number">1</span> 次。</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>] 交换 <span class="number">2</span> 次（利用数组的环形特性）。</span><br><span class="line">无法在交换 <span class="number">0</span> 次的情况下将数组中的所有 <span class="number">1</span> 聚集在一起。</span><br><span class="line">因此，需要的最少交换次数为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：这里列出一些能够将所有 <span class="number">1</span> 聚集在一起的方案：</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>] 交换 <span class="number">2</span> 次（利用数组的环形特性）。</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] 交换 <span class="number">2</span> 次。</span><br><span class="line">无法在交换 <span class="number">0</span> 次或 <span class="number">1</span> 次的情况下将数组中的所有 <span class="number">1</span> 聚集在一起。</span><br><span class="line">因此，需要的最少交换次数为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：得益于数组的环形特性，所有的 <span class="number">1</span> 已经聚集在一起。</span><br><span class="line">因此，需要的最少交换次数为 <span class="number">0</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `nums[i]` 为 `<span class="number">0</span>` 或者 `<span class="number">1</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/number-of-laser-beams-in-a-bank</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  滑动窗口 + 前缀和</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的滑动窗口, 题目中要求求出所有满足将 $<span class="number">1</span>$ 聚集到一起的交换次数, 我们首先找到 $<span class="number">1</span>$ 的个数为 $k$, 然后我们依次找到所有的连续 $k$ 个元素中 $<span class="number">1</span>$ 的最大数目为 $val$, 最小的交换次数为 $k-val$, 此时我们只需将窗口中不为 $<span class="number">1</span>$ 的元素进行交换出去即可. 题目中要求数组为连续数组, 我们可以利用数组的前缀和来快速求出窗口中 $<span class="number">1</span>$ 的个数.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度度为 $O(n)$，其中$n$为数组的元素.</span><br><span class="line">+ 空间复杂度为 $O(n)$, 需要存储数组的前缀和.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minSwaps(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; sum(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = nums[i] + sum[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>) k++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k)&#123;</span><br><span class="line">                ans = min(ans, k - (sum[i] - sum[i-k]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,k - (sum[i] + sum[n] - sum[n-(k-i)]));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5978-统计追加字母可以获得的单词数"><a href="#5978-统计追加字母可以获得的单词数" class="headerlink" title="5978. 统计追加字母可以获得的单词数"></a>5978. 统计追加字母可以获得的单词数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个下标从 0 开始的字符串数组 <code>startWords</code> 和 <code>targetWords</code> 。每个字符串都仅由 小写英文字母 组成。</p><p>对于 <code>targetWords</code> 中的每个字符串，检查是否能够从 <code>startWords</code> 中选出一个字符串，执行一次 转换操作 ，得到的结果与当前 <code>targetWords</code> 字符串相等。</p><p>转换操作 如下面两步所述：</p><ul><li>追加 任何 不存在 于当前字符串的任一小写字母到当前字符串的末尾。</li><li>例如，如果字符串为 “abc” ，那么字母 ‘d’、’e’ 或 ‘y’ 都可以加到该字符串末尾，但 ‘a’ 就不行。如果追加的是 ‘d’ ，那么结果字符串为 “abcd” 。</li><li>重排 新字符串中的字母，可以按 任意 顺序重新排布字母。</li><li>例如，”abcd” 可以重排为 “acbd”、”bacd”、”cbda”，以此类推。注意，它也可以重排为 “abcd” 自身。</li></ul><p>找出 <code>targetWords</code> 中有多少字符串能够由 <code>startWords</code> 中的 任一 字符串执行上述转换操作获得。返回 <code>targetWords</code> 中这类 字符串的数目 。</p><p>注意：你仅能验证 <code>targetWords</code> 中的字符串是否可以由 <code>startWords</code> 中的某个字符串经执行操作获得。<code>startWords</code>  中的字符串在这一过程中 不 发生实际变更。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：startWords = [<span class="string">"ant"</span>,<span class="string">"act"</span>,<span class="string">"tack"</span>], targetWords = [<span class="string">"tack"</span>,<span class="string">"act"</span>,<span class="string">"acti"</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 为了形成 targetWords[<span class="number">0</span>] = <span class="string">"tack"</span> ，可以选用 startWords[<span class="number">1</span>] = <span class="string">"act"</span> ，追加字母 <span class="string">'k'</span> ，并重排 <span class="string">"actk"</span> 为 <span class="string">"tack"</span> 。</span><br><span class="line">- startWords 中不存在可以用于获得 targetWords[<span class="number">1</span>] = <span class="string">"act"</span> 的字符串。</span><br><span class="line">  注意 <span class="string">"act"</span> 确实存在于 startWords ，但是 必须 在重排前给这个字符串追加一个字母。</span><br><span class="line">- 为了形成 targetWords[<span class="number">2</span>] = <span class="string">"acti"</span> ，可以选用 startWords[<span class="number">1</span>] = <span class="string">"act"</span> ，追加字母 <span class="string">'i'</span> ，并重排 <span class="string">"acti"</span> 为 <span class="string">"acti"</span> 自身。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：startWords = [<span class="string">"ab"</span>,<span class="string">"a"</span>], targetWords = [<span class="string">"abc"</span>,<span class="string">"abcd"</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">- 为了形成 targetWords[<span class="number">0</span>] = <span class="string">"abc"</span> ，可以选用 startWords[<span class="number">0</span>] = <span class="string">"ab"</span> ，追加字母 <span class="string">'c'</span> ，并重排为 <span class="string">"abc"</span> 。</span><br><span class="line">- startWords 中不存在可以用于获得 targetWords[<span class="number">1</span>] = <span class="string">"abcd"</span> 的字符串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= startWords.length, targetWords.length &lt;= 5 * 104</code></li><li><code>1 &lt;= startWords[i].length, targetWords[j].length &lt;= 26</code></li><li><code>startWords</code> 和 <code>targetWords</code> 中的每个字符串都仅由小写英文字母组成</li><li>在 <code>startWords</code> 或 <code>targetWords</code> 的任一字符串中，每个字母至多出现一次</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-275/problems/count-words-obtained-after-adding-a-letter/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-275/problems/count-words-obtained-after-adding-a-letter/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>二进制编码</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目给定的策略比较简单，最终的提示为在 <code>startWords</code> 或 <code>targetWords</code> 的任一字符串中，每个字母至多出现一次，这样我们就可以利用二进制编码，将每个字符串编码为一个二进制数. 如果两个字符串的二进制编码一样，则一定可以利用排序将其变为两个相同的字符串, 首先我们对<code>startWords</code>进行编码然后插入到集合 $cnt$ 中, 然后对<code>targetWords</code>的每个字符串 $word$ 进行二进制编码, 然后我们依次尝试将 $word$ 中去掉一个字母后的编码在 $cnt$  中去查找, 如果可以查找到, 则我们认为该字符串 $word$ 一定可以通过变换得到.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(C\times N + M)$ 其中 $M$ 为字符串<code>startWords</code>的长度, $N$ 为字符串 <code>targetWords</code> 的长度。</li><li>空间复杂度分析: $O(N)$, 需要空间来存储字符串编码。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wordCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; startWords, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; targetWords)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; w : startWords) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : w)&#123;</span><br><span class="line">                val = val|(<span class="number">1</span>&lt;&lt;(c-<span class="string">'a'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.insert(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; w : targetWords) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : w)&#123;</span><br><span class="line">                val = val|(<span class="number">1</span>&lt;&lt;(c-<span class="string">'a'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(val&amp;(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt.count(val&amp;(~(<span class="number">1</span>&lt;&lt;i))))&#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5979-全部开花的最早一天"><a href="#5979-全部开花的最早一天" class="headerlink" title="5979. 全部开花的最早一天"></a>5979. 全部开花的最早一天</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你有 <code>n</code> 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 <code>0</code> 开始的整数数组 <code>plantTime</code> 和 <code>growTime</code> ，每个数组的长度都是 <code>n</code> ：</p><ul><li><code>plantTime[i]</code> 是 播种 第 <code>i</code> 枚种子所需的 完整天数 。每天，你只能为播种某一枚种子而劳作。无须 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 <code>plantTime[i]</code> 之后才算完成。</li><li><code>growTime[i]</code> 是第 <code>i</code> 枚种子完全种下后生长所需的 完整天数 。在它生长的最后一天 之后 ，将会开花并且永远 绽放 。</li><li>从第 <code>0</code> 开始，你可以按 任意 顺序播种种子。</li></ul><p>返回所有种子都开花的 最早 一天是第几天。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：plantTime = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>], growTime = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。</span><br><span class="line">一种最优方案是：</span><br><span class="line">第 <span class="number">0</span> 天，播种第 <span class="number">0</span> 枚种子，种子生长 <span class="number">2</span> 整天。并在第 <span class="number">3</span> 天开花。</span><br><span class="line">第 <span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span> 天，播种第 <span class="number">1</span> 枚种子。种子生长 <span class="number">3</span> 整天，并在第 <span class="number">8</span> 天开花。</span><br><span class="line">第 <span class="number">5</span>、<span class="number">6</span>、<span class="number">7</span> 天，播种第 <span class="number">2</span> 枚种子。种子生长 <span class="number">1</span> 整天，并在第 <span class="number">9</span> 天开花。</span><br><span class="line">因此，在第 <span class="number">9</span> 天，所有种子都开花。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：plantTime = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>], growTime = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 </span><br><span class="line">一种最优方案是：</span><br><span class="line">第 <span class="number">1</span> 天，播种第 <span class="number">0</span> 枚种子，种子生长 <span class="number">2</span> 整天。并在第 <span class="number">4</span> 天开花。</span><br><span class="line">第 <span class="number">0</span>、<span class="number">3</span> 天，播种第 <span class="number">1</span> 枚种子。种子生长 <span class="number">1</span> 整天，并在第 <span class="number">5</span> 天开花。</span><br><span class="line">第 <span class="number">2</span>、<span class="number">4</span>、<span class="number">5</span> 天，播种第 <span class="number">2</span> 枚种子。种子生长 <span class="number">2</span> 整天，并在第 <span class="number">8</span> 天开花。</span><br><span class="line">第 <span class="number">6</span>、<span class="number">7</span> 天，播种第 <span class="number">3</span> 枚种子。种子生长 <span class="number">1</span> 整天，并在第 <span class="number">9</span> 天开花。</span><br><span class="line">因此，在第 <span class="number">9</span> 天，所有种子都开花。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：plantTime = [<span class="number">1</span>], growTime = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：第 <span class="number">0</span> 天，播种第 <span class="number">0</span> 枚种子。种子需要生长 <span class="number">1</span> 整天，然后在第 <span class="number">2</span> 天开花。</span><br><span class="line">因此，在第 <span class="number">2</span> 天，所有种子都开花。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == plantTime.length == growTime.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= plantTime[i], growTime[i] &lt;= 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-69/problems/stamping-the-grid/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-69/problems/stamping-the-grid/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>贪心算法</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目与华为的笔试题目一模一样，不过是换了个名字. 典型的贪心算法, 我们可以看到题目由于播种时,最多只能同时播种一个种子, 无论按照何种播种顺序,总的播种时间是固定的, 由于播种完了,等待花开则不需要顺序, 题目要求使得所有的花开时间最短,因此我们应该利用贪心算法, 尽量让等待花开时间最长的优先播种,等待花开的这段时间可以用来播种.如果所有的等待花开时间是一样的, 那么无论如何排序, 所有花开的时间都是一样的, 我们求出最大的花开时间即为所有花开的最早时间.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：时间复杂度为 $O(n \log n)$ , 其中 $n$ 表示数组的长度, 需要进行一次排序.</li><li>空间复杂度分析: $O(n)$, 其中 $n$ 表示拷贝数组进行排序.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">earliestFullBloom</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; plantTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; growTime)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> n = plantTime.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr.emplace_back(growTime[i], plantTime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(), arr.end(), [&amp;](<span class="keyword">const</span>  pii &amp; a, <span class="keyword">const</span> pii &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.first == b.first) <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += arr[i].second;</span><br><span class="line">            ans = max(ans, curr + arr[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-275&quot;&gt;&lt;a href=&quot;#leetcode-contest-275&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 275&quot;&gt;&lt;/a&gt;leetcode  contest 275&lt;/h1&gt;&lt;p&gt;周赛题目放水的一次, 最后一题竟然是华为笔试的原题，感觉简单的不可思议。双周赛的难度反而比较难.&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/09/IXzeamP4V1CKhTF.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5976-检查是否每一行每一列都包含全部整数&quot;&gt;&lt;a href=&quot;#5976-检查是否每一行每一列都包含全部整数&quot; class=&quot;headerlink&quot; title=&quot;5976. 检查是否每一行每一列都包含全部整数&quot;&gt;&lt;/a&gt;5976. 检查是否每一行每一列都包含全部整数&lt;/h3&gt;&lt;p&gt;对一个大小为&lt;code&gt;n x n&lt;/code&gt; 的矩阵而言，如果其每一行和每一列都包含从&lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 的 全部 整数（含 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt;），则认为该矩阵是一个 有效 矩阵。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Weekly Contest 274</title>
    <link href="http://yoursite.com/2022/01/03/356/"/>
    <id>http://yoursite.com/2022/01/03/356/</id>
    <published>2022-01-03T06:09:54.607Z</published>
    <updated>2022-01-05T09:29:47.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-274"><a href="#leetcode-contest-274" class="headerlink" title="leetcode  contest 274"></a>leetcode  contest 274</h1><p>周赛题目放水的一次,最后一题确实不错的题目,非常有新意的题目.</p><h3 id="2124-检查是否所有-A-都在-B-之前"><a href="#2124-检查是否所有-A-都在-B-之前" class="headerlink" title="2124. 检查是否所有 A 都在 B 之前"></a>2124. 检查是否所有 A 都在 B 之前</h3><p>给你一个 仅 由字符 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 组成的字符串<code>s</code> 。如果字符串中 每个 <code>&#39;a&#39;</code> 都出现在 每个 <code>&#39;b&#39;</code> 之前，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaabbb"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line"><span class="string">'a'</span> 位于下标 <span class="number">0</span>、<span class="number">1</span> 和 <span class="number">2</span> ；而 <span class="string">'b'</span> 位于下标 <span class="number">3</span>、<span class="number">4</span> 和 <span class="number">5</span> 。</span><br><span class="line">因此，每个 <span class="string">'a'</span> 都出现在每个 <span class="string">'b'</span> 之前，所以返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abab"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：</span><br><span class="line">存在一个 <span class="string">'a'</span> 位于下标 <span class="number">2</span> ，而一个 <span class="string">'b'</span> 位于下标 <span class="number">1</span> 。</span><br><span class="line">因此，不能满足每个 <span class="string">'a'</span> 都出现在每个 <span class="string">'b'</span> 之前，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"bbb"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">不存在 <span class="string">'a'</span> ，因此可以视作每个 <span class="string">'a'</span> 都出现在每个 <span class="string">'b'</span> 之前，所以返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code> 为 <code>&#39;a&#39;</code> 或 <code>&#39;b&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们只需要找到最后一个 <code>a</code> 的位置与最开始的 <code>b</code>.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n)$, 其中 $n$ 为字符串的长度。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos2 = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'a'</span>) &#123;</span><br><span class="line">                pos1 = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'b'</span> &amp;&amp; pos2 == s.size()) &#123;</span><br><span class="line">                pos2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos1 &lt;= pos2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2125-银行中的激光束数量"><a href="#2125-银行中的激光束数量" class="headerlink" title="2125. 银行中的激光束数量"></a>2125. 银行中的激光束数量</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>银行内部的防盗安全装置已经激活。给你一个下标从 <code>0</code> 开始的二进制字符串数组 <code>bank</code> ，表示银行的平面图，这是一个大小为 <code>m x n</code>的二维矩阵。 <code>bank[i]</code> 表示第 <code>i</code> 行的设备分布，由若干 <code>&#39;0&#39;</code> 和若干 <code>&#39;1&#39;</code> 组成。<code>&#39;0&#39;</code> 表示单元格是空的，而 <code>&#39;1&#39;</code> 表示单元格有一个安全设备。</p><p>对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：</p><p>两个设备位于两个 不同行 ：<code>r1</code> 和 <code>r2</code> ，其中 <code>r1 &lt; r2</code> 。<br>满足 <code>r1 &lt; i &lt; r2</code> 的 所有 行<code>i</code> ，都 没有安全设备 。<br>激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</p><p>返回银行中激光束的总数量。</p><p>示例 1：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：bank = ["011001","000000","010100","001000"]</span><br><span class="line">输出：8</span><br><span class="line">解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：</span><br><span class="line"><span class="bullet"> * </span>bank[<span class="string">0</span>][<span class="symbol">1</span>] -- bank[<span class="string">2</span>][<span class="symbol">1</span>]</span><br><span class="line"><span class="bullet"> * </span>bank[<span class="string">0</span>][<span class="symbol">1</span>] -- bank[<span class="string">2</span>][<span class="symbol">3</span>]</span><br><span class="line"><span class="bullet"> * </span>bank[<span class="string">0</span>][<span class="symbol">2</span>] -- bank[<span class="string">2</span>][<span class="symbol">1</span>]</span><br><span class="line"><span class="bullet"> * </span>bank[<span class="string">0</span>][<span class="symbol">2</span>] -- bank[<span class="string">2</span>][<span class="symbol">3</span>]</span><br><span class="line"><span class="bullet"> * </span>bank[<span class="string">0</span>][<span class="symbol">5</span>] -- bank[<span class="string">2</span>][<span class="symbol">1</span>]</span><br><span class="line"><span class="bullet"> * </span>bank[<span class="string">0</span>][<span class="symbol">5</span>] -- bank[<span class="string">2</span>][<span class="symbol">3</span>]</span><br><span class="line"><span class="bullet"> * </span>bank[<span class="string">2</span>][<span class="symbol">1</span>] -- bank[<span class="string">3</span>][<span class="symbol">2</span>]</span><br><span class="line"><span class="bullet"> * </span>bank[<span class="string">2</span>][<span class="symbol">3</span>] -- bank[<span class="string">3</span>][<span class="symbol">2</span>]</span><br><span class="line">注意，第 0 行和第 3 行上的设备之间不存在激光束。</span><br><span class="line">这是因为第 2 行存在安全设备，这不满足第 2 个条件。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">bank </span>= [<span class="string">"000"</span>,<span class="string">"111"</span>,<span class="string">"000"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在两个位于不同行的设备</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == bank.length</code></li><li><code>n == bank[i].length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>bank[i][j]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们每次记录前一行含有安全设备的数量为 $prev$, 我们记录本行的含有的安全设备为 $cnt$, 则此次新增加的激光束的数量为 $prev \times cnt$, 然后我们再更新 $prev = cnt$, 最终我们即可求出总的激光束的数目.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(n \times m)$，其中$n$ 行数, $m$ 表示列数.</li><li>空间复杂度为 $O(1)$, 除了需要记录前一行的装置的数目外,不需要额外的空间.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; bank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : bank) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : v) &#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'1'</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cnt * prev;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                prev = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2126-摧毁小行星"><a href="#2126-摧毁小行星" class="headerlink" title="2126. 摧毁小行星"></a>2126. 摧毁小行星</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>mass</code> ，它表示一颗行星的初始质量。再给你一个整数数组 <code>asteroids</code> ，其中 <code>asteroids[i]</code> 是第 <code>i</code> 颗小行星的质量。</p><p>你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。</p><p>如果所有小行星 都 能被摧毁，请返回 <code>true</code>，否则返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：mass = <span class="number">10</span>, asteroids = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">19</span>,<span class="number">5</span>,<span class="number">21</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：一种安排小行星的方式为 [<span class="number">9</span>,<span class="number">19</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">21</span>] ：</span><br><span class="line">- 行星与质量为 <span class="number">9</span> 的小行星碰撞。新的行星质量为：<span class="number">10</span> + <span class="number">9</span> = <span class="number">19</span></span><br><span class="line">- 行星与质量为 <span class="number">19</span> 的小行星碰撞。新的行星质量为：<span class="number">19</span> + <span class="number">19</span> = <span class="number">38</span></span><br><span class="line">- 行星与质量为 <span class="number">5</span> 的小行星碰撞。新的行星质量为：<span class="number">38</span> + <span class="number">5</span> = <span class="number">43</span></span><br><span class="line">- 行星与质量为 <span class="number">3</span> 的小行星碰撞。新的行星质量为：<span class="number">43</span> + <span class="number">3</span> = <span class="number">46</span></span><br><span class="line">- 行星与质量为 <span class="number">21</span> 的小行星碰撞。新的行星质量为：<span class="number">46</span> + <span class="number">21</span> = <span class="number">67</span></span><br><span class="line">所有小行星都被摧毁。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mass = <span class="number">5</span>, asteroids = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：</span><br><span class="line">行星无论如何没法获得足够质量去摧毁质量为 <span class="number">23</span> 的小行星。</span><br><span class="line">行星把别的小行星摧毁后，质量为 <span class="number">5</span> + <span class="number">4</span> + <span class="number">9</span> + <span class="number">4</span> = <span class="number">22</span> 。</span><br><span class="line">它比 <span class="number">23</span> 小，所以无法摧毁最后一颗小行星。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= mass &lt;= 105</code></li><li><code>1 &lt;= asteroids.length &lt;= 105</code></li><li><code>1 &lt;= asteroids[i] &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/destroying-asteroids" target="_blank" rel="noopener">https://leetcode-cn.com/problems/destroying-asteroids</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的贪心算法, 按照题目肯定是优先吸收质量比较小的星球, 从而增加自身的质量, 从而使得自身的质量越来越大而可以吸收质量更大的星球, 我们将所有的星球按照质量大小进行排序, 依次进行吸收即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(N)$ 其中 $N$ 为数组的长度。</li><li>空间复杂度分析: $O(1)$。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">asteroidsDestroyed</span><span class="params">(<span class="keyword">int</span> mass, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; asteroids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tot = mass;</span><br><span class="line">        sort(asteroids.begin(), asteroids.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : asteroids) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tot &gt;= v) &#123;</span><br><span class="line">                tot += v;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5970-参加会议的最多员工数"><a href="#5970-参加会议的最多员工数" class="headerlink" title="5970. 参加会议的最多员工数"></a>5970. 参加会议的最多员工数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个公司准备组织一场会议，邀请名单上有 <code>n</code> 位员工。公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工。</p><p>员工编号为 <code>0</code> 到 <code>n - 1</code> 。每位员工都有一位 喜欢 的员工，每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 不会 是他自己。</p><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>favorite</code> ，其中 <code>favorite[i]</code> 表示第 <code>i</code> 位员工喜欢的员工。请你返回参加会议的 最多员工数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">上图展示了公司邀请员工 <span class="number">0</span>，<span class="number">1</span> 和 <span class="number">2</span> 参加会议以及他们在圆桌上的座位。</span><br><span class="line">没办法邀请所有员工参与会议，因为员工 <span class="number">2</span> 没办法同时坐在 <span class="number">0</span>，<span class="number">1</span> 和 <span class="number">3</span> 员工的旁边。</span><br><span class="line">注意，公司也可以邀请员工 <span class="number">1</span>，<span class="number">2</span> 和 <span class="number">3</span> 参加会议。</span><br><span class="line">所以最多参加会议的员工数目为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。</span><br><span class="line">座位安排同图 <span class="number">1</span> 所示：</span><br><span class="line">- 员工 <span class="number">0</span> 坐在员工 <span class="number">2</span> 和 <span class="number">1</span> 之间。</span><br><span class="line">- 员工 <span class="number">1</span> 坐在员工 <span class="number">0</span> 和 <span class="number">2</span> 之间。</span><br><span class="line">- 员工 <span class="number">2</span> 坐在员工 <span class="number">1</span> 和 <span class="number">0</span> 之间。</span><br><span class="line">参与会议的最多员工数目为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">上图展示了公司可以邀请员工 <span class="number">0</span>，<span class="number">1</span>，<span class="number">3</span> 和 <span class="number">4</span> 参加会议以及他们在圆桌上的座位。</span><br><span class="line">员工 <span class="number">2</span> 无法参加，因为他喜欢的员工 <span class="number">0</span> 旁边的座位已经被占领了。</span><br><span class="line">所以公司只能不邀请员工 <span class="number">2</span> 。</span><br><span class="line">参加会议的最多员工数目为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == favorite.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= favorite[i] &lt;= n - 1</code></li><li><code>favorite[i] != i</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>图论</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>很久没有看到比较新颖的题型和题目了，这个题目还算比较新颖的题目. 关于图论的问题, 参考了<a href="https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/" target="_blank" rel="noopener">内向基环树</a>的题解说明，也去维基百科查阅了相关的资料，感觉还算挺麻烦的题目.<a href="https://www.codetd.com/article/7620085#_2" target="_blank" rel="noopener">基环树1</a>,<a href="https://www.cnblogs.com/OI-zzyy/p/11172492.html" target="_blank" rel="noopener">基环树2</a>, 感觉这些知识基本上都是竞赛级别的知识点了.</li><li>检测过程如下: 能够组成会议的所有成员只包含以下两种:</li></ol><ul><li>所有的成员依赖形成一个环, 环上的节点大于等于 $3$ 个, 比如: <script type="math/tex; mode=display">A \rightarrow B \rightarrow C \rightarrow D \rightarrow E \rightarrow F \cdots \rightarrow A</script></li><li>要么所有的成员都能够分组,且每个分组都符合以下特征:<script type="math/tex; mode=display">A \rightarrow B \rightarrow C \leftrightarrow D \leftarrow E \leftarrow F \cdots \leftarrow A</script>每个分组都包含一个环，但是环中只有 $2$ 个数据.</li></ul></blockquote><p>我们依次找到这两种情况的最大值:</p><ul><li>找到图中最大的环, 这个比较简单, 我们可以用 $DFS$ 或者 $BFS$ 的方法均可, 如果用 $DFS$ 则我们可以将所有的环的路径均保存起来即可. 如果用 $BFS$ 则我们可以利用拓扑排序的方法.</li><li>检测第二种情况的话,会比较麻烦一些,需要用到你想图的方法．</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：时间复杂度为 $O(n)$ , 其中 $n$ 表示数组的长度, $DFS$ 或者 $BFS$ 只需要遍历一遍数组即可.</li><li>空间复杂度分析: $O(n)$, 其中 $n$ 表示数组的长度.需要存储每个节点的长度.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li><code>DFS</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, max_loop, from_pairs;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; color, dep;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pairs;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rev;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        color[u] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : rev[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!color[v]) &#123;</span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                dfs(v);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> loop = dep[u] - dep[v] + <span class="number">1</span>;</span><br><span class="line">                max_loop = max(max_loop, loop);</span><br><span class="line">                <span class="keyword">if</span> (loop == <span class="number">2</span>)</span><br><span class="line">                    pairs.emplace_back(u, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        color[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_depth = d;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : rev[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != p)</span><br><span class="line">                max_depth = max(max_depth, dfs2(v, p, d + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumInvitations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; favorite)</span> </span>&#123;</span><br><span class="line">        n = favorite.size();</span><br><span class="line">        color = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        dep = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        max_loop = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        rev = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            rev[favorite[i]].emplace_back(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!color[i])</span><br><span class="line">                dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        from_pairs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[u, v] : pairs) &#123;</span><br><span class="line">            from_pairs += dfs2(u, v, <span class="number">1</span>);</span><br><span class="line">            from_pairs += dfs2(v, u, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(max_loop, from_pairs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>BFS</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumInvitations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; favorite)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = favorite.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出第一种情况, 求出节点数目最多的环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            degree[favorite[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">while</span>(!visit[x]) &#123;</span><br><span class="line">                    path.emplace_back(x);</span><br><span class="line">                    visit[x] = <span class="literal">true</span>;</span><br><span class="line">                    x = favorite[x];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size(); ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(path[j] == x) &#123;</span><br><span class="line">                        ans = max(ans, (<span class="keyword">int</span>)path.size() - j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用拓扑排序求出环上的节点的树枝的最大长度, 不太好理解.</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                qu.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            dp[favorite[curr]] = max(dp[favorite[curr]], dp[curr] + <span class="number">1</span>);</span><br><span class="line">            degree[favorite[curr]]--;</span><br><span class="line">            <span class="keyword">if</span>(degree[favorite[curr]] == <span class="number">0</span>) &#123;</span><br><span class="line">                qu.push(favorite[curr]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pairSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 只有两个节点的环上的最大的树枝的长度</span></span><br><span class="line">            <span class="keyword">if</span>(favorite[favorite[i]] == i &amp;&amp; favorite[i] &gt; i) &#123;</span><br><span class="line">                pairSum += dp[i] + dp[favorite[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, pairSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-274&quot;&gt;&lt;a href=&quot;#leetcode-contest-274&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 274&quot;&gt;&lt;/a&gt;leetcode  contest 274&lt;/h1&gt;&lt;p&gt;周赛题目放水的一次,最后一题确实不错的题目,非常有新意的题目.&lt;/p&gt;&lt;h3 id=&quot;2124-检查是否所有-A-都在-B-之前&quot;&gt;&lt;a href=&quot;#2124-检查是否所有-A-都在-B-之前&quot; class=&quot;headerlink&quot; title=&quot;2124. 检查是否所有 A 都在 B 之前&quot;&gt;&lt;/a&gt;2124. 检查是否所有 A 都在 B 之前&lt;/h3&gt;&lt;p&gt;给你一个 仅 由字符 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt; 组成的字符串&lt;code&gt;s&lt;/code&gt; 。如果字符串中 每个 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 都出现在 每个 &lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt; 之前，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Weekly Contest 273</title>
    <link href="http://yoursite.com/2021/12/26/355/"/>
    <id>http://yoursite.com/2021/12/26/355/</id>
    <published>2021-12-26T04:22:03.444Z</published>
    <updated>2021-12-27T03:36:01.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-273"><a href="#leetcode-contest-273" class="headerlink" title="leetcode  contest 273"></a>leetcode  contest 273</h1><p>周赛题目放水的一次.都是基本上是中等难度题目.</p><h3 id="5963-反转两次的数字"><a href="#5963-反转两次的数字" class="headerlink" title="5963. 反转两次的数字"></a>5963. 反转两次的数字</h3><p>反转 一个整数意味着倒置它的所有位。</p><p>例如，反转 <code>2021</code> 得到 <code>1202</code> 。反转 <code>12300</code> 得到 <code>321</code> ，不保留前导零 。<br>给你一个整数 <code>num</code> ，反转 <code>num</code> 得到 <code>reversed1</code> ，接着反转 <code>reversed1</code> 得到 <code>reversed2</code> 。如果 <code>reversed2</code> 等于 <code>num</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><a id="more"></a><p>提示：</p><ul><li><code>0 &lt;= num &lt;= 106</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/a-number-after-a-double-reversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/a-number-after-a-double-reversal/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>反转两次由于前导<code>0</code>的原因会导致数据不同, 因此我们只需要判断当前数的末尾是否还有<code>0</code>即可, 当然特殊的是<code>0</code>本身需要排除在外.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(1)$。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameAfterReversals</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span> || num%<span class="number">10</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5964-执行所有后缀指令"><a href="#5964-执行所有后缀指令" class="headerlink" title="5964. 执行所有后缀指令"></a>5964. 执行所有后缀指令</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>现有一个 <code>n x n</code> 大小的网格，左上角单元格坐标 <code>(0, 0)</code> ，右下角单元格坐标 <code>(n - 1, n - 1)</code> 。给你整数 <code>n</code> 和一个整数数组 <code>startPos</code> ，其中 <code>startPos = [startrow, startcol]</code> 表示机器人最开始在坐标为 <code>(startrow, startcol)</code> 的单元格上。</p><p>另给你一个长度为 <code>m</code> 、下标从 <code>0</code> 开始的字符串 s ，其中 <code>s[i]</code> 是对机器人的第 <code>i</code> 条指令：’L’（向左移动），’R’（向右移动），’U’（向上移动）和 ‘D’（向下移动）。</p><p>机器人可以从 <code>s</code> 中的任一第 i 条指令开始执行。它将会逐条执行指令直到 s 的末尾，但在满足下述条件之一时，机器人将会停止：</p><p>下一条指令将会导致机器人移动到网格外。<br>没有指令可以执行。<br>返回一个长度为 <code>m</code> 的数组<code>answer</code> ，其中 <code>answer[i]</code> 是机器人从第 <code>i</code>条指令开始 ，可以执行的 指令数目 。</p><p>提示：</p><ul><li><code>m == s.length</code></li><li><code>1 &lt;= n, m &lt;= 500</code></li><li><code>startPos.length == 2</code></li><li><code>0 &lt;= startrow, startcol &lt; n</code></li><li><code>s</code> 由 ‘L’、’R’、’U’ 和 ‘D’ 组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接检测</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>直接遍历检测, 每次我们第<code>i</code>条指令开始进行行走, 检测机器人最多可以走的步数即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(n^2)$，其中$n$指令的长度.</li><li>空间复杂度为 $O(1)$, 除了函数返回值本身的空间外,不需要额外的空间.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; executeInstructions(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startPos, <span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = startPos[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = startPos[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">'L'</span>)&#123;</span><br><span class="line">                    y--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[j] == <span class="string">'R'</span>)&#123;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[j] == <span class="string">'U'</span>)&#123;</span><br><span class="line">                    x--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[j] == <span class="string">'D'</span>)&#123;</span><br><span class="line">                    x++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= n)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans[i] = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5965-相同元素的间隔之和"><a href="#5965-相同元素的间隔之和" class="headerlink" title="5965. 相同元素的间隔之和"></a>5965. 相同元素的间隔之和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始、由 <code>n</code> 个整数组成的数组 <code>arr</code> 。</p><p><code>arr</code> 中两个元素的 间隔 定义为它们下标之间的 绝对差 。更正式地，<code>arr[i]</code> 和 <code>arr[j]</code> 之间的间隔是 |i - j| 。</p><p>返回一个长度为 <code>n</code> 的数组 <code>intervals</code> ，其中 <code>intervals[i]</code> 是 <code>arr[i]</code> 和<code>arr</code> 中每个相同元素（与 arr[i] 的值相同）的 间隔之和 。</p><ul><li>注意：<code>|x|</code>是 <code>x</code> 的绝对值。</li></ul><p>提示：`</p><ul><li><code>n == arr.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= arr[i] &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/intervals-between-identical-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intervals-between-identical-elements</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>前缀和</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的前缀和.首先我们按照相同的数字将索引进行分类, 然后利用前缀和和后缀和 依次求出每个索引到其他索引的绝对值之和.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(N)$ 其中 $N$ 为数组的长度。</li><li>空间复杂度分析: $O(N)$, 其中 $N$为数组的长度。。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; getDistances(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cnt[A[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : cnt)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = v.second;</span><br><span class="line">            <span class="keyword">int</span> m = arr.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; left(m);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; right(m);</span><br><span class="line">            left[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">                </span><br><span class="line">                left[i] = left[i<span class="number">-1</span>] + arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            right[m<span class="number">-1</span>] =arr[m<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">                right[i] = right[i+<span class="number">1</span>] + arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">                ans[arr[i]] = <span class="built_in">abs</span>(left[i] - (<span class="keyword">long</span> <span class="keyword">long</span>)(i+<span class="number">1</span>)*arr[i]) + <span class="built_in">abs</span>(right[i] - (<span class="keyword">long</span> <span class="keyword">long</span>)(m-i)*arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5966-还原原数组"><a href="#5966-还原原数组" class="headerlink" title="5966. 还原原数组"></a>5966. 还原原数组</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><code>Alice</code> 有一个下标从 <code>0</code> 开始的数组 <code>arr</code> ，由 n 个正整数组成。她会选择一个任意的 正整数 k 并按下述方式创建两个下标从 0 开始的新整数数组 lower 和 higher ：</p><ul><li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>lower[i] = arr[i] - k</code></li><li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>higher[i] = arr[i] + k</code><br>不幸地是，<code>Alice</code> 丢失了全部三个数组。但是，她记住了在数组 <code>lower</code> 和 <code>higher</code> 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 <code>Alice</code> 还原原数组。</li></ul><p>给你一个由 <code>2n</code> 个整数组成的整数数组 <code>nums</code> ，其中 恰好 n 个整数出现在<code>lower</code> ，剩下的出现在 higher ，还原并返回 原数组 <code>arr</code> 。如果出现答案不唯一的情况，返回 任一 有效数组。</p><p>注意：生成的测试用例保证存在 至少一个 有效数组 <code>arr</code>。</p><p>提示：</p><ul><li><code>1 &lt;= left &lt;= right &lt;= 106</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/recover-the-original-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/recover-the-original-array</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>枚举　＋　排序</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>感觉本题可以算是难度中等的题目了，由于题目的数据量比较小，我们可以枚举所有可能的 $k$,然后检测当前的$k$ 是否满足题意要求, 即是否可以将原数组分离出两个数组, 两个数组中每个对应的元素的差值刚好为 $2k$.</li><li>检测过程如下:</li></ol><ul><li>首先我们对数组 $nums$ 进行排序, 我们知道符合要求的 $k$ 一定包含在 $nums[i] - nums[0] \quad (i &gt; 0)$ 中,因此我们需要枚举所有可能的 $i$ 即可,从而得到不同的 $k$.</li><li>我们知道对于最终的数组一定满足 $lower[i] = arr[i] - k, higher[i] = arr[i] + k$，因此对于排序好的数组一定满足 $higher[i] &gt; lower[i]$, 因此我们知道对于数组$nums$中的最小数一定是属于 $lower$ 数组的, 最大的数一定是属于 $higher$ 数组的.因此我们每次找到数组$nums$的最小值 $nums[j]$,则我们可以知道 $nums[j]$ 属于 $lower$, $nums[j] + 2*k$ 一定属于 $higher$, 我们每次从数组$nums$ 中挑选两个符合要求的数据, 然后进行删除,直到数组 $nums$ 全部删除,则此时即可找到符合要求的数组.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：时间复杂度为$n^2$, 其中 $n$ 为 $right - left$, 由于其中还存在求 $2$ 的因子, 所以还可能需要有 $logn$ 的运算. 如果用二叉平衡树的方法,则实践复杂度为 $n^2 \log n$.</li><li>空间复杂度分析: $O(n)$, 需要长度为 $n$ 的空间保存中间变量.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li><code>Treeset</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; recoverArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i] - nums[<span class="number">0</span>])%<span class="number">2</span> || nums[i] == nums[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> k = (nums[i] - nums[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; cnt(nums.begin(), nums.end());</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (cnt.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> lowerIt = cnt.begin();</span><br><span class="line">                <span class="keyword">int</span> val = *lowerIt + k;</span><br><span class="line">                cnt.erase(lowerIt);</span><br><span class="line">                <span class="keyword">auto</span> upperIt = cnt.find(val + k);</span><br><span class="line">                <span class="keyword">if</span>(upperIt == cnt.end()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.emplace_back(val);</span><br><span class="line">                cnt.erase(upperIt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans.size() == m) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>双指针:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; recoverArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i] - nums[<span class="number">0</span>])%<span class="number">2</span> || nums[i] == nums[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> k = (nums[i] - nums[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = i;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n, <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(left &lt; n &amp;&amp; right &lt; n) &#123;</span><br><span class="line">                <span class="comment">/*find next key number*/</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; n &amp;&amp; visit[left]) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(right &lt; n &amp;&amp; (visit[right] || nums[right] - nums[left] &lt; <span class="number">2</span> * k)) &#123;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right &lt; n &amp;&amp; nums[right] - nums[left] &gt; <span class="number">2</span>*k) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.emplace_back(nums[left] + k);</span><br><span class="line">                visit[left] = <span class="literal">true</span>;</span><br><span class="line">                visit[right] = <span class="literal">true</span>;</span><br><span class="line">                left++;</span><br><span class="line">                right++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans.size() == m) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-273&quot;&gt;&lt;a href=&quot;#leetcode-contest-273&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 273&quot;&gt;&lt;/a&gt;leetcode  contest 273&lt;/h1&gt;&lt;p&gt;周赛题目放水的一次.都是基本上是中等难度题目.&lt;/p&gt;&lt;h3 id=&quot;5963-反转两次的数字&quot;&gt;&lt;a href=&quot;#5963-反转两次的数字&quot; class=&quot;headerlink&quot; title=&quot;5963. 反转两次的数字&quot;&gt;&lt;/a&gt;5963. 反转两次的数字&lt;/h3&gt;&lt;p&gt;反转 一个整数意味着倒置它的所有位。&lt;/p&gt;&lt;p&gt;例如，反转 &lt;code&gt;2021&lt;/code&gt; 得到 &lt;code&gt;1202&lt;/code&gt; 。反转 &lt;code&gt;12300&lt;/code&gt; 得到 &lt;code&gt;321&lt;/code&gt; ，不保留前导零 。&lt;br&gt;给你一个整数 &lt;code&gt;num&lt;/code&gt; ，反转 &lt;code&gt;num&lt;/code&gt; 得到 &lt;code&gt;reversed1&lt;/code&gt; ，接着反转 &lt;code&gt;reversed1&lt;/code&gt; 得到 &lt;code&gt;reversed2&lt;/code&gt; 。如果 &lt;code&gt;reversed2&lt;/code&gt; 等于 &lt;code&gt;num&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 68</title>
    <link href="http://yoursite.com/2021/12/26/354/"/>
    <id>http://yoursite.com/2021/12/26/354/</id>
    <published>2021-12-26T04:21:59.592Z</published>
    <updated>2021-12-26T15:35:09.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-68"><a href="#leetcode-biweekly-contest-68" class="headerlink" title="leetcode biweekly contest 68"></a>leetcode biweekly contest 68</h1><p>今天双周赛前三题还算是常规题目,最后一题是数学题目,比较少见的求精度的题目.<br><img src="https://s2.loli.net/2021/12/26/YApaJQgNEvb5ktF.png" alt></p><h3 id="5956-找出数组中的第一个回文字符串"><a href="#5956-找出数组中的第一个回文字符串" class="headerlink" title="5956. 找出数组中的第一个回文字符串"></a>5956. 找出数组中的第一个回文字符串</h3><p>一个 句子 由一些 单词 以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。</p><p>给你一个字符串数组 <code>sentences</code> ，其中 <code>sentences[i]</code> 表示单个句子 。</p><a id="more"></a><p>请你返回单个句子里 单词的最多数目 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：sentences = [<span class="string">"alice and bob love leetcode"</span>, <span class="string">"i think so too"</span>, <span class="string">"this is great thanks very much"</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">- 第一个句子 <span class="string">"alice and bob love leetcode"</span> 总共有 <span class="number">5</span> 个单词。</span><br><span class="line">- 第二个句子 <span class="string">"i think so too"</span> 总共有 <span class="number">4</span> 个单词。</span><br><span class="line">- 第三个句子 <span class="string">"this is great thanks very much"</span> 总共有 <span class="number">6</span> 个单词。</span><br><span class="line">所以，单个句子中有最多单词数的是第三个句子，总共有 <span class="number">6</span> 个单词。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentences</span> = [<span class="string">"please wait"</span>, <span class="string">"continue to fight"</span>, <span class="string">"continue to win"</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：可能有多个句子有相同单词数。</span><br><span class="line">这个例子中，第二个句子和第三个句子（加粗斜体）有相同数目的单词数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentences.length &lt;= 100</code></li><li><code>1 &lt;= sentences[i].length &lt;= 100</code></li><li><code>sentences[i]</code> 只包含小写英文字母和 ‘ ‘ 。</li><li><code>sentences[i]</code> 的开头和结尾都没有空格。</li><li><code>sentences[i]</code> 中所有单词由单个空格隔开。<br>。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-words-found-in-sentences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-words-found-in-sentences</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>遍历每个字符串,从句子中分离出单词，找到单词数目最多的句子即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(nm)$, 其中 $n$ 为数组的元素的个数, $m$ 表示每个字符串的平均长度。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostWordsFound</span><span class="params">(self, sentences: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max([len(s.split()) <span class="keyword">for</span> s <span class="keyword">in</span> sentences])</span><br></pre></td></tr></table></figure><h2 id="5947-从给定原材料中找到所有可以做出的菜"><a href="#5947-从给定原材料中找到所有可以做出的菜" class="headerlink" title="5947. 从给定原材料中找到所有可以做出的菜"></a>5947. 从给定原材料中找到所有可以做出的菜</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你有 <code>n</code> 道不同菜的信息。给你一个字符串数组 <code>recipes</code> 和一个二维字符串数组 <code>ingredients</code> 。第 <code>i</code> 道菜的名字为 <code>recipes[i]</code> ，如果你有它 所有 的原材料 <code>ingredients[i]</code> ，那么你可以 做出 这道菜。一道菜的原材料可能是 另一道 菜，也就是说 <code>ingredients[i]</code> 可能包含 <code>recipes</code> 中另一个字符串。</p><p>同时给你一个字符串数组 <code>supplies</code> ，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。</p><p>请你返回你可以做出的所有菜。你可以以 任意顺序 返回它们。</p><p>注意两道菜在它们的原材料中可能互相包含。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：recipes = [<span class="string">"bread"</span>], ingredients = [[<span class="string">"yeast"</span>,<span class="string">"flour"</span>]], supplies = [<span class="string">"yeast"</span>,<span class="string">"flour"</span>,<span class="string">"corn"</span>]</span><br><span class="line">输出：[<span class="string">"bread"</span>]</span><br><span class="line">解释：</span><br><span class="line">我们可以做出 <span class="string">"bread"</span> ，因为我们有原材料 <span class="string">"yeast"</span> 和 <span class="string">"flour"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：recipes = [<span class="string">"bread"</span>,<span class="string">"sandwich"</span>], ingredients = [[<span class="string">"yeast"</span>,<span class="string">"flour"</span>],[<span class="string">"bread"</span>,<span class="string">"meat"</span>]], supplies = [<span class="string">"yeast"</span>,<span class="string">"flour"</span>,<span class="string">"meat"</span>]</span><br><span class="line">输出：[<span class="string">"bread"</span>,<span class="string">"sandwich"</span>]</span><br><span class="line">解释：</span><br><span class="line">我们可以做出 <span class="string">"bread"</span> ，因为我们有原材料 <span class="string">"yeast"</span> 和 <span class="string">"flour"</span> 。</span><br><span class="line">我们可以做出 <span class="string">"sandwich"</span> ，因为我们有原材料 <span class="string">"meat"</span> 且可以做出原材料 <span class="string">"bread"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：recipes = [<span class="string">"bread"</span>,<span class="string">"sandwich"</span>,<span class="string">"burger"</span>], ingredients = [[<span class="string">"yeast"</span>,<span class="string">"flour"</span>],[<span class="string">"bread"</span>,<span class="string">"meat"</span>],[<span class="string">"sandwich"</span>,<span class="string">"meat"</span>,<span class="string">"bread"</span>]], supplies = [<span class="string">"yeast"</span>,<span class="string">"flour"</span>,<span class="string">"meat"</span>]</span><br><span class="line">输出：[<span class="string">"bread"</span>,<span class="string">"sandwich"</span>,<span class="string">"burger"</span>]</span><br><span class="line">解释：</span><br><span class="line">我们可以做出 <span class="string">"bread"</span> ，因为我们有原材料 <span class="string">"yeast"</span> 和 <span class="string">"flour"</span> 。</span><br><span class="line">我们可以做出 <span class="string">"sandwich"</span> ，因为我们有原材料 <span class="string">"meat"</span> 且可以做出原材料 <span class="string">"bread"</span> 。</span><br><span class="line">我们可以做出 <span class="string">"burger"</span> ，因为我们有原材料 <span class="string">"meat"</span> 且可以做出原材料 <span class="string">"bread"</span> 和 <span class="string">"sandwich"</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：recipes = [<span class="string">"bread"</span>], ingredients = [[<span class="string">"yeast"</span>,<span class="string">"flour"</span>]], supplies = [<span class="string">"yeast"</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">我们没法做出任何菜，因为我们只有原材料 <span class="string">"yeast"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == recipes.length == ingredients.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= ingredients[i].length, supplies.length &lt;= 100</code></li><li><code>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10</code></li><li><code>recipes[i], ingredients[i][j]</code> 和 <code>supplies[k]</code> 只包含小写英文字母。</li><li>所有 <code>recipes</code> 和 <code>supplies</code> 中的值互不相同。</li><li><code>ingredients[i]</code> 中的字符串互不相同。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 拓扑排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的拓扑排序,与课程排序几乎是一模一样的原理,只不过这里的节点变为了字符串. 由于原材料无限多, 所以我们不用考虑数量的问题, 直接用拓扑排序, 每种菜品需要一种原材料即对应的有向边, 如果满足一个节点满足所有的入度则该节点可以加入到队列中.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(n)$，其中 $n$ 为所有菜品的种类.</li><li>空间复杂度为 $O(n)$,其中 $n$ 为所有菜品的种类.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5948-判断一个括号字符串是否有效"><a href="#5948-判断一个括号字符串是否有效" class="headerlink" title="5948. 判断一个括号字符串是否有效"></a>5948. 判断一个括号字符串是否有效</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一个括号字符串是只由 ‘(‘ 和 ‘)’ 组成的 非空 字符串。如果一个字符串满足下面 任意 一个条件，那么它就是有效的：</p><ul><li>字符串为 ().</li><li>它可以表示为 <code>AB</code>（<code>A</code> 与 <code>B</code> 连接），其中<code>A</code> 和 <code>B</code> 都是有效括号字符串。</li><li><p>它可以表示为 (<code>A</code>) ，其中 <code>A</code> 是一个有效括号字符串。<br>给你一个括号字符串 <code>s</code> 和一个字符串 <code>locked</code> ，两者长度都为 n 。<code>locked</code> 是一个二进制字符串，只包含 ‘0’ 和 ‘1’ 。对于 <code>locked</code> 中 每一个 下标 i ：</p></li><li><p>如果 <code>locked[i]</code>是 ‘1’ ，你 不能 改变 <code>s[i]</code> 。</p></li><li>如果 <code>locked[i]</code> 是 ‘0’ ，你 可以 将 <code>s[i]</code> 变为 ‘(‘ 或者 ‘)’ 。</li><li>如果你可以将 <code>s</code> 变为有效括号字符串，请你返回 <code>true</code> ，否则返回 <code>false</code>。</li></ul><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"))()))"</span>, locked = <span class="string">"010100"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：locked[<span class="number">1</span>] == <span class="string">'1'</span> 和 locked[<span class="number">3</span>] == <span class="string">'1'</span> ，所以我们无法改变 s[<span class="number">1</span>] 或者 s[<span class="number">3</span>] 。</span><br><span class="line">我们可以将 s[<span class="number">0</span>] 和 s[<span class="number">4</span>] 变为 <span class="string">'('</span> ，不改变 s[<span class="number">2</span>] 和 s[<span class="number">5</span>] ，使 s 变为有效字符串。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"()()"</span>, <span class="attr">locked</span> = <span class="string">"0000"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：我们不需要做任何改变，因为 s 已经是有效字符串了。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">")"</span>, <span class="built_in">locked</span> = <span class="string">"0"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="built_in">locked</span> 允许改变 s[<span class="number">0</span>] 。</span><br><span class="line">但无论将 s[<span class="number">0</span>] 变为 <span class="string">'('</span> 或者 <span class="string">')'</span> 都无法使 s 变为有效字符串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == s.length == locked.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>s[i]</code> 要么是 ‘(‘ 要么是 ‘)’ 。</li><li><code>locked[i]</code> 要么是 <code>&#39;0&#39;</code> 要么是 <code>&#39;1&#39;</code> 。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>括号匹配 + 栈</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目还算是稍微带点思考的问题, 虽然不是很难,但是感觉比较典型的思考性质的题目.思考过程如下:</li></ol><ul><li>由于题目中的字符只包含左括号和右括号, 所以如果字符串长度位奇数, 则我们可以直到该字符串肯定不会匹配. 此时我们直接返回 <code>false</code>.</li><li>我们首先检测不可更改的右括号是否可以满足匹配: 首先我们从左到右进行遍历字符串，假设我们记录当前已经记录的可以改变的括号的数目为 <code>cnt</code>, 记录当前已经锁定且不可更改的括号的匹配为 <code>prev</code>, 假设我们当前的字符为不可更改的左括号则此时我们将 <code>prev = prev + 1</code>,假设我们当前的字符为不可更改的右括号 则此时我们将<code>prev = prev-1</code>,如果当前出现 <code>prev &lt; 0</code>,则我们检测是否有待选的可以更改的括号可以进行匹配, 如果可以匹配，则我们认为当前的右括号可以正常匹配。</li><li>我们首先检测不可更改的左括号是否可以满足匹配: 我们从右向左遍历字符串，假设我们记录当前已经记录的可以改变的括号的数目为 <code>cnt</code>, 记录当前已经锁定且不可更改的括号的匹配为 <code>prev</code>, 假设我们当前的字符为不可更改的右括号则此时我们将 <code>prev = prev + 1</code>,假设我们当前的字符为不可更改的左括号 则此时我们将<code>prev = prev-1</code>,如果当前出现 <code>prev &lt; 0</code>,则我们检测是否有待选的可以更改的括号可以进行匹配, 如果可以匹配，则我们认为当前的左括号可以正常匹配。</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(N)$ 其中 $N$ 为 字符串的长度。</li><li>空间复杂度分析: $O(1)$。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeValid</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> locked)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(locked[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                    prev--;</span><br><span class="line">                    <span class="keyword">if</span>(cnt + prev &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    prev++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(locked[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(locked[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    prev--;</span><br><span class="line">                    <span class="keyword">if</span>(cnt + prev &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                    prev++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(locked[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5949-一个区间内所有数乘积的缩写"><a href="#5949-一个区间内所有数乘积的缩写" class="headerlink" title="5949. 一个区间内所有数乘积的缩写"></a>5949. 一个区间内所有数乘积的缩写</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个正整数 <code>left</code> 和 <code>right</code> ，满足 <code>left &lt;= right</code> 。请你计算 闭区间 <code>[left, right]</code> 中所有整数的 乘积 。</p><p>由于乘积可能非常大，你需要将它按照以下步骤 缩写 ：</p><ul><li>统计乘积中 后缀 <code>0</code> 的数目，将这个数目记为 <code>C</code> 。</li><li>比方说，<code>1000</code> 中有 <code>3</code> 个后缀 <code>0</code>，<code>546</code> 中没有后缀 <code>0</code> 。<br>将乘积中剩余数字记为 d 。如果 d &gt; 10 ，那么将乘积表示为 <code>&lt;pre&gt;...&lt;suf&gt;</code> 的形式，其中 <code>&lt;pre&gt;</code> 表示乘积最 开始 的 5 个数位，<code>&lt;suf&gt;</code> 表示删除后缀 0 之后 结尾的 5 个数位。如果 d &lt;= 10 ，我们不对它做修改。<br>比方说，我们将 <code>1234567654321</code> 表示为 <code>12345...54321</code> ，但是 <code>1234567</code> 仍然表示为 <code>1234567</code> 。<br>最后，将乘积表示为 字符串 <code>&quot;&lt;pre&gt;...&lt;suf&gt;eC&quot;</code> 。<br>比方说，<code>12345678987600000</code> 被表示为 <code>&quot;12345...89876e5&quot;</code> 。<br>请你返回一个字符串，表示 闭区间 <code>[left, right]</code> 中所有整数 乘积 的 缩写 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：left = <span class="number">1</span>, right = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"24e0"</span></span><br><span class="line">解释：</span><br><span class="line">乘积为 <span class="number">1</span> × <span class="number">2</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">24</span> 。</span><br><span class="line">由于没有后缀 <span class="number">0</span> ，所以 <span class="number">24</span> 保持不变，缩写的结尾为 <span class="string">"e0"</span> 。</span><br><span class="line">因为乘积的结果是 <span class="number">2</span> 位数，小于 <span class="number">10</span> ，所欲我们不进一步将它缩写。</span><br><span class="line">所以，最终将乘积表示为 <span class="string">"24e0"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：left = <span class="number">2</span>, right = <span class="number">11</span></span><br><span class="line">输出：<span class="string">"399168e2"</span></span><br><span class="line">解释：</span><br><span class="line">乘积为 <span class="number">39916800</span> 。</span><br><span class="line">有 <span class="number">2</span> 个后缀 <span class="number">0</span> ，删除后得到 <span class="number">399168</span> 。缩写的结尾为 <span class="string">"e2"</span> 。</span><br><span class="line">删除后缀 <span class="number">0</span> 后是 <span class="number">6</span> 位数，不需要进一步缩写。</span><br><span class="line">所以，最终将乘积表示为 <span class="string">"399168e2"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：left = <span class="number">999998</span>, right = <span class="number">1000000</span></span><br><span class="line">输出：<span class="string">"99999...00002e6"</span></span><br><span class="line">解释：</span><br><span class="line">上图展示了如何得到乘积的缩写 <span class="string">"99999...00002e6"</span> 。</span><br><span class="line">- 总共有 <span class="number">6</span> 个后缀 <span class="number">0</span> 。缩写的结尾为 <span class="string">"e6"</span> 。</span><br><span class="line">- 开头 <span class="number">5</span> 个数位是 <span class="number">99999</span> 。</span><br><span class="line">- 删除后缀 <span class="number">0</span> 后结尾 <span class="number">5</span> 个数字为 <span class="number">00002</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：left = <span class="number">256</span>, right = <span class="number">65535</span></span><br><span class="line">输出：<span class="string">"23510...78528e16317"</span></span><br><span class="line">解释：</span><br><span class="line">乘积是一个非常大的数字：</span><br><span class="line">- 总共有 <span class="number">16317</span> 个后缀 <span class="number">0</span> 。缩写结尾为 <span class="string">"e16317"</span> 。</span><br><span class="line">- 开头 <span class="number">5</span> 个数字为 <span class="number">23510</span> 。</span><br><span class="line">- 删除后缀 <span class="number">0</span> 后，结尾 <span class="number">5</span> 个数字为 <span class="number">78528</span> 。</span><br><span class="line">所以，乘积的缩写为 <span class="string">"23510...78528e16317"</span> 。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= left &lt;= right &lt;= 106</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range" target="_blank" rel="noopener">https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>此题为典型的数学问题, 主要难点在于精度如何处理. 题目有三点需要处理:</li></ol><ul><li>求出最终乘积中末尾 <code>0</code> 的个数, 我们可以求出所有的因子 <code>5</code> 的个数和因子 <code>2</code> 的个数, 即可求出最终含有 <code>0</code> 的个数.</li><li>求出最终乘积中的除了<code>0</code>以外的低<code>5</code>位: 我们可以求出将求出的乘积对<code>100000</code>进行取模即可得到最终的低<code>5</code>位.</li><li>求出最终乘积中的除了<code>0</code>以外的高<code>5</code>位: 这个是本题中难度最大的地方,关键在于精度如何处理:<ul><li>我们可以保留最高位到<code>12</code>位, 每次数字的乘积仅仅保留最高位的<code>12</code>位即可通过该题目的所有测试用例, 当然这样的精度还算存在的一定的问题.</li><li>我们可以用对数来存储乘积,这样就能很容易的控制精度,我们知道有 $\log(a_1\times a_2 \times …\times a_n) = \log a_1 + \log a_2 + … + \log a_n$. 所以我们对每个因数取对数然后求和即可.当然最后的精度控制看了题解之后感觉还算存在一定的问题，精度问题确实不好解决</li></ul></li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：时间复杂度为$n \log n$, 其中 $n$ 为 $right - left$, 由于其中还存在求 $2$ 的因子, 所以还可能需要有 $logn$ 的运算.</li><li>空间复杂度分析: $O(C)$, 需要常数个变量保存中间结果。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getfrac</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> frac)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((x%frac) == <span class="number">0</span>)&#123;</span><br><span class="line">            x /= frac;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">abbreviateProduct</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">bool</span> trans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> five = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> two = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i;</span><br><span class="line">            <span class="keyword">while</span>((x%<span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                two++;</span><br><span class="line">                x /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>((x%<span class="number">5</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                x /= <span class="number">5</span>;</span><br><span class="line">                five++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.emplace_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(five &gt; <span class="number">0</span> &amp;&amp; two &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            zero++;</span><br><span class="line">            five--;</span><br><span class="line">            two--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">            curr = curr*arr[i];</span><br><span class="line">            <span class="keyword">if</span>(curr &gt;= <span class="number">10000000000</span>)&#123;</span><br><span class="line">                trans = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(curr &gt;= (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1000000000000</span>)&#123;</span><br><span class="line">                curr = curr/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end = (end*arr[i])%<span class="number">100000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(five &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            curr = curr*<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr &gt;= <span class="number">10000000000</span>)&#123;</span><br><span class="line">                trans = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(curr &gt;= <span class="number">1000000000000</span>)&#123;</span><br><span class="line">                curr = curr/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end = (end*<span class="number">5</span>)%<span class="number">100000</span>;</span><br><span class="line">            five--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(two &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr = curr*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr &gt;= <span class="number">10000000000</span>)&#123;</span><br><span class="line">                trans = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(curr &gt;= <span class="number">1000000000000</span>)&#123;</span><br><span class="line">                curr = curr/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end = (end*<span class="number">2</span>)%<span class="number">100000</span>;</span><br><span class="line">            two--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> s1 = to_string(curr).substr(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">string</span> s2 = to_string(end);</span><br><span class="line">        <span class="keyword">if</span>(s2.size() &lt; <span class="number">5</span>)&#123;</span><br><span class="line">            <span class="built_in">string</span> add;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> - s2.size(); ++i)&#123;</span><br><span class="line">                add.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s2 = add + s2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(trans)&#123;</span><br><span class="line">            <span class="keyword">return</span> s1 + <span class="string">"..."</span> + s2 + <span class="string">"e"</span> + to_string(zero);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> to_string(curr) + <span class="string">"e"</span> + to_string(zero);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-68&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-68&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 68&quot;&gt;&lt;/a&gt;leetcode biweekly contest 68&lt;/h1&gt;&lt;p&gt;今天双周赛前三题还算是常规题目,最后一题是数学题目,比较少见的求精度的题目.&lt;br&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/26/YApaJQgNEvb5ktF.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5956-找出数组中的第一个回文字符串&quot;&gt;&lt;a href=&quot;#5956-找出数组中的第一个回文字符串&quot; class=&quot;headerlink&quot; title=&quot;5956. 找出数组中的第一个回文字符串&quot;&gt;&lt;/a&gt;5956. 找出数组中的第一个回文字符串&lt;/h3&gt;&lt;p&gt;一个 句子 由一些 单词 以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。&lt;/p&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;sentences&lt;/code&gt; ，其中 &lt;code&gt;sentences[i]&lt;/code&gt; 表示单个句子 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 272</title>
    <link href="http://yoursite.com/2021/12/12/352/"/>
    <id>http://yoursite.com/2021/12/12/352/</id>
    <published>2021-12-12T03:47:59.489Z</published>
    <updated>2021-12-19T06:00:12.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-272"><a href="#leetcode-contest-272" class="headerlink" title="leetcode  contest 272"></a>leetcode  contest 272</h1><p>今天的周赛基本上都可以用简单题目来说，最后一题简单的LIS问题。</p><h3 id="5956-找出数组中的第一个回文字符串"><a href="#5956-找出数组中的第一个回文字符串" class="headerlink" title="5956. 找出数组中的第一个回文字符串"></a>5956. 找出数组中的第一个回文字符串</h3><p>给你一个字符串数组 <code>words</code> ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 <code>&quot;&quot;</code> 。</p><p>回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">words</span> = [<span class="string">"abc"</span>,<span class="string">"car"</span>,<span class="string">"ada"</span>,<span class="string">"racecar"</span>,<span class="string">"cool"</span>]</span><br><span class="line">输出：<span class="string">"ada"</span></span><br><span class="line">解释：第一个回文字符串是 <span class="string">"ada"</span> 。</span><br><span class="line">注意，<span class="string">"racecar"</span> 也是回文字符串，但它不是第一个。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">words</span> = [<span class="string">"notapalindrome"</span>,<span class="string">"racecar"</span>]</span><br><span class="line">输出：<span class="string">"racecar"</span></span><br><span class="line">解释：第一个也是唯一一个回文字符串是 <span class="string">"racecar"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">words</span> = [<span class="string">"def"</span>,<span class="string">"ghi"</span>]</span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：不存在回文字符串，所以返回一个空字符串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 100</code></li><li><code>words[i]</code> 仅由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-first-palindromic-string-in-the-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-palindromic-string-in-the-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>遍历每个字符串,判断该字符串是否为回文串即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(nm)$, 其中 $n$ 为数组的元素的个数, $m$ 表示每个字符串的平均长度。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">firstPalindrome</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w : words)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(w)) <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5957-向字符串添加空格"><a href="#5957-向字符串添加空格" class="headerlink" title="5957. 向字符串添加空格"></a>5957. 向字符串添加空格</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的字符串 s ，以及一个下标从 0 开始的整数数组 <code>spaces</code> 。</p><p>数组 <code>spaces</code> 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 之前 。</p><p>例如，<code>s = &quot;EnjoyYourCoffee&quot;</code> 且 <code>spaces = [5, 9]</code>，那么我们需要在 <code>&#39;Y&#39;</code> 和 <code>&#39;C&#39;</code> 之前添加空格，这两个字符分别位于下标 <code>5</code> 和下标 <code>9</code> 。因此，最终得到 <code>&quot;Enjoy Your Coffee&quot;</code> 。<br>请你添加空格，并返回修改后的字符串。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"LeetcodeHelpsMeLearn"</span>, spaces = [<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="string">"Leetcode Helps Me Learn"</span></span><br><span class="line">解释：</span><br><span class="line">下标 <span class="number">8</span>、<span class="number">13</span> 和 <span class="number">15</span> 对应 <span class="string">"LeetcodeHelpsMeLearn"</span> 中加粗斜体字符。</span><br><span class="line">接着在这些字符前添加空格。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"icodeinpython"</span>, spaces = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="string">"i code in py thon"</span></span><br><span class="line">解释：</span><br><span class="line">下标 <span class="number">1</span>、<span class="number">5</span>、<span class="number">7</span> 和 <span class="number">9</span> 对应 <span class="string">"icodeinpython"</span> 中加粗斜体字符。</span><br><span class="line">接着在这些字符前添加空格。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"spacing"</span>, spaces = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="string">" s p a c i n g"</span></span><br><span class="line">解释：</span><br><span class="line">字符串的第一个字符前可以添加空格。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 仅由大小写英文字母组成</li><li><code>1 &lt;= spaces.length &lt;= 3 * 105</code></li><li><code>0 &lt;= spaces[i] &lt;= s.length - 1</code></li><li><code>spaces</code> 中的所有值 严格递增</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/adding-spaces-to-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/adding-spaces-to-a-string</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 遍历</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>直接遍历字符串,在特定位置加上空格即可</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(n)$，其中 $n$ 为字符串的长度.</li><li>空间复杂度为 $O(n)$,其中 $n$ 为字符串的长度.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addSpaces</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; spaces)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = spaces.size();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; m &amp;&amp; i == spaces[j])&#123;</span><br><span class="line">                ans.push_back(<span class="string">' '</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5958-股票平滑下跌阶段的数目"><a href="#5958-股票平滑下跌阶段的数目" class="headerlink" title="5958. 股票平滑下跌阶段的数目"></a>5958. 股票平滑下跌阶段的数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>prices</code> ，表示一支股票的历史每日股价，其中 <code>prices[i]</code> 是这支股票第 <code>i</code> 天的价格。</p><p>一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 <code>1</code>，这个阶段第一天的股价没有限制。</p><p>请你返回 平滑下降阶段 的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：总共有 <span class="number">7</span> 个平滑下降阶段：</span><br><span class="line">[<span class="number">3</span>], [<span class="number">2</span>], [<span class="number">1</span>], [<span class="number">4</span>], [<span class="number">3</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">1</span>] 和 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">注意，仅一天按照定义也是平滑下降阶段。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：总共有 <span class="number">4</span> 个连续平滑下降阶段：[<span class="number">8</span>], [<span class="number">6</span>], [<span class="number">7</span>] 和 [<span class="number">7</span>]</span><br><span class="line">由于 <span class="number">8</span> - <span class="number">6</span> ≠ <span class="number">1</span> ，所以 [<span class="number">8</span>,<span class="number">6</span>] 不是平滑下降阶段。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：总共有 <span class="number">1</span> 个平滑下降阶段：[<span class="number">1</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= prices.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= prices[i] &lt;= <span class="number">105</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/number-of-smooth-descent-periods-of-a-stock</span></span><br><span class="line">### 题意</span><br><span class="line">&gt; 数学问题</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 简单题目，我们只需要找到连续的股票下滑持续的天数 $cnt$ 即可, 每次新增的下滑阶段为 $cnt$.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度：$O(N)$ 其中 $N$ 为数组的长度。</span><br><span class="line">+ 空间复杂度分析: $O(N)$,其中 $N$ 为数组的长度。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    long long getDescentPeriods(vector&lt;<span class="built_in">int</span>&gt;&amp; prices) &#123;</span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; prices[i] == prices[i<span class="number">-1</span>] - <span class="number">1</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5959-使数组-K-递增的最少操作次数"><a href="#5959-使数组-K-递增的最少操作次数" class="headerlink" title="5959. 使数组 K 递增的最少操作次数"></a>5959. 使数组 K 递增的最少操作次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始包含 <code>n</code> 个正整数的数组 <code>arr</code> ，和一个正整数 <code>k</code> 。</p><p>如果对于每个满足 <code>k &lt;= i &lt;= n-1</code> 的下标 <code>i</code> ，都有 <code>arr[i-k] &lt;= arr[i]</code> ，那么我们称 <code>arr</code> 是 <code>K</code> 递增 的。</p><p>比方说，<code>arr = [4, 1, 5, 2, 6, 2]</code> 对于 <code>k = 2</code> 是 <code>K</code> 递增的，因为：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] &lt;= arr[<span class="number">2</span>] (<span class="number">4</span> &lt;= <span class="number">5</span>)</span><br><span class="line">arr[<span class="number">1</span>] &lt;= arr[<span class="number">3</span>] (<span class="number">1</span> &lt;= <span class="number">2</span>)</span><br><span class="line">arr[<span class="number">2</span>] &lt;= arr[<span class="number">4</span>] (<span class="number">5</span> &lt;= <span class="number">6</span>)</span><br><span class="line">arr[<span class="number">3</span>] &lt;= arr[<span class="number">5</span>] (<span class="number">2</span> &lt;= <span class="number">2</span>)</span><br></pre></td></tr></table></figure><br>但是，相同的数组 <code>arr</code> 对于 <code>k = 1</code> 不是 K 递增的（因为 <code>arr[0] &gt; arr[1]</code>），对于 <code>k = 3</code> 也不是 <code>K</code> 递增的（因为 <code>arr[0] &gt; arr[3]</code>）。<br>每一次 操作 中，你可以选择一个下标 i 并将 <code>arr[i]</code> 改成任意 正整数。</p><p>请你返回对于给定的 <code>k</code> ，使数组变成 <code>K</code> 递增的 最少操作次数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">对于 k = <span class="number">1</span> ，数组最终必须变成非递减的。</span><br><span class="line">可行的 K 递增结果数组为 [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]，[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>] 。它们都需要 <span class="number">4</span> 次操作。</span><br><span class="line">次优解是将数组变成比方说 [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>] ，因为需要 <span class="number">5</span> 次操作。</span><br><span class="line">显然我们无法使用少于 <span class="number">4</span> 次操作将数组变成 K 递增的。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">这是题目描述中的例子。</span><br><span class="line">对于每个满足 <span class="number">2</span> &lt;= i &lt;= <span class="number">5</span> 的下标 i ，有 arr[i<span class="number">-2</span>] &lt;= arr[i] 。</span><br><span class="line">由于给定数组已经是 K 递增的，我们不需要进行任何操作。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">下标 <span class="number">3</span> 和 <span class="number">5</span> 是仅有的 <span class="number">3</span> &lt;= i &lt;= <span class="number">5</span> 且不满足 arr[i<span class="number">-3</span>] &lt;= arr[i] 的下标。</span><br><span class="line">将数组变成 K 递增的方法之一是将 arr[<span class="number">3</span>] 变为 <span class="number">4</span> ，且将 arr[<span class="number">5</span>] 变成 <span class="number">5</span> 。</span><br><span class="line">数组变为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>] 。</span><br><span class="line">可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 105</code></li><li><code>1 &lt;= arr[i], k &lt;= arr.length</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>LIS问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>此题可以转换为最长递增子序列问题, 我们首先可以将数组进行按照相隔 $k$ 划分为 $k$ 个子数组, 如果我们需要保证每个子数组都递增，则我们希望保留的元素尽可能的多，我们首先想到最长递增子序列，我们依次对每个子数组求最长递增子序列即可.典型的最长递增子序列可以参考 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300</a>.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：时间复杂度为$O(n \log \frac{n}{k})$, 其中 $n$ 为数组的长度。</li><li>空间复杂度分析: $O(n)$,其中 $n$ 为数组的长度。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                st.emplace_back(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> it = upper_bound(st.begin(), st.end(), arr[i]);</span><br><span class="line">                <span class="keyword">if</span>(it == st.end()) &#123;</span><br><span class="line">                    st.emplace_back(arr[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    *it = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr.size() - st.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kIncreasing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; barr(k);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j += k)&#123;</span><br><span class="line">                barr[i].push_back(arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            ans += lis(barr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-272&quot;&gt;&lt;a href=&quot;#leetcode-contest-272&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 272&quot;&gt;&lt;/a&gt;leetcode  contest 272&lt;/h1&gt;&lt;p&gt;今天的周赛基本上都可以用简单题目来说，最后一题简单的LIS问题。&lt;/p&gt;&lt;h3 id=&quot;5956-找出数组中的第一个回文字符串&quot;&gt;&lt;a href=&quot;#5956-找出数组中的第一个回文字符串&quot; class=&quot;headerlink&quot; title=&quot;5956. 找出数组中的第一个回文字符串&quot;&gt;&lt;/a&gt;5956. 找出数组中的第一个回文字符串&lt;/h3&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;words&lt;/code&gt; ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 67</title>
    <link href="http://yoursite.com/2021/12/11/351/"/>
    <id>http://yoursite.com/2021/12/11/351/</id>
    <published>2021-12-11T15:21:35.418Z</published>
    <updated>2021-12-11T16:15:11.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-67"><a href="#leetcode-biweekly-contest-67" class="headerlink" title="leetcode  biweekly contest 67"></a>leetcode  biweekly contest 67</h1><p>感觉又是手速场的一次竞赛,不过感觉力扣的题目确实越来越水了,还是 $CF$ $Atcoder$ 之类的要锻炼思维一些. </p><h3 id="5934-找到和最大的长度为-K-的子序列"><a href="#5934-找到和最大的长度为-K-的子序列" class="headerlink" title="5934. 找到和最大的长度为 K 的子序列"></a>5934. 找到和最大的长度为 K 的子序列</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你需要找到 <code>nums</code> 中长度为 <code>k</code> 的 子序列 ，且这个子序列的 和最大 。</p><a id="more"></a><p>请你返回 任意 一个长度为 <code>k</code>的整数子序列。</p><p>子序列 定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">子序列有最大和：<span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">4</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">子序列有最大和：<span class="number">-1</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">子序列有最大和：<span class="number">3</span> + <span class="number">4</span> = <span class="number">7</span> 。</span><br><span class="line">另一个可行的子序列为 [<span class="number">4</span>, <span class="number">3</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-67/problems/find-subsequence-of-length-k-with-the-largest-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-67/problems/find-subsequence-of-length-k-with-the-largest-sum/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>遍历数组找到最大的 $k$ 个数即可, 题目要求按照数组的顺序返回,我们再按照数组的顺序进行排序即可. 稍微优化一下可以用用 $topk$ 的解法.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n \log n)$, 其中 $n$ 为数组的元素的个数。</li><li>空间复杂度分析: 空间复杂度为 $O(k)$。</li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSubsequence(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; arr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; arr1;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            arr.emplace_back(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            arr1.emplace_back(arr[n<span class="number">-1</span>-i].second,arr[n<span class="number">-1</span>-i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr1.begin(),arr1.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ans.emplace_back(arr1[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5935-适合打劫银行的日子"><a href="#5935-适合打劫银行的日子" class="headerlink" title="5935. 适合打劫银行的日子"></a>5935. 适合打劫银行的日子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你和一群强盗准备打劫银行。给你一个下标从 <code>0</code> 开始的整数数组 <code>security</code> ，其中 <code>security[i]</code>是第 <code>i</code> 天执勤警卫的数量。日子从 <code>0</code> 开始编号。同时给你一个整数 <code>time</code> 。</p><p>如果第 <code>i</code> 天满足以下所有条件，我们称它为一个适合打劫银行的日子：</p><ul><li>第 <code>i</code> 天前和后都分别至少有 <code>time</code> 天。</li><li>第 <code>i</code> 天前连续 <code>time</code> 天警卫数目都是非递增的。</li><li>第 <code>i</code> 天后连续 <code>time</code> 天警卫数目都是非递减的。</li><li>更正式的，第 <code>i</code>天是一个合适打劫银行的日子当且仅当：<code>security[i - time] &gt;= security[i - time + 1] &gt;= ... &gt;= security[i] &lt;= ... &lt;= security[i + time - 1] &lt;= security[i + time]</code>.</li></ul><p>请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：security = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>], time = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">2</span> 天，我们有 security[<span class="number">0</span>] &gt;= security[<span class="number">1</span>] &gt;= security[<span class="number">2</span>] &lt;= security[<span class="number">3</span>] &lt;= security[<span class="number">4</span>] 。</span><br><span class="line">第 <span class="number">3</span> 天，我们有 security[<span class="number">1</span>] &gt;= security[<span class="number">2</span>] &gt;= security[<span class="number">3</span>] &lt;= security[<span class="number">4</span>] &lt;= security[<span class="number">5</span>] 。</span><br><span class="line">没有其他日子符合这个条件，所以日子 <span class="number">2</span> 和 <span class="number">3</span> 是适合打劫银行的日子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：security = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], time = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">因为 time 等于 <span class="number">0</span> ，所以每一天都是适合打劫银行的日子，所以返回每一天。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：security = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], time = <span class="number">2</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">没有任何一天的前 <span class="number">2</span> 天警卫数目是非递增的。</span><br><span class="line">所以没有适合打劫银行的日子，返回空数组。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：security = [<span class="number">1</span>], time = <span class="number">5</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">没有日子前面和后面有 <span class="number">5</span> 天时间。</span><br><span class="line">所以没有适合打劫银行的日子，返回空数组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= security.length &lt;= 105</code></li><li><code>0 &lt;= security[i], time &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-67/problems/find-good-days-to-rob-the-bank/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-67/problems/find-good-days-to-rob-the-bank/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>常规题目, 我们记录每个索引 $i$ 以 $i$ 为结尾的向左非递减的长度为 $left[i]$ ,向右非递减的长度为 $right[i]$, 我们可以知道如下递推公司:<script type="math/tex; mode=display">\left\{\begin{array}{lr}left[i] = left[i-1] + 1 \quad if (security[i] \le security [i-1])\\left[i] = 0  if (security[i] > security [i-1])\\\end{array}\right.</script><script type="math/tex; mode=display">\left\{\begin{array}{lr}right[i] = right[i+1] + 1 \quad if (security[i] \le security [i+1])\\right[i] = 0  if (security[i] > security [i+1])\\\end{array}\right.</script></li><li>我们遍历每个索引 $i$, 找到所有同时满足 $left[i] \ge time, right[i] \ge time$的索引即可 </li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(n)$，其中 $n$ 为数组的长度.</li><li>空间复杂度为 $O(n)$,其中 $n$ 为数组的长度.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goodDaysToRobBank(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; security, <span class="keyword">int</span> time) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = security.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(security[i<span class="number">-1</span>] &gt;= security[i])&#123;</span><br><span class="line">                left[i] = left[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(security[i+<span class="number">1</span>] &gt;= security[i]) &#123;</span><br><span class="line">                right[i] = right[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i] &gt;= time &amp;&amp; right[i] &gt;= time) &#123;</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5936-引爆最多的炸弹"><a href="#5936-引爆最多的炸弹" class="headerlink" title="5936. 引爆最多的炸弹"></a>5936. 引爆最多的炸弹</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个炸弹列表。一个炸弹的 爆炸范围 定义为以炸弹为圆心的一个圆。</p><p>炸弹用一个下标从 <code>0</code> 开始的二维整数数组 <code>bombs</code> 表示，其中 <code>bombs[i] = [xi, yi, ri]</code> 。<code>xi</code> 和 <code>yi</code> 表示第 <code>i</code> 个炸弹的 <code>X</code> 和 <code>Y</code> 坐标，<code>ri</code>表示爆炸范围的 半径 。</p><p>你需要选择引爆 一个 炸弹。当这个炸弹被引爆时，所有 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。</p><p>给你数组 bombs ，请你返回在引爆 一个 炸弹的前提下，最多 能引爆的炸弹数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bombs = [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">上图展示了 <span class="number">2</span> 个炸弹的位置和爆炸范围。</span><br><span class="line">如果我们引爆左边的炸弹，右边的炸弹不会被影响。</span><br><span class="line">但如果我们引爆右边的炸弹，两个炸弹都会爆炸。</span><br><span class="line">所以最多能引爆的炸弹数目是 max(<span class="number">1</span>, <span class="number">2</span>) = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：bombs = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>],[<span class="number">10</span>,<span class="number">10</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">引爆任意一个炸弹都不会引爆另一个炸弹。所以最多能引爆的炸弹数目为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：bombs = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">最佳引爆炸弹为炸弹 <span class="number">0</span> ，因为：</span><br><span class="line">- 炸弹 <span class="number">0</span> 引爆炸弹 <span class="number">1</span> 和 <span class="number">2</span> 。红色圆表示炸弹 <span class="number">0</span> 的爆炸范围。</span><br><span class="line">- 炸弹 <span class="number">2</span> 引爆炸弹 <span class="number">3</span> 。蓝色圆表示炸弹 <span class="number">2</span> 的爆炸范围。</span><br><span class="line">- 炸弹 <span class="number">3</span> 引爆炸弹 <span class="number">4</span> 。绿色圆表示炸弹 <span class="number">3</span> 的爆炸范围。</span><br><span class="line">所以总共有 <span class="number">5</span> 个炸弹被引爆。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= bombs.length &lt;= 100</code></li><li><code>bombs[i].length == 3</code></li><li><code>1 &lt;= xi, yi, ri &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-67/problems/detonate-the-maximum-bombs/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-67/problems/detonate-the-maximum-bombs/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>BFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目本质为有向图的遍历, 首先我们通过比较 $bombs[i]$ 与 $bombs[j]$的圆心的距离与半径的差, 如果某个炸弹 $i$ 的圆心刚好处于另外一个炸弹 $j$ 的爆炸范围内, 则我们认为存在有向边 $(j,i)$, 我们找到有向图的所有边.</li><li>我们采用 $BFS$, 从每个顶点出发, 最多可以访问有向图中多少个顶点结尾爆炸的炸弹的个数.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(N^3)$ 其中 $N$ 为炸弹的个数。</li><li>空间复杂度分析: $O(N^2)$,其中 $N$ 为炸弹的个数。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(f[x] != x) &#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumDetonation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bombs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bombs.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g(n);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> dx = bombs[i][<span class="number">0</span>] - bombs[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> dy = bombs[i][<span class="number">1</span>] - bombs[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> dist = dx*dx + dy*dy;</span><br><span class="line">                <span class="keyword">if</span>(dist &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>)bombs[i][<span class="number">2</span>]*bombs[i][<span class="number">2</span>])&#123;</span><br><span class="line">                    g[i].emplace_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dist &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>)bombs[j][<span class="number">2</span>]*bombs[j][<span class="number">2</span>])&#123;</span><br><span class="line">                    g[j].emplace_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">            qu.push(i);</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                num++;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[curr]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">                        qu.push(v);</span><br><span class="line">                        visit[v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5937-序列顺序查询"><a href="#5937-序列顺序查询" class="headerlink" title="5937. 序列顺序查询"></a>5937. 序列顺序查询</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个观光景点由它的名字 <code>name</code> 和景点评分 <code>score</code> 组成，其中 <code>name</code> 是所有观光景点中 唯一 的字符串，<code>score</code> 是一个整数。景点按照最好到最坏排序。景点评分 越高 ，这个景点越好。如果有两个景点的评分一样，那么 字典序较小 的景点更好。</p><p>你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：</p><p>添加 景点，每次添加 一个 景点。<br>查询 已经添加景点中第 <code>i</code> 好 的景点，其中 i 是系统目前位置查询的次数（包括当前这一次）。<br>比方说，如果系统正在进行第 <code>4</code> 次查询，那么需要返回所有已经添加景点中第 4 好的。<br>注意，测试数据保证 任意查询时刻 ，查询次数都 不超过 系统中景点的数目。</p><p>请你实现 <code>SORTracker</code> 类：</p><ul><li><code>SORTracker()</code> 初始化系统。</li><li><code>void add(string name, int score)</code> 向系统中添加一个名为 <code>name</code> 评分为 <code>score</code> 的景点。</li><li><code>string get()</code>查询第 <code>i</code> 好的景点，其中 i 是目前系统查询的次数（包括当前这次查询）。</li></ul><p>示例：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"SORTracker"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"get"</span>, <span class="string">"add"</span>, <span class="string">"get"</span>, <span class="string">"add"</span>, <span class="string">"get"</span>, <span class="string">"add"</span>, <span class="string">"get"</span>, <span class="string">"add"</span>, <span class="string">"get"</span>, <span class="string">"get"</span>]</span><br><span class="line">[[], [<span class="string">"bradford"</span>, <span class="number">2</span>], [<span class="string">"branford"</span>, <span class="number">3</span>], [], [<span class="string">"alps"</span>, <span class="number">2</span>], [], [<span class="string">"orland"</span>, <span class="number">2</span>], [], [<span class="string">"orlando"</span>, <span class="number">3</span>], [], [<span class="string">"alpine"</span>, <span class="number">2</span>], [], []]</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"branford"</span>, <span class="literal">null</span>, <span class="string">"alps"</span>, <span class="literal">null</span>, <span class="string">"bradford"</span>, <span class="literal">null</span>, <span class="string">"bradford"</span>, <span class="literal">null</span>, <span class="string">"bradford"</span>, <span class="string">"orland"</span>]</span><br></pre></td></tr></table></figure></p><p>解释：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">SORTracker tracker = <span class="keyword">new</span> SORTracker(); <span class="comment">// 初始化系统</span></span><br><span class="line">tracker.<span class="keyword">add</span>(<span class="string">"bradford"</span>, <span class="number">2</span>); <span class="comment">// 添加 name="bradford" 且 score=2 的景点。</span></span><br><span class="line">tracker.<span class="keyword">add</span>(<span class="string">"branford"</span>, <span class="number">3</span>); <span class="comment">// 添加 name="branford" 且 score=3 的景点。</span></span><br><span class="line">tracker.<span class="keyword">get</span>();              <span class="comment">// 从好带坏的景点为：branford ，bradford 。</span></span><br><span class="line">                            <span class="comment">// 注意到 branford 比 bradford 好，因为它的 评分更高 (3 &gt; 2) 。</span></span><br><span class="line">                            <span class="comment">// 这是第 1 次调用 get() ，所以返回最好的景点："branford" 。</span></span><br><span class="line">tracker.<span class="keyword">add</span>(<span class="string">"alps"</span>, <span class="number">2</span>);     <span class="comment">// 添加 name="alps" 且 score=2 的景点。</span></span><br><span class="line">tracker.<span class="keyword">get</span>();              <span class="comment">// 从好到坏的景点为：branford, alps, bradford 。</span></span><br><span class="line">                            <span class="comment">// 注意 alps 比 bradford 好，虽然它们评分相同，都为 2 。</span></span><br><span class="line">                            <span class="comment">// 这是因为 "alps" 字典序 比 "bradford" 小。</span></span><br><span class="line">                            <span class="comment">// 返回第 2 好的地点 "alps" ，因为当前为第 2 次调用 get() 。</span></span><br><span class="line">tracker.<span class="keyword">add</span>(<span class="string">"orland"</span>, <span class="number">2</span>);   <span class="comment">// 添加 name="orland" 且 score=2 的景点。</span></span><br><span class="line">tracker.<span class="keyword">get</span>();              <span class="comment">// 从好到坏的景点为：branford, alps, bradford, orland 。</span></span><br><span class="line">                            <span class="comment">// 返回 "bradford" ，因为当前为第 3 次调用 get() 。</span></span><br><span class="line">tracker.<span class="keyword">add</span>(<span class="string">"orlando"</span>, <span class="number">3</span>);  <span class="comment">// 添加 name="orlando" 且 score=3 的景点。</span></span><br><span class="line">tracker.<span class="keyword">get</span>();              <span class="comment">// 从好到坏的景点为：branford, orlando, alps, bradford, orland 。</span></span><br><span class="line">                            <span class="comment">// 返回 "bradford".</span></span><br><span class="line">tracker.<span class="keyword">add</span>(<span class="string">"alpine"</span>, <span class="number">2</span>);   <span class="comment">// 添加 name="alpine" 且 score=2 的景点。</span></span><br><span class="line">tracker.<span class="keyword">get</span>();              <span class="comment">// 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。</span></span><br><span class="line">                            <span class="comment">// 返回 "bradford" 。</span></span><br><span class="line">tracker.<span class="keyword">get</span>();              <span class="comment">// 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。</span></span><br><span class="line">                            <span class="comment">// 返回 "orland" 。</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `name` 只包含小写英文字母，且每个景点名字互不相同。</span><br><span class="line">+ `<span class="number">1</span> &lt;= name.length &lt;= <span class="number">10</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= score &lt;= <span class="number">105</span>`</span><br><span class="line">+ 任意时刻，调用 `<span class="keyword">get</span>` 的次数都不超过调用 `<span class="keyword">add</span>` 的次数。</span><br><span class="line">+ 总共 调用 `<span class="keyword">add</span>` 和 `<span class="keyword">get</span>` 不超过 `<span class="number">4</span> * <span class="number">104</span>` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址</span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-67/problems/sequentially-ordinal-rank-tracker/</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt; 平衡二叉树</span><br><span class="line"><span class="meta">### 解题思路</span></span><br><span class="line"><span class="number">1.</span> 本题与力扣之前的题目很相似，类似于二叉平衡数的解法，我们利用二叉查找的解法，我们设当前已经经历了　 $query$ 次查询, 假设总共有 $n$ 个景点,我们构造二叉查找树, 左子树保存 $query$ 个节点, 右子树保存 $n<span class="number">-1</span>-query$ 个节点.</span><br><span class="line">+ 每次 $<span class="keyword">add</span>$ 操作时,我们始终保证左子树有 $query$ 个节点, 插入操作时我们将当前节点与根进行比较, 如果比左子树的根节点大,则我们插入到左子树, 然后进行调整, 否则我们直接插入到右子树即可.</span><br><span class="line">+ 每次 $<span class="keyword">get</span>$ 操作时,由于本题的查询操作并不是随机的查询，而是连续递增的，所以我们直接查找左子树的根节点，然后将右子树调整一个节点过来即可．</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度：$<span class="keyword">add</span>$ 和 $<span class="keyword">get</span>$ 均为$O(\log N)$, 其中 $N$ 为景点的个数。</span><br><span class="line">+ 空间复杂度分析: $O(N)$,其中 $N$ 为景点的个数。</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">struct</span> Node&#123;</span><br><span class="line">    <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Node(<span class="keyword">string</span> name, <span class="keyword">int</span> score)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> cmp&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span>(<span class="params"></span>) (<span class="params"><span class="keyword">const</span> Node &amp;a , <span class="keyword">const</span> Node &amp;b</span>)<span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.score == b.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SORTracker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SORTracker() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;query = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">string</span> name, <span class="keyword">int</span> score</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left.size() == query)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.rbegin()-&gt;score &gt; score || (left.rbegin()-&gt;score == score &amp;&amp; left.rbegin()-&gt;name &lt; name))&#123;</span><br><span class="line">                right.insert(Node(name,score));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left.insert(Node(name,score));</span><br><span class="line">                right.insert(*left.rbegin());</span><br><span class="line">                left.erase(*left.rbegin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.size() &lt; query)&#123;</span><br><span class="line">            right.insert(Node(name,score));</span><br><span class="line">            left.insert(*right.begin());</span><br><span class="line">            right.erase(*right.begin());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">string</span> res = left.rbegin()-&gt;name;</span><br><span class="line">        <span class="keyword">if</span>(right.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            left.insert(*right.begin());</span><br><span class="line">            right.erase(*right.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        query++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> query;</span><br><span class="line">    <span class="keyword">set</span>&lt;Node,cmp&gt; left;</span><br><span class="line">    <span class="keyword">set</span>&lt;Node,cmp&gt; right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SORTracker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SORTracker* obj = new SORTracker();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(name,score);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;get();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-67&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-67&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 67&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 67&lt;/h1&gt;&lt;p&gt;感觉又是手速场的一次竞赛,不过感觉力扣的题目确实越来越水了,还是 $CF$ $Atcoder$ 之类的要锻炼思维一些. &lt;/p&gt;&lt;h3 id=&quot;5934-找到和最大的长度为-K-的子序列&quot;&gt;&lt;a href=&quot;#5934-找到和最大的长度为-K-的子序列&quot; class=&quot;headerlink&quot; title=&quot;5934. 找到和最大的长度为 K 的子序列&quot;&gt;&lt;/a&gt;5934. 找到和最大的长度为 K 的子序列&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; 。你需要找到 &lt;code&gt;nums&lt;/code&gt; 中长度为 &lt;code&gt;k&lt;/code&gt; 的 子序列 ，且这个子序列的 和最大 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 270</title>
    <link href="http://yoursite.com/2021/12/05/350/"/>
    <id>http://yoursite.com/2021/12/05/350/</id>
    <published>2021-12-05T10:12:06.134Z</published>
    <updated>2021-12-08T16:13:11.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-270"><a href="#leetcode-contest-270" class="headerlink" title="leetcode  contest 270"></a>leetcode  contest 270</h1><p>最后一题欧拉回路,确实不会，其余的题目都是简单题目．</p><h3 id="5942-找出-3-位偶数"><a href="#5942-找出-3-位偶数" class="headerlink" title="5942. 找出 3 位偶数"></a>5942. 找出 3 位偶数</h3><p>给你一个整数数组 <code>digits</code> ，其中每个元素是一个数字<code>（0 - 9）</code>。数组中可能存在重复元素。</p><p>你需要找出 所有 满足下述条件且 互不相同 的整数：</p><ul><li>该整数由 digits 中的三个元素按 任意 顺序 依次连接 组成。</li><li>该整数不含 前导零</li><li>该整数是一个 偶数<br>例如，给定的 <code>digits</code> 是 <code>[1, 2, 3]</code> ，整数 <code>132</code> 和 <code>312</code> 满足上面列出的全部条件。</li></ul><a id="more"></a><p>将找出的所有互不相同的整数按 递增顺序 排列，并以数组形式返回。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-270/problems/finding-3-digit-even-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-270/problems/finding-3-digit-even-numbers/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>遍历所有的三位数，检测符合性条件即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(C)$, 其中 $C = 1000$ 为三位数的总数。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findEvenNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : digits)&#123;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">string</span> s = to_string(i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">                curr[c-<span class="string">'0'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr[j] &gt; cnt[j])&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5943-删除链表的中间节点"><a href="#5943-删除链表的中间节点" class="headerlink" title="5943. 删除链表的中间节点"></a>5943. 删除链表的中间节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 <code>head</code> 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 <code>head</code>。</p><p>长度为 n 链表的中间节点是从头数起第<code>⌊n / 2⌋</code>个节点（下标从 <code>0</code>开始），其中<code>⌊x⌋</code>表示小于或等于 x 的最大整数。</p><p>对于 <code>n = 1、2、3、4</code>和 <code>5</code> 的情况，中间节点的下标分别是 <code>0、1、1、2</code>和 <code>2</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">上图表示给出的链表。节点的下标分别标注在每个节点的下方。</span><br><span class="line">由于 n = <span class="number">7</span> ，值为 <span class="number">7</span> 的节点 <span class="number">3</span> 是中间节点，用红色标注。</span><br><span class="line">返回结果为移除节点后的新链表。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">上图表示给出的链表。</span><br><span class="line">对于 n = <span class="number">4</span> ，值为 <span class="number">3</span> 的节点 <span class="number">2</span> 是中间节点，用红色标注。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">2</span>]</span><br><span class="line">解释：</span><br><span class="line">上图表示给出的链表。</span><br><span class="line">对于 n = <span class="number">2</span> ，值为 <span class="number">1</span> 的节点 <span class="number">1</span> 是中间节点，用红色标注。</span><br><span class="line">值为 <span class="number">2</span> 的节点 <span class="number">0</span> 是移除节点 <span class="number">1</span> 后剩下的唯一一个节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表中节点的数目在范围 [1, 105] 内</li><li>1 &lt;= Node.val &lt;= 105</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-270/problems/delete-the-middle-node-of-a-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-270/problems/delete-the-middle-node-of-a-linked-list/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 快慢指针或者数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>好无聊的题目，找到目标删除节点的前一个节点，进行删除即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(n)$，其中 $n$ 为链表的长度.</li><li>空间复杂度为 $O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteMiddle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode * curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> m = n/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;next = curr-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5944-从二叉树一个节点到另一个节点每一步的方向"><a href="#5944-从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="5944. 从二叉树一个节点到另一个节点每一步的方向"></a>5944. 从二叉树一个节点到另一个节点每一步的方向</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一棵 二叉树 的根节点 root ，这棵二叉树总共有 <code>n</code> 个节点。每个节点的值为 <code>1</code> 到 <code>n</code> 中的一个整数，且互不相同。给你一个整数 <code>startValue</code> ，表示起点节点 s 的值，和另一个不同的整数 <code>destValue</code>，表示终点节点 <code>t</code> 的值。</p><p>请找到从节点 <code>s</code> 到节点 <code>t</code> 的 最短路径 ，并以字符串的形式返回每一步的方向。每一步用 大写 字母 ‘L’ ，’R’ 和 ‘U’ 分别表示一种方向：</p><ul><li>‘L’ 表示从一个节点前往它的 左孩子 节点。</li><li>‘R’ 表示从一个节点前往它的 右孩子 节点。</li><li>‘U’ 表示从一个节点前往它的 父 节点。<br>请你返回从 <code>s</code> 到 <code>t</code> 最短路径 每一步的方向。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">4</span>], startValue = <span class="number">3</span>, destValue = <span class="number">6</span></span><br><span class="line">输出：<span class="string">"UURL"</span></span><br><span class="line">解释：最短路径为：<span class="number">3</span> → <span class="number">1</span> → <span class="number">5</span> → <span class="number">2</span> → <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">1</span>], startValue = <span class="number">2</span>, destValue = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"L"</span></span><br><span class="line">解释：最短路径为：<span class="number">2</span> → <span class="number">1</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">+ 树中节点数目为 `n` 。</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= Node.val &lt;= n`</span><br><span class="line">+ 树中所有节点的值 互不相同 。</span><br><span class="line">+ `<span class="number">1</span> &lt;= startValue, destValue &lt;= n`</span><br><span class="line">+ `startValue != destValue`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-270/problems/step-by-step-directions-from-a-binary-tree-node-to-another/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt; DFS</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 感觉也是非常常见的题目,先利用 $lca$ 算法找到给定值的最低的公共父节点 $fa$ ,可以参考原题关于 $lca$ 的求法. 然后再利用 `dfs` 找到从 $fa$ 到每个起点 $start$ 和 终点 $dest$ 的路径. 知道路径以后我们可以知道从起点 $start$ 到 $fa$ 的方向应该都是 $U$, 从$fa$ 到 </span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度：$O(N)$ 其中 $n$ 为二叉树中节点的个数。</span><br><span class="line">+ 空间复杂度分析: $O(N)$,其中 $n$ 为二叉树中节点的个数.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode * lca(TreeNode * root, <span class="built_in">int</span> startValue, <span class="built_in">int</span> destValue) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>ptr;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == startValue) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == destValue) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode * left = lca(root-&gt;left,startValue,destValue);</span><br><span class="line">        TreeNode * right = lca(root-&gt;right,startValue,destValue);</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; !right)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bool</span> dfs(TreeNode * root, <span class="built_in">int</span> val,vector&lt;<span class="built_in">int</span>&gt; &amp; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        res.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dfs(root-&gt;left,val,res))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.pop_back();</span><br><span class="line">        res.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(dfs(root-&gt;right,val,res))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> getDirections(TreeNode* root, <span class="built_in">int</span> startValue, <span class="built_in">int</span> destValue) &#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        TreeNode * p = lca(root,startValue,destValue);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; paths;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; patht;</span><br><span class="line">        dfs(p,startValue,paths);</span><br><span class="line">        dfs(p,destValue,patht);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; paths.size(); ++i)&#123;</span><br><span class="line">            ans.push_back(<span class="string">'U'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; patht.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(patht[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.push_back(<span class="string">'L'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="string">'R'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5932-合法重新排列数对"><a href="#5932-合法重新排列数对" class="headerlink" title="5932. 合法重新排列数对"></a>5932. 合法重新排列数对</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的二维整数数组 <code>pairs</code> ，其中 <code>pairs[i] = [starti, endi]</code> 。如果 <code>pairs</code> 的一个重新排列，满足对每一个下标<code>i （ 1 &lt;= i &lt; pairs.length ）</code>都有 <code>endi-1 == starti</code>，那么我们就认为这个重新排列是 <code>pairs</code> 的一个 合法重新排列 。</p><p>请你返回 任意一个 <code>pairs</code> 的合法重新排列。</p><p>注意：数据保证至少存在一个 <code>pairs</code> 的合法重新排列。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：pairs = [[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">11</span>,<span class="number">9</span>],[<span class="number">9</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[[<span class="number">11</span>,<span class="number">9</span>],[<span class="number">9</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">1</span>]]</span><br><span class="line">解释：</span><br><span class="line">输出的是一个合法重新排列，因为每一个 endi<span class="number">-1</span> 都等于 starti 。</span><br><span class="line">end0 = <span class="number">9</span> == <span class="number">9</span> = start1 </span><br><span class="line">end1 = <span class="number">4</span> == <span class="number">4</span> = start2</span><br><span class="line">end2 = <span class="number">5</span> == <span class="number">5</span> = start3</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：pairs = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">解释：</span><br><span class="line">输出的是一个合法重新排列，因为每一个 endi<span class="number">-1</span> 都等于 starti 。</span><br><span class="line">end0 = <span class="number">3</span> == <span class="number">3</span> = start1</span><br><span class="line">end1 = <span class="number">2</span> == <span class="number">2</span> = start2</span><br><span class="line">重新排列后的数组 [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>]] 和 [[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>]] 都是合法的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：pairs = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">输出的是一个合法重新排列，因为每一个 endi<span class="number">-1</span> 都等于 starti 。</span><br><span class="line">end0 = <span class="number">2</span> == <span class="number">2</span> = start1</span><br><span class="line">end1 = <span class="number">1</span> == <span class="number">1</span> = start2</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= pairs.length &lt;= 105</code></li><li><code>pairs[i].length == 2</code></li><li><code>0 &lt;= starti, endi &lt;= 109</code></li><li><code>starti != endi</code></li><li><code>pairs</code> 中不存在一模一样的数对。</li><li>至少 存在 一个合法的 <code>pairs</code> 重新排列。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-270/problems/valid-arrangement-of-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-270/problems/valid-arrangement-of-pairs/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>欧拉回路</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>欧拉回路的题目确实很少碰到，确实比较超纲的知识，一个有向图满足欧拉回路的条件如下：</li></ol><ul><li>要么所有的节点的入度和出度相等;</li><li>要么只有一个节点的出度比入度大 $1$, 另外存在另一个节点的入度比出度大 $1$为终点, 其余的节点的入度与出度相等.</li></ul><ol><li>求欧拉回路可以用 $\text{Hierholzer}$ 算法,详细可以参考<a href="https://www.geeksforgeeks.org/hierholzers-algorithm-directed-graph/" target="_blank" rel="noopener">欧拉回路</a>上面的讲解,非常详细和简答明了. 在此题中由于题目已经给定说明存在欧拉回路,因此重要的是我们要找到欧拉回路的起点, 我们可以看到实际的有向图以每个数为顶点,以 $pairs$ 中的元素作为边, 我们求出顶点的入度和出度即可.</li><li>$\text{Hierholzer}$ 算法的核心思想大概是利用栈的思想,从一个可能的起点出发，进行深度优先搜索，但是每次沿着辅助边从某个顶点移动到另外一个顶点的时候，都需要删除这个辅助边。如果没有可移动的路径，则将所在结点加入到栈中，并返回。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dfs(node, trace)&#123;</span><br><span class="line"><span class="keyword">while</span>(!node.adj.isEmpty())&#123;</span><br><span class="line">Node next = node.adj.removeLast();</span><br><span class="line">dfs(next, trace);</span><br><span class="line">&#125;</span><br><span class="line">trace.addLast(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最后得到的栈中保存的就是整个欧拉闭迹中的顶点。（要恢复我们需要不断出栈，因此如果你用列表来存欧垃迹的话需要反转一次）。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(N)$,$\text{Hierholzer}$ 算法的时间复杂度为 $O(V + E)$, 即等于边的个数加上顶点的个数, 本题中边的数目即为 $pairs$ 数组的长度。</li><li>空间复杂度分析: $O(N)$,其中 $N$ 为数组 $pairs$ 中元素的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; edges, <span class="keyword">int</span> u,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!edges[u].empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edges[u].back();</span><br><span class="line">            edges[u].pop_back();</span><br><span class="line">            dfs(edges, v, res);</span><br><span class="line">            res.push_back(&#123;u, v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; validArrangement(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; degree;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; v : pairs) &#123;</span><br><span class="line">            edges[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">            degree[v[<span class="number">0</span>]]--;</span><br><span class="line">            degree[v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = pairs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : degree) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second == <span class="number">-1</span>) &#123;</span><br><span class="line">                start = v.first;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(edges, start, ans);</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-270&quot;&gt;&lt;a href=&quot;#leetcode-contest-270&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 270&quot;&gt;&lt;/a&gt;leetcode  contest 270&lt;/h1&gt;&lt;p&gt;最后一题欧拉回路,确实不会，其余的题目都是简单题目．&lt;/p&gt;&lt;h3 id=&quot;5942-找出-3-位偶数&quot;&gt;&lt;a href=&quot;#5942-找出-3-位偶数&quot; class=&quot;headerlink&quot; title=&quot;5942. 找出 3 位偶数&quot;&gt;&lt;/a&gt;5942. 找出 3 位偶数&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;digits&lt;/code&gt; ，其中每个元素是一个数字&lt;code&gt;（0 - 9）&lt;/code&gt;。数组中可能存在重复元素。&lt;/p&gt;&lt;p&gt;你需要找出 所有 满足下述条件且 互不相同 的整数：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;该整数由 digits 中的三个元素按 任意 顺序 依次连接 组成。&lt;/li&gt;
&lt;li&gt;该整数不含 前导零&lt;/li&gt;
&lt;li&gt;该整数是一个 偶数&lt;br&gt;例如，给定的 &lt;code&gt;digits&lt;/code&gt; 是 &lt;code&gt;[1, 2, 3]&lt;/code&gt; ，整数 &lt;code&gt;132&lt;/code&gt; 和 &lt;code&gt;312&lt;/code&gt; 满足上面列出的全部条件。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 269</title>
    <link href="http://yoursite.com/2021/11/28/349/"/>
    <id>http://yoursite.com/2021/11/28/349/</id>
    <published>2021-11-28T14:42:07.015Z</published>
    <updated>2021-11-28T16:10:15.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-269"><a href="#leetcode-contest-269" class="headerlink" title="leetcode  contest 269"></a>leetcode  contest 269</h1><p>本周最后一题竟然基本上都过了，最后模拟了一把暴力 $BFS$ 过了最后一题.<br><img src="https://i.loli.net/2021/11/28/5mDFS3qcyM7a8QI.png" alt></p><h3 id="5938-找出数组排序后的目标下标"><a href="#5938-找出数组排序后的目标下标" class="headerlink" title="5938. 找出数组排序后的目标下标"></a>5938. 找出数组排序后的目标下标</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> 以及一个目标元素 <code>target</code> 。</p><p>目标下标 是一个满足 <code>nums[i] == target</code>的下标 <code>i</code> 。</p><a id="more"></a><p>将 <code>nums</code> 按 非递减 顺序排序后，返回由 <code>nums</code> 中目标下标组成的列表。如果不存在目标下标，返回一个 空 列表。返回的列表必须按 递增 顺序排列。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：排序后，nums 变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">满足 nums[i] == <span class="number">2</span> 的下标是 <span class="number">1</span> 和 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>]</span><br><span class="line">解释：排序后，nums 变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">满足 nums[i] == <span class="number">3</span> 的下标是 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>]</span><br><span class="line">解释：排序后，nums 变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">满足 nums[i] == <span class="number">5</span> 的下标是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">4</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：nums 中不含值为 <span class="number">4</span> 的元素。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i], target &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序后遍历．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N \log N)$,其中 $N$ 为数组的长度。</li><li>空间复杂度: $O(N)$, 其中 $N$ 为数组的长度。。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; targetIndices(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;ｓ</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5939-半径为-k-的子数组平均值"><a href="#5939-半径为-k-的子数组平均值" class="headerlink" title="5939. 半径为 k 的子数组平均值"></a>5939. 半径为 k 的子数组平均值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的数组 <code>nums</code> ，数组中有 <code>n</code> 个整数，另给你一个整数 <code>k</code> 。</p><p>半径为 <code>k</code> 的子数组平均值 是指：<code>nums</code> 中一个以下标 <code>i</code> 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 <code>i - k</code> 和<code>i + k</code>范围（含 <code>i - k</code> 和<code>i + k</code>）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。</p><p>构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。</p><p>x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。</p><p>例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 3.75，截断后得到 3 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：</span><br><span class="line">- avg[<span class="number">0</span>]、avg[<span class="number">1</span>] 和 avg[<span class="number">2</span>] 是 <span class="number">-1</span> ，因为在这几个下标前的元素数量都不足 k 个。</span><br><span class="line">- 中心为下标 <span class="number">3</span> 且半径为 <span class="number">3</span> 的子数组的元素总和是：<span class="number">7</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">9</span> + <span class="number">1</span> + <span class="number">8</span> + <span class="number">5</span> = <span class="number">37</span> 。</span><br><span class="line">  使用截断式 整数除法，avg[<span class="number">3</span>] = <span class="number">37</span> / <span class="number">7</span> = <span class="number">5</span> 。</span><br><span class="line">- 中心为下标 <span class="number">4</span> 的子数组，avg[<span class="number">4</span>] = (<span class="number">4</span> + <span class="number">3</span> + <span class="number">9</span> + <span class="number">1</span> + <span class="number">8</span> + <span class="number">5</span> + <span class="number">2</span>) / <span class="number">7</span> = <span class="number">4</span> 。</span><br><span class="line">- 中心为下标 <span class="number">5</span> 的子数组，avg[<span class="number">5</span>] = (<span class="number">3</span> + <span class="number">9</span> + <span class="number">1</span> + <span class="number">8</span> + <span class="number">5</span> + <span class="number">2</span> + <span class="number">6</span>) / <span class="number">7</span> = <span class="number">4</span> 。</span><br><span class="line">- avg[<span class="number">6</span>]、avg[<span class="number">7</span>] 和 avg[<span class="number">8</span>] 是 <span class="number">-1</span> ，因为在这几个下标后的元素数量都不足 k 个。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">100000</span>], k = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">100000</span>]</span><br><span class="line">解释：</span><br><span class="line">- 中心为下标 <span class="number">0</span> 且半径 <span class="number">0</span> 的子数组的元素总和是：<span class="number">100000</span> 。</span><br><span class="line">  avg[<span class="number">0</span>] = <span class="number">100000</span> / <span class="number">1</span> = <span class="number">100000</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">8</span>], k = <span class="number">100000</span></span><br><span class="line">输出：[<span class="number">-1</span>]</span><br><span class="line">解释：</span><br><span class="line">- avg[<span class="number">0</span>] 是 <span class="number">-1</span> ，因为在下标 <span class="number">0</span> 前后的元素数量均不足 k 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == nums.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= nums[i], k &lt;= <span class="number">105</span>。`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-269/problems/k-radius-subarray-averages/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 滑动窗口大小为 $<span class="number">2</span> \times k + <span class="number">1</span>$, 我们依次求出连续长度为 $<span class="number">2</span> \times k + <span class="number">1</span>$ 的连续子数组的和.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度分析: 时间复杂度为 $O(N)$, 其中 $N$ 为数组的长度。</span><br><span class="line">+ 空间复杂度分析: 空间复杂度为 $O(N)$, 其中 $N$ 为数组的长度。。</span><br><span class="line"></span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; getAverages(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">int</span> sz = k*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n,<span class="number">-1</span>);</span><br><span class="line">        long long curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz &amp;&amp; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = k; i &lt; n-k; ++i)&#123;</span><br><span class="line">            ans[i] = curr/sz;</span><br><span class="line">            curr -= nums[i-k];</span><br><span class="line">            <span class="keyword">if</span>(i + k + <span class="number">1</span> &lt; n)&#123;</span><br><span class="line">                curr += nums[i+k+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5940-从数组中移除最大值和最小值"><a href="#5940-从数组中移除最大值和最小值" class="headerlink" title="5940. 从数组中移除最大值和最小值"></a>5940. 从数组中移除最大值和最小值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的数组 <code>nums</code> ，数组由若干 互不相同 的整数组成。</p><p><code>nums</code> 中有一个值最小的元素和一个值最大的元素。分别称为 最小值 和 最大值 。你的目标是从数组中移除这两个元素。</p><p>一次 删除 操作定义为从数组的 前面 移除一个元素或从数组的 后面 移除一个元素。</p><p>返回将数组中最小值和最大值 都 移除需要的最小删除次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">数组中的最小元素是 nums[<span class="number">5</span>] ，值为 <span class="number">1</span> 。</span><br><span class="line">数组中的最大元素是 nums[<span class="number">1</span>] ，值为 <span class="number">10</span> 。</span><br><span class="line">将最大值和最小值都移除需要从数组前面移除 <span class="number">2</span> 个元素，从数组后面移除 <span class="number">3</span> 个元素。</span><br><span class="line">结果是 <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span> ，这是所有可能情况中的最小删除次数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">-4</span>,<span class="number">19</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">数组中的最小元素是 nums[<span class="number">1</span>] ，值为 <span class="number">-4</span> 。</span><br><span class="line">数组中的最大元素是 nums[<span class="number">2</span>] ，值为 <span class="number">19</span> 。</span><br><span class="line">将最大值和最小值都移除需要从数组前面移除 <span class="number">3</span> 个元素。</span><br><span class="line">结果是 <span class="number">3</span> ，这是所有可能情况中的最小删除次数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">101</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。</span><br><span class="line">移除它只需要 <span class="number">1</span> 次删除操作。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">-105</span> &lt;= nums[i] &lt;= <span class="number">105</span>`</span><br><span class="line">+ `nums` 中的整数 互不相同</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-269/problems/removing-minimum-and-maximum-from-array/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学问题</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 感觉这个题目可以算是一个简单题目，因为一个数要么从前取，要么从后取，因此不同的数的组合取法最多有 $<span class="number">4</span>$ 种:</span><br><span class="line">+ 要么两个数都从数组的开头取;</span><br><span class="line">+ 要么两个数都从数组的结尾取;</span><br><span class="line">+ 要么一个数从数组的开头取,另一个数从数组的结尾取.</span><br><span class="line">以上几种组合的全部求一遍即可得到最小的移除步骤.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度度为 $O(n)$.</span><br><span class="line">+ 空间复杂度为 $O(<span class="number">1</span>)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minimumDeletions(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="built_in">int</span> maxVal = INT_MIN;</span><br><span class="line">        <span class="built_in">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">int</span> ans = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; minVal)&#123;</span><br><span class="line">                minVal = nums[i];</span><br><span class="line">                minIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxVal)&#123;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans = min(ans,max(minIdx,maxIdx) + <span class="number">1</span>);</span><br><span class="line">        ans = min(ans,max(n - maxIdx, n - minIdx));</span><br><span class="line">        ans = min(ans,maxIdx + <span class="number">1</span> + n - minIdx);</span><br><span class="line">        ans = min(ans,minIdx + <span class="number">1</span> + n - maxIdx);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5941-找出知晓秘密的所有专家"><a href="#5941-找出知晓秘密的所有专家" class="headerlink" title="5941. 找出知晓秘密的所有专家"></a>5941. 找出知晓秘密的所有专家</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code> ，表示有 <code>n</code> 个专家从 <code>0</code> 到 <code>n - 1</code>编号。另外给你一个下标从 <code>0</code> 开始的二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [xi, yi, timei]</code> 表示专家 <code>xi</code>和专家 <code>yi</code> 在时间 <code>timei</code>要开一场会。一个专家可以同时参加 多场会议 。最后，给你一个整数 <code>firstPerson</code> 。</p><p>专家<code>0</code> 有一个 秘密 ，最初，他在时间 <code>0</code> 将这个秘密分享给了专家 <code>firstPerson</code> 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 <code>xi</code> 在时间 <code>timei</code> 时知晓这个秘密，那么他将会与专家 yi 分享这个秘密，反之亦然。</p><p>秘密共享是 瞬时发生 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p><p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 任何顺序 返回答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, meetings = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>]], firstPerson = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">解释：</span><br><span class="line">时间 <span class="number">0</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">1</span> 共享。</span><br><span class="line">时间 <span class="number">5</span> ，专家 <span class="number">1</span> 将秘密与专家 <span class="number">2</span> 共享。</span><br><span class="line">时间 <span class="number">8</span> ，专家 <span class="number">2</span> 将秘密与专家 <span class="number">3</span> 共享。</span><br><span class="line">时间 <span class="number">10</span> ，专家 <span class="number">1</span> 将秘密与专家 <span class="number">5</span> 共享。</span><br><span class="line">因此，在所有会议结束后，专家 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span> 和 <span class="number">5</span> 都将知晓这个秘密。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, meetings = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>]], firstPerson = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">时间 <span class="number">0</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">3</span> 共享。</span><br><span class="line">时间 <span class="number">2</span> ，专家 <span class="number">1</span> 与专家 <span class="number">2</span> 都不知晓这个秘密。</span><br><span class="line">时间 <span class="number">3</span> ，专家 <span class="number">3</span> 将秘密与专家 <span class="number">0</span> 和专家 <span class="number">1</span> 共享。</span><br><span class="line">因此，在所有会议结束后，专家 <span class="number">0</span>、<span class="number">1</span> 和 <span class="number">3</span> 都将知晓这个秘密。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, meetings = [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]], firstPerson = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">时间 <span class="number">0</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">1</span> 共享。</span><br><span class="line">时间 <span class="number">1</span> ，专家 <span class="number">1</span> 将秘密与专家 <span class="number">2</span> 共享，专家 <span class="number">2</span> 将秘密与专家 <span class="number">3</span> 共享。</span><br><span class="line">注意，专家 <span class="number">2</span> 可以在收到秘密的同一时间分享此秘密。</span><br><span class="line">时间 <span class="number">2</span> ，专家 <span class="number">3</span> 将秘密与专家 <span class="number">4</span> 共享。</span><br><span class="line">因此，在所有会议结束后，专家 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span> 和 <span class="number">4</span> 都将知晓这个秘密。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, meetings = [[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>]], firstPerson = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">时间 <span class="number">0</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">1</span> 共享。</span><br><span class="line">时间 <span class="number">1</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">2</span> 共享，专家 <span class="number">1</span> 将秘密与专家 <span class="number">3</span> 共享。</span><br><span class="line">因此，在所有会议结束后，专家 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span> 和 <span class="number">3</span> 都将知晓这个秘密。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= meetings.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `meetings[i].length == <span class="number">3</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= xi, yi &lt;= n - <span class="number">1</span>`</span><br><span class="line">+ `xi != yi`</span><br><span class="line">+ `<span class="number">1</span> &lt;= timei &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= firstPerson &lt;= n - <span class="number">1</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-269/problems/find-all-people-with-secret/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt; BFS或者集合</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 我们首先将所有的会议按照时间大小进行排序,题目最难的地方在于如何处理像同时间下的会议间的关系的传递, 可以通过 $BFS$ 或者集合来处理.</span><br><span class="line"><span class="number">2.</span> $BFS$ : 我们首先利用优先队列, 队列里面存储的为某个专家 $x$ 在 $t$ 时间开会, 我们按照时间的先后顺序来依次访问每个节点, 每个节点弹出时, 我们会依次将该专家 $x$ 所有与其他专家开过的会议时间全部压入到优先队列中, 记录下节点 $x$ 最早知道秘密的时间为 $cost[x]$, 当我们如果发现当前参加会议且知道秘密的时间小于 $cost[x]$, 则我们需要重新进行迭代一次.减枝技巧如下:</span><br><span class="line">+ 我们设 $x$ 的最早知道秘密的时间为 $cost[x]$, 并同时用 $visit[x]$ 记录他是否已经遍历过该节点, 如果遍历过该节点我们不再对该节点的邻居进行迭代.</span><br><span class="line">+ 初始时我们将 $(<span class="number">0</span>,firsperson)$ 的 $cost$ 都设置为 $<span class="number">0</span>$.</span><br><span class="line">+ 如果节点的相邻节点的会议时间小于当前的节点的会议时间, 则我们直接应该跳过, 我们只访问比当前节点晚的会议时间, 因为是向后传递.</span><br><span class="line"><span class="number">3.</span> 题目的难点在于如何处理相同时间下的会议传递, 我们自然而然的想到利用集合,我们处理如下:</span><br><span class="line">+ 首先我们对 $<span class="number">0</span>, firstperson$ 进行合并, 且设置父节点为 $<span class="number">0</span>$;</span><br><span class="line">+ 我们首先对连续相同的起始时间的会议中专家的传递关系进行合并, 两个集合合并时更新父节点为较小的父节点, 然后我们再次遍历一遍相同时间的会议, 对父节点不为 $<span class="number">0</span>$ 的集合进行删除, 这样我们每次就只保证了父节点为 $<span class="number">0</span>$ 的元素进行合并.</span><br><span class="line">+ 我们最终检测父节点为 $<span class="number">0</span>$ 的集合中的元素即为所求.</span><br><span class="line"><span class="number">4.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度：$BFS$ 的时间复杂度为 $O(m\log n)$,其中 $m$ 为会议的个数, $n$ 为专家的个数, 集合方法的时间复杂度为 $O(m \alpha)$。</span><br><span class="line">+ 空间复杂度分析: $O(n + m)$,其中 $m$ 为会议的个数, $n$ 为专家的个数,.</span><br><span class="line">### 代码</span><br><span class="line">+ $BFS$:</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; findAllPeople(<span class="built_in">int</span> n, vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; meetings, <span class="built_in">int</span> firstPerson) &#123;</span><br><span class="line">        <span class="built_in">int</span> m = meetings.size();</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; cost(n,INT_MAX);</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; graph(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans;</span><br><span class="line">        cost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cost[firstPerson] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        sort(meetings.begin(),meetings.end(),[&amp;](<span class="keyword">const</span> vector&lt;<span class="built_in">int</span>&gt; &amp; a, <span class="keyword">const</span> vector&lt;<span class="built_in">int</span>&gt; &amp; b)&#123;</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : meetings)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(&#123;v[<span class="number">2</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(&#123;v[<span class="number">2</span>],v[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">        pq.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        pq.push(&#123;<span class="number">0</span>,firstPerson&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            <span class="comment">/*当前节点*/</span></span><br><span class="line">            pii curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(visit[curr.second]) <span class="keyword">continue</span>;</span><br><span class="line">            visit[curr.second] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">auto</span> [t, v] : graph[curr.second])&#123;</span><br><span class="line">                <span class="comment">/* 所有早于当前会议的会议全部跳过*/</span></span><br><span class="line">                <span class="keyword">if</span>(t &lt; curr.first) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">/* 如果当前的时间小于它知道秘密的时间, 则将其加入到队列中重新迭代*/</span></span><br><span class="line">                <span class="keyword">if</span>(t &lt; cost[v])&#123;</span><br><span class="line">                    pq.push(&#123;t, v&#125;);</span><br><span class="line">                    cost[v] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i])&#123;</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>集合:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x]) &#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(f, x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(f, y);</span><br><span class="line">        <span class="keyword">if</span>(x1 == y1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; y1) &#123;</span><br><span class="line">            f[x1] = y1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            f[y1] = x1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAllPeople(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; meetings, <span class="keyword">int</span> firstPerson) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = meetings.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(meetings.begin(),meetings.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        uni(f, <span class="number">0</span> ,firstPerson);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = i;</span><br><span class="line">            <span class="keyword">int</span> time = meetings[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; meetings[i][<span class="number">2</span>] == time) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = curr; j &lt; i; ++j) &#123;</span><br><span class="line">                uni(f, meetings[j][<span class="number">0</span>], meetings[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = curr; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(find(f,meetings[j][<span class="number">0</span>]) != <span class="number">0</span>) &#123;</span><br><span class="line">                    f[meetings[j][<span class="number">0</span>]] = meetings[j][<span class="number">0</span>];</span><br><span class="line">                    f[meetings[j][<span class="number">1</span>]] = meetings[j][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(f, i) == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-269&quot;&gt;&lt;a href=&quot;#leetcode-contest-269&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 269&quot;&gt;&lt;/a&gt;leetcode  contest 269&lt;/h1&gt;&lt;p&gt;本周最后一题竟然基本上都过了，最后模拟了一把暴力 $BFS$ 过了最后一题.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/11/28/5mDFS3qcyM7a8QI.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5938-找出数组排序后的目标下标&quot;&gt;&lt;a href=&quot;#5938-找出数组排序后的目标下标&quot; class=&quot;headerlink&quot; title=&quot;5938. 找出数组排序后的目标下标&quot;&gt;&lt;/a&gt;5938. 找出数组排序后的目标下标&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; 以及一个目标元素 &lt;code&gt;target&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;目标下标 是一个满足 &lt;code&gt;nums[i] == target&lt;/code&gt;的下标 &lt;code&gt;i&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 66</title>
    <link href="http://yoursite.com/2021/11/28/348/"/>
    <id>http://yoursite.com/2021/11/28/348/</id>
    <published>2021-11-27T16:21:13.005Z</published>
    <updated>2021-11-28T01:50:48.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-66"><a href="#leetcode-biweekly-contest-66" class="headerlink" title="leetcode biweekly contest 66"></a>leetcode biweekly contest 66</h1><p>本周的双周赛的题目不是很高，总体感觉难度不是很大.<br><img src="https://i.loli.net/2021/11/28/yKFfbsrYiGI43CR.png" alt></p><h3 id="5922-统计出现过一次的公共字符串"><a href="#5922-统计出现过一次的公共字符串" class="headerlink" title="5922. 统计出现过一次的公共字符串"></a>5922. 统计出现过一次的公共字符串</h3><p>给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：words1 = [<span class="string">"leetcode"</span>,<span class="string">"is"</span>,<span class="string">"amazing"</span>,<span class="string">"as"</span>,<span class="string">"is"</span>], words2 = [<span class="string">"amazing"</span>,<span class="string">"leetcode"</span>,<span class="string">"is"</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- <span class="string">"leetcode"</span> 在两个数组中都恰好出现一次，计入答案。</span><br><span class="line">- <span class="string">"amazing"</span> 在两个数组中都恰好出现一次，计入答案。</span><br><span class="line">- <span class="string">"is"</span> 在两个数组中都出现过，但在 words1 中出现了 <span class="number">2</span> 次，不计入答案。</span><br><span class="line">- <span class="string">"as"</span> 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。</span><br><span class="line">所以，有 <span class="number">2</span> 个字符串在两个数组中都恰好出现了一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">words1</span> = [<span class="string">"b"</span>,<span class="string">"bb"</span>,<span class="string">"bbb"</span>], <span class="attr">words2</span> = [<span class="string">"a"</span>,<span class="string">"aa"</span>,<span class="string">"aaa"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有字符串在两个数组中都恰好出现一次。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words1 = [<span class="comment">"a"</span>,<span class="comment">"ab"</span>], words2 = [<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"ab"</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一在两个数组中都出现一次的字符串是 <span class="comment">"ab"</span> 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= words1.length, words2.length &lt;= 1000</code></li><li><code>1 &lt;= words1[i].length, words2[j].length &lt;= 30</code></li><li><code>words1[i] 和 words2[j] 都只包含小写英文字母。</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-common-words-with-one-occurrence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-common-words-with-one-occurrence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测统计字符串中字符的次数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>分别检测两个字符串中的字符串的次数,找到次数都为$1$ 的字符串．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串数组的长度。</li><li>空间复杂度: $O(N)$,其中 $N$ 为字符串数组的长度。。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cnt1;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cnt2;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words1) cnt1[word]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words2) cnt2[word]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt1) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt2.count(v.first) &amp;&amp; cnt2[v.first] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5923-从房屋收集雨水需要的最少水桶数"><a href="#5923-从房屋收集雨水需要的最少水桶数" class="headerlink" title="5923. 从房屋收集雨水需要的最少水桶数"></a>5923. 从房屋收集雨水需要的最少水桶数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的字符串 <code>street</code> 。<code>street</code> 中每个字符要么是表示房屋的 <code>&#39;H&#39;</code> ，要么是表示空位的 <code>&#39;.&#39;</code> 。</p><p>你可以在 空位 放置水桶，从相邻的房屋收集雨水。位置在 <code>i - 1</code> 或者 <code>i + 1</code> 的水桶可以收集位置为 <code>i</code> 处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 两个 房屋的雨水。</p><p>在确保 每个 房屋旁边都 至少 有一个水桶的前提下，请你返回需要的 最少 水桶数。如果无解请返回 <code>-1</code>。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：street = <span class="string">"H..H"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">我们可以在下标为 <span class="number">1</span> 和 <span class="number">2</span> 处放水桶。</span><br><span class="line"><span class="string">"H..H"</span> -&gt; <span class="string">"HBBH"</span>（'B' 表示放置水桶）。</span><br><span class="line">下标为 <span class="number">0</span> 处的房屋右边有水桶，下标为 <span class="number">3</span> 处的房屋左边有水桶。</span><br><span class="line">所以每个房屋旁边都至少有一个水桶收集雨水。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：street = <span class="string">".H.H."</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">我们可以在下标为 <span class="number">2</span> 处放置一个水桶。</span><br><span class="line"><span class="string">".H.H."</span> -&gt; <span class="string">".HBH."</span>（'B' 表示放置水桶）。</span><br><span class="line">下标为 <span class="number">1</span> 处的房屋右边有水桶，下标为 <span class="number">3</span> 处的房屋左边有水桶。</span><br><span class="line">所以每个房屋旁边都至少有一个水桶收集雨水。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：street = <span class="string">".HHH."</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">没有空位可以放置水桶收集下标为 <span class="number">2</span> 处的雨水。</span><br><span class="line">所以没有办法收集所有房屋的雨水。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">street </span>= <span class="string">"H"</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">没有空位放置水桶。</span><br><span class="line">所以没有办法收集所有房屋的雨水。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：street = <span class="string">"."</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">没有房屋需要收集雨水。</span><br><span class="line">所以需要 <span class="number">0</span> 个水桶。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= street.length &lt;= 105</code></li><li><code>street[i] 要么是 &#39;H&#39; ，要么是 &#39;.&#39;</code> 。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-66/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-66/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目本身确实想复杂了，就是一个简单的贪心算法，我们遍历到第 $i$ 个位置的房屋时,我们放置桶时优先放到第 $i+1$ 个位置, 因为这样有可能相邻的房屋可以共享桶; 其次我们再尝试在 $i-1$ 个位置放置桶,如果两个位置都无法放置,则表示无法完成.。无法完成的条件实际有以下几种情况:</li></ol><ul><li>字符串长度为 $1$ 且只有一个房屋.</li><li>字符串的开头或者结尾为两个连续的房屋.</li><li>字符串中存在三个连续的房屋.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$, 其中 $N$ 为字符串的长度。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumBuckets</span><span class="params">(<span class="built_in">string</span> street)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = street.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(street[i] == <span class="string">'H'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; street[i<span class="number">-1</span>] == <span class="string">'B'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; street[i+<span class="number">1</span>] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    street[i+<span class="number">1</span>] = <span class="string">'B'</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; street[i<span class="number">-1</span>] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    street[i<span class="number">-1</span>] = <span class="string">'B'</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5924-网格图中机器人回家的最小代价"><a href="#5924-网格图中机器人回家的最小代价" class="headerlink" title="5924. 网格图中机器人回家的最小代价"></a>5924. 网格图中机器人回家的最小代价</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>m x n</code> 的网格图，其中 <code>(0, 0)</code> 是最左上角的格子，<code>(m - 1, n - 1)</code> 是最右下角的格子。给你一个整数数组 <code>startPos ，startPos = [startrow, startcol]</code> 表示 初始 有一个 机器人 在格子 <code>(startrow, startcol)</code> 处。同时给你一个整数数组 <code>homePos ，homePos = [homerow, homecol]</code> 表示机器人的 家 在格子 <code>(homerow, homecol)</code> 处。</p><p>机器人需要回家。每一步它可以往四个方向移动：上，下，左，右，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从 <code>0</code> 开始的额整数数组：长度为 <code>m</code> 的数组 <code>rowCosts</code>  和长度为 <code>n</code> 的数组 <code>colCosts</code> 。</p><p>如果机器人往 上 或者往 下 移动到第 <code>r</code> 行 的格子，那么代价为 <code>rowCosts[r]</code>。<br>如果机器人往 左 或者往 右 移动到第 <code>c</code> 列 的格子，那么代价为 <code>colCosts[c]</code> 。<br>请你返回机器人回家需要的 最小总代价 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：startPos = [<span class="number">1</span>, <span class="number">0</span>], homePos = [<span class="number">2</span>, <span class="number">3</span>], rowCosts = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>], colCosts = [<span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：一个最优路径为：</span><br><span class="line">从 (<span class="number">1</span>, <span class="number">0</span>) 开始</span><br><span class="line">-&gt; 往下走到 (<span class="number">2</span>, <span class="number">0</span>) 。代价为 rowCosts[<span class="number">2</span>] = <span class="number">3</span> 。</span><br><span class="line">-&gt; 往右走到 (<span class="number">2</span>, <span class="number">1</span>) 。代价为 colCosts[<span class="number">1</span>] = <span class="number">2</span> 。</span><br><span class="line">-&gt; 往右走到 (<span class="number">2</span>, <span class="number">2</span>) 。代价为 colCosts[<span class="number">2</span>] = <span class="number">6</span> 。</span><br><span class="line">-&gt; 往右走到 (<span class="number">2</span>, <span class="number">3</span>) 。代价为 colCosts[<span class="number">3</span>] = <span class="number">7</span> 。</span><br><span class="line">总代价为 <span class="number">3</span> + <span class="number">2</span> + <span class="number">6</span> + <span class="number">7</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：startPos = [<span class="number">0</span>, <span class="number">0</span>], homePos = [<span class="number">0</span>, <span class="number">0</span>], rowCosts = [<span class="number">5</span>], colCosts = [<span class="number">26</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：机器人已经在家了，所以不需要移动。总代价为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == rowCosts.length</code></li><li><code>n == colCosts.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>0 &lt;= rowCosts[r], colCosts[c] &lt;= 104</code></li><li><code>startPos.length == 2</code></li><li><code>homePos.length == 2</code></li><li><code>0 &lt;= startrow, homerow &lt; m</code></li><li><code>0 &lt;= startcol, homecol &lt; n</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 曼哈顿距离</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们仔细思考一下相关情况.实际最小的行代价与列代价类似于求曼哈顿距离，只有起始和终点坐标有关系，与路径无关．由于每个格子的 $cost$ 都是大于 $0$ 的,最小的距离肯定是没有回头路的距离，所以我们直接求出两点之间的经过的行的代价和列的代价之和即可.如果本题改为格子的 $cost$ 可能小于 $0$ 那么情况就负责许多.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(m \times n)$.</li><li>空间复杂度为 $O(1)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startPos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; homePos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rowCosts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; colCosts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = rowCosts.size();</span><br><span class="line">        <span class="keyword">int</span> col = colCosts.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(startPos[<span class="number">0</span>] &lt; homePos[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = startPos[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= homePos[<span class="number">0</span>]; ++i)&#123;</span><br><span class="line">                ans += rowCosts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = startPos[<span class="number">0</span>] - <span class="number">1</span>; i &gt;= homePos[<span class="number">0</span>]; --i)&#123;</span><br><span class="line">                ans += rowCosts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(startPos[<span class="number">1</span>] &lt; homePos[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = startPos[<span class="number">1</span>] + <span class="number">1</span>; i &lt;= homePos[<span class="number">1</span>]; ++i)&#123;</span><br><span class="line">                ans += colCosts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = startPos[<span class="number">1</span>] - <span class="number">1</span>; i &gt;= homePos[<span class="number">1</span>]; --i)&#123;</span><br><span class="line">                ans += colCosts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5925-统计农场中肥沃金字塔的数目"><a href="#5925-统计农场中肥沃金字塔的数目" class="headerlink" title="5925. 统计农场中肥沃金字塔的数目"></a>5925. 统计农场中肥沃金字塔的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一个 矩形网格 状的农场，划分为 <code>m</code> 行 <code>n</code> 列的单元格。每个格子要么是 肥沃的 （用 <code>1</code> 表示），要么是 贫瘠 的（用 <code>0</code> 表示）。网格图以外的所有与格子都视为贫瘠的。</p><p>农场中的 金字塔 区域定义如下：</p><ul><li>区域内格子数目 大于 <code>1</code> 且所有格子都是 肥沃的 。<br>金字塔 顶端 是这个金字塔 最上方 的格子。金字塔的高度是它所覆盖的行数。令 <code>(r, c)</code> 为金字塔的顶端且高度为<code>h</code> ，那么金字塔区域内包含的任一格子 <code>(i, j)</code> 需满足<code>r &lt;= i &lt;= r + h - 1</code>且 <code>c - (i - r) &lt;= j &lt;= c + (i - r)</code> 。<br>一个 倒金字塔 类似定义如下：</li><li>区域内格子数目 大于 <code>1</code> 且所有格子都是 肥沃的 。<br>倒金字塔的 顶端 是这个倒金字塔 最下方 的格子。倒金字塔的高度是它所覆盖的行数。令 <code>(r, c)</code> 为金字塔的顶端且高度为 <code>h</code> ，那么金字塔区域内包含的任一格子 <code>(i, j)</code> 需满足 <code>r - h + 1 &lt;= i &lt;= r</code> 且 <code>c - (r - i) &lt;= j &lt;= c + (r - i)</code> 。<br>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。</li></ul><p>给你一个下标从 <code>0</code> 开始且大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，它表示农场，请你返回 <code>grid</code> 中金字塔和倒金字塔的 总数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">2</span> 个可能的金字塔区域分别如上图蓝色和红色区域所示。</span><br><span class="line">这个网格图中没有倒金字塔区域。</span><br><span class="line">所以金字塔区域总数为 <span class="number">2</span> + <span class="number">0</span> = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">金字塔区域如上图蓝色区域所示，倒金字塔如上图红色区域所示。</span><br><span class="line">所以金字塔区域总数目为 <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">网格图中没有任何金字塔或倒金字塔区域。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">7</span> 个金字塔区域。上图第二和第三张图中展示了它们中的 <span class="number">3</span> 个。</span><br><span class="line">有 <span class="number">6</span> 个倒金字塔区域。上图中最后一张图展示了它们中的 <span class="number">2</span> 个。</span><br><span class="line">所以金字塔区域总数目为 <span class="number">7</span> + <span class="number">6</span> = <span class="number">13.</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>grid[i][j]</code>要么是 <code>0</code> ，要么是 <code>1</code> 。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测或者dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>暴力检测:　我们利用前缀和的方法可以求出以第 $(i,j)$ 个格子为中心,向左右进行同时扩张的最长连续的为$1$ 的格子的数目为 $dp[i][j]$. 我们每次检测以 $(i,j)$ 为金字塔的顶点，向下衍生的金字塔的最大次数,此时我们只需要满足以下条件即可一直往下衍生:<script type="math/tex; mode=display">dp[i][j] >= 1 \\dp[i][j + 1] >= 1*2 + 1 \\\cdots \\dp[i][j + k] >= k*2 + 1 \\</script>我们检测$(i,j)$ 为顶点的最大层数为 $cnt$ ,则此时我们可以得到的金字塔的数目为 $cnt-1$.同理倒金字塔的检测方法也类似．</li><li>动态规划: 我们可以设 $(i,j)$ 为顶点的构成金字塔的层数为 $dp[i][j]$ ,则我们可以知道递推公式如下:<script type="math/tex; mode=display">dp[i][j] = \left\{\begin{array}{lr}\min(\min(dp[i+1][j-1],dp[i+1][j+1]),dp[i+1][j]) + 1 \qquad (grid[i][j] = 0)\\0 \qquad (grid[i][j] = 1) \\\end{array}\right.</script>已经知道递推公式,上述检测方法并不是很难.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：动态规划的时间复杂度为 $O(m \times n)$, 暴力检测的时间复杂度为 $(m \times n) \times \min(m,n)$。</li><li>空间复杂度分析: $O(m \times n)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>暴力检测:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPyramids</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(col);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix(col);</span><br><span class="line">            prefix[<span class="number">0</span>] = grid[i][<span class="number">0</span>];</span><br><span class="line">            suffix[col<span class="number">-1</span>] = grid[i][col<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    prefix[j] = prefix[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    prefix[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-2</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    suffix[j] = suffix[j+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    suffix[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">2</span>*min(prefix[j],suffix[j]) - <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> k = i;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; row &amp;&amp; dp[k][j] &gt;= cnt*<span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += cnt - <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                k = i;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; dp[k][j] &gt;= cnt*<span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += cnt - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>动态规划:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m + <span class="number">2</span>); <span class="comment">// 在首尾各增加了一个哨兵位，以避免对边界情况的讨论。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ndp(m + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                ndp[j + <span class="number">1</span>] = min(dp[j], min(dp[j + <span class="number">1</span>], dp[j + <span class="number">2</span>])) + <span class="number">1</span>;</span><br><span class="line">                ans += ndp[j + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = move(ndp); <span class="comment">// 滚动数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPyramids</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = count(grid);</span><br><span class="line">        reverse(grid.begin(), grid.end());</span><br><span class="line">        ans += count(grid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-66&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-66&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 66&quot;&gt;&lt;/a&gt;leetcode biweekly contest 66&lt;/h1&gt;&lt;p&gt;本周的双周赛的题目不是很高，总体感觉难度不是很大.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/11/28/yKFfbsrYiGI43CR.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5922-统计出现过一次的公共字符串&quot;&gt;&lt;a href=&quot;#5922-统计出现过一次的公共字符串&quot; class=&quot;headerlink&quot; title=&quot;5922. 统计出现过一次的公共字符串&quot;&gt;&lt;/a&gt;5922. 统计出现过一次的公共字符串&lt;/h3&gt;&lt;p&gt;给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：words1 = [&lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;is&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;amazing&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;as&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;is&quot;&lt;/span&gt;], words2 = [&lt;span class=&quot;string&quot;&gt;&quot;amazing&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;is&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt; 在两个数组中都恰好出现一次，计入答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;string&quot;&gt;&quot;amazing&quot;&lt;/span&gt; 在两个数组中都恰好出现一次，计入答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;string&quot;&gt;&quot;is&quot;&lt;/span&gt; 在两个数组中都出现过，但在 words1 中出现了 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 次，不计入答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;string&quot;&gt;&quot;as&quot;&lt;/span&gt; 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以，有 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 个字符串在两个数组中都恰好出现了一次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;attr&quot;&gt;words1&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;bb&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;bbb&quot;&lt;/span&gt;], &lt;span class=&quot;attr&quot;&gt;words2&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;aa&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;aaa&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：没有字符串在两个数组中都恰好出现一次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight smalltalk&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：words1 = [&lt;span class=&quot;comment&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;&quot;ab&quot;&lt;/span&gt;], words2 = [&lt;span class=&quot;comment&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;&quot;ab&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：唯一在两个数组中都出现一次的字符串是 &lt;span class=&quot;comment&quot;&gt;&quot;ab&quot;&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Weekly Contest 268</title>
    <link href="http://yoursite.com/2021/11/17/347/"/>
    <id>http://yoursite.com/2021/11/17/347/</id>
    <published>2021-11-17T00:57:29.873Z</published>
    <updated>2021-11-21T08:28:34.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-268"><a href="#leetcode-contest-268" class="headerlink" title="leetcode contest 268"></a>leetcode contest 268</h1><p>最后一题确实不太友好,虽然做出来了,但是感觉就是纯暴力破解.<br><img src="https://i.loli.net/2021/11/21/d6ZYRPT2FqaOMGQ.png" alt></p><h3 id="5930-两栋颜色不同且距离最远的房子"><a href="#5930-两栋颜色不同且距离最远的房子" class="headerlink" title="5930. 两栋颜色不同且距离最远的房子"></a>5930. 两栋颜色不同且距离最远的房子</h3><p>街上有 <code>n</code> 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 <code>0</code> 开始且长度为 <code>n</code> 的整数数组 <code>colors</code> ，其中 <code>colors[i]</code> 表示第 <code>i</code>栋房子的颜色。</p><a id="more"></a><p>返回 两栋 颜色 不同 房子之间的 最大 距离。</p><p>第 <code>i</code> 栋房子和第 <code>j</code> 栋房子之间的距离是 <code>abs(i - j)</code> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：上图中，颜色 <span class="number">1</span> 标识成蓝色，颜色 <span class="number">6</span> 标识成红色。</span><br><span class="line">两栋颜色不同且距离最远的房子是房子 <span class="number">0</span> 和房子 <span class="number">3</span> 。</span><br><span class="line">房子 <span class="number">0</span> 的颜色是颜色 <span class="number">1</span> ，房子 <span class="number">3</span> 的颜色是颜色 <span class="number">6</span> 。两栋房子之间的距离是 abs(<span class="number">0</span> - <span class="number">3</span>) = <span class="number">3</span> 。</span><br><span class="line">注意，房子 <span class="number">3</span> 和房子 <span class="number">6</span> 也可以产生最佳答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：上图中，颜色 <span class="number">1</span> 标识成蓝色，颜色 <span class="number">8</span> 标识成黄色，颜色 <span class="number">3</span> 标识成绿色。</span><br><span class="line">两栋颜色不同且距离最远的房子是房子 <span class="number">0</span> 和房子 <span class="number">4</span> 。</span><br><span class="line">房子 <span class="number">0</span> 的颜色是颜色 <span class="number">1</span> ，房子 <span class="number">4</span> 的颜色是颜色 <span class="number">3</span> 。两栋房子之间的距离是 abs(<span class="number">0</span> - <span class="number">4</span>) = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：两栋颜色不同且距离最远的房子是房子 <span class="number">0</span> 和房子 <span class="number">1</span> 。</span><br><span class="line">房子 <span class="number">0</span> 的颜色是颜色 <span class="number">0</span> ，房子 <span class="number">1</span> 的颜色是颜色 <span class="number">1</span> 。两栋房子之间的距离是 abs(<span class="number">0</span> - <span class="number">1</span>) = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == colors.length</code></li><li><code>2 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= colors[i] &lt;= 100</code></li><li>生成的测试数据满足至少存在 <code>2</code> 栋颜色不同的房子</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接从数组中暴力检测即可，遍历所有的不同颜色的房子．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N^2)$,其中 $N$ 为数组的长度。</li><li>空间复杂度: $O(1)$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; colors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = colors.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[i] != colors[j])&#123;</span><br><span class="line">                    ans = max(ans,j - i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5201-给植物浇水"><a href="#5201-给植物浇水" class="headerlink" title="5201. 给植物浇水"></a>5201. 给植物浇水</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你打算用一个水罐给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。<code>x = -1</code> 处有一条河，你可以在那里重新灌满你的水罐。</p><p>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p><ul><li>按从左到右的顺序给植物浇水。</li><li>在给当前植物浇完水之后，如果你没有足够的水 完全 浇灌下一株植物，那么你就需要返回河边重新装满水罐。</li><li>你 不能 提前重新灌满水罐。</li><li>最初，你在河边（也就是，<code>x = -1</code>），在 <code>x</code> 轴上每移动 一个单位 都需要 一步 。</li></ul><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有一个整数 <code>capacity</code> 表示水罐的容量，返回浇灌所有植物需要的 步数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：plants = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>], capacity = <span class="number">5</span></span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">解释：从河边开始，此时水罐是装满的：</span><br><span class="line">- 走到植物 <span class="number">0</span> (<span class="number">1</span> 步) ，浇水。水罐中还有 <span class="number">3</span> 单位的水。</span><br><span class="line">- 走到植物 <span class="number">1</span> (<span class="number">1</span> 步) ，浇水。水罐中还有 <span class="number">1</span> 单位的水。</span><br><span class="line">- 由于不能完全浇灌植物 <span class="number">2</span> ，回到河边取水 (<span class="number">2</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">2</span> (<span class="number">3</span> 步) ，浇水。水罐中还有 <span class="number">2</span> 单位的水。</span><br><span class="line">- 由于不能完全浇灌植物 <span class="number">3</span> ，回到河边取水 (<span class="number">3</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">3</span> (<span class="number">4</span> 步) ，浇水。</span><br><span class="line">需要的步数是 = <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">14</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：plants = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], capacity = <span class="number">4</span></span><br><span class="line">输出：<span class="number">30</span></span><br><span class="line">解释：从河边开始，此时水罐是装满的：</span><br><span class="line">- 走到植物 <span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span> (<span class="number">3</span> 步) ，浇水。回到河边取水 (<span class="number">3</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">3</span> (<span class="number">4</span> 步) ，浇水。回到河边取水 (<span class="number">4</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">4</span> (<span class="number">5</span> 步) ，浇水。回到河边取水 (<span class="number">5</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">5</span> (<span class="number">6</span> 步) ，浇水。</span><br><span class="line">需要的步数是 = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">6</span> = <span class="number">30</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：plants = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>], capacity = <span class="number">8</span></span><br><span class="line">输出：<span class="number">49</span></span><br><span class="line">解释：每次浇水都需要重新灌满水罐。</span><br><span class="line">需要的步数是 = <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">6</span> + <span class="number">7</span> = <span class="number">49</span> 。</span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-268/problems/watering-plants/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-268/problems/watering-plants/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 枚举和模拟</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们每次记录上一次灌溉能够达到的最远位置为 $last$, 则我们返回起始位置后装满水,需要耗费的步数为 $2 \times (last + 1)$, 下一次灌溉尝试则从位置 $last + 1$ 开始尝试, 直到我们到达最后一株植物即可。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$, 其中 $N$ 为数组的长度,我们只需要遍历一遍数组即可。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wateringPlants</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; plants, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = plants.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(last &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = last; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr + plants[i] &lt;= capacity)&#123;</span><br><span class="line">                    last = i;</span><br><span class="line">                    curr += plants[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += last + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(last &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                ans += last + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2075-解码斜向换位密码"><a href="#2075-解码斜向换位密码" class="headerlink" title="2075. 解码斜向换位密码"></a>2075. 解码斜向换位密码</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。</p><p>子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。</p><p>请你实现 <code>RangeFreqQuery</code> 类：</p><ul><li><code>RangeFreqQuery(int[] arr)</code> 用下标从 <code>0</code>开始的整数数组 <code>arr</code> 构造一个类的实例。</li><li><code>int query(int left, int right, int value)</code> 返回子数组 <code>arr[left...right]</code> 中 <code>value</code> 的 频率 。</li><li>一个 子数组 指的是数组中一段连续的元素。<code>arr[left...right]</code> 指的是 <code>nums</code> 中包含下标 <code>left</code> 和 <code>right</code> 在内 的中间一段连续元素。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"RangeFreqQuery"</span>, <span class="string">"query"</span>, <span class="string">"query"</span>]</span><br><span class="line">[[[<span class="number">12</span>, <span class="number">33</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>]], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">11</span>, <span class="number">33</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([<span class="number">12</span>, <span class="number">33</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>]);</span><br><span class="line">rangeFreqQuery.query(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 返回 1 。4 在子数组 [33, 4] 中出现 1 次。</span></span><br><span class="line">rangeFreqQuery.query(<span class="number">0</span>, <span class="number">11</span>, <span class="number">33</span>); <span class="comment">// 返回 2 。33 在整个子数组中出现 2 次。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 105</code></li><li><code>1 &lt;= arr[i], value &lt;= 104</code></li><li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li><li>调用 <code>query</code> 不超过 <code>105</code> 次。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-268/problems/range-frequency-queries/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-268/problems/range-frequency-queries/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 哈希存储 + 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>刚拿到挺难的样子,实际我们用哈希表存储每个元素在数组中的所以,此时如果我们需要查询某个元素 $val$ 在区间 $[left,right]$ 中的频率, 则此时我们只需要利用二分查找,查找该元素在数组中索引的集合中有多少处在区间 $[left,right]$ 中即可.</li><li>复杂度分析:</li></ol><ul><li><code>query</code>的时间复杂度为 $O(2\log n)$,其中 $n$ 为数组的长度, 对于每个查询我们需要两次二分查找．<code>RangeFreqQuery</code>需要 $O(n)$ 的时间复杂度.</li><li>空间复杂度为 $O(n)$,其中 $n$ 为数组的长度, 我们只需要存储每个元素在数组中的索引即可.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeFreqQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RangeFreqQuery(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            cnt[arr[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cnt.count(value)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it1 = lower_bound(cnt[value].begin(),cnt[value].end(),left);</span><br><span class="line">        <span class="keyword">auto</span> it2 = upper_bound(cnt[value].begin(),cnt[value].end(),right);</span><br><span class="line">        <span class="keyword">return</span> it2 - it1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5933-k-镜像数字的和"><a href="#5933-k-镜像数字的和" class="headerlink" title="5933. k 镜像数字的和"></a>5933. k 镜像数字的和</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个 <code>k</code> 镜像数字 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 没有前导 <code>0</code> 的 正 整数。</p><p>比方说，<code>9</code>是一个 <code>2</code> 镜像数字。<code>9</code> 在十进制下为<code>9</code> ，二进制下为 <code>1001</code> ，两者从前往后读和从后往前读都一样。<br>相反地，<code>4</code> 不是一个 <code>2</code> 镜像数字。<code>4</code> 在二进制下为 100 ，从前往后和从后往前读不相同。<br>给你进制 <code>k</code> 和一个数字<code>n</code> ，请你返回 k 镜像数字中 最小 的 <code>n</code> 个数 之和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">2</span>, n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">最小的 <span class="number">5</span> 个 <span class="number">2</span> 镜像数字和它们的二进制表示如下：</span><br><span class="line">  十进制       二进制</span><br><span class="line">    <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">    <span class="number">3</span>          <span class="number">11</span></span><br><span class="line">    <span class="number">5</span>          <span class="number">101</span></span><br><span class="line">    <span class="number">7</span>          <span class="number">111</span></span><br><span class="line">    <span class="number">9</span>          <span class="number">1001</span></span><br><span class="line">它们的和为 <span class="number">1</span> + <span class="number">3</span> + <span class="number">5</span> + <span class="number">7</span> + <span class="number">9</span> = <span class="number">25</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">499</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">7</span> 个最小的 <span class="number">3</span> 镜像数字和它们的三进制表示如下：</span><br><span class="line">  十进制       三进制</span><br><span class="line">    <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>          <span class="number">2</span></span><br><span class="line">    <span class="number">4</span>          <span class="number">11</span></span><br><span class="line">    <span class="number">8</span>          <span class="number">22</span></span><br><span class="line">    <span class="number">121</span>        <span class="number">11111</span></span><br><span class="line">    <span class="number">151</span>        <span class="number">12121</span></span><br><span class="line">    <span class="number">212</span>        <span class="number">21212</span></span><br><span class="line">它们的和为 <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">121</span> + <span class="number">151</span> + <span class="number">212</span> = <span class="number">499</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">7</span>, n = <span class="number">17</span></span><br><span class="line">输出：<span class="number">20379000</span></span><br><span class="line">解释：<span class="number">17</span> 个最小的 <span class="number">7</span> 镜像数字分别为：</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">121</span>, <span class="number">171</span>, <span class="number">242</span>, <span class="number">292</span>, <span class="number">16561</span>, <span class="number">65656</span>, <span class="number">2137312</span>, <span class="number">4602064</span>, <span class="number">6597956</span>, <span class="number">6958596</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 30</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-268/problems/sum-of-k-mirror-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-268/problems/sum-of-k-mirror-numbers/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 模拟 + 枚举</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目挺奇怪的，拿到之后确实没有非常好的方法, 只能按照题目要求生成所有 $k$ 进制的镜像数 $x$,同时我们检测 $x$ 是否也属于 $10$ 进制的镜像数, 知道满足 $n$ 个即可.</li><li>题目的难点在于如何生成镜像数, 其实这个有规律可循的, 假设我们生成 $k$ 进制且长度为 $bit$ 的所有镜像数集合(且满足从小到大)为 $cnt$.  则我们生成每个长度为 $bit + 1$ 的 $k$ 进制镜像数时,生成规则如下:</li></ol><ul><li>如果 $bit$ 为偶数, 则我们可以知道 $bit + 1$ 肯定为奇数, 此时生成规则为 我们依次在每个 $bit$ 位的 $k$ 进制镜像数的中间依次插入 $(0-9)$即可,比如当前 $4$ 进制镜像数为 $1111$, 则此时我们可以生成的镜像数为 $11011,11111,11211,11311$,每个$bit$ 位镜像数 $x$ 可以生成 $k$ 个 $bit + 1$ 位镜像数.</li><li>如果 $bit$ 为奇数数, 则我们可以知道 $bit + 1$ 肯定为偶数, 此时生成规则为我们依次在每个 $\frac{bit-1}{2}$ 与 $\frac{bit+1}{2}$ 中间插入一个 $s[\frac{bit-1}{2}]$,比如当前 $3$ 进制镜像数为 $121$, 则此时我们可以生成的镜像数为 $1221$,每个$bit$ 位镜像数 $x$ 可以生成 $1$ 个 $bit + 1$ 位镜像数.</li><li>感觉数据量很小,可以直接暴力计算出来所有可能的值,然后打表查找即可.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(n \times k \times 10)$。</li><li>空间复杂度分析: $O(n \times k)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp; str, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)&#123;</span><br><span class="line">            curr = curr*k + c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(curr);</span><br><span class="line">        <span class="built_in">string</span> t = s;</span><br><span class="line">        reverse(t.begin(),t.end());</span><br><span class="line">        <span class="keyword">if</span>(t == s)&#123;</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> bit,<span class="keyword">int</span> count,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; cnt, <span class="keyword">long</span> <span class="keyword">long</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : cnt)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = bit/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> curr = s.substr(<span class="number">0</span>,mid) + s[mid<span class="number">-1</span>] + s.substr(mid);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = check(curr, k);</span><br><span class="line">                <span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += x;</span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                next.push_back(curr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">                    <span class="built_in">string</span> curr = s.substr(<span class="number">0</span>,mid) + to_string(i) + s.substr(mid);</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> x = check(curr, k);</span><br><span class="line">                    <span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        res += x;</span><br><span class="line">                        count--;</span><br><span class="line">                        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next.push_back(curr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(k,bit+<span class="number">1</span>,count,next,res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kMirror</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            cnt.push_back(to_string(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">                res += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            res += i;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(k,<span class="number">2</span>,n - (k<span class="number">-1</span>),cnt,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-268&quot;&gt;&lt;a href=&quot;#leetcode-contest-268&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 268&quot;&gt;&lt;/a&gt;leetcode contest 268&lt;/h1&gt;&lt;p&gt;最后一题确实不太友好,虽然做出来了,但是感觉就是纯暴力破解.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/11/21/d6ZYRPT2FqaOMGQ.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5930-两栋颜色不同且距离最远的房子&quot;&gt;&lt;a href=&quot;#5930-两栋颜色不同且距离最远的房子&quot; class=&quot;headerlink&quot; title=&quot;5930. 两栋颜色不同且距离最远的房子&quot;&gt;&lt;/a&gt;5930. 两栋颜色不同且距离最远的房子&lt;/h3&gt;&lt;p&gt;街上有 &lt;code&gt;n&lt;/code&gt; 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始且长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;colors&lt;/code&gt; ，其中 &lt;code&gt;colors[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt;栋房子的颜色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab8 Thread</title>
    <link href="http://yoursite.com/2021/11/15/346/"/>
    <id>http://yoursite.com/2021/11/15/346/</id>
    <published>2021-11-15T05:21:58.779Z</published>
    <updated>2021-11-15T05:22:33.651Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>Kickstart Kickstart 2021 Round  H</title>
    <link href="http://yoursite.com/2021/11/15/345/"/>
    <id>http://yoursite.com/2021/11/15/345/</id>
    <published>2021-11-15T05:19:31.766Z</published>
    <updated>2021-12-05T10:29:28.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kickstart-2021-round-H"><a href="#kickstart-2021-round-H" class="headerlink" title="kickstart 2021 round  H"></a>kickstart 2021 round  H</h1><p><code>kickstart</code>的题目一向质量高,并且难度非常大，感觉基本上是校招面试题中难度最大的题目了，感觉力扣的难度弱爆了. 前三题感觉基本上只需要基本的数学技巧和数据结构的基本知识就可以做出来，最后一题真心是达到<code>ACM</code>的入门难度，还是挺难的题目。第四题花了好长时间才能弄懂题解.</p><a id="more"></a><h3 id="Transform-the-String"><a href="#Transform-the-String" class="headerlink" title="Transform the String"></a>Transform the String</h3><p>Problem<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You are given a string S which denotes a padlock consisting of lower case English letters. You are also given a string F consisting of <span class="keyword">set</span> <span class="keyword">of</span> favorite <span class="keyword">lower</span> <span class="keyword">case</span> English letters. You <span class="keyword">are</span> allowed <span class="keyword">to</span> perform several <span class="keyword">operations</span> <span class="keyword">on</span> the padlock. <span class="keyword">In</span> <span class="keyword">each</span> operation, you can <span class="keyword">change</span> one letter <span class="keyword">of</span> the <span class="keyword">string</span> <span class="keyword">to</span> the one <span class="keyword">following</span> it <span class="keyword">or</span> <span class="keyword">preceding</span> it <span class="keyword">in</span> the alphabetical order. <span class="keyword">For</span> example: <span class="keyword">for</span> the letter c, you <span class="keyword">are</span> allowed <span class="keyword">to</span> <span class="keyword">change</span> it <span class="keyword">to</span> either b <span class="keyword">or</span> d <span class="keyword">in</span> an operation. The letters can be considered <span class="keyword">in</span> a cyclic <span class="keyword">order</span>, i.e., the <span class="keyword">preceding</span> letter <span class="keyword">for</span> letter a would be letter z. Similarly, the <span class="keyword">following</span> letter <span class="keyword">for</span> letter z would be letter a.</span><br><span class="line"></span><br><span class="line">Your aim <span class="keyword">is</span> <span class="keyword">to</span> find the <span class="keyword">minimum</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">operations</span> that <span class="keyword">are</span> <span class="keyword">required</span> such that <span class="keyword">each</span> letter <span class="keyword">in</span> <span class="keyword">string</span> S <span class="keyword">after</span> applying the <span class="keyword">operations</span>, <span class="keyword">is</span> <span class="keyword">present</span> <span class="keyword">in</span> <span class="keyword">string</span> F.</span><br></pre></td></tr></table></figure></p><p>Input<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The <span class="keyword">first</span> <span class="built_in">line</span> <span class="keyword">of</span> <span class="keyword">the</span> input gives <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> test cases, T. T test cases follow.</span><br><span class="line"></span><br><span class="line">Each test <span class="keyword">case</span> consists <span class="keyword">of</span> <span class="literal">two</span> <span class="keyword">lines</span>.</span><br><span class="line">The <span class="keyword">first</span> <span class="built_in">line</span> <span class="keyword">of</span> <span class="keyword">each</span> test <span class="keyword">case</span> <span class="keyword">contains</span> <span class="keyword">the</span> <span class="keyword">string</span> S.</span><br><span class="line">The <span class="keyword">second</span> <span class="built_in">line</span> <span class="keyword">of</span> <span class="keyword">each</span> test <span class="keyword">case</span> <span class="keyword">contains</span> <span class="keyword">the</span> <span class="keyword">string</span> F.</span><br></pre></td></tr></table></figure></p><p>Output<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> <span class="keyword">each</span> test <span class="keyword">case</span>, output one <span class="type">line</span> containing <span class="keyword">Case</span> #x: y, <span class="keyword">where</span> x <span class="keyword">is</span> the test <span class="keyword">case</span> number (starting <span class="keyword">from</span> <span class="number">1</span>) <span class="keyword">and</span> y <span class="keyword">is</span> the minimum number <span class="keyword">of</span> operations that are required such that <span class="keyword">each</span> letter <span class="keyword">in</span> string S <span class="keyword">after</span> applying the operations, <span class="keyword">is</span> one <span class="keyword">of</span> the characters <span class="keyword">in</span> string F.</span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008da461#problem" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008da461#problem</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 遍历</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一题就是灌水题，非常简单.　要求找到将字符串中的字符全部变为给定的字符集中字符，求最小的变换次数，字符 <code>a</code> 转换到字符 <code>b</code> 有两种转换方法, 要么递增,要么递减翻转. $minstep = \min(|a-b|,26 - |a-b|)$,我们首先统计字符串 $s$ 中每种字符的个数, 然后对 $s$ 中的每种字符在字符集中找到最小的变换步数的目标字符 $c$ 即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(CN)$,其中 $M$ 为字符集中字符的个数。</li><li>空间复杂度: $O(C)$,其中 $C = 26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> src;</span><br><span class="line">    <span class="built_in">string</span> target;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;src;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;target;  </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : src) cnt[c - <span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : target) &#123;</span><br><span class="line">            curr = min(curr, <span class="built_in">abs</span>(<span class="string">'a'</span> + i - c));</span><br><span class="line">            curr = min(curr, <span class="number">26</span> - <span class="built_in">abs</span>(<span class="string">'a'</span> + i - c));</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="keyword">long</span> <span class="keyword">long</span>)curr * cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="Painter"><a href="#Painter" class="headerlink" title="Painter"></a>Painter</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/12/01/CoIOBGxR7zY4P3U.png" alt></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9a88" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9a88</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法或者<code>dfs</code></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常有趣,感觉跟某个力扣的某个题非常像,题意是说每种颜色可能有红黄蓝三种基本颜色组合, 每次涂画时可以选择一个区间　$[L,R]$ 涂上一种基本色, 给定的区间颜色分布,找到最少的涂画次数.</li><li>贪心算法, 我们设 $dp[i]$ 表示涂画前 $i$ 个颜色时所需要的涂画的最小步数, 我们在画 第 $i+1$ 个颜色时我们应该如何选择呢:</li></ol><ul><li>按照贪心算法进行选择颜色, 假设第 $i$ 个颜色的基色包括 $i+1$ 个颜色使用的所有基色, 那么我们可以知道在画第 $i$ 个颜色时的基色时 我们肯定可以将 $i+1$ 个颜色的基色也包含进去,因此 $dp[i+1] = dp[i]$, 我们举例如下:<ul><li>我们假设第 $i$ 个颜色为 $G$, 第 $i+1$ 个颜色为 $P$, 则此时我们假设 $i$ 中的三种基色最后涂画时的区间分布分别为 $[L_r,i],[L_g,i],[L_b,i]$, 我们可以知道按照贪心原则我们可以将以上 $red$, $blue$ 的区间向由扩展一个位置,则此时三种基色的区间分别为 $[L_r,i+1],[L_g,i],[L_b,i+1]$, 此时即可同时满足第 $i$ 个颜色与 第 $i+1$ 个颜色.</li></ul></li><li>假设第 $i$ 个颜色的基色不能包含第 $i+1$ 个颜色使用的所有基色时,则此时我们只需要找到第 $i+1$ 个颜色使用了与第 $i$ 个颜色有哪些不同的基色.此时递推公式为 $dp[i+1] = dp[i] + diff(i,i+1)$<br>实际处理中我们对每种颜色进行二进制编码, 我们用 $mask[i]$ 表示第 $i$ 个颜色的二进制编码, $mask[i+1]$ 表示第 $i+1$ 个颜色的二进制编码,则此时我们可以知道递推公式为 $dp[i+1] = dp[i] + count((mask[i]|mask[i]) \oplus maks[i])$</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$,其中 $N$ 为字符串的长度.</li><li>空间复杂度分析: 空间复杂度为 $O(N)$,其中 $N$ 为字符串的长度.</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Red + Yellow = Orange 110</span></span><br><span class="line"><span class="comment">Red + Blue = Purple   101</span></span><br><span class="line"><span class="comment">Yellow + Blue = Green 011</span></span><br><span class="line"><span class="comment">Red + Yellow + Blue = Gray 111</span></span><br><span class="line"><span class="comment">U = Uncolored 000</span></span><br><span class="line"><span class="comment">R = Red       100</span></span><br><span class="line"><span class="comment">Y = Yellow    010</span></span><br><span class="line"><span class="comment">B = Blue      001</span></span><br><span class="line"><span class="comment">O = Orange    110</span></span><br><span class="line"><span class="comment">P = Purple    101</span></span><br><span class="line"><span class="comment">G = Green     011</span></span><br><span class="line"><span class="comment">A = Gray      111</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*ROAOR 3</span></span><br><span class="line"><span class="comment">  12331 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        x = x&amp;(x<span class="number">-1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; dict = &#123;<span class="string">'U'</span>,<span class="string">'R'</span>,<span class="string">'Y'</span>,<span class="string">'B'</span>,<span class="string">'O'</span>,<span class="string">'P'</span>,<span class="string">'G'</span>,<span class="string">'A'</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">        cnt[dict[i]] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = count(cnt[s[<span class="number">0</span>]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = cnt[s[i]];</span><br><span class="line">        <span class="keyword">int</span> prev = cnt[s[i - <span class="number">1</span>]];</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + count(curr|prev) - count(prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Silly-Substitutions"><a href="#Silly-Substitutions" class="headerlink" title="Silly Substitutions"></a>Silly Substitutions</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>You are given a string S of length N which consists of digits 0-9. You do the following operations on the string in the order given.<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Find all <span class="keyword">the</span> substrings <span class="number">01</span> <span class="keyword">and</span> <span class="built_in">replace</span> <span class="keyword">each</span> <span class="keyword">of</span> them <span class="keyword">with</span> <span class="number">2.</span></span><br><span class="line">Find all <span class="keyword">the</span> substrings <span class="number">12</span> <span class="keyword">and</span> <span class="built_in">replace</span> <span class="keyword">each</span> <span class="keyword">of</span> them <span class="keyword">with</span> <span class="number">3.</span></span><br><span class="line">Find all <span class="keyword">the</span> substrings <span class="number">23</span> <span class="keyword">and</span> <span class="built_in">replace</span> <span class="keyword">each</span> <span class="keyword">of</span> them <span class="keyword">with</span> <span class="number">4.</span></span><br><span class="line">Find all <span class="keyword">the</span> substrings <span class="number">34</span> <span class="keyword">and</span> <span class="built_in">replace</span> <span class="keyword">each</span> <span class="keyword">of</span> them <span class="keyword">with</span> <span class="number">5.</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><br>Find all the substrings 89 and replace each of them with 0.<br>Find all the substrings 90 and replace each of them with 1.<br>You repeat this process in the same given order until none of the above operations change the string. For example, if S is 12 then we do not stop at operation 1 since it does not affect the string but perform operation 2 and change the string to 3. We can see that the string does not change further no matter how many times we repeat the above process.</p><p>Your task is to find how the final string will look like for the given S.</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d94f5" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d94f5</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 双链表</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目还是非常不错的，我们首先将字符串用双链表来表示出来．我们首先将双链表中所有可能合并的字符串的头节点全部存储在10个集合中,比如我们知道目前双链表如下:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>此时我们知道可能合并的字符串分别为:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line"><span class="number">3</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>我们会存储$0,1,2,3$ 所在的头节点.</li><li>我们依次遍历所有可能合并的组合 $01,12,23,34,45,56,…,90$等等.我们每次取出可以合并的数字组合时,每次合并时可能会产生新的组合,我们将新的可以合并的组合再加入到集合中,比如以下举例:<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...a-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;b...</span><br></pre></td></tr></table></figure>我们将 $01$ 进行合并后生成 $a2b$, 此时我们首先对双链表进行节点的删除与插入,同时对新生成的数字组合判断是否可以构成待消除的组合,如果含有可以消除的组合,则我们将其插入到集合中.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(CN)$,其中 $N$ 为字符串的长度, 我们每次 $10$ 次循环依次判断从 $01 \cdots 90$的消除组合，每次消除时都能消除一个字符，最多需要 $O(10N)$ 的时间复杂度．</li><li>空间复杂度为 $O(N)$,其中 $N$ 为字符串的长度.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">T val;</span><br><span class="line">    ListNode * prev;</span><br><span class="line">    ListNode * next;</span><br><span class="line">    ListNode(T val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> ListNode&lt;T&gt; * insert(ListNode&lt;T&gt; * curr, T val) &#123;</span><br><span class="line">    ListNode&lt;T&gt; * node = <span class="keyword">new</span> ListNode&lt;T&gt;(val);</span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;next)&#123;</span><br><span class="line">        node-&gt;next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curr) &#123;</span><br><span class="line">        curr-&gt;next = node;</span><br><span class="line">        node-&gt;prev = curr;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">   <span class="built_in">string</span> s;</span><br><span class="line">   <span class="built_in">string</span> ans;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt(<span class="number">12</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) nxt[i] = (i+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">   nxt[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">   nxt[<span class="number">11</span>] = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* link list*/</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;ListNode&lt;<span class="keyword">int</span>&gt; *&gt;&gt; arr(<span class="number">10</span>);</span><br><span class="line">   ListNode&lt;<span class="keyword">int</span>&gt; * head = <span class="keyword">new</span> ListNode&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">   insert(head,<span class="number">11</span>);</span><br><span class="line">   ListNode&lt;<span class="keyword">int</span>&gt; * tail = head;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">       tail = insert(tail, c - <span class="string">'0'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(ListNode&lt;<span class="keyword">int</span>&gt; * node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">       <span class="keyword">if</span>(node-&gt;next &amp;&amp; nxt[node-&gt;val] == node-&gt;next-&gt;val)&#123;</span><br><span class="line">           arr[node-&gt;val].insert(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* we remove each key and merge*/</span> </span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">bool</span> rflag = <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">           rflag = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">auto</span> t : arr[i])&#123;</span><br><span class="line">               ListNode&lt;<span class="keyword">int</span>&gt; * curr = <span class="keyword">new</span> ListNode&lt;<span class="keyword">int</span>&gt;((nxt[t-&gt;val] + <span class="number">1</span>)%<span class="number">10</span>);</span><br><span class="line">               ListNode&lt;<span class="keyword">int</span>&gt; * prev = t-&gt;prev;</span><br><span class="line">               ListNode&lt;<span class="keyword">int</span>&gt; * next = t-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*remove key node*/</span></span><br><span class="line">               <span class="keyword">if</span>(nxt[prev-&gt;val] == t-&gt;val)&#123;</span><br><span class="line">                   arr[prev-&gt;val].erase(prev);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(nxt[t-&gt;next-&gt;val] == next-&gt;val)&#123;</span><br><span class="line">                   arr[t-&gt;next-&gt;val].erase(t-&gt;next);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*merge new key*/</span></span><br><span class="line">               prev-&gt;next = curr;</span><br><span class="line">               curr-&gt;prev = prev;</span><br><span class="line">               curr-&gt;next = next;</span><br><span class="line">               next-&gt;prev = curr;</span><br><span class="line">               <span class="keyword">if</span>(nxt[prev-&gt;val] == curr-&gt;val)&#123;</span><br><span class="line">                   arr[prev-&gt;val].insert(prev);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(nxt[curr-&gt;val] == next-&gt;val)&#123;</span><br><span class="line">                   arr[curr-&gt;val].insert(curr);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">delete</span> t-&gt;next;</span><br><span class="line">               <span class="keyword">delete</span> t;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">           arr[i].clear();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!rflag) <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(ListNode&lt;<span class="keyword">int</span>&gt; * node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">       <span class="keyword">if</span>(node-&gt;val &gt;= <span class="number">0</span> &amp;&amp; node-&gt;val &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">           ans.push_back(node-&gt;val + <span class="string">'0'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="Dependent-Events"><a href="#Dependent-Events" class="headerlink" title="Dependent Events"></a>Dependent Events</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are N events, numbered <span class="number">1</span> through N. The probability <span class="keyword">of</span> occurrence <span class="keyword">of</span> <span class="keyword">each</span> <span class="keyword">event</span> depends upon the occurrence <span class="keyword">of</span> exactly one other <span class="keyword">event</span> called the parent <span class="keyword">event</span>, <span class="keyword">except</span> <span class="keyword">event</span> <span class="number">1</span>, which <span class="keyword">is</span> an independent <span class="keyword">event</span>. <span class="keyword">In</span> other words, <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">event</span> <span class="keyword">from</span> <span class="number">2</span> <span class="keyword">to</span> N, <span class="number">3</span> values are given: Pi denoting the parent <span class="keyword">event</span> <span class="keyword">of</span> <span class="keyword">event</span> i, Ai denoting the probability <span class="keyword">of</span> occurrence <span class="keyword">of</span> <span class="keyword">event</span> i <span class="keyword">if</span> its parent <span class="keyword">event</span> occurs, <span class="keyword">and</span> Bi denoting the probability <span class="keyword">of</span> occurrence <span class="keyword">of</span> <span class="keyword">event</span> i <span class="keyword">if</span> its parent <span class="keyword">event</span> does <span class="keyword">not</span> occur. <span class="keyword">For</span> <span class="keyword">event</span> <span class="number">1</span>, its probability <span class="keyword">of</span> occurrence K <span class="keyword">is</span> given. There are Q queries that we want <span class="keyword">to</span> answer. <span class="keyword">Each</span> query consists <span class="keyword">of</span> <span class="number">2</span> <span class="keyword">distinct</span> events, uj <span class="keyword">and</span> vj, <span class="keyword">and</span> you need <span class="keyword">to</span> find the probability that both events uj <span class="keyword">and</span> vj have occurred.</span><br></pre></td></tr></table></figure><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9970" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9970</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目太难了，不会．</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kickstart-2021-round-H&quot;&gt;&lt;a href=&quot;#kickstart-2021-round-H&quot; class=&quot;headerlink&quot; title=&quot;kickstart 2021 round  H&quot;&gt;&lt;/a&gt;kickstart 2021 round  H&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kickstart&lt;/code&gt;的题目一向质量高,并且难度非常大，感觉基本上是校招面试题中难度最大的题目了，感觉力扣的难度弱爆了. 前三题感觉基本上只需要基本的数学技巧和数据结构的基本知识就可以做出来，最后一题真心是达到&lt;code&gt;ACM&lt;/code&gt;的入门难度，还是挺难的题目。第四题花了好长时间才能弄懂题解.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Weekly Contest 267</title>
    <link href="http://yoursite.com/2021/11/15/344/"/>
    <id>http://yoursite.com/2021/11/15/344/</id>
    <published>2021-11-15T03:21:04.506Z</published>
    <updated>2021-11-15T04:00:06.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-267"><a href="#leetcode-contest-267" class="headerlink" title="leetcode contest 267"></a>leetcode contest 267</h1><p>最后一题果真没有区分度,基本上都做出来了,就是一个简单集合合并的问题.</p><h3 id="2073-买票需要的时间"><a href="#2073-买票需要的时间" class="headerlink" title="2073. 买票需要的时间"></a>2073. 买票需要的时间</h3><p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 最前方 ，第 <code>(n - 1)</code> 人站在队伍 最后方 。</p><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p><a id="more"></a><p>每个人买票都需要用掉 恰好 <code>1</code> 秒 。一个人 一次只能买一张票 ，如果需要购买更多票，他必须走到  队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 离开 队伍。</p><p>返回位于位置 <code>k</code>（下标从 <code>0</code> 开始）的人完成买票需要的时间（以秒为单位）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释： </span><br><span class="line">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>] 。</span><br><span class="line">- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>] 。</span><br><span class="line">位置 <span class="number">2</span> 的人成功买到 <span class="number">2</span> 张票，用掉 <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span> 秒。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：</span><br><span class="line">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] 。</span><br><span class="line">- 接下来的 <span class="number">4</span> 轮，只有位置 <span class="number">0</span> 的人在买票。</span><br><span class="line">位置 <span class="number">0</span> 的人成功买到 <span class="number">5</span> 张票，用掉 <span class="number">4</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">8</span> 秒。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == tickets.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= tickets[i] &lt;= 100</code></li><li><code>0 &lt;= k &lt; n</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/time-needed-to-buy-tickets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/time-needed-to-buy-tickets</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 模拟队列或者数学问题均可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接模拟即可实现所有的排队完成.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(K \times N)$,其中 $N$ 为数组的长度。</li><li>空间复杂度: $O(N)$,其中 $C = 26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeRequiredToBuy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tickets, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = tickets.size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            qu.push(make_pair(tickets[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            ans++;</span><br><span class="line">            curr.first--;</span><br><span class="line">            <span class="keyword">if</span>(curr.first &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                qu.push(curr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr.second == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2074-反转偶数长度组的节点"><a href="#2074-反转偶数长度组的节点" class="headerlink" title="2074. 反转偶数长度组的节点"></a>2074. 反转偶数长度组的节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 <code>head</code> 。</p><p>链表中的节点 按顺序 划分成若干 非空 组，这些非空组的长度构成一个自然数序列<code>（1, 2, 3, 4, ...）</code>。一个组的 长度 就是组中分配到的节点数目。换句话说：</p><ul><li>节点 1 分配给第一组</li><li>节点 2 和 3 分配给第二组</li><li>节点 4、5 和 6 分配给第三组，以此类推</li><li>注意，最后一组的长度可能小于或者等于 1 + 倒数第二组的长度 。</li></ul><p>反转 每个 偶数 长度组中的节点，并返回修改后链表的头节点 <code>head</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">解释：</span><br><span class="line">- 第一组长度为 <span class="number">1</span> ，奇数，没有发生反转。</span><br><span class="line">- 第二组长度为 <span class="number">2</span> ，偶数，节点反转。</span><br><span class="line">- 第三组长度为 <span class="number">3</span> ，奇数，没有发生反转。</span><br><span class="line">- 最后一组长度为 <span class="number">4</span> ，偶数，节点反转。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">- 第一组长度为 <span class="number">1</span> ，没有发生反转。</span><br><span class="line">- 第二组长度为 <span class="number">2</span> ，节点反转。</span><br><span class="line">- 最后一组长度为 <span class="number">1</span> ，没有发生反转。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：</span><br><span class="line">- 第一组长度为 <span class="number">1</span> ，没有发生反转。</span><br><span class="line">- 最后一组长度为 <span class="number">1</span> ，没有发生反转。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">8</span>]</span><br><span class="line">解释：只有一个长度为 <span class="number">1</span> 的组，没有发生反转。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表中节点数目范围是 <code>[1, 105]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 链表转数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目本身比较奇葩的问题，真心不如转换成数组，然后进行翻转，题目本上就变得非常简单.我们将链表转换为数组，然后按照题目要求进行分组翻转，然后再重建链表即可，比较坑的一点在于：</li></ol><ul><li>特别需要注意最后一组的长度可能为偶数,此时我们需要进行翻转.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$,其中 $N$ 为链表的长度.</li><li>空间复杂度分析: 空间复杂度为 $O(N)$,其中 $N$ 为链表的长度.</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseEvenLengthGroups</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(ListNode * node = head; node; node = node-&gt;next)&#123;</span><br><span class="line">            arr.emplace_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; n &gt; <span class="number">0</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = (i<span class="number">-1</span>)*i/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> r = min((<span class="keyword">int</span>)arr.size(),(i+<span class="number">1</span>)*i/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>((r - l)%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                reverse(arr.begin() + l,arr.begin() + r);</span><br><span class="line">            &#125;</span><br><span class="line">            n -= r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * newhead = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode * curr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;           </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                curr = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">                newhead = curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr-&gt;next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2075-解码斜向换位密码"><a href="#2075-解码斜向换位密码" class="headerlink" title="2075. 解码斜向换位密码"></a>2075. 解码斜向换位密码</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>字符串 <code>originalText</code> 使用 斜向换位密码 ，经由 行数固定 为 rows 的矩阵辅助，加密得到一个字符串 <code>encodedText</code> 。</p><p><code>originalText</code> 先按从左上到右下的方式放置到矩阵中。</p><p>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 <code>originalText</code> 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 ‘ ‘ 进行填充。矩阵的列数需满足：用 <code>originalText</code> 填充之后，最右侧列 不为空 。</p><p>接着按行将字符附加到矩阵中，构造 <code>encodedText</code> 。</p><p>先把蓝色单元格中的字符附加到 <code>encodedText</code> 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。</p><p>例如，如果 <code>originalText = &quot;cipher&quot;</code> 且 <code>rows = 3</code> ，那么我们可以按下述方法将其编码：</p><p>蓝色箭头标识 <code>originalText</code> 是如何放入矩阵中的，红色箭头标识形成 <code>encodedText</code> 的顺序。在上述例子中，<code>encodedText = &quot;ch   ie   pr&quot;</code>。</p><p>给你编码后的字符串 encodedText 和矩阵的行数 rows ，返回源字符串 originalText 。</p><p>注意：<code>originalText</code> 不 含任何尾随空格 ‘ ‘ 。生成的测试用例满足 仅存在一个 可能的 <code>originalText</code> 。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">encodedText</span> = <span class="string">"ch   ie   pr"</span>, <span class="attr">rows</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"cipher"</span></span><br><span class="line">解释：此示例与问题描述中的例子相同。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：encodedText = <span class="string">"iveo    eed   l te   olc"</span>, rows = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"i love leetcode"</span></span><br><span class="line">解释：上图标识用于编码 <span class="keyword">originalText </span>的矩阵。 </span><br><span class="line">蓝色箭头展示如何从 encodedText 找到 <span class="keyword">originalText </span>。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：encodedText = <span class="string">"coding"</span>, rows = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"coding"</span></span><br><span class="line">解释：由于只有 <span class="number">1</span> 行，所以 originalText 和 encodedText 是相同的。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">encodedText</span> = <span class="string">" b  ac"</span>, <span class="attr">rows</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="string">" abc"</span></span><br><span class="line">解释：originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>0 &lt;= encodedText.length &lt;= 106</code></li><li><code>encodedText</code> 仅由小写英文字母和 ‘ ‘ 组成</li><li><code>encodedText</code> 是对某个 不含 尾随空格的 <code>originalText</code> 的一个有效编码</li><li><code>1 &lt;= rows &lt;= 1000</code></li><li>生成的测试用例满足 仅存在一个 可能的 <code>originalText</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/decode-the-slanted-ciphertext" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-the-slanted-ciphertext</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 对字符串进行还原即可</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>少点这种奇奇怪怪的题目,还是能够多一点思考和智力的题目,题目本身感觉非常怪异,题目本省其实也比较简答.我们首先可以确定矩阵的列数为 $cols = \frac{n}{rows}$,然后我们就可以知道 $originalText$ 的第 $i$ 个字符对应矩阵的位置坐标为 $(i/cols,i\%cols)$,我们还原矩阵后,就按照斜行的访问方式还原原始字符串,最终需要去掉字符串末尾的空格.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$,其中 $N$ 为字符串的个数．</li><li>空间复杂度为 $O(N)$,其中 $N$ 为字符串的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeCiphertext</span><span class="params">(<span class="built_in">string</span> encodedText, <span class="keyword">int</span> rows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = encodedText.size();</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> cols = n/rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; mat(rows,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(cols,<span class="string">'#'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            mat[i/cols][i%cols] = encodedText[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cols; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = i;</span><br><span class="line">            <span class="keyword">while</span>(x &lt; rows &amp;&amp; y &lt; cols &amp;&amp; mat[x][y] != <span class="string">'#'</span>)&#123;</span><br><span class="line">                ans.push_back(mat[x][y]);</span><br><span class="line">                x++;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ans.size(); i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.back() == <span class="string">' '</span>) ans.pop_back();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2076-处理含限制条件的好友请求"><a href="#2076-处理含限制条件的好友请求" class="headerlink" title="2076. 处理含限制条件的好友请求"></a>2076. 处理含限制条件的好友请求</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code> ，表示网络上的用户数目。每个用户按从 <code>0</code> 到 <code>n - 1</code>进行编号。</p><p>给你一个下标从 0 开始的二维整数数组 <code>restrictions</code> ，其中<code>restrictions[i] = [xi, yi]</code> 意味着用户 <code>xi</code> 和用户 <code>yi</code> 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。</p><p>最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 <code>requests</code> 表示好友请求的列表，其中 <code>requests[j] = [uj, vj]</code>是用户 <code>uj</code>和用户 vj 之间的一条好友请求。</p><p>如果<code>uj</code> 和 <code>vj</code> 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，<code>requests[j]</code> 会在 <code>requests[j + 1]</code>前）。一旦请求成功，那么对所有未来的好友请求而言， <code>uj</code> 和 <code>vj</code> 将会 成为直接朋友 。</p><p>返回一个 布尔数组 <code>result</code> ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 <code>result[j]</code> 就是 <code>true</code> ；否则，为 <code>false</code> 。</p><p>注意：如果 <code>uj</code>和<code>vj</code> 已经是直接朋友，那么他们之间的请求将仍然 成功 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, restrictions = [[<span class="number">0</span>,<span class="number">1</span>]], requests = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：</span><br><span class="line">请求 <span class="number">0</span> ：用户 <span class="number">0</span> 和 用户 <span class="number">2</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">1</span> ：用户 <span class="number">2</span> 和 用户 <span class="number">1</span> 不能成为朋友，因为这会使 用户 <span class="number">0</span> 和 用户 <span class="number">1</span> 成为间接朋友 (<span class="number">1</span>-<span class="number">-2</span>-<span class="number">-0</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, restrictions = [[<span class="number">0</span>,<span class="number">1</span>]], requests = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：</span><br><span class="line">请求 <span class="number">0</span> ：用户 <span class="number">1</span> 和 用户 <span class="number">2</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">1</span> ：用户 <span class="number">0</span> 和 用户 <span class="number">2</span> 不能成为朋友，因为这会使 用户 <span class="number">0</span> 和 用户 <span class="number">1</span> 成为间接朋友 (<span class="number">0</span>-<span class="number">-2</span>-<span class="number">-1</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, restrictions = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]], requests = [[<span class="number">0</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：</span><br><span class="line">请求 <span class="number">0</span> ：用户 <span class="number">0</span> 和 用户 <span class="number">4</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">1</span> ：用户 <span class="number">1</span> 和 用户 <span class="number">2</span> 不能成为朋友，因为他们之间存在限制。</span><br><span class="line">请求 <span class="number">2</span> ：用户 <span class="number">3</span> 和 用户 <span class="number">1</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">3</span> ：用户 <span class="number">3</span> 和 用户 <span class="number">4</span> 不能成为朋友，因为这会使 用户 <span class="number">0</span> 和 用户 <span class="number">1</span> 成为间接朋友 (<span class="number">0</span>-<span class="number">-4</span>-<span class="number">-3</span>-<span class="number">-1</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>0 &lt;= restrictions.length &lt;= 1000</code></li><li><code>restrictions[i].length == 2</code></li><li><code>0 &lt;= xi, yi &lt;= n - 1</code></li><li><code>xi != yi</code></li><li><code>1 &lt;= requests.length &lt;= 1000</code></li><li><code>requests[j].length == 2</code></li><li><code>0 &lt;= uj, vj &lt;= n - 1</code></li><li><code>uj != vj</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/process-restricted-friend-requests" target="_blank" rel="noopener">https://leetcode-cn.com/problems/process-restricted-friend-requests</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 集合</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目可以算是中等题目．难点在于如何判断两个人是否通过朋友圈链接合法性,我们可以利用集合的特性,如果两个人 $x,y$ 不能成为朋友,我们只需要判断这两个人是否在同一个集合中即可.</li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(mn \cdot \alpha(n))$，其中 mm 是数组 $\textit{restrictions}$ 的长度，$\alpha(\cdot)$ 是反阿克曼函数，表示在路径压缩和按秩合并优化下的并查集的单次操作时间复杂度。</li><li>空间复杂度分析: $O(n)$，即为并查集需要使用的空间.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x] == f[y]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">        f[x1] = y1;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; friendRequests(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; restrictions, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requests) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = restrictions.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requests.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = requests[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = requests[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> fx = find(f,x);</span><br><span class="line">            <span class="keyword">int</span> fy = find(f,y);</span><br><span class="line">            <span class="keyword">if</span>(fx == fy)&#123;</span><br><span class="line">                ans.push_back(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> fa = find(f,restrictions[j][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> fb = find(f,restrictions[j][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>((fa == fx &amp;&amp; fb == fy) || (fa == fy &amp;&amp; fb == fx))&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                uni(f,x,y);</span><br><span class="line">                ans.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-267&quot;&gt;&lt;a href=&quot;#leetcode-contest-267&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 267&quot;&gt;&lt;/a&gt;leetcode contest 267&lt;/h1&gt;&lt;p&gt;最后一题果真没有区分度,基本上都做出来了,就是一个简单集合合并的问题.&lt;/p&gt;&lt;h3 id=&quot;2073-买票需要的时间&quot;&gt;&lt;a href=&quot;#2073-买票需要的时间&quot; class=&quot;headerlink&quot; title=&quot;2073. 买票需要的时间&quot;&gt;&lt;/a&gt;2073. 买票需要的时间&lt;/h3&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个人前来排队买票，其中第 &lt;code&gt;0&lt;/code&gt; 人站在队伍 最前方 ，第 &lt;code&gt;(n - 1)&lt;/code&gt; 人站在队伍 最后方 。&lt;/p&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;tickets&lt;/code&gt; ，数组长度为 &lt;code&gt;n&lt;/code&gt; ，其中第 &lt;code&gt;i&lt;/code&gt; 人想要购买的票数为 &lt;code&gt;tickets[i]&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 65</title>
    <link href="http://yoursite.com/2021/11/14/343/"/>
    <id>http://yoursite.com/2021/11/14/343/</id>
    <published>2021-11-14T15:30:25.886Z</published>
    <updated>2021-11-15T01:45:37.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-65"><a href="#leetcode-biweekly-contest-65" class="headerlink" title="leetcode biweekly contest 65"></a>leetcode biweekly contest 65</h1><p>双周赛的难度还是挺大的,</p><h3 id="5910-检查两个字符串是否几乎相等"><a href="#5910-检查两个字符串是否几乎相等" class="headerlink" title="5910. 检查两个字符串是否几乎相等"></a>5910. 检查两个字符串是否几乎相等</h3><p>如果两个字符串 <code>word1</code> 和 <code>word2</code> 中从 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 每一个字母出现频率之差都 不超过 3 ，那么我们称这两个字符串 <code>word1</code> 和 <code>word2</code> 几乎相等 。</p><a id="more"></a><p>给你两个长度都为 <code>n</code> 的字符串 <code>word1</code> 和 <code>word2</code> ，如果 <code>word1</code> 和 <code>word2</code> 几乎相等 ，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>一个字母 <code>x</code> 的出现 频率 指的是它在字符串中出现的次数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"aaaa"</span>, word2 = <span class="string">"bccb"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：字符串 <span class="string">"aaaa"</span> 中有 <span class="number">4</span> 个 'a' ，但是 <span class="string">"bccb"</span> 中有 <span class="number">0</span> 个 'a' 。</span><br><span class="line">两者之差为 <span class="number">4</span> ，大于上限 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"abcdeef"</span>, word2 = <span class="string">"abaaacc"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：word1 和 word2 中每个字母出现频率之差至多为 <span class="number">3</span> ：</span><br><span class="line">- 'a' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">4</span> 次，差为 <span class="number">3</span> 。</span><br><span class="line">- 'b' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">1</span> 次，差为 <span class="number">0</span> 。</span><br><span class="line">- 'c' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">2</span> 次，差为 <span class="number">1</span> 。</span><br><span class="line">- 'd' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">1</span> 。</span><br><span class="line">- 'e' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">2</span> 。</span><br><span class="line">- 'f' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"cccddabba"</span>, word2 = <span class="string">"babababab"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：word1 和 word2 中每个字母出现频率之差至多为 <span class="number">3</span> ：</span><br><span class="line">- 'a' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">4</span> 次，差为 <span class="number">2</span> 。</span><br><span class="line">- 'b' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">5</span> 次，差为 <span class="number">3</span> 。</span><br><span class="line">- 'c' 在 word1 中出现了 <span class="number">3</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">3</span> 。</span><br><span class="line">- 'd' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == word1.length == word2.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>word1</code> 和 <code>word2</code> 都只包含小写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-whether-two-strings-are-almost-equivalent" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-whether-two-strings-are-almost-equivalent</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>统计两个字符串中所有字符的统计个数,然后检测每个字符的统计个数的差的绝对值.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串的长度。</li><li>空间复杂度: $O(C)$,其中 $C = 26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkAlmostEquivalent</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt1(<span class="number">26</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt2(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word1)&#123;</span><br><span class="line">            cnt1[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word2)&#123;</span><br><span class="line">            cnt2[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(cnt1[i] - cnt2[i]) &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5911-模拟行走机器人-II"><a href="#5911-模拟行走机器人-II" class="headerlink" title="5911. 模拟行走机器人 II"></a>5911. 模拟行走机器人 II</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个在 <code>XY</code> 平面上的 <code>width x height</code> 的网格图，左下角 的格子为 <code>(0, 0)</code> ，右上角 的格子为 <code>(width - 1, height - 1)</code> 。网格图中相邻格子为四个基本方向之一<code>（&quot;North&quot;，&quot;East&quot;，&quot;South&quot; 和 &quot;West&quot;）</code>。一个机器人 初始 在格子 <code>(0, 0)</code>，方向为 “East” 。</p><p>机器人可以根据指令移动指定的 步数 。每一步，它可以执行以下操作。</p><ul><li>沿着当前方向尝试 往前一步 。</li><li>如果机器人下一步将到达的格子 超出了边界 ，机器人会 逆时针 转 90 度，然后再尝试往前一步。</li><li>如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。</li></ul><p>请你实现 <code>Robot</code> 类：</p><ul><li><code>Robot(int width, int height)</code> 初始化一个 width x height 的网格图，机器人初始在 (0, 0) ，方向朝 “East” 。</li><li><code>void move(int num)</code> 给机器人下达前进 num 步的指令。</li><li><code>int[] getPos()</code> 返回机器人当前所处的格子位置，用一个长度为 2 的数组 [x, y] 表示。</li><li><code>String getDir()</code> 返回当前机器人的朝向，为 “North” ，”East” ，”South” 或者 “West” 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"Robot"</span>, <span class="string">"move"</span>, <span class="string">"move"</span>, <span class="string">"getPos"</span>, <span class="string">"getDir"</span>, <span class="string">"move"</span>, <span class="string">"move"</span>, <span class="string">"move"</span>, <span class="string">"getPos"</span>, <span class="string">"getDir"</span>]</span><br><span class="line">[[<span class="number">6</span>, <span class="number">3</span>], [<span class="number">2</span>], [<span class="number">2</span>], [], [], [<span class="number">2</span>], [<span class="number">1</span>], [<span class="number">4</span>], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, [<span class="number">4</span>, <span class="number">0</span>], <span class="string">"East"</span>, null, null, null, [<span class="number">1</span>, <span class="number">2</span>], <span class="string">"West"</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Robot robot = new Robot(<span class="number">6</span>, <span class="number">3</span>); <span class="comment">// 初始化网格图，机器人在 (0, 0) ，朝东。</span></span><br><span class="line">robot.move(<span class="number">2</span>);  <span class="comment">// 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。</span></span><br><span class="line">robot.move(<span class="number">2</span>);  <span class="comment">// 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。</span></span><br><span class="line">robot.getPos(); <span class="comment">// 返回 [4, 0]</span></span><br><span class="line">robot.getDir(); <span class="comment">// 返回 "East"</span></span><br><span class="line">robot.move(<span class="number">2</span>);  <span class="comment">// 朝东移动 1 步到达 (5, 0) ，并朝东。</span></span><br><span class="line">                <span class="comment">// 下一步继续往东移动将出界，所以逆时针转变方向朝北。</span></span><br><span class="line">                <span class="comment">// 然后，往北移动 1 步到达 (5, 1) ，并朝北。</span></span><br><span class="line">robot.move(<span class="number">1</span>);  <span class="comment">// 朝北移动 1 步到达 (5, 2) ，并朝 北 （不是朝西）。</span></span><br><span class="line">robot.move(<span class="number">4</span>);  <span class="comment">// 下一步继续往北移动将出界，所以逆时针转变方向朝西。</span></span><br><span class="line">                <span class="comment">// 然后，移动 4 步到 (1, 2) ，并朝西。</span></span><br><span class="line">robot.getPos(); <span class="comment">// 返回 [1, 2]</span></span><br><span class="line">robot.getDir(); <span class="comment">// 返回 "West"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= width, height &lt;= 100</code></li><li><code>1 &lt;= num &lt;= 105</code></li><li><code>move</code> ，<code>getPos</code> 和 <code>getDir</code> 总共 调用次数不超过 104 次。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/walking-robot-simulation-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/walking-robot-simulation-ii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>真心是个很蛋疼的题目, 我们仔细分析一下即可得知,机器人始终会在最外圈一直循环行走, 因此我们可以求出最外圈的坐标的数组及方向的数组, 机器人的移动实际等价于数组上的循环移动,因此就比较简单了,有两点比较坑的是:</li></ol><ul><li>每个拐角处的方向需要注意实际上在四个拐角处不会切换方向,在拐角处的下一个方块需要切换方向, 及这四个坐标方向会改变 $(1,0),(width-1,1),(widht-2,height-1),(0,height-2)$.</li><li>机器人起始的坐标和移动方向需要特别注意,当它下一次移动到 $(0,0)$ 坐标时的方向实际应该是向南.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $Robot$ 函数的时间复杂度为 $0(width \times height)$，$move,getPos，getDir$的时间复杂度均为 $O(1)$.</li><li>空间复杂度分析: 空间复杂度为$O(width \times height)$．</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Robot(<span class="keyword">int</span> width, <span class="keyword">int</span> height) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; width; ++i)&#123;</span><br><span class="line">            arr.push_back(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height; ++i)&#123;</span><br><span class="line">            arr.push_back(&#123;width<span class="number">-1</span>,i&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = width<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            arr.push_back(&#123;i,height<span class="number">-1</span>&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = height<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            arr.push_back(&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;curr = arr.size()<span class="number">-1</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        num = num%arr.size();</span><br><span class="line">        curr = (curr + num)%arr.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getPos() &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;arr[curr].first,arr[curr].second&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"East"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dirstr[arrd[curr]];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> curr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dirstr = &#123;<span class="string">"East"</span>,<span class="string">"North"</span>,<span class="string">"West"</span>,<span class="string">"South"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; arr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Robot object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Robot* obj = new Robot(width, height);</span></span><br><span class="line"><span class="comment"> * obj-&gt;move(num);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;getPos();</span></span><br><span class="line"><span class="comment"> * string param_3 = obj-&gt;getDir();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="5912-每一个查询的最大美丽值"><a href="#5912-每一个查询的最大美丽值" class="headerlink" title="5912. 每一个查询的最大美丽值"></a>5912. 每一个查询的最大美丽值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>items</code> ，其中 <code>items[i] = [pricei, beautyi]</code> 分别表示每一个物品的 价格 和 美丽值 。</p><p>同时给你一个下标从 <code>0</code> 开始的整数数组 <code>queries</code> 。对于每个查询 <code>queries[j]</code> ，你想求出价格小于等于 <code>queries[j]</code> 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为<code>0</code> 。</p><p>请你返回一个长度与 <code>queries</code> 相同的数组 <code>answer</code>，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>]], queries = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">- queries[<span class="number">0</span>]=<span class="number">1</span> ，[<span class="number">1</span>,<span class="number">2</span>] 是唯一价格 &lt;= <span class="number">1</span> 的物品。所以这个查询的答案为 <span class="number">2</span> 。</span><br><span class="line">- queries[<span class="number">1</span>]=<span class="number">2</span> ，符合条件的物品有 [<span class="number">1</span>,<span class="number">2</span>] 和 [<span class="number">2</span>,<span class="number">4</span>] 。</span><br><span class="line">  它们中的最大美丽值为 <span class="number">4</span> 。</span><br><span class="line">- queries[<span class="number">2</span>]=<span class="number">3</span> 和 queries[<span class="number">3</span>]=<span class="number">4</span> ，符合条件的物品都为 [<span class="number">1</span>,<span class="number">2</span>] ，[<span class="number">3</span>,<span class="number">2</span>] ，[<span class="number">2</span>,<span class="number">4</span>] 和 [<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">  它们中的最大美丽值为 <span class="number">5</span> 。</span><br><span class="line">- queries[<span class="number">4</span>]=<span class="number">5</span> 和 queries[<span class="number">5</span>]=<span class="number">6</span> ，所有物品都符合条件。</span><br><span class="line">  所以，答案为所有物品中的最大美丽值，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]], queries = [<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">每个物品的价格均为 <span class="number">1</span> ，所以我们选择最大美丽值 <span class="number">4</span> 。</span><br><span class="line">注意，多个物品可能有相同的价格和美丽值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="number">10</span>,<span class="number">1000</span>]], queries = [<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">没有物品的价格小于等于 <span class="number">5</span> ，所以没有物品可以选择。</span><br><span class="line">因此，查询的结果为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= items.length, queries.length &lt;= 105</code></li><li><code>items[i].length == 2</code></li><li><code>1 &lt;= pricei, beautyi, queries[j] &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/most-beautiful-item-for-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-beautiful-item-for-each-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找或者双指针</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>应该可以说是简单题目，我们首先将所有的物品按照价格进行排序，我们用 $prefix[i]$ 表示排序的物品中前 $i$ 个物品的最大美丽值. 我们每次进行查询 $x$ 时,我们找到物品价格小于等于 $x$ 的最大的索引 $j$, $prefix[j]$ 即为本次需要查询的结果.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O((m+n) \log n)$,其中 $n$ 为商品的个数, $m$ 为查询的此时．</li><li>空间复杂度为 $O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maximumBeauty(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; items, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = items.size();</span><br><span class="line">        sort(items.begin(),items.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                prefix[i] = items[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prefix[i] = max(prefix[i<span class="number">-1</span>], items[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(items[mid][<span class="number">0</span>] &lt;= queries[i])&#123;</span><br><span class="line">                    curr = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(prefix[curr]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5913-你可以安排的最多任务数目"><a href="#5913-你可以安排的最多任务数目" class="headerlink" title="5913. 你可以安排的最多任务数目"></a>5913. 你可以安排的最多任务数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 $n$ 个任务和 $m$ 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <code>0</code> 开始的整数数组 <code>tasks</code> 中，第 <code>i</code> 个任务需要 <code>tasks[i]</code> 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 <code>workers</code> 中，第 <code>j</code> 个工人的力量值为 <code>workers[j]</code> 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 <code>workers[j] &gt;= tasks[i]</code> ）。</p><p>除此以外，你还有 <code>pills</code> 个神奇药丸，可以给 一个工人的力量值 增加 <code>strength</code> 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。</p><p>给你下标从 <code>0</code> 开始的整数数组<code>tasks</code> 和 <code>workers</code> 以及两个整数 <code>pills</code> 和 <code>strength</code> ，请你返回 最多 有多少个任务可以被完成。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], workers = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>], pills = <span class="number">1</span>, strength = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">0</span> 号工人药丸。</span><br><span class="line">- <span class="number">0</span> 号工人完成任务 <span class="number">2</span>（<span class="number">0</span> + <span class="number">1</span> &gt;= <span class="number">1</span>）</span><br><span class="line">- <span class="number">1</span> 号工人完成任务 <span class="number">1</span>（<span class="number">3</span> &gt;= <span class="number">2</span>）</span><br><span class="line">- <span class="number">2</span> 号工人完成任务 <span class="number">0</span>（<span class="number">3</span> &gt;= <span class="number">3</span>）</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">5</span>,<span class="number">4</span>], workers = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], pills = <span class="number">1</span>, strength = <span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">0</span> 号工人药丸。</span><br><span class="line">- <span class="number">0</span> 号工人完成任务 <span class="number">0</span>（<span class="number">0</span> + <span class="number">5</span> &gt;= <span class="number">5</span>）</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">10</span>,<span class="number">15</span>,<span class="number">30</span>], workers = [<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>], pills = <span class="number">3</span>, strength = <span class="number">10</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">0</span> 号和 <span class="number">1</span> 号工人药丸。</span><br><span class="line">- <span class="number">0</span> 号工人完成任务 <span class="number">0</span>（<span class="number">0</span> + <span class="number">10</span> &gt;= <span class="number">10</span>）</span><br><span class="line">- <span class="number">1</span> 号工人完成任务 <span class="number">1</span>（<span class="number">10</span> + <span class="number">10</span> &gt;= <span class="number">15</span>）</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>], workers = [<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>], pills = <span class="number">1</span>, strength = <span class="number">5</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">2</span> 号工人药丸。</span><br><span class="line">- <span class="number">1</span> 号工人完成任务 <span class="number">0</span>（<span class="number">6</span> &gt;= <span class="number">5</span>）</span><br><span class="line">- <span class="number">2</span> 号工人完成任务 <span class="number">2</span>（<span class="number">4</span> + <span class="number">5</span> &gt;= <span class="number">8</span>）</span><br><span class="line">- <span class="number">4</span> 号工人完成任务 <span class="number">3</span>（<span class="number">6</span> &gt;= <span class="number">5</span>）</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == tasks.length</code></li><li><code>m == workers.length</code></li><li><code>1 &lt;= n, m &lt;= 5 * 104</code></li><li><code>0 &lt;= pills &lt;= m</code></li><li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找 + 贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们可以想到最优的解，肯定可以用二分查找找到最多可以完成多少个任务，重点是在于检测当前给定的条件下可以完成 $n$ 个任务. 首先我们想到一点的是,假设我们当前可以完全 $n$ 个人任务,那么根据贪心算法,可以知道我们一定是可以完成需要力量值最小的 $n$ 个任务.因此我们将任务按照所需要的力量值的大小进行排序,每次尝试是安排最强的 $x$ 个人完成前 $x$ 个任务.可以参考下官方题解，感觉写的非常清楚，证明也非常清晰．</li><li>我们如何检测给定条件下, 是否能够完成前 $n$ 个任务，需要一定的贪心策略．</li></ol><ul><li>当我们考虑当前任务值最大的任务时，此时我们的选择策略有贪心策略，能够不用药丸的情况下我们应该尽量避免使用药丸，因此我们应当从任务值最大的任务开始检测起：</li><li><ul><li>a. 要么直接选择当前力量值刚好能够大于等于这个任务的工人，此时我们有能够满足条件的工人，此时我们直接选择最小能够满足该任务的工人，避免使用药丸;</li></ul></li><li><ul><li>b. 要么选择一个工人吃一颗药丸后的力量值刚好能够大于等于这个任务.则此时我们应当选择满足条件下力量值最小的工人．<br>我们按照上述的贪心策略进行选择即可．</li></ul></li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(m \log m + n \log n + min(m,n) \times \log n\times log m)$, 其中 $m$ 表示任务的个数, $n$ 表示工人的数量.</li><li>空间复杂度分析: $O(n + \log n + \log m)$,其中 $m$ 表示任务的个数, $n$ 表示工人的数量.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTaskAssign</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tasks, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; workers, <span class="keyword">int</span> pills, <span class="keyword">int</span> strength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = tasks.size();</span><br><span class="line">        <span class="keyword">int</span> n = workers.size();</span><br><span class="line">        sort(tasks.begin(), tasks.end());</span><br><span class="line">        sort(workers.begin(), workers.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> x)-&gt;<span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> p = pills;</span><br><span class="line">            <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : workers) cnt.insert(v);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = cnt.lower_bound(tasks[i]);</span><br><span class="line">                <span class="keyword">if</span>(it != cnt.end())&#123;</span><br><span class="line">                    cnt.erase(it);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">auto</span> it1 = cnt.lower_bound(tasks[i] - strength);</span><br><span class="line">                    <span class="keyword">if</span>(it1 == cnt.end()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt.erase(it1);</span><br><span class="line">                    p--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = m;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-65&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-65&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 65&quot;&gt;&lt;/a&gt;leetcode biweekly contest 65&lt;/h1&gt;&lt;p&gt;双周赛的难度还是挺大的,&lt;/p&gt;&lt;h3 id=&quot;5910-检查两个字符串是否几乎相等&quot;&gt;&lt;a href=&quot;#5910-检查两个字符串是否几乎相等&quot; class=&quot;headerlink&quot; title=&quot;5910. 检查两个字符串是否几乎相等&quot;&gt;&lt;/a&gt;5910. 检查两个字符串是否几乎相等&lt;/h3&gt;&lt;p&gt;如果两个字符串 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt; 中从 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 到 &lt;code&gt;&amp;#39;z&amp;#39;&lt;/code&gt; 每一个字母出现频率之差都 不超过 3 ，那么我们称这两个字符串 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt; 几乎相等 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 266</title>
    <link href="http://yoursite.com/2021/11/07/342/"/>
    <id>http://yoursite.com/2021/11/07/342/</id>
    <published>2021-11-07T08:28:00.218Z</published>
    <updated>2021-11-09T15:47:16.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-266"><a href="#leetcode-contest-266" class="headerlink" title="leetcode contest 266"></a>leetcode contest 266</h1><p>今天周赛的题目比较简单，前三题基本上没有什么难度的题目，最后一题做法上想的太复杂了点，最后用一个简单的$BFS$ 搞定.</p><h3 id="5918-统计字符串中的元音子字符串"><a href="#5918-统计字符串中的元音子字符串" class="headerlink" title="5918. 统计字符串中的元音子字符串"></a>5918. 统计字符串中的元音子字符串</h3><p>子字符串 是字符串中的一个连续（非空）的字符序列。</p><p>元音子字符串 是 仅 由元音<code>（&#39;a&#39;、&#39;e&#39;、&#39;i&#39;、&#39;o&#39; 和 &#39;u&#39;）6</code>组成的一个子字符串，且必须包含 全部五种 元音。</p><a id="more"></a><p>给你一个字符串 word ，统计并返回 word 中 元音子字符串的数目 。</p><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"aeiouu"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：下面列出 <span class="built_in">word</span> 中的元音子字符串（斜体加粗部分）：</span><br><span class="line">- <span class="string">"aeiouu"</span></span><br><span class="line">- <span class="string">"aeiouu"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"unicornarihan"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="built_in">word</span> 中不含 <span class="number">5</span> 种元音，所以也不会存在元音子字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "cuaieuouac"</span><br><span class="line">输出：7</span><br><span class="line">解释：下面列出 word 中的元音子字符串（斜体加粗部分）：</span><br><span class="line">-<span class="ruby"> <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">word</span> = <span class="string">"bbaeixoubb"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：所有包含全部五种元音的子字符串都含有辅音，所以不存在元音子字符串。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= <span class="keyword">word</span>.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="keyword">word</span>` 仅由小写英文字母组成</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-266/problems/count-vowel-substrings-of-a-string/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  枚举</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 枚举每个子字符串，检测每个字符串是否满足元音要求。</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度: $O(N^<span class="number">3</span>)$,其中 $N$ 为字符串的长度。</span><br><span class="line">+ 空间复杂度: $O(<span class="number">1</span>)$。</span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="keyword">int</span> countVowelSubstrings(<span class="keyword">string</span> <span class="keyword">word</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        cnt.insert(<span class="string">'a'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'e'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'i'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'o'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'u'</span>);</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">for</span>(<span class="keyword">int</span> j = i + <span class="number">4</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">bool</span> <span class="built_in">isValid</span> = true;</span><br><span class="line">                unordered_set&lt;<span class="keyword">char</span>&gt; curr;</span><br><span class="line">                <span class="built_in">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++k)&#123;</span><br><span class="line">                    <span class="built_in">if</span>(!cnt.count(<span class="keyword">word</span>[k]))&#123;</span><br><span class="line">                        <span class="built_in">isValid</span> = false;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;<span class="built_in">else</span>&#123;</span><br><span class="line">                        curr.insert(<span class="keyword">word</span>[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">if</span>(<span class="built_in">isValid</span> &amp;&amp; curr.<span class="built_in">size</span>() == <span class="number">5</span>)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5919-所有子字符串中的元音"><a href="#5919-所有子字符串中的元音" class="headerlink" title="5919. 所有子字符串中的元音"></a>5919. 所有子字符串中的元音</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>word</code> ，返回 <code>word</code> 的所有子字符串中 元音的总数 ，元音是指 <code>&#39;a&#39;、&#39;e&#39;、&#39;i&#39;、&#39;o&#39;</code> 和 <code>&#39;u&#39;</code> 。</p><p>子字符串 是字符串中一个连续（非空）的字符序列。</p><p>注意：由于对 <code>word</code> 长度的限制比较宽松，答案可能超过有符号 <code>32</code> 位整数的范围。计算时需当心。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"aba"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">所有子字符串是：<span class="string">"a"</span>、<span class="string">"ab"</span>、<span class="string">"aba"</span>、<span class="string">"b"</span>、<span class="string">"ba"</span> 和 <span class="string">"a"</span> 。</span><br><span class="line">- <span class="string">"b"</span> 中有 <span class="number">0</span> 个元音</span><br><span class="line">- <span class="string">"a"</span>、<span class="string">"ab"</span>、<span class="string">"ba"</span> 和 <span class="string">"a"</span> 每个都有 <span class="number">1</span> 个元音</span><br><span class="line">- <span class="string">"aba"</span> 中有 <span class="number">2</span> 个元音</span><br><span class="line">因此，元音总数 = <span class="number">0</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"abc"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">所有子字符串是：<span class="string">"a"</span>、<span class="string">"ab"</span>、<span class="string">"abc"</span>、<span class="string">"b"</span>、<span class="string">"bc"</span> 和 <span class="string">"c"</span> 。</span><br><span class="line">- <span class="string">"a"</span>、<span class="string">"ab"</span> 和 <span class="string">"abc"</span> 每个都有 <span class="number">1</span> 个元音</span><br><span class="line">- <span class="string">"b"</span>、<span class="string">"bc"</span> 和 <span class="string">"c"</span> 每个都有 <span class="number">0</span> 个元音</span><br><span class="line">因此，元音总数 = <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">0</span> + <span class="number">0</span> + <span class="number">0</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"ltcd"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"ltcd"</span> 的子字符串均不含元音。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"noosabasboosa"</span></span><br><span class="line">输出：<span class="number">237</span></span><br><span class="line">解释：所有子字符串中共有 <span class="number">237</span> 个元音。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= word.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `word` 由小写英文字母组成</span><br><span class="line"></span><br><span class="line"><span class="comment">### 地址</span></span><br><span class="line"><span class="symbol">https:</span>/<span class="regexp">/leetcode-cn.com/contest</span><span class="regexp">/weekly-contest-266/problems</span><span class="regexp">/vowels-of-all-substrings/</span></span><br><span class="line"><span class="comment">### 题意</span></span><br><span class="line">&gt;  DP</span><br><span class="line"><span class="comment">### 思路</span></span><br><span class="line"><span class="number">1</span>. 题目为一个比较简单的动态规划,我们设 <span class="variable">$dp</span>[i]<span class="variable">$ </span>表示以字符串中第 <span class="variable">$i</span><span class="variable">$ </span>个元素为结尾的连续子字符串包含的元音字母. 则我们可以知道分为以下两种情况<span class="symbol">:</span></span><br><span class="line">+ 如果第 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个子母为非元音字母: 则我们知道以第 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个字母为结尾的字符中包含的原因字符刚好等于 <span class="variable">$dp</span>[i]<span class="variable">$,</span> 则此时可以知道 <span class="variable">$dp</span>[i+<span class="number">1</span>] = dp[i].</span><br><span class="line">+ 如果第 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个子母为元音字母: 则我们知道以 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>为结尾的字符串有 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个, 同时包含之前以 <span class="variable">$i</span><span class="variable">$ </span>为结尾的子字符串中的元音字母, 因此 <span class="variable">$dp</span>[i+<span class="number">1</span>] = dp[i] + i + <span class="number">1</span><span class="variable">$.</span></span><br><span class="line">总的子字符串中包含的元音字母的个数为 <span class="variable">$sum</span> = \sum<span class="number">_</span>&#123;i=<span class="number">0</span>&#125;^&#123;n-<span class="number">1</span>&#125;dp[i]<span class="variable">$.</span></span><br><span class="line"><span class="number">2</span>. 复杂度分析<span class="symbol">:</span></span><br><span class="line">+ 时间复杂度分析: 时间复杂度为 <span class="variable">$O</span>(N)<span class="variable">$.</span> 其中 <span class="variable">$N</span><span class="variable">$ </span>为字符串的长度.</span><br><span class="line">+ 空间复杂度分析: 空间复杂度为<span class="variable">$O</span>(N)<span class="variable">$,</span> 其中 <span class="variable">$N</span><span class="variable">$ </span>为字符串的长度．</span><br><span class="line"></span><br><span class="line"><span class="comment">### 代码</span></span><br><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    long long countVowels(string word) &#123;</span><br><span class="line">        int n = word.size();</span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;long long&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">        int curr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        unordered_set&lt;char&gt; cnt;</span><br><span class="line">        cnt.insert(<span class="string">'a'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'e'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'i'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'o'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'u'</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            if(cnt.count(word[i]))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i] + i + <span class="number">1</span>;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5920-分配给商店的最多商品的最小值"><a href="#5920-分配给商店的最多商品的最小值" class="headerlink" title="5920. 分配给商店的最多商品的最小值"></a>5920. 分配给商店的最多商品的最小值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 间零售商店。总共有 <code>m</code> 种产品，每种产品的数目用一个下标从 <code>0</code> 开始的整数数组 <code>quantities</code> 表示，其中 <code>quantities[i]</code> 表示第 <code>i</code> 种商品的数目。</p><p>你需要将 所有商品 分配到零售商店，并遵守这些规则：</p><ul><li>一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。</li><li>分配后，每间商店都会被分配一定数目的商品（可能为 <code>0</code> 件）。用 <code>x</code> 表示所有商店中+ 分配商品数目的最大值，你希望 <code>x</code> 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的最大值 。<br>请你返回最小的可能的 <code>x</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, quantities = [<span class="number">11</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释： 一种最优方案为：</span><br><span class="line">- <span class="number">11</span> 件种类为 <span class="number">0</span> 的商品被分配到前 <span class="number">4</span> 间商店，分配数目分别为：<span class="number">2</span>，<span class="number">3</span>，<span class="number">3</span>，<span class="number">3</span> 。</span><br><span class="line">- <span class="number">6</span> 件种类为 <span class="number">1</span> 的商品被分配到另外 <span class="number">2</span> 间商店，分配数目分别为：<span class="number">3</span>，<span class="number">3</span> 。</span><br><span class="line">分配给所有商店的最大商品数目为 max(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, quantities = [<span class="number">15</span>,<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一种最优方案为：</span><br><span class="line">- <span class="number">15</span> 件种类为 <span class="number">0</span> 的商品被分配到前 <span class="number">3</span> 间商店，分配数目为：<span class="number">5</span>，<span class="number">5</span>，<span class="number">5</span> 。</span><br><span class="line">- <span class="number">10</span> 件种类为 <span class="number">1</span> 的商品被分配到接下来 <span class="number">2</span> 间商店，数目为：<span class="number">5</span>，<span class="number">5</span> 。</span><br><span class="line">- <span class="number">10</span> 件种类为 <span class="number">2</span> 的商品被分配到最后 <span class="number">2</span> 间商店，数目为：<span class="number">5</span>，<span class="number">5</span> 。</span><br><span class="line">分配给所有商店的最大商品数目为 max(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>) = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, quantities = [<span class="number">100000</span>]</span><br><span class="line">输出：<span class="number">100000</span></span><br><span class="line">解释：唯一一种最优方案为：</span><br><span class="line">- 所有 <span class="number">100000</span> 件商品 <span class="number">0</span> 都分配到唯一的商店中。</span><br><span class="line">分配给所有商店的最大商品数目为 max(<span class="number">100000</span>) = <span class="number">100000</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == quantities.length</code></li><li><code>1 &lt;= m &lt;= n &lt;= 105</code></li><li><code>1 &lt;= quantities[i] &lt;= 105</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-convert-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-convert-number</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>如果直接来做,肯定比麻烦. 因为题目中要求每个零售店最多只能持有一种商品, 我们知道对于最大上限的$x$, 对于第 $i$ 个商品总量为 $quantities[i]$,我们知道最少需要配备 $\lfloor \frac{quantities[i] + x - 1}{x} \rfloor$ 个商店来分配该商品, 总共需要配备的商调的数目为 $\sum_{i=0}^{n-1}\lfloor \frac{quantities[i] + x - 1}{x} \rfloor$. 所以我们采用二分法测试 $x$,每次检测对于 $x$ 最少需要配备多少个商店来满足分配要求, 如果需要的商店的个数小于等于 $n$,则满足题目要求,否则我们需要增大 $x$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(M\log(\max(quantities)))$,其中 $M$ 为商品的个数, $MAX(quantities)$ 为商品的个数的最大值．</li><li>空间复杂度为 $O(1)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quantities,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : quantities)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curr += (v + val - <span class="number">1</span>)/val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr &lt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimizedMaximum</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quantities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = quantities.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = *max_element(quantities.begin(),quantities.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(n,quantities,mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5921-最大化一张图中的路径价值"><a href="#5921-最大化一张图中的路径价值" class="headerlink" title="5921. 最大化一张图中的路径价值"></a>5921. 最大化一张图中的路径价值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一张 无向 图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> （都包括）。同时给你一个下标从 <code>0</code> 开始的整数数组 <code>values</code> ，其中 <code>values[i]</code> 是第 <code>i</code> 个节点的 价值 。同时给你一个下标从 <code>0</code> 开始的二维整数数组 <code>edges</code> ，其中 <code>edges[j] = [uj, vj, timej]</code> 表示节点 <code>uj</code> 和 <code>vj</code> 之间有一条需要 <code>timej</code> 秒才能通过的无向边。最后，给你一个整数 <code>maxTime</code> 。</p><p>合法路径 指的是图中任意一条从节点 <code>0</code> 开始，最终回到节点<code>0</code>，且花费的总时间 不超过<code>maxTime</code> 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 价值 定义为路径中 不同节点 的价值 之和 （每个节点的价值 至多 算入价值总和中一次）。</p><p>请你返回一条合法路径的 最大 价值。</p><p>注意：每个节点 至多 有 四条 边与之相连。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">0</span>,<span class="number">32</span>,<span class="number">10</span>,<span class="number">43</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]], maxTime = <span class="number">49</span></span><br><span class="line">输出：<span class="number">75</span></span><br><span class="line">解释：</span><br><span class="line">一条可能的路径为：<span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">3</span> -&gt; <span class="number">0</span> 。总花费时间为 <span class="number">10</span> + <span class="number">10</span> + <span class="number">10</span> + <span class="number">10</span> = <span class="number">40</span> &lt;= <span class="number">49</span> 。</span><br><span class="line">访问过的节点为 <span class="number">0</span> ，<span class="number">1</span> 和 <span class="number">3</span> ，最大路径价值为 <span class="number">0</span> + <span class="number">32</span> + <span class="number">43</span> = <span class="number">75</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]], maxTime = <span class="number">30</span></span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">一条可能的路径为：<span class="number">0</span> -&gt; <span class="number">3</span> -&gt; <span class="number">0</span> 。总花费时间为 <span class="number">10</span> + <span class="number">10</span> = <span class="number">20</span> &lt;= <span class="number">30</span> 。</span><br><span class="line">访问过的节点为 <span class="number">0</span> 和 <span class="number">3</span> ，最大路径价值为 <span class="number">5</span> + <span class="number">20</span> = <span class="number">25</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">13</span>]], maxTime = <span class="number">50</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">一条可能的路径为：<span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> 。总花费时间为 <span class="number">10</span> + <span class="number">13</span> + <span class="number">13</span> + <span class="number">10</span> = <span class="number">46</span> &lt;= <span class="number">50</span> 。</span><br><span class="line">访问过的节点为 <span class="number">0</span> ，<span class="number">1</span> 和 <span class="number">3</span> ，最大路径价值为 <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], edges = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>]], maxTime = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">唯一一条路径为 <span class="number">0</span> 。总花费时间为 <span class="number">0</span> 。</span><br><span class="line">唯一访问过的节点为 <span class="number">0</span> ，最大路径价值为 <span class="number">0</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == values.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= values[i] &lt;= <span class="number">108</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= edges.length &lt;= <span class="number">2000</span>`</span><br><span class="line">+ `edges[j].length == <span class="number">3</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= uj &lt; vj &lt;= n - <span class="number">1</span>`</span><br><span class="line">+ `<span class="number">10</span> &lt;= timej, maxTime &lt;= <span class="number">100</span>`</span><br><span class="line">+ `[uj, vj]` 所有节点对 互不相同 。</span><br><span class="line">+ 每个节点至多有四条 边。</span><br><span class="line">+ 图可能不连通。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-266/problems/maximum-path-quality-of-a-graph/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  BFS+减枝或者DFS</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 题目中关键的提示在于`<span class="number">10</span> &lt;= timej, maxTime &lt;= <span class="number">100</span>`,这就意味着最大路径的节点最多不会超过 $<span class="number">10</span>$ 步,每个节点最多有 $<span class="number">4</span>$ 条边,实际意味着最多可能的路径选择空间在 $<span class="number">4</span>^<span class="number">10</span>$ 以内,因此这个数量级就决定了我们可以用暴力的 $DFS$ 或者 $BFS$ 来进行搜索,找到符合要求的最大路径即可.</span><br><span class="line"><span class="number">2.</span> 稍微麻烦的是需要涉及到减枝的优化：</span><br><span class="line">+ 对路径上每个节点进行标记,如果已经访问过的,则计算价值时不再做计算.</span><br><span class="line">+ 可以记录在某个节点在某个时间内到达时的最大价值,如果当前的价值小于该值则直接返回.</span><br><span class="line"><span class="number">3.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度分析: $O(D^&#123;\frac&#123;maxt&#125;&#123;t&#125;&#125;)$, 其中 $D$ 为节点的最大度数.</span><br><span class="line">+ 空间复杂度分析: $O(V+E)$,其中 $V$ 为节点的个数, $E$ 为边的数目.</span><br><span class="line">### 代码</span><br><span class="line">+ `BFS`</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    <span class="built_in">int</span> x;</span><br><span class="line">    <span class="built_in">int</span> cost;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    unordered_set&lt;<span class="built_in">int</span>&gt; visit;</span><br><span class="line">    Node(<span class="built_in">int</span> x,<span class="built_in">int</span> cost,<span class="built_in">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maximalPathQuality(vector&lt;<span class="built_in">int</span>&gt;&amp; values, vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; edges, <span class="built_in">int</span> maxTime) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = values.size();</span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; graph(n);</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; dp(n,vector&lt;long long&gt;(maxTime + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(make_pair(v[<span class="number">1</span>],v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(make_pair(v[<span class="number">0</span>],v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        queue&lt;Node&gt; qu;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = values[<span class="number">0</span>];</span><br><span class="line">        Node node(<span class="number">0</span>,<span class="number">0</span>,values[<span class="number">0</span>]);</span><br><span class="line">        node.visit.insert(<span class="number">0</span>);</span><br><span class="line">        qu.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            Node curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">auto</span> [x, time] : graph[curr.x])&#123;</span><br><span class="line">                <span class="built_in">int</span> cost = curr.cost + time;</span><br><span class="line">                <span class="keyword">if</span>(cost &gt; maxTime) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">int</span> val = curr.val;</span><br><span class="line">                <span class="keyword">if</span>(!curr.visit.count(x))&#123;</span><br><span class="line">                    val += values[x];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[x][cost] &lt;= val)&#123;</span><br><span class="line">                    dp[x][cost] = val;</span><br><span class="line">                    Node nx(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                    nx.x = x;</span><br><span class="line">                    nx.cost = cost;</span><br><span class="line">                    nx.val = val;</span><br><span class="line">                    nx.visit = curr.visit;</span><br><span class="line">                    nx.visit.insert(x);</span><br><span class="line">                    qu.push(nx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= maxTime; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><code>DFS</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; graph;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> curTime, <span class="keyword">int</span> curValue, <span class="keyword">int</span> maxTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curTime &gt; maxTime) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == <span class="number">0</span>) &#123; <span class="comment">/* 回到起点, 更新最大值 */</span></span><br><span class="line">            ans = fmax(ans, curValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : graph[start]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123; <span class="comment">/* 目标节点没有访问过 */</span></span><br><span class="line">                visited[v] = <span class="number">1</span>;</span><br><span class="line">                dfs(v, curTime + w, curValue + values[v], maxTime, values);</span><br><span class="line">                visited[v] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">/* 目标节点已经访问过 */</span></span><br><span class="line">                dfs(v, curTime + w, curValue, maxTime, values);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalPathQuality</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> maxTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = values.size();</span><br><span class="line">        graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;(n);</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">int</span> curTime  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curValue = <span class="number">0</span>;</span><br><span class="line">        ans = values[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : edges) &#123; <span class="comment">/* 建立连接表 */</span></span><br><span class="line">            graph[e[<span class="number">0</span>]].emplace_back(e[<span class="number">1</span>], e[<span class="number">2</span>]);</span><br><span class="line">            graph[e[<span class="number">1</span>]].emplace_back(e[<span class="number">0</span>], e[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, curTime, curValue, maxTime, values);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-266&quot;&gt;&lt;a href=&quot;#leetcode-contest-266&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 266&quot;&gt;&lt;/a&gt;leetcode contest 266&lt;/h1&gt;&lt;p&gt;今天周赛的题目比较简单，前三题基本上没有什么难度的题目，最后一题做法上想的太复杂了点，最后用一个简单的$BFS$ 搞定.&lt;/p&gt;&lt;h3 id=&quot;5918-统计字符串中的元音子字符串&quot;&gt;&lt;a href=&quot;#5918-统计字符串中的元音子字符串&quot; class=&quot;headerlink&quot; title=&quot;5918. 统计字符串中的元音子字符串&quot;&gt;&lt;/a&gt;5918. 统计字符串中的元音子字符串&lt;/h3&gt;&lt;p&gt;子字符串 是字符串中的一个连续（非空）的字符序列。&lt;/p&gt;&lt;p&gt;元音子字符串 是 仅 由元音&lt;code&gt;（&amp;#39;a&amp;#39;、&amp;#39;e&amp;#39;、&amp;#39;i&amp;#39;、&amp;#39;o&amp;#39; 和 &amp;#39;u&amp;#39;）6&lt;/code&gt;组成的一个子字符串，且必须包含 全部五种 元音。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
