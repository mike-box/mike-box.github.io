<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-09-07T00:48:32.104Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 257</title>
    <link href="http://yoursite.com/2021/09/05/324/"/>
    <id>http://yoursite.com/2021/09/05/324/</id>
    <published>2021-09-05T09:42:41.722Z</published>
    <updated>2021-09-07T00:48:32.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-257"><a href="#leetcode-contest-257" class="headerlink" title="leetcode  contest 257"></a>leetcode  contest 257</h1><p>周赛的题目质量果真很高，第二题和第四题，确实出的非常好。</p><h2 id="5863-统计特殊四元组"><a href="#5863-统计特殊四元组" class="headerlink" title="5863. 统计特殊四元组"></a>5863. 统计特殊四元组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 下标从<code>0</code>开始 的整数数组 <code>nums</code>，返回满足下述条件的 不同 四元组<code>(a, b, c, d)</code> 的 数目 ：</p><ul><li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且<br><code>a &lt; b &lt; c &lt; d</code></li></ul><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：满足要求的唯一一个四元组是 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) 因为 <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> == <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>] 中不存在满足要求的四元组。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：满足要求的 <span class="number">4</span> 个四元组如下：</span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span></span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>): <span class="number">1</span> + <span class="number">1</span> + <span class="number">3</span> == <span class="number">5</span></span><br><span class="line">- (<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>): <span class="number">1</span> + <span class="number">1</span> + <span class="number">3</span> == <span class="number">5</span></span><br><span class="line">- (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>): <span class="number">1</span> + <span class="number">1</span> + <span class="number">3</span> == <span class="number">5</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">4</span> &lt;= nums.length &lt;= <span class="number">50</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">100</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-257/problems/count-special-quadruplets/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力或者`hash`</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 由于题目数量很小，我们直接暴力 $<span class="number">4</span>$ 重循环即可解决。时间复杂度为 $O(n^&#123;<span class="number">4</span>&#125;)$,空间复杂度为$O(<span class="number">1</span>)$.</span><br><span class="line"><span class="number">2.</span> 另一种解法，我们可以利用 $hash$ 较少一层循环，时间复杂度为 $O(n^&#123;<span class="number">3</span>&#125;)$.</span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> countQuadruplets(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="built_in">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> m = k + <span class="number">1</span>; m &lt; n; ++m)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum == nums[m])&#123;</span><br><span class="line">                            ans++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5864-游戏中弱角色的数量"><a href="#5864-游戏中弱角色的数量" class="headerlink" title="5864. 游戏中弱角色的数量"></a>5864. 游戏中弱角色的数量</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 <code>properties</code> ，其中 <code>properties[i] = [attacki, defensei]</code> 表示游戏中第 <code>i</code>个角色的属性。</p><p>如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 <code>i</code> 弱于 存在的另一个角色<code>j</code>，那么 <code>attackj &gt; attacki</code> 且 <code>defensej &gt; defensei</code> 。</p><p>返回 弱角色 的数量。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties = [[<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在攻击和防御都严格高于其他角色的角色。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties = [[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">10</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= properties.length &lt;= 105</code></li><li><code>properties[i].length == 2</code></li><li><code>1 &lt;= attacki, defensei &lt;= 105</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-all-groups-of-farmland" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-groups-of-farmland</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序 + 贪心算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们将数组按照 $properties$ 的属性的从小到大进行排序。</li><li>我们从数组的后往前进行访问，我们每次保存当前已经访问过的元素的 $defensei$ 的最大值 $maxcurr$，我们每次访问 $attacki$ 相同的元素，如果当前元素的 $defensei$ 严格小于 $maxcurr$,则我们认为一定存在元素满足 $attackj &gt; attacki,defensej &gt; defensei$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(n\lg(n))$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfWeakCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = properties.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCurr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : properties) cnt[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> it = cnt.rbegin();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : it-&gt;second)&#123;</span><br><span class="line">            maxCurr = max(maxCurr,v);</span><br><span class="line">        &#125;</span><br><span class="line">        it++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;it != cnt.rend(); it++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : it-&gt;second)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v &lt; maxCurr) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : it-&gt;second)&#123;</span><br><span class="line">                maxCurr = max(maxCurr,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5865-访问-完所有房间的第一天"><a href="#5865-访问-完所有房间的第一天" class="headerlink" title="5865. 访问`完所有房间的第一天"></a>5865. 访问`完所有房间的第一天</h2><p>你需要访问<code>n</code>个房间，房间从 <code>0</code>到 <code>n - 1</code>编号。同时，每一天都有一个日期编号，从 <code>0</code>开始，依天数递增。你每天都会访问一个房间。</p><p>最开始的第 <code>0</code>天，你访问 <code>0</code>号房间。给你一个长度为<code>n</code>且 下标从 0 开始 的数组 <code>nextVisit</code> 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：</p><p>假设某一天，你访问 i 号房间。</p><ul><li>如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中<code>0 &lt;= nextVisit[i] &lt;= i</code>。</li><li>如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 <code>(i + 1) mod n</code>号房间。<br>请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 <code>109 + 7</code> 取余后的结果。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nextVisit = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 第 <span class="number">0</span> 天，你访问房间 <span class="number">0</span> 。访问 <span class="number">0</span> 号房间的总次数为 <span class="number">1</span> ，次数为奇数。</span><br><span class="line">  下一天你需要访问房间的编号是 nextVisit[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">- 第 <span class="number">1</span> 天，你访问房间 <span class="number">0</span> 。访问 <span class="number">0</span> 号房间的总次数为 <span class="number">2</span> ，次数为偶数。</span><br><span class="line">  下一天你需要访问房间的编号是 (<span class="number">0</span> + <span class="number">1</span>) mod <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">- 第 <span class="number">2</span> 天，你访问房间 <span class="number">1</span> 。这是你第一次完成访问所有房间的那天。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nextVisit = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">你每天访问房间的次序是 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...] 。</span><br><span class="line">第 <span class="number">6</span> 天是你访问完所有房间的第一天。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nextVisit = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">你每天访问房间的次序是 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,...] 。</span><br><span class="line">第 <span class="number">6</span> 天是你访问完所有房间的第一天。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nextVisit.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= nextVisit[i] &lt;= i</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-257/problems/first-day-where-you-have-been-in-all-the-rooms/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-257/problems/first-day-where-you-have-been-in-all-the-rooms/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题，动态规划</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目的思考过程非常有趣，主要有以下几点分析：</li></ol><ul><li>第 $i+1$ 号房间只能通过第 $i$ 号房间来访问,且第 $1$ 次访问 $i$号房间时,从 $[0,i-1]$ 号房间都被访问了偶数次.</li><li>第 $1$ 次访问 $i$ 号房间后,下一个访问的房间号一定为 $nextVisit[i]$, 而此时访问 $nextVisit[i]$ 号时的次数一定为奇数.</li><li>第 $2$ 次访问 $i$ 号房间后,下一个访问的房间号即为 $i+1$.</li><li>我们只关心访问房间的次数的奇数和偶数的性,我们不关心具体的次数. </li></ul><ol><li>我们设 $dp[i]$ 表示第一次访问第 $i$ 号房间时所需要花费的天数, 则我们可以推理出从 $nextVisit[i]$ 第一次访问到第 $i$ 号房间访问的时间间隔一定为: $dp[i] - dp[nextVisit[i]]$.假如我们在奇数次时访问了第 $nextVisit[i]$ 号房间,则此时我们如果要想再回到第 $i$ 号房间,则所需的花费刚好等于 $dp[i] - dp[nextVisit[i]]$.</li><li>因此我们可以推理如下:</li></ol><ul><li>我们如果想第一次到到达第 $i+1$ 号房间,则我们首先需要第 $1$ 次到达第 $i$ 号房间, 然后再到达第 $nextVisit[i]$ 号房间,然后再依次经过 $[nextVisit[i],nextVisit[i]+1,…,i]$ 最终第 $2$ 次到达第 $i$ 号房间,然后下一步即可到达第 $i+1$ 号房间,因此我们可以得到递推公式:<script type="math/tex; mode=display">dp[i+1] = 2 + dp[i] + dp[i] - dp[nextVisit[i]]</script></li></ul><ol><li>时间复杂度为 $O(n)$,空间复杂度为 $O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstDayBeenInAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nextVisit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nextVisit.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = (<span class="number">2</span> + <span class="number">2</span>*dp[i<span class="number">-1</span>] - dp[nextVisit[i<span class="number">-1</span>]] + mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5866-数组的最大公因数排序"><a href="#5866-数组的最大公因数排序" class="headerlink" title="5866. 数组的最大公因数排序"></a>5866. 数组的最大公因数排序</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，你可以在 <code>nums</code> 上执行下述操作 任意次 ：</p><p>如果 <code>gcd(nums[i], nums[j]) &gt; 1</code> ，交换 <code>nums[i] 和 nums[j]</code>的位置。其中 <code>gcd(nums[i], nums[j])</code> 是 <code>nums[i]</code> 和 <code>nums[j]</code> 的最大公因数。<br>如果能使用上述交换方式将 <code>nums</code> 按 非递减顺序 排列，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">21</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可以执行下述操作完成对 [<span class="number">7</span>,<span class="number">21</span>,<span class="number">3</span>] 的排序：</span><br><span class="line">- 交换 <span class="number">7</span> 和 <span class="number">21</span> 因为 gcd(<span class="number">7</span>,<span class="number">21</span>) = <span class="number">7</span> 。nums = [<span class="number">21</span>,<span class="number">7</span>,<span class="number">3</span>]</span><br><span class="line">- 交换 <span class="number">21</span> 和 <span class="number">3</span> 因为 gcd(<span class="number">21</span>,<span class="number">3</span>) = <span class="number">3</span> 。nums = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">21</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法完成排序，因为 <span class="number">5</span> 不能与其他元素交换。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">可以执行下述操作完成对 [<span class="number">10</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>] 的排序：</span><br><span class="line">- 交换 <span class="number">10</span> 和 <span class="number">15</span> 因为 gcd(<span class="number">10</span>,<span class="number">15</span>) = <span class="number">5</span> 。nums = [<span class="number">15</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">- 交换 <span class="number">15</span> 和 <span class="number">3</span> 因为 gcd(<span class="number">15</span>,<span class="number">3</span>) = <span class="number">3</span> 。nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">10</span>]</span><br><span class="line">- 交换 <span class="number">10</span> 和 <span class="number">15</span> 因为 gcd(<span class="number">10</span>,<span class="number">15</span>) = <span class="number">5</span> 。nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">3</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">2</span> &lt;= nums[i] &lt;= <span class="number">105</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/the-number-of-good-subsets</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  集合＋排序</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 首先我们思考一下,对于最大公约数大于 $<span class="number">1</span>$ 的两个位置可以任意交换,所以我们可以发现具有公因子的块中的元素位置是可以任意交换，我们首先需要将这些连通块找出来，然后将这些连通块内的数按照从小到大进行排序，然后检测排序后的结果是否为非递减排序．</span><br><span class="line"><span class="number">2.</span> 题目的难点在于如何找到所有具有大于 $<span class="number">1</span>$ 的质因子的数的集合,我们可以直接利用筛查法, 如果两个集合之间存在任意的两个元素具有大于 $<span class="number">1</span>$ 的公因子,则我们即可将这两个集合进行合并.总体来说这个题目出的很好,质量很高,既考了基本的数学方法,也考了集合,思考也非常综合的一个题目.</span><br><span class="line"><span class="number">3.</span> 复杂度分析:</span><br><span class="line">+ 时间负载度分析: 我们首先需要计算公约数筛查的复杂度分析,公约数的筛查的花费的时间约为:</span><br><span class="line">$$</span><br><span class="line">T_&#123;<span class="number">1</span>&#125; = \frac&#123;n&#125;&#123;<span class="number">2</span>&#125; + \frac&#123;n&#125;&#123;<span class="number">3</span>&#125; + \frac&#123;n&#125;&#123;<span class="number">4</span>&#125; + \frac&#123;n&#125;&#123;<span class="number">5</span>&#125; + ... + \frac&#123;n&#125;&#123;<span class="number">2</span>&#125; \approx n*(\log (n)<span class="number">-1</span>)\\</span><br><span class="line">$$</span><br><span class="line">每次筛查完成后需要进行集合合并所花费的时间为 $\log(n)$,最后我们还需要进行排序花费的时间复杂度为　$O(n \log(n))$,检查时花费的时间为 $O(n)$,因此总的时间复杂度为: $T = n*(\log (n)<span class="number">-1</span>)*\log(n) + n\log(n) + n = n*(\log(n))^&#123;<span class="number">2</span>&#125; + n = n*(\log(n))^&#123;<span class="number">2</span>&#125;$.</span><br><span class="line">+ 空间复杂度分析: 空间复杂度为　$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> find(vector&lt;<span class="built_in">int</span>&gt; &amp;f,<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x] != f[f[x]]) f[x] = find(f,f[x]);</span><br><span class="line">        <span class="keyword">return</span> f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bool</span> merge(vector&lt;<span class="built_in">int</span>&gt; &amp;f,<span class="built_in">int</span> x,<span class="built_in">int</span> y)&#123;</span><br><span class="line">        <span class="built_in">int</span> x1 = find(f,x);</span><br><span class="line">        <span class="built_in">int</span> y1 = find(f,y);</span><br><span class="line">        <span class="keyword">if</span>(x1 != y1) f[x1] = y1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">bool</span> gcdSort(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; pos(MAXN);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; fa(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            pos[nums[i]].push_back(i);</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">2</span>; k &lt; MAXN; ++k)&#123;</span><br><span class="line">            <span class="built_in">int</span> last = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = k; i &lt; MAXN; i += k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos[i].size() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; pos[i].size(); ++j)&#123;</span><br><span class="line">                    merge(fa,pos[i][j<span class="number">-1</span>],pos[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(last &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    merge(fa,last,pos[i].back());</span><br><span class="line">                &#125;</span><br><span class="line">                last = pos[i].back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; arr(MAXN);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr[find(fa,i)].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i].size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                vector&lt;<span class="built_in">int</span>&gt; idx = arr[i];</span><br><span class="line">                sort(idx.begin(),idx.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">int</span> a,<span class="keyword">const</span> <span class="built_in">int</span> b)&#123;</span><br><span class="line">                   <span class="keyword">return</span> nums[a] &lt; nums[b]; </span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr[i].size(); ++j)&#123;</span><br><span class="line">                    ans[arr[i][j]] = nums[idx[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i] &lt; ans[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-257&quot;&gt;&lt;a href=&quot;#leetcode-contest-257&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 257&quot;&gt;&lt;/a&gt;leetcode  contest 257&lt;/h1&gt;&lt;p&gt;周赛的题目质量果真很高，第二题和第四题，确实出的非常好。&lt;/p&gt;&lt;h2 id=&quot;5863-统计特殊四元组&quot;&gt;&lt;a href=&quot;#5863-统计特殊四元组&quot; class=&quot;headerlink&quot; title=&quot;5863. 统计特殊四元组&quot;&gt;&lt;/a&gt;5863. 统计特殊四元组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个 下标从&lt;code&gt;0&lt;/code&gt;开始 的整数数组 &lt;code&gt;nums&lt;/code&gt;，返回满足下述条件的 不同 四元组&lt;code&gt;(a, b, c, d)&lt;/code&gt; 的 数目 ：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums[a] + nums[b] + nums[c] == nums[d]&lt;/code&gt; ，且&lt;br&gt;&lt;code&gt;a &amp;lt; b &amp;lt; c &amp;lt; d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 60</title>
    <link href="http://yoursite.com/2021/09/05/323/"/>
    <id>http://yoursite.com/2021/09/05/323/</id>
    <published>2021-09-05T04:26:05.346Z</published>
    <updated>2021-09-05T07:11:05.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-60"><a href="#leetcode-biweekly-contest-60" class="headerlink" title="leetcode  biweekly contest 60"></a>leetcode  biweekly contest 60</h1><p>双周赛的题目，最后一题确实出的很好的题目，虽然带点技巧，但是确实非常不错。</p><h2 id="5846-找到数组的中间位置"><a href="#5846-找到数组的中间位置" class="headerlink" title="5846. 找到数组的中间位置"></a>5846. 找到数组的中间位置</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，请你找到 最左边 的中间位置 <code>middleIndex</code> （也就是所有可能中间位置下标最小的一个）。</p><a id="more"></a><p>中间位置 <code>middleIndex</code> 是满足 <code>nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]</code> 的数组下标。</p><p>如果 <code>middleIndex == 0</code> ，左边部分的和定义为 <code>0</code> 。类似的，如果 <code>middleIndex == nums.length - 1</code> ，右边部分的和定义为 <code>0</code> 。</p><p>请你返回满足上述条件 最左边 的 <code>middleIndex</code> ，如果不存在这样的中间位置，请你返回 <code>-1</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">下标 <span class="number">3</span> 之前的数字和为：<span class="number">2</span> + <span class="number">3</span> + <span class="number">-1</span> = <span class="number">4</span></span><br><span class="line">下标 <span class="number">3</span> 之后的数字和为：<span class="number">4</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">下标 <span class="number">2</span> 之前的数字和为：<span class="number">1</span> + <span class="number">-1</span> = <span class="number">0</span></span><br><span class="line">下标 <span class="number">2</span> 之后的数字和为：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">不存在符合要求的 middleIndex 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">下标 <span class="number">0</span> 之前的数字和为：<span class="number">0</span></span><br><span class="line">下标 <span class="number">0</span> 之后的数字和为：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-middle-index-in-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-middle-index-in-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单题目，滑动窗口即可，我们依次遍历每一个元素，然后比较该元素左边贺该元素右边的和是否相等。我们子数组的和的时候，我们可以利用前缀和即可。</li><li>算法时间复杂度为 $O(n)$,空间复杂度为 $O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMiddleIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[i] == (sum[n] - sum[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5847-找到所有的农场组"><a href="#5847-找到所有的农场组" class="headerlink" title="5847. 找到所有的农场组"></a>5847. 找到所有的农场组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code>开始，大小为 <code>m x n</code>的二进制矩阵 <code>land</code>，其中 <code>0</code> 表示一单位的森林土地，<code>1</code>表示一单位的农场土地。</p><p>为了让农场保持有序，农场土地之间以矩形的 农场组 的形式存在。每一个农场组都 仅 包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 不会 与另一个农场组的任何一块土地在四个方向上相邻。</p><p><code>land</code> 可以用坐标系统表示，其中 <code>land</code> 左上角坐标为 <code>(0, 0)</code> ，右下角坐标为 <code>(m-1, n-1)</code> 。请你找到所有 农场组 最左上角和最右下角的坐标。一个左上角坐标为 <code>(r1, c1)</code> 且右下角坐标为 <code>(r2, c2)</code> 的 农场组 用长度为 <code>4</code> 的数组 <code>[r1, c1, r2, c2]</code> 表示。</p><p>请你返回一个二维数组，它包含若干个长度为 <code>4</code> 的子数组，每个子数组表示 <code>land</code> 中的一个 农场组 。如果没有任何农场组，请你返回一个空数组。可以以 任意顺序 返回所有农场组。</p><p>示例 1：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：land = [[1,0,0],[0,1,1],[0,1,1]]</span><br><span class="line">输出：[[0,0,0,0],[1,1,2,2]]</span><br><span class="line">解释：</span><br><span class="line">第一个农场组的左上角为 land[<span class="string">0</span>][<span class="symbol">0</span>] ，右下角为 land[<span class="string">0</span>][<span class="symbol">0</span>] 。</span><br><span class="line">第二个农场组的左上角为 land[<span class="string">1</span>][<span class="symbol">1</span>] ，右下角为 land[<span class="string">2</span>][<span class="symbol">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：land = [[1,1],[1,1]]</span><br><span class="line">输出：[[0,0,1,1]]</span><br><span class="line">解释：</span><br><span class="line">第一个农场组左上角为 land[<span class="string">0</span>][<span class="symbol">0</span>] ，右下角为 land[<span class="string">1</span>][<span class="symbol">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：land = <span class="string">[[0]]</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">没有任何农场组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == land.length</code></li><li><code>n == land[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>land</code> 只包含 <code>0</code> 和 <code>1</code> 。</li><li>农场组都是 矩形 的形状。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-all-groups-of-farmland" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-groups-of-farmland</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们利用 ${BFS}$ 找到每个连通的子区域，然后判断该区域是否为矩形即可。</li><li>判断一个区域是否为矩形，可以用如下算法：</li></ol><ul><li>我们设矩形的左上角的坐标为 $(r1,c1)$,右下角的坐标为 $(r2,c2)$,则此时矩形中的元素应该为 $(r2-r1+1) \cdot (c2-c1+1)$.</li><li>我们此时判断该区域的个数 $total$ 是否与 $(r2-r1+1) \cdot (c2-c1+1)$ 相等.</li></ul><ol><li>时间复杂度为 $O(m<em>n)$，空间复杂度为$O(m</em>n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findFarmland(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; land) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = land.size();</span><br><span class="line">        <span class="keyword">int</span> col = land[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(land[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(visit[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> r1 = i;</span><br><span class="line">                <span class="keyword">int</span> c1 = j;</span><br><span class="line">                <span class="keyword">int</span> r2 = i;</span><br><span class="line">                <span class="keyword">int</span> c2 = j;</span><br><span class="line">                <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">                qu.push(i*col+j);</span><br><span class="line">                visit[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                    tot++;</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = curr/col + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = curr%col + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(land[x][y] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(visit[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                        r2 = max(r2,x);</span><br><span class="line">                        c2 = max(c2,y);</span><br><span class="line">                        r1 = min(r1,x);</span><br><span class="line">                        c1 = min(c1,y);</span><br><span class="line">                        visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">                        qu.push(x*col+y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> cnt = (r2-r1+<span class="number">1</span>)*(c2-c1+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(cnt == tot &amp;&amp; r1 == i &amp;&amp; c1 == j)&#123;</span><br><span class="line">                    ans.push_back(&#123;r1,c1,r2,c2&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5848-树上的操作"><a href="#5848-树上的操作" class="headerlink" title="5848. 树上的操作"></a>5848. 树上的操作</h2><p>给你一棵 <code>n</code> 个节点的树，编号从 <code>0</code>到 <code>n - 1</code> ，以父节点数组 <code>parent</code> 的形式给出，其中 <code>parent[i]</code> 是第 <code>i</code> 个节点的父节点。树的根节点为 <code>0</code>号节点，所以 <code>parent[0] = -1</code> ，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。</p><p>数据结构需要支持如下函数：</p><ul><li><code>Lock</code>：指定用户给指定节点 上锁 ，上锁后其他用户将无法给同一节点上锁。只有当节点处于未上锁的状态下，才能进行上锁操作。</li><li><code>Unlock</code>：指定用户给指定节点 解锁 ，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。</li><li><p><code>Upgrade</code>：指定用户给指定节点 上锁 ，并且将该节点的所有子孙节点 解锁 。只有如下 <code>3</code> 个条件 全部 满足时才能执行升级操作：<br>指定节点当前状态为未上锁。<br>指定节点至少有一个上锁状态的子孙节点（可以是 任意 用户上锁的）。<br>指定节点没有任何上锁的祖先节点。<br>请你实现 <code>LockingTree</code> 类：</p></li><li><p><code>LockingTree(int[] parent)</code> 用父节点数组初始化数据结构。</p></li><li><code>lock(int num, int user)</code> 如果 <code>id</code> 为 <code>user</code> 的用户可以给节点 <code>num</code> 上锁，那么返回 true ，否则返回 false 。如果可以执行此操作，节点 num 会被 id 为 user 的用户 上锁 。</li><li><code>unlock(int num, int user)</code> 如果 id 为 user 的用户可以给节点 num 解锁，那么返回 true ，否则返回 false 。如果可以执行此操作，节点 num 变为 未上锁 状态。</li><li><code>upgrade(int num, int user)</code> 如果 <code>id</code> 为 <code>user</code> 的用户可以给节点 <code>num</code> 升级，那么返回 <code>true</code> ，否则返回 <code>false</code>。如果可以执行此操作，节点 num 会被 升级 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"LockingTree"</span>, <span class="string">"lock"</span>, <span class="string">"unlock"</span>, <span class="string">"unlock"</span>, <span class="string">"lock"</span>, <span class="string">"upgrade"</span>, <span class="string">"lock"</span>]</span><br><span class="line">[[[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">输出：</span><br><span class="line">[<span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">LockingTree lockingTree = new LockingTree([<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]);</span><br><span class="line">lockingTree.lock(<span class="number">2</span>, <span class="number">2</span>);    <span class="comment">// 返回 true ，因为节点 2 未上锁。</span></span><br><span class="line">                           <span class="comment">// 节点 2 被用户 2 上锁。</span></span><br><span class="line">lockingTree.unlock(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 返回 false ，因为用户 3 无法解锁被用户 2 上锁的节点。</span></span><br><span class="line">lockingTree.unlock(<span class="number">2</span>, <span class="number">2</span>);  <span class="comment">// 返回 true ，因为节点 2 之前被用户 2 上锁。</span></span><br><span class="line">                           <span class="comment">// 节点 2 现在变为未上锁状态。</span></span><br><span class="line">lockingTree.lock(<span class="number">4</span>, <span class="number">5</span>);    <span class="comment">// 返回 true ，因为节点 4 未上锁。</span></span><br><span class="line">                           <span class="comment">// 节点 4 被用户 5 上锁。</span></span><br><span class="line">lockingTree.upgrade(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 返回 true ，因为节点 0 未上锁且至少有一个被上锁的子孙节点（节点 4）。</span></span><br><span class="line">                           <span class="comment">// 节点 0 被用户 1 上锁，节点 4 变为未上锁。</span></span><br><span class="line">lockingTree.lock(<span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 返回 false ，因为节点 0 已经被上锁了。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == parent.length</code></li><li><code>2 &lt;= n &lt;= 2000</code></li><li>对于 <code>i != 0</code>，满足 <code>0 &lt;= parent[i] &lt;= n - 1</code></li><li><code>parent[0] == -1</code></li><li><code>0 &lt;= num &lt;= n - 1</code></li><li><code>1 &lt;= user &lt;= 104</code></li><li><code>parent</code> 表示一棵合法的树。</li><li><code>lock</code> ，<code>unlock</code> 和 <code>upgrade</code> 的调用 总共 不超过 <code>2000</code>次。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/operations-on-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/operations-on-tree</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目看似比较简单，但是感觉出的还是比较有新意。</li><li>我们首先要建立树的关系，记录每个节点 $p$ 的父节点 $pa[p]$ 和子节点数组 $ch[p]$,同时设立另外单独的数组 $lockuser[p]$ 记录节点 $p$上锁的用户 $id$,同时另外记录两个数组 $chlock[p]$ 和 $palock[p]$,其中 $chlock[p]$ 表示节点 $p$ 的子节点中有多少个节点被 $lock$，$palock[p]$表示节点 $p$ 的父节点中有多少个节点被 $lock$。</li><li>具体算法如下：</li></ol><ul><li><code>lock(int num, int user)</code>：在<code>lock</code>操作时，首先判断该节点 $num$ 是否已经被 $lock$,如果被 $lock$ 则直接返回错误；如果没有被 $lock$,则我们直接将其 $lock$,同时将该节点 $num$ 的所有父节点的 $chlock$ 加 $1$, 同时将该节点 $num$ 的所有子节点的 $palock$ 加 $1$,。</li><li><code>unlock(int num, int user)</code>：在<code>unlock</code>操作时，首先判断该节点 $num$ 是否已经被 $lock$,如果未被 $lock$ 则直接返回错误；如果被 $lock$,则我们判断 $lockuser$ 是否与 $user$ 相等，如果相等则将其进行 $unlock$操作。直接将其 $unlock$,同时将该节点 $num$ 的所有父节点的 $chlock$ 减 $1$, 同时将该节点 $num$ 的所有子节点的 $palock$ 减 $1$,。</li><li><code>upgrade(int num, int user)</code>：首先判断该节点是否 $lock$,其次判断节点的 $palock$ 是否等于 $0$, 再次判断该节点的 $chlock$ 是否大于 $0$。首先我们需要将节点 $num$ 的所有父节点的 $chlock$ 加上 $1 - chlock[num]$,其次我们将该节点的所有子节点的全部设置为 $unlock$,同时将所有的子节点的 $chlock$ 设置为 $0$,所有子节点的 $palock$ 设置为 $1$。</li></ul><ol><li>算法的时间复杂度为 $O(n^{2})$,空间复杂度为 $O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LockingTree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parent) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = parent.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;pa = parent;</span><br><span class="line">        <span class="keyword">this</span>-&gt;palock = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;chlock = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;lockuser = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ch[parent[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addparent</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : ch[num])&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;palock[v] += x;</span><br><span class="line">            addparent(v,x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addchild</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="keyword">this</span>-&gt;pa[num];</span><br><span class="line">        <span class="keyword">while</span>(p &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;chlock[p] += x;</span><br><span class="line">            p = pa[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lockuser[num] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lockuser[num] = user;</span><br><span class="line">        </span><br><span class="line">        addchild(num,<span class="number">1</span>);</span><br><span class="line">        addparent(num,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lockuser[num] != user) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lockuser[num] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        addchild(num,<span class="number">-1</span>);</span><br><span class="line">        addparent(num,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">setparent</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : ch[num])&#123;</span><br><span class="line">            lockuser[v] = <span class="number">0</span>;</span><br><span class="line">            chlock[v] = <span class="number">0</span>;</span><br><span class="line">            palock[v] = x;</span><br><span class="line">            setparent(v,x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">upgrade</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lockuser[num] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(palock[num] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(chlock[num] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lockuser[num] = user;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span> - chlock[num];</span><br><span class="line">        addchild(num,x);</span><br><span class="line">        setparent(num,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pa;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ch;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; palock;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chlock;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lockuser;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LockingTree object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LockingTree* obj = new LockingTree(parent);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;lock(num,user);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;unlock(num,user);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;upgrade(num,user);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5849-好子集的数目"><a href="#5849-好子集的数目" class="headerlink" title="5849. 好子集的数目"></a>5849. 好子集的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。如果 <code>nums</code> 的一个子集中，所有元素的乘积可以用若干个 互不相同的质数 相乘得到，那么我们称它为 好子集 。</p><p>比方说，如果 <code>nums = [1, 2, 3, 4]</code>：<br><code>[2, 3] ，[1, 2, 3] 和 [1, 3]</code> 是 好 子集，乘积分别为 <code>6 = 2*3 ，6 = 2*3 和 3 = 3</code> 。<br><code>[1, 4]</code> 和<code>[4]</code>不是 好 子集，因为乘积分别为<code>4 = 2*2</code>和 <code>4 = 2*2</code>。<br>请你返回 <code>nums</code> 中不同的 好 子集的数目对 <code>109 + 7</code> 取余 的结果。</p><p><code>nums</code> 中的 子集 是通过删除<code>nums</code> 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：好子集为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>]：乘积为 <span class="number">2</span> ，可以表示为质数 <span class="number">2</span> 的乘积。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]：乘积为 <span class="number">6</span> ，可以表示为互不相同的质数 <span class="number">2</span> 和 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">3</span>]：乘积为 <span class="number">3</span> ，可以表示为质数 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">2</span>]：乘积为 <span class="number">2</span> ，可以表示为质数 <span class="number">2</span> 的乘积。</span><br><span class="line">- [<span class="number">2</span>,<span class="number">3</span>]：乘积为 <span class="number">6</span> ，可以表示为互不相同的质数 <span class="number">2</span> 和 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">3</span>]：乘积为 <span class="number">3</span> ，可以表示为质数 <span class="number">3</span> 的乘积。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：好子集为：</span><br><span class="line">- [<span class="number">2</span>]：乘积为 <span class="number">2</span> ，可以表示为质数 <span class="number">2</span> 的乘积。</span><br><span class="line">- [<span class="number">2</span>,<span class="number">3</span>]：乘积为 <span class="number">6</span> ，可以表示为互不相同质数 <span class="number">2</span> 和 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">2</span>,<span class="number">15</span>]：乘积为 <span class="number">30</span> ，可以表示为互不相同质数 <span class="number">2</span>，<span class="number">3</span> 和 <span class="number">5</span> 的乘积。</span><br><span class="line">- [<span class="number">3</span>]：乘积为 <span class="number">3</span> ，可以表示为质数 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">15</span>]：乘积为 <span class="number">15</span> ，可以表示为互不相同质数 <span class="number">3</span> 和 <span class="number">5</span> 的乘积。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 30</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/the-number-of-good-subsets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-number-of-good-subsets</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩 + 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>刚开始拿到这个题目感觉很奇怪，竟然没有思路，后来仔细想了一下，想出来了，我们利用状态压缩即可，当然这个状态压缩会稍微麻烦一点，题目中其实最重要的提示为 $1 \le  nums[i] \le 30$. 竟然每个元素都小于等于 $30$,由于子数组与数组元素的顺序无关，则我们可以将数组进行压缩，只存储每个元素出现的次数即可。</li><li>由于每个元素的大小都处于 $1 \le  nums[i] \le 30$ 之间，则我们应该首先可以求出在小于等于 $30$的质数的数组为：$[2,3,5,7,11,13,17,19,23,29]$, 我们看到质数最多只有 $10$个，因此我们可以知道不同的质数组合最多也只有 $2^{10}$ 种组合，因此我们想到可以用状态压缩$dp$.</li></ol><ul><li>我们设 $dp[i][mask]$ 表示当前小于等于 $i$ 的元素种，不同元素的乘积组合分解成不同的素数的组合状态刚好 $mask$ 时的个数。我们设将$num$ 分解为质数乘积的掩码为 $maks(num)$,则此时我们可以得到递推公式如下：<script type="math/tex; mode=display">dp[i+1][mask(i+1)|state] = (dp[i+1][mask(i+1)|state] + dp[i][state]*cnt[i+1]) \qquad (if \quad mask(i+1) \And state == 0)</script></li><li>因为题目中要求必须子集中的乘积分解为不同的质数，则必须满足 $mask(i+1) \And state == 0$,即表示元素 $i+1$ 与子集$state$ 之间无重复的质因子。</li><li>我们最终求出的结果为将所有可能的组合进行相加即可：<script type="math/tex; mode=display">ans = \sum_{i=0}^{2^{m}-1}dp[30][i]</script></li></ul></blockquote><ul><li>另外我们需要单独处理的是题目中 $1$ 的个数，由于题目明确说明如果两个子集删除的下标不同，那么它们被视为不同的子集,则我们知道所有不同素因子乘积的组合的总数目为 $ans$,则此时假设我们有 $cnt[1]$ 个 $1$,则我们知道对于 $1$ 的取法的种类有:<script type="math/tex; mode=display">\begin{aligned}count &= C_{cnt[1]}^{0} + C_{cnt[1]}^{1} + C_{cnt[1]}^{2} + ... + C_{cnt[1]}^{cnt[1]} \\&= 2^{cnt[1]}\end{aligned}</script>所有我们知道最终所有可能的组合应该为: <script type="math/tex; mode=display">ans = 2^{cnt[1]}*\sum_{i=0}^{2^{m}-1}dp[30][i]</script></li></ul><ol><li>复杂度分析：</li></ol><ul><li>时间复杂度为 $O(n*2^{m})$, 其中 $n$ 为数组中的最大元素， $m$为所有小于等于 $n$ 的质数的个数。</li><li>空间复杂度为 $O(n + 2^{m})$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = x;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>)&#123;</span><br><span class="line">                ret = (ret*curr)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfGoodSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = prime.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">1</span>&lt;&lt;m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt(<span class="number">31</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; valid(<span class="number">31</span>,<span class="literal">true</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cnt[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">30</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j%(prime[i]*prime[i])) == <span class="number">0</span>)&#123;</span><br><span class="line">                    valid[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">30</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!valid[i]) <span class="keyword">continue</span>;</span><br><span class="line">             <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp = dp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i%prime[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    mask |= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;m); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mask&amp;j) <span class="keyword">continue</span>;</span><br><span class="line">                ndp[mask|j] = (ndp[mask|j] + dp[j]*cnt[i])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans = (ans*fastpow(<span class="number">2</span>,cnt[<span class="number">1</span>],mod))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-60&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-60&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 60&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 60&lt;/h1&gt;&lt;p&gt;双周赛的题目，最后一题确实出的很好的题目，虽然带点技巧，但是确实非常不错。&lt;/p&gt;&lt;h2 id=&quot;5846-找到数组的中间位置&quot;&gt;&lt;a href=&quot;#5846-找到数组的中间位置&quot; class=&quot;headerlink&quot; title=&quot;5846. 找到数组的中间位置&quot;&gt;&lt;/a&gt;5846. 找到数组的中间位置&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找到 最左边 的中间位置 &lt;code&gt;middleIndex&lt;/code&gt; （也就是所有可能中间位置下标最小的一个）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab6 Cow Pages</title>
    <link href="http://yoursite.com/2021/09/02/322/"/>
    <id>http://yoursite.com/2021/09/02/322/</id>
    <published>2021-09-02T02:55:41.241Z</published>
    <updated>2021-09-02T13:33:15.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cow-pages"><a href="#cow-pages" class="headerlink" title="cow pages"></a>cow pages</h1><p>感觉<code>cow lab</code>是我做的最纠结的<code>lab</code>了，代码量其实非常少，但是就是非常见简单的<code>20</code>~<code>30</code>行代码，就出了许多莫名奇妙的<code>bug</code>。<code>copy on write page</code>实现原理非常简单，父进程在创建子进程时，子进程只需要将父进程的所有的虚拟地址<code>拷贝</code>一份即可,此时子进程与父进程共享同样的物理页，子进程和父进程可以同时读取同样的物理页面；当子进程或者父进程需要将数据写回物理页时，则申请一块新的物理页，并将虚拟地址重新映射到新的物理页上。这样实现的好处有两点：</p><a id="more"></a><ul><li>可以节省内存，此时子进程与父进程可以有多个进行共享只读的物理页面，从而减少物理内存的使用。</li><li>可以加快子进程的创建效率，此时子进程不需要再重新申请物理页面，从而可以加快子进程的创建速度。<br>在这个<code>lab</code>实现的时候真心遇到各种坑，熬了不少夜，很多莫名奇妙的<code>bug</code>总是出现，可以记录下出现的各种<code>bug</code>。</li><li>出现<code>page fault</code>，且<code>scause = 2</code>，表示出现了错误的指令。</li><li>出现<code>page fault</code>,且<code>scause = 12</code>,表示出现了加载页面失败的错误。</li><li>程序在单核模式下运行正确，但在多核模式下就各种奇怪的问题。</li><li>程序莫名奇妙出现陷入死循环，卡住不动。<br><img src="https://i.loli.net/2021/09/02/rUC6nqydHvie1ND.png" alt><br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-cow-handin" target="_blank" rel="noopener">git repo</a></li></ul><h2 id="Implement-copy-on-write"><a href="#Implement-copy-on-write" class="headerlink" title="Implement copy-on write"></a>Implement copy-on write</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your task <span class="keyword">is</span> <span class="keyword">to</span> implement <span class="keyword">copy</span>-<span class="keyword">on</span>-<span class="built_in">write</span> fork <span class="keyword">in</span> <span class="keyword">the</span> xv6 kernel. You are done <span class="keyword">if</span> your modified kernel executes both <span class="keyword">the</span> cowtest <span class="keyword">and</span> usertests programs successfully.</span><br></pre></td></tr></table></figure><p>代码实现的话，总共分为四个部门:</p><ul><li><code>uvmcopy</code>时，此时我们需要将子进程的页表项中的所有虚拟地址全部映射到父进程的物理页面里面。</li><li><code>copyout</code>时，此时因为在系统内部调用文件读写时，此时则是通过<code>copy out</code>和<code>copy in</code>来实现的，此时我们则需要判断当前的页面是否为<code>cow page</code>，如果为<code>cow page</code>则需要重新申请物理内存页面，然后重新写入数据。h’t’y’y’y’y’y’y’y’y’y’y’y’y’y’y’y’y’y </li><li><code>usertrap</code>：在发生写入没有写权限的页面时，就会处罚<code>page fault</code>的<code>trap</code>，此时我们需要申请新的物理页面然后映射到虚拟地址上，然后再次重新执行该指令。</li><li><code>kalloc</code>: 在进行<code>kalloc</code>和<code>kfree</code>时，我们增加对物理页面内存的引用计数，如果一个物理页面被映射到多个虚拟地址上，则每增加一次映射，则将计数进行增加，每次进行<code>free</code>操作时，我们则将引用进行进行较少，当引用计数为<code>0</code>时，此时我们可以释放该物理页面，并进行回收。</li></ul><ol><li><code>usertrap</code>: 添加对trap的处理<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= MAXVA || (va &lt;= PGROUNDDOWN(p-&gt;trapframe-&gt;sp) &amp;&amp; va &gt;= PGROUNDDOWN(p-&gt;trapframe-&gt;sp) - PGSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测pte的flag</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcowalloc(p-&gt;pagetable, va) != <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>vm：</li></ol><ul><li>子进程复制时，对物理内存页进行标记<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">uvmcopy(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"uvmcopy: pte should exist"</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"uvmcopy: page not present"</span>);</span><br><span class="line"></span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear PTE_W and mark the page as cow page.</span></span><br><span class="line">    <span class="keyword">if</span>(flags &amp; PTE_W)&#123;</span><br><span class="line">      flags = (flags | PTE_COW) &amp; (~PTE_W);</span><br><span class="line">      *pte = PA2PTE(pa) | flags;</span><br><span class="line">    &#125;</span><br><span class="line">    krefinc((<span class="keyword">void</span>*)pa);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>检测是否为<code>cow page</code>,如果是<code>cow page</code>则申请新的物理页，加进来。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">uvmcowalloc(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">if</span> (pa == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; PTE_COW)&#123;  </span><br><span class="line">    flags = (flags &amp; ~PTE_COW) | PTE_W;</span><br><span class="line">    <span class="keyword">char</span> *ka = kalloc();</span><br><span class="line">    <span class="keyword">if</span> (ka == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    memmove(ka, (<span class="keyword">char</span>*)pa, PGSIZE);</span><br><span class="line">    kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">    *pte = PA2PTE((uint64)ka) | flags;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>copyout</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">copyout(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="keyword">if</span> (uvmcowalloc(pagetable, va0) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>kalloc</code>函数处理：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint32 <span class="title">krefcount</span><span class="params">(<span class="keyword">void</span> *pa)</span></span>&#123;</span><br><span class="line">uint32 ret = <span class="number">0</span>;</span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">ret = kmem.refcount[PA2IDX(pa)];</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">krefinc</span><span class="params">(<span class="keyword">void</span> *pa)</span></span>&#123;</span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">kmem.refcount[PA2IDX(pa)]++;</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">krefdec</span><span class="params">(<span class="keyword">void</span> *pa)</span></span>&#123;</span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">kmem.refcount[PA2IDX(pa)]--;</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul><li>当我们遇到<code>fork</code>时我们如何处理？</li><li><ul><li>我们依次拷贝父进程的所有虚拟地址空间，同时将子进程的虚拟地址全部隐射到父进程的物理页面，并同时将父进程和子进程的页面全部标记为<code>cow page</code>。假设父进程的页面已经全部都为<code>cow page</code>,则此时我们只需要设置子进程的页面标志即可。</li></ul></li><li>当父进程或子进程写<code>cow page</code>时，我们如何处理？</li><li><ul><li>父进程或子进程写<code>cow page</code>时，我们直接申请一个新的物理页，并将虚拟地址映射到新的物理页上即可。</li></ul></li><li>引用计数的数组长度？</li><li><ul><li>引用数组，如果直接选择的话，实际上我们可以选择长度为$\frac{PHYSTOP}{4096}$。但是实际上没有必要，实际上我们可以看到大于$kernelbase$以上的高地址位都被内核给占用了，不会分配给用户进程，实际上这些物理页面被分配后，永远不会再被别的进程占用和分配。因此实际上我们的长度可以设定为$\frac{PHYSTOP-KERNELBASE}{4096}$.</li></ul></li><li>为什么我们需要处理<code>copy out</code>?</li><li><code>cow page</code>写入时如何处理？</li><li><ul><li><code>cow page</code>写入时会发生<code>trap</code>，因为此时该物理页并没有写入的标志，此时我们则需要捕获<code>trap</code>，然后进行处理。</li></ul></li><li>当<code>cow page</code>被子进程复制时，如何处理?</li><li><ul><li>我们直接进行将地址进行映射。</li></ul></li><li>当前<code>cow page</code>的引用计数？</li><li><ul><li>当<code>cow page</code>的<code>reference</code>大于<code>1</code>时，则我们可以知道该页面可能被多个进程映射，则此时我们按照正常的<code>cow page</code>处理即可。</li></ul></li><li><ul><li>当<code>cow page</code>的<code>reference</code>等于<code>1</code>时，则我们可以知道该页面只被一个进程映射，则此时我们可以还是按照正常的进程申请物理页面然后映射；其实我们还有另一种办法，直接恢复该页面的标记，将该物理页面标记为正常的页面，可读可写即可。</li></ul></li><li><ul><li>我们进行<code>kfree</code>时，会对引用计数减一操作，引用计数如果大于<code>1</code>时，则我们此时不做任何操作。当<code>reference</code>等于<code>0</code>时，则我们可以知道该页面未被任何一个进程引用，则可以对其进行释放。</li></ul></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;cow-pages&quot;&gt;&lt;a href=&quot;#cow-pages&quot; class=&quot;headerlink&quot; title=&quot;cow pages&quot;&gt;&lt;/a&gt;cow pages&lt;/h1&gt;&lt;p&gt;感觉&lt;code&gt;cow lab&lt;/code&gt;是我做的最纠结的&lt;code&gt;lab&lt;/code&gt;了，代码量其实非常少，但是就是非常见简单的&lt;code&gt;20&lt;/code&gt;~&lt;code&gt;30&lt;/code&gt;行代码，就出了许多莫名奇妙的&lt;code&gt;bug&lt;/code&gt;。&lt;code&gt;copy on write page&lt;/code&gt;实现原理非常简单，父进程在创建子进程时，子进程只需要将父进程的所有的虚拟地址&lt;code&gt;拷贝&lt;/code&gt;一份即可,此时子进程与父进程共享同样的物理页，子进程和父进程可以同时读取同样的物理页面；当子进程或者父进程需要将数据写回物理页时，则申请一块新的物理页，并将虚拟地址重新映射到新的物理页上。这样实现的好处有两点：&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 256</title>
    <link href="http://yoursite.com/2021/08/23/321/"/>
    <id>http://yoursite.com/2021/08/23/321/</id>
    <published>2021-08-23T15:22:32.728Z</published>
    <updated>2021-09-02T12:32:38.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-256"><a href="#leetcode-contest-256" class="headerlink" title="leetcode contest 256"></a>leetcode contest 256</h1><p>本周的周赛题目难度始终，不过前三题确实比较简单。最后一题是之前某个题目的变形，确实不好想到。</p><h2 id="5854-学生分数的最小差值"><a href="#5854-学生分数的最小差值" class="headerlink" title="5854. 学生分数的最小差值"></a>5854. 学生分数的最小差值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 下标从 <code>0</code> 开始 的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code>名学生的分数。另给你一个整数 <code>k</code> 。</p><p>从数组中选出任意<code>k</code>名学生的分数，使这<code>k</code>个分数间 最高分 和 最低分 的 差值 达到 最小化 。</p><a id="more"></a><p>返回可能的 最小差值 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">90</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：选出 <span class="number">1</span> 名学生的分数，仅有 <span class="number">1</span> 种方法：</span><br><span class="line">- [<span class="number">90</span>] 最高分和最低分之间的差值是 <span class="number">90</span> - <span class="number">90</span> = <span class="number">0</span></span><br><span class="line">可能的最小差值是 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：选出 <span class="number">2</span> 名学生的分数，有 <span class="number">6</span> 种方法：</span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">9</span> - <span class="number">4</span> = <span class="number">5</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">9</span> - <span class="number">1</span> = <span class="number">8</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">9</span> - <span class="number">7</span> = <span class="number">2</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">4</span> - <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">7</span> - <span class="number">4</span> = <span class="number">3</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">7</span> - <span class="number">1</span> = <span class="number">6</span></span><br><span class="line">可能的最小差值是 <span class="number">2</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= k &lt;= nums.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">105</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   排序 + 滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 我们遍历所有可能的最小值即可。我们首先将所有学生的分数按照从小到大排名，找到第`i`个排名与第`i+k<span class="number">-1</span>`个排名的成绩之间的最小值即可。因为我们知道任意选择`nums[i]`作为已选则的`k`个学生中的最小分数，则使得最高分和最低分的差值最小的话，则我们应该选择最大值为$nums[i+k<span class="number">-1</span>]$.</span><br><span class="line"><span class="number">2.</span> 算法时间复杂度为$O(nlg + n)$,空间复杂度为$O(<span class="number">1</span>)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minimumDifference(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= n-k; ++i)&#123;</span><br><span class="line">            ans = min(ans,nums[i+k<span class="number">-1</span>]-nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5855-找出数组中的第-K-大整数"><a href="#5855-找出数组中的第-K-大整数" class="headerlink" title="5855. 找出数组中的第 K 大整数"></a>5855. 找出数组中的第 K 大整数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>nums</code> 和一个整数 <code>k</code> 。<code>nums</code> 中的每个字符串都表示一个不含前导零的整数。</p><p>返回 <code>nums</code> 中表示第 <code>k</code> 大整数的字符串。</p><p>注意：重复的数字在统计时会视为不同元素考虑。例如，如果 <code>nums</code> 是 <code>[&quot;1&quot;,&quot;2&quot;,&quot;2&quot;]</code>，那么 <code>&quot;2&quot;</code> 是最大的整数，”2” 是第二大的整数，”1” 是第三大的整数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"3"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"10"</span>], k = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"3"</span></span><br><span class="line">解释：</span><br><span class="line">nums 中的数字按非递减顺序排列为 [<span class="string">"3"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"10"</span>]</span><br><span class="line">其中第 <span class="number">4</span> 大整数是 <span class="string">"3"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"2"</span>,<span class="string">"21"</span>,<span class="string">"12"</span>,<span class="string">"1"</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"2"</span></span><br><span class="line">解释：</span><br><span class="line">nums 中的数字按非递减顺序排列为 [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"12"</span>,<span class="string">"21"</span>]</span><br><span class="line">其中第 <span class="number">3</span> 大整数是 <span class="string">"2"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"0"</span>,<span class="string">"0"</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">解释：</span><br><span class="line">nums 中的数字按非递减顺序排列为 [<span class="string">"0"</span>,<span class="string">"0"</span>]</span><br><span class="line">其中第 <span class="number">2</span> 大整数是 <span class="string">"0"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>1 &lt;= nums[i].length &lt;= 100</code></li><li><code>nums[i]</code> 仅由数字组成</li><li><code>nums[i]</code> 不含任何前导零</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-kth-largest-integer-in-the-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-kth-largest-integer-in-the-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们将字符串数组按照字符串转换后的整数的大小进行排序。</li><li>排序比较方法如下：</li></ol><ul><li>如果字符串$a$与$b$的长度不相等，则长度较大的转换为整数后较大。</li><li>如果字符串$a$与$b$的长度相等，则比较两个字符串的字典序，字典序较大的转换为整数后较大。</li></ul><ol><li>算法的时间复杂度为 $O(n\lg n*m)$,其中 $n$ 为字符串数组的长度，$m$ 为字符串的平均长度。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">kthLargestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a,<span class="keyword">const</span> <span class="built_in">string</span> &amp;b)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a.size() == b.size())&#123;</span><br><span class="line">               <span class="keyword">return</span> a &gt; b;</span><br><span class="line">           &#125;           </span><br><span class="line">            <span class="keyword">return</span> a.size() &gt; b.size();</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5856-完成任务的最少工作时间段"><a href="#5856-完成任务的最少工作时间段" class="headerlink" title="5856. 完成任务的最少工作时间段"></a>5856. 完成任务的最少工作时间段</h2><p>你被安排了 <code>n</code> 个任务。任务需要花费的时间用长度为 <code>n</code>的整数数组 <code>tasks</code> 表示，第 i 个任务需要花费 <code>tasks[i]</code> 小时完成。一个 工作时间段 中，你可以 至多 连续工作 <code>sessionTime</code> 个小时，然后休息一会儿。</p><p>你需要按照如下条件完成给定任务：</p><p>如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。<br>完成一个任务后，你可以 立马 开始一个新的任务。<br>你可以按 任意顺序 完成任务。<br>给你<code>tasks</code> 和 <code>sessionTime</code>，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。</p><p>测试数据保证 <code>sessionTime</code> 大于等于 <code>tasks[i]</code> 中的 最大值 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], sessionTime = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以在两个工作时间段内完成所有任务。</span><br><span class="line">- 第一个工作时间段：完成第一和第二个任务，花费 <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> 小时。</span><br><span class="line">- 第二个工作时间段：完成第三个任务，花费 <span class="number">3</span> 小时。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>], sessionTime = <span class="number">8</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以在两个工作时间段内完成所有任务。</span><br><span class="line">- 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 <span class="number">3</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">8</span> 小时。</span><br><span class="line">- 第二个工作时间段，完成最后一个任务，花费 <span class="number">1</span> 小时。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], sessionTime = <span class="number">15</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你可以在一个工作时间段以内完成所有任务。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == tasks.length</code></li><li><code>1 &lt;= n &lt;= 14</code></li><li><code>1 &lt;= tasks[i] &lt;= 10</code></li><li><code>max(tasks[i]) &lt;= sessionTime &lt;= 15</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的求掩码组合的动态规划，我们设$dp[mask]$表示$mask$代表的二进制编码所表示的任务组合下所花费的最小的 $sessionTime$的数量。</li><li>则我们可以知道如下<code>dp</code>的递推公式:<script type="math/tex; mode=display">dp[mask] = max(dp[mask],dp[mask^state] + 1)</script>其中$state$所表示的任务能够在$1$个$sessionTime$里面完成，这就需要我们进行预处理即可，我们预处理所有可能在 $sessionTime$ 里面完成的任务组合。</li><li>遍历所有的状态返回即可。</li><li>时间复杂度为$O(n*2^{n} + 3^{n})$，空间复杂度为$O(2^{n})$,其中$n$为任务的数量。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSessions</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tasks, <span class="keyword">int</span> sessionTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tasks.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; valid(<span class="number">1</span>&lt;&lt;n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        valid[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr += tasks[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt;= sessionTime)&#123;</span><br><span class="line">                valid[i] = <span class="literal">true</span>;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">0</span>; j = (j<span class="number">-1</span>)&amp;i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid[i^j])&#123;</span><br><span class="line">                    dp[i] = min(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5857-不同的好子序列数目"><a href="#5857-不同的好子序列数目" class="headerlink" title="5857. 不同的好子序列数目"></a>5857. 不同的好子序列数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串<code>binary</code>。 <code>binary</code>的一个 子序列 如果是 非空 的且没有 前导 0 （除非数字是 “0” 本身），那么它就是一个 好 的子序列。</p><p>请你找到<code>binary</code>不同好子序列 的数目。</p><ul><li>比方说，如果 <code>binary = &quot;001&quot;</code>，那么所有 好 子序列为<code>[&quot;0&quot;, &quot;0&quot;, &quot;1&quot;]</code>，所以 不同 的好子序列为 <code>&quot;0&quot;</code> 和 <code>&quot;1&quot;</code>。 注意，子序列 “00” ，”01” 和 <code>&quot;001&quot;</code> 不是好的，因为它们有前导 0 。<br>请你返回<code>binary</code>中 不同好子序列 的数目。由于答案可能很大，请将它对 109 + 7 取余 后返回。</li></ul><p>一个 子序列 指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。</p><p>示例 1：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">binary </span>= <span class="string">"001"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：好的二进制子序列为 [<span class="string">"0"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>] 。</span><br><span class="line">不同的好子序列为 <span class="string">"0"</span> 和 <span class="string">"1"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">binary </span>= <span class="string">"11"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：好的二进制子序列为 [<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"11"</span>] 。</span><br><span class="line">不同的好子序列为 <span class="string">"1"</span> 和 <span class="string">"11"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">binary </span>= <span class="string">"101"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：好的二进制子序列为 [<span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"10"</span>, <span class="string">"11"</span>, <span class="string">"101"</span>] 。</span><br><span class="line">不同的好子序列为 <span class="string">"0"</span> ，<span class="string">"1"</span> ，<span class="string">"10"</span> ，<span class="string">"11"</span> 和 <span class="string">"101"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= binary.length &lt;= 105</code></li><li><code>binary</code> 只含有 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-unique-good-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-unique-good-subsequences</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目确实挺难想到这个递推关系。我们设 $dp[i][x]$ 表示当前字符串前 $i$ 个字符中以 $x$ 为结尾的字符串的好子字符串的数目，则我们可以知道递推关系如下：</li></ol><ul><li>当$s[i] == 0$时，则此时以 $1$ 为结尾的字符串的数目保持不变，我们可以在所有的好的字符串的末尾都加上 $0$,且单独的 $0$ 也为一个可能的字符串：<script type="math/tex; mode=display">dp[i+1][0] = dp[i][0] + dp[i][1] + 1 \\dp[i+1][1] = dp[i][1]</script></li><li>当$s[i] == 1$时，则此时以 $0$ 为结尾的字符串的数目保持不变，我们可以在所有的好的字符串的末尾都加上 $1$,且单独的 $1$也为一个可能的字符串：<script type="math/tex; mode=display">dp[i+1][0] = dp[i][0] \\dp[i+1][1] = dp[i][0] + dp[i][1] + 1</script></li></ul><ol><li>我们首先将字符串进行反转，此时因为字符串前导不能为 $0$，所以我们只需要求出当前的字符串中以 $1$为结尾的字符串的好子字符串的数目，同时再加上单独的 $0$即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfUniqueGoodSubsequences</span><span class="params">(<span class="built_in">string</span> binary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = binary.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">bool</span> has_zero = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">2</span>);</span><br><span class="line">        reverse(binary.begin(),binary.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = binary[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span>)&#123; </span><br><span class="line">                has_zero = <span class="literal">true</span>;</span><br><span class="line">                dp[<span class="number">0</span>] = (<span class="number">1</span> + dp[<span class="number">0</span>] + dp[<span class="number">1</span>])%mod;</span><br><span class="line">                dp[<span class="number">1</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[<span class="number">0</span>] = dp[<span class="number">0</span>];</span><br><span class="line">                dp[<span class="number">1</span>] = (<span class="number">1</span> + dp[<span class="number">0</span>] + dp[<span class="number">1</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(has_zero)&#123;</span><br><span class="line">            dp[<span class="number">1</span>] = (dp[<span class="number">1</span>] + <span class="number">1</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-256&quot;&gt;&lt;a href=&quot;#leetcode-contest-256&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 256&quot;&gt;&lt;/a&gt;leetcode contest 256&lt;/h1&gt;&lt;p&gt;本周的周赛题目难度始终，不过前三题确实比较简单。最后一题是之前某个题目的变形，确实不好想到。&lt;/p&gt;&lt;h2 id=&quot;5854-学生分数的最小差值&quot;&gt;&lt;a href=&quot;#5854-学生分数的最小差值&quot; class=&quot;headerlink&quot; title=&quot;5854. 学生分数的最小差值&quot;&gt;&lt;/a&gt;5854. 学生分数的最小差值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个 下标从 &lt;code&gt;0&lt;/code&gt; 开始 的整数数组 &lt;code&gt;nums&lt;/code&gt; ，其中 &lt;code&gt;nums[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt;名学生的分数。另给你一个整数 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;从数组中选出任意&lt;code&gt;k&lt;/code&gt;名学生的分数，使这&lt;code&gt;k&lt;/code&gt;个分数间 最高分 和 最低分 的 差值 达到 最小化 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab5 Lazy Alloaction</title>
    <link href="http://yoursite.com/2021/08/22/320/"/>
    <id>http://yoursite.com/2021/08/22/320/</id>
    <published>2021-08-22T10:33:01.039Z</published>
    <updated>2021-08-24T12:56:03.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lazy-alloaction"><a href="#lazy-alloaction" class="headerlink" title="lazy alloaction"></a>lazy alloaction</h1><p>感觉这个<code>lab</code>是最近感觉最容易的<code>lab</code>了，只花了一天就完成了<code>lab</code>，还是感谢网络资源，感谢各位后浪们的付出，将课件翻译成中文版，翻译的质量很好，通过阅读<code>lecture</code>即可很快的熟悉相关的<code>lazy allocation</code>的原理描述，利用<code>trap</code>来实现。我们再来仔细看一下<code>trap</code>的原理：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中断现场-&gt;保存现场-&gt; 处理trap -&gt;恢复现场-&gt;恢复运行</span><br></pre></td></tr></table></figure><br>利用<code>trap</code>我们可以进行相关的指令跳转，来执行我们需要的操作，执行完成之后，我们再恢复指令重新执行。所以我们可以利用<code>trap</code>来进行<code>lazy allocation</code>.按需申请物理内存资源，我们在申请内存时，可以先对只对该虚拟地址<code>va</code>进行标记，如果实际的程序需要进行访问该<code>va</code>时，我们再申请实际的物理内存页进行映射，映射完成后我们再恢复指令运行。<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-lazy-handin" target="_blank" rel="noopener">git repo</a></p><a id="more"></a><h2 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk"></a>Eliminate allocation from sbrk</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your first task is to <span class="keyword">delete</span> page allocation <span class="keyword">from</span> the sbrk(n) <span class="keyword">system</span> <span class="keyword">call</span> implementation, which <span class="keyword">is</span> the <span class="keyword">function</span> sys_sbrk() <span class="keyword">in</span> sysproc.c. The sbrk(n) <span class="keyword">system</span> <span class="keyword">call</span> grows the process<span class="string">'s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process'</span>s <span class="keyword">size</span> (myproc()-&gt;sz) <span class="keyword">by</span> n <span class="keyword">and</span> <span class="keyword">return</span> the <span class="keyword">old</span> size. It should <span class="keyword">not</span> <span class="keyword">allocate</span> <span class="keyword">memory</span> <span class="comment">-- so you should delete the call to growproc() (but you still need to increase the process's size!).</span></span><br></pre></td></tr></table></figure><p>这个非常容易实现，我们只需要在<code>sys_sbrk</code>函数内部对地址进行标记，标记该进程已经拥有该地址空间即可。<br>我们可以仔细分析一下内存<br><img src="https://i.loli.net/2021/08/24/OoGUsINFqVa62cy.png" alt><br>我们可以看到代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sbrk(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;sz + n &gt; MAXVA) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  p-&gt;sz += n;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modify the code <span class="keyword">in</span> trap.c <span class="keyword">to</span> respond <span class="keyword">to</span> a<span class="built_in"> page </span>fault <span class="keyword">from</span><span class="built_in"> user </span>space by mapping a newly-allocated<span class="built_in"> page </span>of physical memory at the faulting address, <span class="keyword">and</span> then returning back <span class="keyword">to</span><span class="built_in"> user </span>space <span class="keyword">to</span> let the process continue executing. You should <span class="builtin-name">add</span> your code just before the printf call that produced the <span class="string">"usertrap(): ..."</span> message. Modify whatever other xv6 kernel code you need <span class="keyword">to</span> <span class="keyword">in</span> order <span class="keyword">to</span> <span class="builtin-name">get</span> echo hi <span class="keyword">to</span> work.</span><br></pre></td></tr></table></figure><ul><li>实现在发生<code>trap</code>时我们时，我们首先判断发生<code>trap</code>时的地址是否合法，如果合法则我们认为该内存是<code>lazy allocation</code>，此时我们就<code>kalloc</code>一页实际的物理内存，然后进行映射，映射完成后，我们将<code>trap</code>恢复时执行的指令地址设置为$sepc$寄存器中的地址，CPU会从再次从发生<code>trap</code>的指令处开始执行。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 pcode = r_scause();</span><br><span class="line">uint64 va = r_stval();</span><br><span class="line">uint64 epc = r_sepc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// page fault, valid virtual address, 记录trap发生的原因</span></span><br><span class="line">  <span class="keyword">if</span>(pcode == <span class="number">15</span> || pcode == <span class="number">13</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(va &gt;= p-&gt;sz || va &lt;= p-&gt;trapframe-&gt;sp || va &gt; MAXVA)&#123;</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// alloc a page</span></span><br><span class="line"><span class="keyword">char</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapper a page for va</span></span><br><span class="line"><span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">kfree(mem);</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore epc</span></span><br><span class="line">p-&gt;trapframe-&gt;epc = epc;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修改<code>uvmunmap</code>时，我们在页表中<code>walk</code>时一旦发现该<code>virtual address</code>无法找到对应的物理页时，则我们此时直接跳过，而不是直接<code>panic</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">uvmunmap(<span class="keyword">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="keyword">int</span> do_free)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"uvmunmap: not aligned"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// 未找到该地址</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">"uvmunmap: not a leaf"</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">We've supplied you <span class="keyword">with</span> lazytests, an xv6 <span class="keyword">user</span> program that tests <span class="keyword">some</span> specific situations that may stress your lazy <span class="keyword">memory</span> allocator. <span class="keyword">Modify</span> your kernel code so that <span class="keyword">all</span> <span class="keyword">of</span> <span class="keyword">both</span> lazytests <span class="keyword">and</span> usertests pass.</span><br><span class="line">Handle negative sbrk() arguments.</span><br><span class="line"><span class="keyword">Kill</span> a process <span class="keyword">if</span> it page-faults <span class="keyword">on</span> a <span class="keyword">virtual</span> <span class="keyword">memory</span> address higher <span class="keyword">than</span> <span class="keyword">any</span> allocated <span class="keyword">with</span> sbrk().</span><br><span class="line">Handle the <span class="keyword">parent</span>-<span class="keyword">to</span>-<span class="keyword">child</span> <span class="keyword">memory</span> copy <span class="keyword">in</span> fork() correctly.</span><br><span class="line">Handle the <span class="keyword">case</span> <span class="keyword">in</span> which a process passes a valid address <span class="keyword">from</span> sbrk() <span class="keyword">to</span> a <span class="keyword">system</span> <span class="keyword">call</span> such <span class="keyword">as</span> <span class="keyword">read</span> <span class="keyword">or</span> write, but the <span class="keyword">memory</span> <span class="keyword">for</span> that address has <span class="keyword">not</span> yet been allocated.</span><br><span class="line">Handle <span class="keyword">out</span>-<span class="keyword">of</span>-<span class="keyword">memory</span> correctly: <span class="keyword">if</span> kalloc() fails <span class="keyword">in</span> the page fault <span class="keyword">handler</span>, <span class="keyword">kill</span> the <span class="keyword">current</span> process.</span><br><span class="line">Handle faults <span class="keyword">on</span> the invalid page below the <span class="keyword">user</span> stack.</span><br></pre></td></tr></table></figure></li><li>我们发现在进行<code>usertests</code>，<code>sbrkarg</code>这个测试结果一直过不了，页没有报<code>usertrap</code>的错误，仔细跟踪了一下代码，发现它是调用了<code>sys_write</code>操作，而<code>sys_write</code>最终调用了<code>copyin</code>的操作，仔细检查一下<code>copyin</code>的函数发现它是直接在页表中读取操作，<code>walkaddr</code>时报错，所以直接返回<code>-1</code>。所以我们需要修改<code>walkaddr</code>函数，我们发现当前的地址没有在页表中找到时，则取申请一页新的物理页，然后将其映射到新的物理地址中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">walkaddr(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"><span class="keyword">if</span>(va &gt;= p-&gt;sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// malloc a new page</span></span><br><span class="line"><span class="keyword">char</span> *mem = kalloc();</span><br><span class="line"><span class="keyword">if</span>(mem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// map a page for the new address</span></span><br><span class="line"><span class="keyword">if</span>(mappages(pagetable,PGROUNDDOWN(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">kfree(mem);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (uint64)mem;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>我们最后还需要注意的提示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handle faults on the invalid page below the user <span class="built_in">stack</span>.</span><br></pre></td></tr></table></figure>我们首先看一下系统用户进程的栈空间分布？<br>我们知道在栈的空件是从高地址往低地址增长的，如果我们发现栈的空间大小一个<code>page</code>，栈的地址空间为<code>1~4096</code>,因为所有的进程都是用户初始化进程的子进程，在子进程复制时，同时会复制父进程的栈空间。我们在进行<code>sbrk</code>操作时，实际扩充的进程的<code>heap</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">userinit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init's instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first "return" from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">"initcode"</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Handle faults on the invalid page below the user stack.</code></li></ul><ol><li><code>user stack</code>：user stack主要作为用户程序在<code>userspace</code>执行时需要的栈空间，当我们在用户空间执行用户的程序时，这时<code>sp</code>寄存器指向的就是<code>user stack</code>。</li><li><code>kernel stack</code>：<code>kernel stack</code>主要用户进程在系统调用时，切换到内核时执行内核的系统函数时，则这时<code>kernel space</code>执行时需要的栈空间，当系统调用发生时，则会发生<code>trap</code>，此时系统会切换<code>pc</code>到内核的函数调用，则此时我们执行内核函数时所需要的栈即为<code>kernel stack</code>。我们可以看到<code>kstack</code>之间有一个<code>guard page</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process's kernel stack</span></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br></pre></td></tr></table></figure></li><li><code>stack</code>相邻的地方都有一个<code>guard page</code>，为了防止<code>stack</code>越界，访问<code>guard page</code>时就会报错。我们可以看到在<code>exec</code>函数执行时，代码和数据加装在完成后，会紧接着申请两个物理页，一个作为<code>guard page</code>,一个作为<code>stack</code>。当然方式比较奇怪：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line"><span class="comment">// Use the second as the user stack.</span></span><br><span class="line">sz = PGROUNDUP(sz);</span><br><span class="line">uint64 sz1;</span><br><span class="line"><span class="comment">// malloc 2 page</span></span><br><span class="line"><span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">sz = sz1;</span><br><span class="line"><span class="comment">// 将第一个page标志位去掉</span></span><br><span class="line">uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">sp = sz;</span><br><span class="line">stackbase = sp - PGSIZE;</span><br></pre></td></tr></table></figure></li><li><code>Handle faults on the invalid page below the user stack.</code>我们只需要检测当前的<code>va</code>是否处在<code>guard page</code>中。我们知道<code>guard page</code>的地址范围为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackbase = PGROUNDDOWN(p-&gt;trapframe-&gt;sp) \\</span><br><span class="line">stackbase - PGSIZE \le va \le stackbase</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page fault, valid virtual address</span></span><br><span class="line">  <span class="keyword">if</span>(pcode == <span class="number">15</span> || pcode == <span class="number">13</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(va &gt;= (<span class="built_in">stack</span><span class="number">-2</span>*PGSIZE) &amp;&amp; va &lt; (<span class="built_in">stack</span>-PGSIZE))&#123;</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(va &gt;= p-&gt;sz || va &gt; MAXVA)&#123;</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">kfree(mem);</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;trapframe-&gt;epc = epc;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lazy-alloaction&quot;&gt;&lt;a href=&quot;#lazy-alloaction&quot; class=&quot;headerlink&quot; title=&quot;lazy alloaction&quot;&gt;&lt;/a&gt;lazy alloaction&lt;/h1&gt;&lt;p&gt;感觉这个&lt;code&gt;lab&lt;/code&gt;是最近感觉最容易的&lt;code&gt;lab&lt;/code&gt;了，只花了一天就完成了&lt;code&gt;lab&lt;/code&gt;，还是感谢网络资源，感谢各位后浪们的付出，将课件翻译成中文版，翻译的质量很好，通过阅读&lt;code&gt;lecture&lt;/code&gt;即可很快的熟悉相关的&lt;code&gt;lazy allocation&lt;/code&gt;的原理描述，利用&lt;code&gt;trap&lt;/code&gt;来实现。我们再来仔细看一下&lt;code&gt;trap&lt;/code&gt;的原理：&lt;br&gt;&lt;figure class=&quot;highlight clean&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;中断现场-&amp;gt;保存现场-&amp;gt; 处理trap -&amp;gt;恢复现场-&amp;gt;恢复运行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;利用&lt;code&gt;trap&lt;/code&gt;我们可以进行相关的指令跳转，来执行我们需要的操作，执行完成之后，我们再恢复指令重新执行。所以我们可以利用&lt;code&gt;trap&lt;/code&gt;来进行&lt;code&gt;lazy allocation&lt;/code&gt;.按需申请物理内存资源，我们在申请内存时，可以先对只对该虚拟地址&lt;code&gt;va&lt;/code&gt;进行标记，如果实际的程序需要进行访问该&lt;code&gt;va&lt;/code&gt;时，我们再申请实际的物理内存页进行映射，映射完成后我们再恢复指令运行。&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/MIT6.S081/tree/main/lab-lazy-handin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git repo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 乐鑫科技</title>
    <link href="http://yoursite.com/2021/08/22/319/"/>
    <id>http://yoursite.com/2021/08/22/319/</id>
    <published>2021-08-22T10:32:52.855Z</published>
    <updated>2021-08-23T02:55:54.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-乐鑫科技"><a href="#leetcode-contest-乐鑫科技" class="headerlink" title="leetcode  contest 乐鑫科技"></a>leetcode  contest 乐鑫科技</h1><p>题目还不错，但是难度不算很高。</p><h2 id="乐鑫01-录取分数线"><a href="#乐鑫01-录取分数线" class="headerlink" title="乐鑫01. 录取分数线"></a>乐鑫01. 录取分数线</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个浮点数数组 <code>scores</code>，其中 <code>scores[i]</code> 表示第 <code>i</code> 个考生的高考分数。<br>现在请你求出某大学的录取分数线，该大学的录取分数线恰好为将所有考生按高考分数由高到低排序后第 <code>k</code> 名考生的高考分数。</p><a id="more"></a><p>注意： <code>scores[i]</code> 恰好为 <code>0.5</code> 的倍数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">k = <span class="number">5</span>, scores = [<span class="number">150</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">550</span>,<span class="number">450</span>,<span class="number">450</span>,<span class="number">500</span>,<span class="number">555.5</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">500</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">将所有考生按高考分数由高到低排序后第 <span class="number">5</span> 名考生的高考分数为 <span class="number">500</span>。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">k = <span class="number">4</span>, scores = [<span class="number">723</span>,<span class="number">699</span>,<span class="number">510</span>,<span class="number">488.5</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">488.5</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">将所有考生按高考分数由高到低排序后第 <span class="number">4</span> 名考生的高考分数为 <span class="number">488.5</span>。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= scores.lengths &lt;= 10^5</code></li><li><code>0 &lt;= scores[i] &lt;=750</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/espressif-2021/problems/QXquF0/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/espressif-2021/problems/QXquF0/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序即可，然后取相应的排名。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAdmissionLine</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; scores)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = scores.size();</span><br><span class="line">        sort(scores.begin(),scores.end());</span><br><span class="line">        <span class="keyword">return</span> scores[n-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="乐鑫02-调整电平"><a href="#乐鑫02-调整电平" class="headerlink" title="乐鑫02. 调整电平"></a>乐鑫02. 调整电平</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>某实验逻辑电路中，初始时有<code>cnt</code> 个观测点处于低电平状态。</p><p>对于某个观测点的电平调整意味着：如果观测点处于低电平，会被调整为高电平；而观测点处于高电平，会被调整为低电平。</p><ul><li><p>第 1 轮，每个观测点调整一次电平。即，所有观测点处于高电平；</p></li><li><p>第 2 轮，每两个观测点调整一次电平。即，第 1、3、5 … 个观察点不调整，第 2、4、6 … 个观察点调整；</p></li><li><p>第 3 轮，每三个观测点调整一次电平。即，第 1、2、4、5 … 个观察点不调整，第 3、6 … 个观察点调整；</p></li><li><p>第 i 轮，每 i 观测点调整一次电平。 而第 cnt 轮，你只调整最后一个观测点的电平。</p></li><li><p>请找出 <code>cnt</code> 轮之后有多少处于高电平状态的观测点。</p></li></ul><p>示例 1：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：cnt = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：</span><br><span class="line">初始时, 电平状态为 <span class="string">[低, 低, 低，低]</span>,</span><br><span class="line">第一轮后, 电平状态 <span class="string">[高, 高, 高, 高]</span>,</span><br><span class="line">第二轮后, 电平状态 <span class="string">[高, 低, 高, 低]</span>,</span><br><span class="line">第三轮后, 电平状态 <span class="string">[高, 低, 低, 低]</span>,</span><br><span class="line">第四轮后, 电平状态 <span class="string">[高, 低, 低, 高]</span>, </span><br><span class="line"></span><br><span class="line">最终有 <span class="number">2</span> 个处于高电平状态的观测点，因此返回 <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入：cnt = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：cnt = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">0</span> &lt;= cnt &lt;= <span class="number">109</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/espressif-2021/problems/i4tX1E/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学问题</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 刚开始看到这个题目确实没有什么思路，后来仔细转化提交一下，我们可以看到每次遇到某个数的约数，则该点就会变化一次电平，一个数有多少个约数就会变换多少次电平。</span><br><span class="line"><span class="number">2.</span> 只有当某个数变换电平的次数为奇数时，才会出现高电平，仔细分析一下，我们发现只有平方数才有奇数个约数，所以我们找到所有小于等于`cnt`的平方数的个数即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> adjustLevel(<span class="built_in">int</span> cnt) &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="乐鑫03-签到序列"><a href="#乐鑫03-签到序列" class="headerlink" title="乐鑫03. 签到序列"></a>乐鑫03. 签到序列</h2><p>在某活动现场打卡处，活动参与者需要 按照到达顺序 依次领取并在签到簿上填下自己的排队编号（排队编号从 <code>1</code>开始），将签到簿上的排队编号依次首尾相连可以得到形如 <code>&quot;123456789101112...&quot;</code> 的 签到序列 ，请返回 签到序列 中的第 k 位数字。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：签到序列 <span class="string">"12345678910..."</span>中的第 <span class="number">6</span> 位数字是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">20</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：签到序列 <span class="string">"123456789101112131415..."</span>中的第 <span class="number">20</span> 位数字是 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= k &lt;= 231-1</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/espressif-2021/problems/fSghVj/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/espressif-2021/problems/fSghVj/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的数学问题，我们可以看到数字长度为<code>i</code>的数字的个数为：<script type="math/tex; mode=display">dp[i] = 9 (i= 1) \\dp[i] = 10^{i} - 10^{i-1} (i\neq 0) \\num[i] = i*dp[i]</script></li></ol></blockquote><ol><li>所以我们可以利用求和公式，快速的找到当前数所在的数字的位数,然后找到当前数字的实际数应该是多少，这个即是纯粹的数学问题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthNum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr;</span><br><span class="line">        arr.push_back(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">15</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="built_in">pow</span>(<span class="number">10</span>,i) - <span class="number">1</span> - sum;</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">            sum += curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; arr[i]*(i+<span class="number">1</span>))&#123;</span><br><span class="line">                k -= arr[i]*(i+<span class="number">1</span>);</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> c = k%(i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> x = k/(i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">                    x = sum + x;</span><br><span class="line">                    <span class="keyword">return</span> to_string(x).back() - <span class="string">'0'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    x = sum + x + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> to_string(x)[c<span class="number">-1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="乐鑫04-自行车拉力赛"><a href="#乐鑫04-自行车拉力赛" class="headerlink" title="乐鑫04. 自行车拉力赛"></a>乐鑫04. 自行车拉力赛</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>自行车拉力赛的选手从起点出发，计划前往距离起点 num 公里处的终点。</p><p>自行车上配有一个用于给轮胎降温用的容量无限的水箱，在出发时水箱中有 <code>initWater</code> 升水，并且选手每骑行一公里就需要消耗一升水用于给轮胎降温。</p><p>在比赛路线途中设有若干个补给站，以 [与起点的距离,水量] 的格式记录于二维数组 <code>supplyStations</code> 中。当选手抵达补给站时，可选择是否对水箱进行补水，若选择补水，则会将该补水站当前水量全部补入水箱中。</p><p>请返回选手抵达终点至少需要的补水次数。若无法抵达终点，则返回 -1。</p><p>注意：</p><p>若选手抵达补给站时水箱剩余水量为 0，可在此补水；<br>若选手抵达终点时水箱剩余水量为 0，视作抵达目的地。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num =<span class="number">10</span>, initWater = <span class="number">11</span>, supplyStations = [[<span class="number">5</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无需加水就可直接到达终点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">572</span>, initWater = <span class="number">200</span>, supplyStations = [[<span class="number">200</span>,<span class="number">156</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：即使选择在第一个补给站加水也无法抵达终点。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">200</span>, initWater = <span class="number">11</span>, supplyStations = [[<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">100</span>],[<span class="number">10</span>,<span class="number">189</span>],[<span class="number">11</span>,<span class="number">30</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：以下是一种可行的方案：</span><br><span class="line">出发时水箱中水量为 <span class="number">11</span> 升；</span><br><span class="line">骑行来到距起点 <span class="number">5</span> 公里处的补给站，不选择加水，此时水箱中的水量为 <span class="number">6</span> 升；</span><br><span class="line">骑行来到距起点 <span class="number">6</span> 公里处的补给站，不选择加水，此时水箱中的水量为 <span class="number">5</span> 升；</span><br><span class="line">骑行来到距起点 <span class="number">10</span> 公里处的补给站，选择加水，此时水箱中的水量为 <span class="number">190</span> 升；</span><br><span class="line">骑行来到距起点 <span class="number">11</span> 公里处的补给站，不选择加水，此时水箱中的水量为 <span class="number">189</span> 升；</span><br><span class="line">到达终点，此时水箱中的水量为 <span class="number">0</span> 升。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= num, initWater, supplyStations[i][<span class="number">1</span>] &lt;= <span class="number">10</span>^<span class="number">9</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= supplyStations.length &lt;= <span class="number">500</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt; supplyStations[<span class="number">0</span>][<span class="number">0</span>] &lt; supplyStations[<span class="number">1</span>][<span class="number">0</span>] &lt; ... &lt; supplyStations[supplyStations.length<span class="number">-1</span>][<span class="number">0</span>] &lt; num`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/find-array-given-subset-sums</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  dp或者优先级队列</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 我们首先看一下`dp`的解法，非常简单，我们设`dp[i][j]`表示为到达第`i`个补给站，且加水`j`次后，水箱拥有的最大的水量，则我们可以知道递推关系：</span><br><span class="line">+ 假设我们前`i<span class="number">-1</span>`个站点已经补充过`j`次了，则此时我们在`i`个站点则不应该再补充水。</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j] - (supplyStations[i][<span class="number">0</span>] - supplyStations[i<span class="number">-1</span>][<span class="number">0</span>])) </span><br><span class="line">$$</span><br><span class="line">+ 假设我们前`i<span class="number">-1</span>`个站点已经补充过`j<span class="number">-1</span>`次，则此时我们在`i`个站点则需要补充水。</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>] - (supplyStations[i][<span class="number">0</span>] - supplyStations[i<span class="number">-1</span>][<span class="number">0</span>]) + supplyStations[i][<span class="number">1</span>])</span><br><span class="line">$$</span><br><span class="line"><span class="number">2.</span> 我们从最小的`<span class="number">0</span>`开始测试，到达第`n`个站点时，如果剩余的最大水量能够支撑其到达终点，则我们认为可以满足条件。</span><br><span class="line"><span class="number">3.</span> 优先级队列。</span><br><span class="line">### 代码</span><br><span class="line">+ dp</span><br><span class="line">```c++</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minSupplyTimes(<span class="built_in">int</span> num, <span class="built_in">int</span> initWater, vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; supplyStations) &#123;</span><br><span class="line">        <span class="built_in">int</span> m = supplyStations.size();</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; dp(m+<span class="number">1</span>,vector&lt;long long&gt;(m+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; dist;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(initWater &gt;= num) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            dist.push_back(supplyStations[i][<span class="number">0</span>] - curr);</span><br><span class="line">            curr = supplyStations[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = initWater;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(initWater &gt;= supplyStations[i<span class="number">-1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">                        dp[i][j] = initWater - supplyStations[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i<span class="number">-1</span> &gt;= j &amp;&amp; dp[i<span class="number">-1</span>][j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &gt;= dist[i<span class="number">-1</span>])&#123;</span><br><span class="line">                            dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j] - dist[i<span class="number">-1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &gt;= dist[i<span class="number">-1</span>])&#123;</span><br><span class="line">                            dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>] - dist[i<span class="number">-1</span>] + supplyStations[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[m][i] + supplyStations[m<span class="number">-1</span>][<span class="number">0</span>] &gt;= num)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-乐鑫科技&quot;&gt;&lt;a href=&quot;#leetcode-contest-乐鑫科技&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 乐鑫科技&quot;&gt;&lt;/a&gt;leetcode  contest 乐鑫科技&lt;/h1&gt;&lt;p&gt;题目还不错，但是难度不算很高。&lt;/p&gt;&lt;h2 id=&quot;乐鑫01-录取分数线&quot;&gt;&lt;a href=&quot;#乐鑫01-录取分数线&quot; class=&quot;headerlink&quot; title=&quot;乐鑫01. 录取分数线&quot;&gt;&lt;/a&gt;乐鑫01. 录取分数线&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个浮点数数组 &lt;code&gt;scores&lt;/code&gt;，其中 &lt;code&gt;scores[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个考生的高考分数。&lt;br&gt;现在请你求出某大学的录取分数线，该大学的录取分数线恰好为将所有考生按高考分数由高到低排序后第 &lt;code&gt;k&lt;/code&gt; 名考生的高考分数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 59</title>
    <link href="http://yoursite.com/2021/08/22/318/"/>
    <id>http://yoursite.com/2021/08/22/318/</id>
    <published>2021-08-22T10:31:52.677Z</published>
    <updated>2021-08-23T03:36:47.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-59"><a href="#leetcode-biweekly-contest-59" class="headerlink" title="leetcode biweekly contest 59"></a>leetcode biweekly contest 59</h1><p>双周赛的题目质量很高，出的非常不错的题目</p><h2 id="5850-找出数组的最大公约数"><a href="#5850-找出数组的最大公约数" class="headerlink" title="5850. 找出数组的最大公约数"></a>5850. 找出数组的最大公约数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>使用特殊打字机键入单词的最少时间<br>有一个特殊打字机，它由一个 圆盘 和一个 指针 组成， 圆盘上标有小写英文字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code>。只有 当指针指向某个字母时，它才能被键入。指针 初始时 指向字符 <code>&#39;a&#39;</code> 。</li></ol><a id="more"></a><p>每一秒钟，你可以执行以下操作之一：</p><p>将指针 顺时针 或者 逆时针 移动一个字符。<br>键入指针 当前 指向的字符。<br>给你一个字符串 word ，请你返回键入 word 所表示单词的 最少 秒数 。</p><p>示例 1：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "abc"</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">单词按如下操作键入：</span><br><span class="line">-<span class="ruby"> 花 <span class="number">1</span> 秒键入字符 <span class="string">'a'</span> <span class="keyword">in</span> <span class="number">1</span> ，因为指针初始指向 <span class="string">'a'</span> ，故不需移动指针。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒将指针顺时针移到 <span class="string">'b'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'b'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒将指针顺时针移到 <span class="string">'c'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'c'</span> 。</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "bza"</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">单词按如下操作键入：</span><br><span class="line">-<span class="ruby"> 花 <span class="number">1</span> 秒将指针顺时针移到 <span class="string">'b'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'b'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">2</span> 秒将指针逆时针移到 <span class="string">'z'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'z'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒将指针顺时针移到 <span class="string">'a'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'a'</span> 。</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "zjpc"</span><br><span class="line">输出：34</span><br><span class="line">解释：</span><br><span class="line">单词按如下操作键入：</span><br><span class="line">-<span class="ruby"> 花 <span class="number">1</span> 秒将指针逆时针移到 <span class="string">'z'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'z'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">10</span> 秒将指针顺时针移到 <span class="string">'j'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'j'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">6</span> 秒将指针顺时针移到 <span class="string">'p'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'p'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">13</span> 秒将指针逆时针移到 <span class="string">'c'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'c'</span> 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 100</code></li><li><code>word</code> 只包含小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-time-to-type-word-using-special-typewriter" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-time-to-type-word-using-special-typewriter</a><br>n### 题意</p><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们每次取$min(diff,26-diff)$即可，暴力检测，算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToType</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> curr = <span class="string">'a'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = <span class="built_in">abs</span>(c-curr);</span><br><span class="line">            ans += min(diff,<span class="number">26</span>-diff);</span><br><span class="line">            curr = c;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5835-最大方阵和"><a href="#5835-最大方阵和" class="headerlink" title="5835. 最大方阵和"></a>5835. 最大方阵和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>n x n</code> 的整数方阵 <code>matrix</code> 。你可以执行以下操作 任意次 ：</p><p>选择 <code>matrix</code> 中 相邻 两个元素，并将它们都 乘以 <code>-1</code> 。<br>如果两个元素有 公共边 ，那么它们就是 相邻 的。</p><p>你的目的是 最大化 方阵元素的和。请你在执行以上操作之后，返回方阵的 最大 和。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">-1</span>],[<span class="number">-1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：我们可以执行以下操作使和等于 <span class="number">4</span> ：</span><br><span class="line">- 将第一行的 <span class="number">2</span> 个元素乘以 <span class="number">-1</span> 。</span><br><span class="line">- 将第一列的 <span class="number">2</span> 个元素乘以 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：我们可以执行以下操作使和等于 <span class="number">16</span> ：</span><br><span class="line">- 将第二行的最后 <span class="number">2</span> 个元素乘以 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>2 &lt;= n &lt;= 250</code></li><li><code>-105 &lt;= matrix[i][j] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-matrix-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-matrix-sum</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>几个重要结论：</li></ol><ul><li>我们可以通过变换，将正负号在任意元素中惊醒传递，类似于图的边。</li><li>如果存在元素为$0$,则我们总可以将负号传递给元素$0$,则此时矩阵中所有元素均为非负整数;</li><li>如果存在偶数个负数，则我们总可以通过传递，将其全部变为正数；</li><li>如果存在奇数个负数，则我们总可以通过传递，最终只剩下一个负数。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxMatrixSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minval = INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                ans += <span class="built_in">abs</span>(matrix[i][j]);</span><br><span class="line">                minval = min(minval,<span class="built_in">abs</span>(matrix[i][j]));</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>) zero++;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] &lt; <span class="number">0</span>) neg++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((neg%<span class="number">2</span>) &amp;&amp; zero == <span class="number">0</span>) <span class="keyword">return</span> ans - <span class="number">2</span>*minval;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5836-到达目的地的方案数"><a href="#5836-到达目的地的方案数" class="headerlink" title="5836. 到达目的地的方案数"></a>5836. 到达目的地的方案数</h2><p>你在一个城市里，城市由<code>n</code>个路口组成，路口编号为<code>0</code>到<code>n - 1</code> ，某些路口之间有 双向 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。</p><p>给你一个整数 <code>n</code>和二维整数数组 <code>roads</code> ，其中<code>roads[i] = [ui, vi, timei]</code> 表示在路口 <code>ui</code> 和 <code>vi</code> 之间有一条需要花费 <code>timei</code> 时间才能通过的道路。你想知道花费 最少时间 从路口 <code>0</code> 出发到达路口<code>n - 1</code>的方案数。</p><p>请返回花费 最少时间 到达目的地的 路径数目 。由于答案可能很大，将结果对 <code>109 + 7</code> 取余 后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, roads = [[<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：从路口 <span class="number">0</span> 出发到路口 <span class="number">6</span> 花费的最少时间是 <span class="number">7</span> 分钟。</span><br><span class="line">四条花费 <span class="number">7</span> 分钟的路径分别为：</span><br><span class="line">- <span class="number">0</span> ➝ <span class="number">6</span></span><br><span class="line">- <span class="number">0</span> ➝ <span class="number">4</span> ➝ <span class="number">6</span></span><br><span class="line">- <span class="number">0</span> ➝ <span class="number">1</span> ➝ <span class="number">2</span> ➝ <span class="number">5</span> ➝ <span class="number">6</span></span><br><span class="line">- <span class="number">0</span> ➝ <span class="number">1</span> ➝ <span class="number">3</span> ➝ <span class="number">5</span> ➝ <span class="number">6</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, roads = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">10</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只有一条从路口 <span class="number">0</span> 到路口 <span class="number">1</span> 的路，花费 <span class="number">10</span> 分钟。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 200</code></li><li><code>n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li><li><code>roads[i].length == 3</code></li><li><code>0 &lt;= ui, vi &lt;= n - 1</code></li><li><code>1 &lt;= timei &lt;= 109</code></li><li><code>ui != vi</code></li><li>任意两个路口之间至多有一条路。</li><li>从任意路口出发，你能够到达其他任意路口</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-arrive-at-destination" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-arrive-at-destination</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra + dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们可以利用<code>dijistra</code>算法，求出从<code>0</code>点到各点的最短距离。</li><li>其次为了保证<code>dp</code>的正确性，即每个点的顺序访问时满足从前到后，则我们需要将每个点按照该点到<code>0</code>点的距离大小进行排序。</li><li>其次我们即可使用<code>dp</code>的算法，每次发现从当前点到下一点的距离刚好为最小值上，则将可能的路径数向后传递即可。</li><li>算法时间复杂度为$O(n^{2} + n + m)$,空间复杂度为$(n + m)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPaths</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = roads.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dist(n,LLONG_MAX);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: roads)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(&#123;v[<span class="number">0</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        qu.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.first])&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> cost = (<span class="keyword">long</span> <span class="keyword">long</span>)curr.second + v.second;</span><br><span class="line">                <span class="keyword">if</span>(dist[v.first] &gt; cost)&#123;</span><br><span class="line">                    dist[v.first] = cost;</span><br><span class="line">                    qu.push(&#123;v.first,cost&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr.push_back(&#123;dist[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = arr[i].second;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> c = arr[i].first;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(c + v.second == dist[v.first])&#123;</span><br><span class="line">                    dp[v.first] = (dp[v.first] + dp[x])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5837-划分数字的方案数"><a href="#5837-划分数字的方案数" class="headerlink" title="5837. 划分数字的方案数"></a>5837. 划分数字的方案数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你写下了若干 正整数 ，并将它们连接成了一个字符串  <code>num</code> 。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 非递减 的且 没有 任何数字有前导 0 。</p><p>请你返回有多少种可能的 正整数数组 可以得到字符串 <code>num</code> 。由于答案可能很大，将结果对 <code>109 + 7</code> 取余 后返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"327"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：以下为可能的方案：</span><br><span class="line"><span class="number">3</span>, <span class="number">27</span></span><br><span class="line"><span class="number">327</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"094"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不能有数字有前导 <span class="number">0</span> ，且所有数字均为正数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"0"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不能有数字有前导 <span class="number">0</span> ，且所有数字均为正数。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"9999999999999"</span></span><br><span class="line">输出：<span class="number">101</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 3500</code></li><li><code>num</code> 只含有数字 <code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code>。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-separate-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-separate-numbers</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本题难度较大，其实仔细思考了非常长的时间才有结果。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-59&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-59&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 59&quot;&gt;&lt;/a&gt;leetcode biweekly contest 59&lt;/h1&gt;&lt;p&gt;双周赛的题目质量很高，出的非常不错的题目&lt;/p&gt;&lt;h2 id=&quot;5850-找出数组的最大公约数&quot;&gt;&lt;a href=&quot;#5850-找出数组的最大公约数&quot; class=&quot;headerlink&quot; title=&quot;5850. 找出数组的最大公约数&quot;&gt;&lt;/a&gt;5850. 找出数组的最大公约数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用特殊打字机键入单词的最少时间&lt;br&gt;有一个特殊打字机，它由一个 圆盘 和一个 指针 组成， 圆盘上标有小写英文字母 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 到 &lt;code&gt;&amp;#39;z&amp;#39;&lt;/code&gt;。只有 当指针指向某个字母时，它才能被键入。指针 初始时 指向字符 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 255</title>
    <link href="http://yoursite.com/2021/08/22/317/"/>
    <id>http://yoursite.com/2021/08/22/317/</id>
    <published>2021-08-22T08:56:47.708Z</published>
    <updated>2021-08-22T13:06:41.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-255"><a href="#leetcode-contest-255" class="headerlink" title="leetcode contest 255"></a>leetcode contest 255</h1><p>周赛的第四题好难，没想出来，还算脑力不够，只能靠努力来补。<br><img src="https://i.loli.net/2021/08/22/PRk9gEplMtzKVQZ.png" alt></p><h2 id="5850-找出数组的最大公约数"><a href="#5850-找出数组的最大公约数" class="headerlink" title="5850. 找出数组的最大公约数"></a>5850. 找出数组的最大公约数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>找出数组的最大公约数 显示英文描述<br>给你一个整数数组 <code>nums</code> ，返回数组中最大数和最小数的 最大公约数 。</li></ol><p>两个数的 最大公约数 是能够被两个数整除的最大正整数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">nums 中最小的数是 <span class="number">2</span></span><br><span class="line">nums 中最大的数是 <span class="number">10</span></span><br><span class="line"><span class="number">2</span> 和 <span class="number">10</span> 的最大公约数是 <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">nums 中最小的数是 <span class="number">3</span></span><br><span class="line">nums 中最大的数是 <span class="number">8</span></span><br><span class="line"><span class="number">3</span> 和 <span class="number">8</span> 的最大公约数是 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">nums 中最小的数是 <span class="number">3</span></span><br><span class="line">nums 中最大的数是 <span class="number">3</span></span><br><span class="line"><span class="number">3</span> 和 <span class="number">3</span> 的最大公约数是 <span class="number">3</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= nums.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">1000</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-255/problems/find-greatest-common-divisor-of-array/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力检测</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 我们找到数组中的最大值和最小值，然后取公约数即可，简单题目。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findGCD(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> __gcd(nums[<span class="number">0</span>],nums.back());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="5851-找出不同的二进制字符串"><a href="#5851-找出不同的二进制字符串" class="headerlink" title="5851. 找出不同的二进制字符串"></a>5851. 找出不同的二进制字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>nums</code> ，该数组由<code>n</code> 个 互不相同 的二进制字符串组成，且每个字符串长度都是 <code>n</code>。请你找出并返回一个长度为 <code>n</code> 且 没有出现 在 <code>nums</code> 中的二进制字符串。如果存在多种答案，只需返回 任意一个 即可。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="string">"01"</span>,<span class="string">"10"</span>]</span><br><span class="line">输出：<span class="string">"11"</span></span><br><span class="line">解释：<span class="string">"11"</span> 没有出现在 nums 中。<span class="string">"00"</span> 也是正确答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="string">"00"</span>,<span class="string">"01"</span>]</span><br><span class="line">输出：<span class="string">"11"</span></span><br><span class="line">解释：<span class="string">"11"</span> 没有出现在 nums 中。<span class="string">"10"</span> 也是正确答案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"111"</span>,<span class="string">"011"</span>,<span class="string">"001"</span>]</span><br><span class="line">输出：<span class="string">"101"</span></span><br><span class="line">解释：<span class="string">"101"</span> 没有出现在 nums 中。<span class="string">"000"</span>、<span class="string">"010"</span>、<span class="string">"100"</span>、<span class="string">"110"</span> 也是正确答案。</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">提示：</span></span><br><span class="line"><span class="string">+ `</span>n == nums.length<span class="string">`</span></span><br><span class="line"><span class="string">+ `</span><span class="number">1</span> &lt;= n &lt;= <span class="number">16</span><span class="string">`</span></span><br><span class="line"><span class="string">+ `</span>nums[i].length == n<span class="string">`</span></span><br><span class="line"><span class="string">+ `</span>nums[i] 为 <span class="string">'0'</span> 或 <span class="string">'1'</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 地址</span></span><br><span class="line"><span class="string">https://leetcode-cn.com/problems/find-unique-binary-string</span></span><br><span class="line"><span class="string">### 题意</span></span><br><span class="line"><span class="string">&gt;  字符串编码</span></span><br><span class="line"><span class="string">### 思路</span></span><br><span class="line"><span class="string">1. 两种思路，我们直到字符串的编码只会在$0~(2^&#123;n&#125;-1)$中，我们在范围中找到一个在字符串中没有出现的数字接口，然后将其转换为字符串编码。</span></span><br><span class="line"><span class="string">2. 我们将字符串编码按照字典序的大小来排序，找到一个不存在的编码即可。</span></span><br><span class="line"><span class="string">### 代码</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">string</span> findDifferentBinaryString(<span class="keyword">vector</span>&lt;<span class="keyword">string</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums[<span class="number">0</span>].<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">string</span> ans;</span><br><span class="line">        unordered_set&lt;<span class="keyword">string</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(auto w : nums) cnt.insert(w);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">string</span> curr;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) curr.push_back(<span class="string">'0'</span>);       </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">0</span>; j = j/<span class="number">2</span>)&#123;</span><br><span class="line">                curr.push_back(<span class="string">'0'</span> + j%2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">string</span> zero;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-curr.<span class="keyword">size</span>(); ++j)&#123;</span><br><span class="line">                zero.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            curr = zero + curr;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(curr)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5852-最小化目标值与所选元素的差"><a href="#5852-最小化目标值与所选元素的差" class="headerlink" title="5852. 最小化目标值与所选元素的差"></a>5852. 最小化目标值与所选元素的差</h2><p>给你一个大小为 <code>m x n</code>的整数矩阵<code>mat</code>和一个整数<code>target</code> 。<br>从矩阵的 每一行 中选择一个整数，你的目标是 最小化 所有选中元素之 和 与目标值 <code>target</code>的 绝对差 。<br>返回 最小的绝对差 。<br><code>a</code> 和 <code>b</code>两数字的 绝对差 是 <code>a - b</code>的绝对值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]], target = <span class="number">13</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：一种可能的最优选择方案是：</span><br><span class="line">- 第一行选出 <span class="number">1</span></span><br><span class="line">- 第二行选出 <span class="number">5</span></span><br><span class="line">- 第三行选出 <span class="number">7</span></span><br><span class="line">所选元素的和是 <span class="number">13</span> ，等于目标值，所以绝对差是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]], target = <span class="number">100</span></span><br><span class="line">输出：<span class="number">94</span></span><br><span class="line">解释：唯一一种选择方案是：</span><br><span class="line">- 第一行选出 <span class="number">1</span></span><br><span class="line">- 第二行选出 <span class="number">2</span></span><br><span class="line">- 第三行选出 <span class="number">3</span></span><br><span class="line">所选元素的和是 <span class="number">6</span> ，绝对差是 <span class="number">94</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>]], target = <span class="number">6</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最优的选择方案是选出第一行的 <span class="number">7</span> 。</span><br><span class="line">绝对差是 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= m, n &lt;= 70</code></li><li><code>1 &lt;= mat[i][j] &lt;= 70</code></li><li><code>1 &lt;= target &lt;= 800</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimize-the-difference-between-target-and-chosen-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimize-the-difference-between-target-and-chosen-elements</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 背包算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>根据题意我们只需要求矩阵每一行数组所有可能的组合即可，然后求出所有可能的组合中与$target$的最小值即可。我们发现矩阵最大可能组合的和为$m<em>70$,也即为$4900$,所以这时我们假如使用背包的话其实很容易，算法的时间复杂度为$O(m</em>70<em>m</em>n)$,是在可以接受的范围内，有没有可以优化的空间？.</li><li>我们仔细观察一下，由于$target$的数量很小，由于矩阵中的每个元素的值都大于$0$,其实我们只关心组合的和处在$[0,2<em>target]$之间的可能性，如果没有处在$[0,2</em>target]$之间的组合，则此时其实我们可以推论得出矩阵中每一行的最小元素之和与$target$的绝对值之差最小。超过$2*target$，我们其实可以不同关心。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>|<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.   </span><br><span class="line">0       target   2*target</span><br></pre></td></tr></table></figure></li><li>求组合就非常简单了，我们设<code>dp[i][j] = 1</code>表示矩阵前<code>i</code>行元素取每一行元素组合得到的和为<code>j</code>存在，<code>dp[i][j] = 0</code>表示矩阵前<code>i</code>行元素取每一行元素组合得到的和为<code>j</code>不存在，则我们求出所有可能的组合。我们直到下面的组合的可能性推导：<script type="math/tex; mode=display">dp[i+1][j+mat[i+1][x]] = dp[i][j]</script>所以我们只需要直到上述的推理传递过程即可。</li><li>时间复杂度为$O(m<em>n</em>target<em>2$,空间复杂度为$O(target</em>2)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimizeTheDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> large = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">2</span>*target+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ndp(<span class="number">2</span>*target+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">            sort(mat[i].begin(),mat[i].end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>*target; ++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[k] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(k + mat[i][j] &lt;= <span class="number">2</span>*target)&#123;</span><br><span class="line">                            ndp[k + mat[i][j]] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr += mat[i][<span class="number">0</span>];</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">abs</span>(target-curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*target; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; <span class="number">0</span>)</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(target-i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5853-从子集的和还原数组"><a href="#5853-从子集的和还原数组" class="headerlink" title="5853. 从子集的和还原数组"></a>5853. 从子集的和还原数组</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>存在一个未知数组需要你进行还原，给你一个整数 n 表示该数组的长度。另给你一个数组 <code>sums</code> ，由未知数组中全部 <code>2n</code>个 子集的和 组成（子集中的元素没有特定的顺序）。<br>返回一个长度为 <code>n</code> 的数组 <code>ans</code> 表示还原得到的未知数组。如果存在 多种 答案，只需返回其中 任意一个 。<br>如果可以由数组 <code>arr</code> 删除部分元素（也可能不删除或全删除）得到数组 sub ，那么数组 <code>sub</code> 就是数组 <code>arr</code> 的一个 子集 。<code>sub</code>的元素之和就是 <code>arr</code> 的一个 子集的和 。一个空数组的元素之和为<code>0</code>。<br>注意：生成的测试用例将保证至少存在一个正确答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, sums = [<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>]</span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>] 能够满足给出的子集的和：</span><br><span class="line">- []：和是 <span class="number">0</span></span><br><span class="line">- [<span class="number">1</span>]：和是 <span class="number">1</span></span><br><span class="line">- [<span class="number">2</span>]：和是 <span class="number">2</span></span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>]：和是 <span class="number">3</span></span><br><span class="line">- [<span class="number">-3</span>]：和是 <span class="number">-3</span></span><br><span class="line">- [<span class="number">1</span>,<span class="number">-3</span>]：和是 <span class="number">-2</span></span><br><span class="line">- [<span class="number">2</span>,<span class="number">-3</span>]：和是 <span class="number">-1</span></span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>]：和是 <span class="number">0</span></span><br><span class="line">注意，[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>] 的任何排列和 [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">3</span>] 的任何排列都会被视作正确答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, sums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：唯一的正确答案是 [<span class="number">0</span>,<span class="number">0</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, sums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">5</span>] 能够满足给出的子集的和。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">15</span>`</span><br><span class="line">+ `sums.length == <span class="number">2</span>n`</span><br><span class="line">+ `<span class="number">-104</span> &lt;= sums[i] &lt;= <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/find-array-given-subset-sums</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学问题</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 参考从sums 中所有元素均为非负数子集sums恢复数组的做法，就可以很容易得出结论。这个题目没有做出来，参考了答案感觉确实非常好的值得思考的题目。</span><br><span class="line"><span class="number">2.</span> 我们假设数组中所有元素都为非负整数，则我们可以知道数组中最小的元素即为$sums[<span class="number">1</span>] - sums[<span class="number">0</span>]$.最终重要的退路如下：</span><br><span class="line">+ 第一个最小的元素肯定为$sums[<span class="number">1</span>] - sums[<span class="number">0</span>]$。</span><br><span class="line">+ 假设我们已经推出了数组的前`k`个最小的元素，则我们将属于这前`k`个元素的子集全部去掉，则此时剩下的元素中的最小值即为第`k+<span class="number">1</span>`个元素。</span><br><span class="line">+ 我们依次迭代即可得到第$<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>..n$个元素。</span><br><span class="line"><span class="number">3.</span> 如果数组中出现负数时，则此时我们将所有元素都加上所有负数的和的绝对值$m$，此时即可将所有的元素变为正数,则此时$sums$中的所有元素即为所有正数元素的和。</span><br><span class="line"><span class="number">4.</span> 恢复元素时，我们测试所有可能元素的集合是否等于$m$,如果存在元素的集合的和为$m$,则我们将该集合中所有的元素取反即可，即可将所有的元素进行恢复。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; recoverArray(<span class="built_in">int</span> n, vector&lt;<span class="built_in">int</span>&gt;&amp; sums) &#123;</span><br><span class="line">        map&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; st;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : sums) &#123;</span><br><span class="line">            b = min(b,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) b = -b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : sums) st[b+v]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//remove zero</span></span><br><span class="line">        st[<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(st[<span class="number">0</span>] == <span class="number">0</span>) st.erase(<span class="number">0</span>);</span><br><span class="line">        ans.push_back(st.begin()-&gt;first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = (<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)); j &lt; (<span class="number">1</span>&lt;&lt;i); j++)&#123;</span><br><span class="line">                <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; i; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;k))&#123;</span><br><span class="line">                        curr += ans[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st[curr]--;</span><br><span class="line">                <span class="keyword">if</span>(st[curr] == <span class="number">0</span>) st.erase(curr);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(st.begin()-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) curr += ans[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == b)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) ans[j] = -ans[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-255&quot;&gt;&lt;a href=&quot;#leetcode-contest-255&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 255&quot;&gt;&lt;/a&gt;leetcode contest 255&lt;/h1&gt;&lt;p&gt;周赛的第四题好难，没想出来，还算脑力不够，只能靠努力来补。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/22/PRk9gEplMtzKVQZ.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5850-找出数组的最大公约数&quot;&gt;&lt;a href=&quot;#5850-找出数组的最大公约数&quot; class=&quot;headerlink&quot; title=&quot;5850. 找出数组的最大公约数&quot;&gt;&lt;/a&gt;5850. 找出数组的最大公约数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;找出数组的最大公约数 显示英文描述&lt;br&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，返回数组中最大数和最小数的 最大公约数 。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;两个数的 最大公约数 是能够被两个数整除的最大正整数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最小的数是 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最大的数是 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 的最大公约数是 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最小的数是 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最大的数是 &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; 的最大公约数是 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最小的数是 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最大的数是 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 的最大公约数是 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ `&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;lt;= nums.length &amp;lt;= &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ `&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;= nums[i] &amp;lt;= &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 地址 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&lt;span class=&quot;comment&quot;&gt;//leetcode-cn.com/contest/weekly-contest-255/problems/find-greatest-common-divisor-of-array/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 题意&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;   暴力检测&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 思路&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 我们找到数组中的最大值和最小值，然后取公约数即可，简单题目。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```c++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; findGCD(vector&amp;lt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(nums.begin(),nums.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __gcd(nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],nums.back());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab4 Traps</title>
    <link href="http://yoursite.com/2021/08/19/316/"/>
    <id>http://yoursite.com/2021/08/19/316/</id>
    <published>2021-08-19T01:00:50.977Z</published>
    <updated>2021-08-20T14:10:21.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="traps"><a href="#traps" class="headerlink" title="traps"></a>traps</h1><p>最近封闭在家，没事干，只能刷题图开心，感觉MIT的lab刷起来真心是有意思，有挑战，难度很高，非常有思维挑战性，代码量倒是不是特别大。<br>特别<code>alarm</code>这个功能，思维确实比较牛逼，不过最重要的还算要看textbook，而不是忙着刷题，先把textbook看熟之后，再来刷题。<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-traps-handin" target="_blank" rel="noopener">git repo</a></p><h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><a id="more"></a><p>这个<code>lab</code>主要事熟悉risc-v汇编语言的基本语法，跟x86的语法很不同的是，函数的参数不是压入栈，而是存放在寄存器中，所以我们在调试时需要注意这个问题，典型的X86的栈如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">arg[n-1]</span><br><span class="line">arg[n-2]</span><br><span class="line">arg[n-3]</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">arg[0]</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">return address-----------&gt;frame pointer</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>   |</span><br><span class="line">prev  frame      |</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>   |</span><br><span class="line">saved register   |</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>   |</span><br><span class="line">Local variable   |</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>&lt;----|</span><br><span class="line"><span class="built_in">..</span></span><br><span class="line"><span class="built_in">..</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><br>risc-v的栈帧最大的区别就是函数的参数可能并不在栈上存储，可能在寄存器中存储。所以我觉得还算是非常容易理解的lab，采用risck gdb调试即可。</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p><code>backtrace</code>这一个lab可以说是为了能够深刻理解<code>stack machine</code>机制的设计的，每当调用函数时，首先需要将返回地址，之前的栈帧地址入栈，由于risck-v存储是以Little-Endian存储的，而栈空间的地址也是从高地址往低地址增长的，所以当前的栈帧的偏移8个字节即为<code>return address</code>，我们需要每次打印出返回地址，同时偏移16个字节则为前一个栈帧的地址，我们依次往前寻找，直到当前的栈帧的起始地址为<code>PGROUNDUP(fp)</code>，我们直到risc-v中每个栈空间的大小为4096byte，所以我们可以快速计算出栈顶和栈底的地址：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="keyword">bottom </span>= PGROUNDUP(<span class="built_in">fp</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>每次我们可以读寄存器fp即可得到当前栈的栈帧指向的地址，代码实现其实非常简单，但是需要仔细思考其中的原理。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add by mike meng</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">    uint64 fp = r_fp();</span><br><span class="line">uint64 bottom = PGROUNDUP(fp);</span><br><span class="line">uint64 address;</span><br><span class="line"><span class="keyword">char</span> path[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">int</span> line;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"backtrace:\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//printf("%p\n",*((uint64 *)(fp-8)));</span></span><br><span class="line">address = *((uint64 *)(fp<span class="number">-8</span>));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">ltaddr2line(address,path,&amp;line);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pc = %p, %s:%d\n"</span>,address,path,line);</span><br><span class="line">fp = *((uint64 *)(fp<span class="number">-16</span>));</span><br><span class="line">    <span class="keyword">if</span>(fp &gt;= bottom) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>这个<code>alarm</code>的lab还真心很难，想了很长时间没有想出来，后来看了好多参考书才有了一点眉目。首先需要了解<code>CPU</code>对于trap的处理原理，刚开始确实没有仔细阅读材料，导致浪费了很多时间。不过这门课程的视频课程讲的真心很好，感觉还是不能单看<code>textbook</code>。首先我们需要仔细理解<code>xv6</code>系统的<code>trap</code>的处理流程：<br><img src="https://i.loli.net/2021/08/20/UdOR1sVEX9xISYg.png" alt><br>上图为标准的syscall的处理流程。基本处理流程如下，<code>stvec</code>寄存器中设置的<code>trap</code>处理的入口地址处，一旦有<code>trap</code>需要处理时，首先CPU会把<code>PC</code>跳转到<code>stvec</code>寄存器设置的入口地址处,一般我们我们需要处理<code>usertrap</code>和<code>kernel trap</code>.trap的处理流程基本相似：<br><img src="https://i.loli.net/2021/08/20/HBkiRNlXGYn4sbU.png" alt></p><ul><li><code>kernel trap</code>：kernel trap主要处理设备的特殊中断请求。</li><li><code>usertrap</code>：user trap主要处理用户进程的trap处理。流程稍微复杂一点。最重要的两个函数为<code>usertrap</code>和<code>usertrapret</code>。我们仔细查找一下<code>usertrap</code>的入口函数，发现很难找到。实际上入口都是用汇编来完成，我们首先看一下<code>uservec</code>的具体内容用汇编实现的：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">#</span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="meta"># traps from user space start here,</span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="meta"># user page table.</span></span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process's p-&gt;trapframe is</span><br><span class="line">        <span class="meta"># mapped into user space, at TRAPFRAME.</span></span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">    <span class="meta"># swap a0 and sscratch</span></span><br><span class="line">        <span class="meta"># so that a0 is TRAPFRAME</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # 保存寄存器内容到TRAPFRAME所指向的地址上</span><br><span class="line">        <span class="meta"># save the user registers in TRAPFRAME</span></span><br><span class="line">        sd ra, <span class="number">40</span>(a0)</span><br><span class="line">        sd sp, <span class="number">48</span>(a0)</span><br><span class="line">        sd gp, <span class="number">56</span>(a0)</span><br><span class="line">        sd tp, <span class="number">64</span>(a0)</span><br><span class="line">        sd t0, <span class="number">72</span>(a0)</span><br><span class="line">        sd t1, <span class="number">80</span>(a0)</span><br><span class="line">        sd t2, <span class="number">88</span>(a0)</span><br><span class="line">        sd s0, <span class="number">96</span>(a0)</span><br><span class="line">        sd s1, <span class="number">104</span>(a0)</span><br><span class="line">        sd a1, <span class="number">120</span>(a0)</span><br><span class="line">        sd a2, <span class="number">128</span>(a0)</span><br><span class="line">        sd a3, <span class="number">136</span>(a0)</span><br><span class="line">        sd a4, <span class="number">144</span>(a0)</span><br><span class="line">        sd a5, <span class="number">152</span>(a0)</span><br><span class="line">        sd a6, <span class="number">160</span>(a0)</span><br><span class="line">        sd a7, <span class="number">168</span>(a0)</span><br><span class="line">        sd s2, <span class="number">176</span>(a0)</span><br><span class="line">        sd s3, <span class="number">184</span>(a0)</span><br><span class="line">        sd s4, <span class="number">192</span>(a0)</span><br><span class="line">        sd s5, <span class="number">200</span>(a0)</span><br><span class="line">        sd s6, <span class="number">208</span>(a0)</span><br><span class="line">        sd s7, <span class="number">216</span>(a0)</span><br><span class="line">        sd s8, <span class="number">224</span>(a0)</span><br><span class="line">        sd s9, <span class="number">232</span>(a0)</span><br><span class="line">        sd s10, <span class="number">240</span>(a0)</span><br><span class="line">        sd s11, <span class="number">248</span>(a0)</span><br><span class="line">        sd t3, <span class="number">256</span>(a0)</span><br><span class="line">        sd t4, <span class="number">264</span>(a0)</span><br><span class="line">        sd t5, <span class="number">272</span>(a0)</span><br><span class="line">        sd t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">        # 将a0用户的寄存器保存到frame上</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, <span class="number">112</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span></span><br><span class="line">        ld sp, <span class="number">8</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span><br><span class="line">        ld tp, <span class="number">32</span>(a0)</span><br><span class="line"></span><br><span class="line">        # 将usertrap的入口地址写给a0</span><br><span class="line">        <span class="meta"># load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span></span><br><span class="line">        ld t0, <span class="number">16</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span></span><br><span class="line">        # 将kernel的pagetable写入到satp寄存器，并刷新页表</span><br><span class="line">        ld t1, <span class="number">0</span>(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        <span class="meta"># table does not specially map p-&gt;tf.</span></span><br><span class="line"></span><br><span class="line">        # 跳转到usertrap()</span><br><span class="line">        <span class="meta"># jump to usertrap(), which does not return</span></span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>大致就是保存寄存器到<code>tramfram</code>上,然后<code>kstack</code>的地址写入sp寄存器，将hartid标记位写入到寄存器中，将<code>kernel</code>的页表写入到<code>satp</code>寄存器中，然后跳转到<code>usertrap</code>中，usertrap函数以下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取当前模式，是否为 user trap</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  <span class="comment">// interrupts process will be set to kernelvec.</span></span><br><span class="line">  <span class="comment">// 将trap的入口设置为kernel trap</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  <span class="comment">// 保存当前的pc值</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//if the interrupts is system call</span></span><br><span class="line">  <span class="comment">// 判断当前的trap类型</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;<span class="comment">// 系统调用</span></span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    <span class="comment">// 如果为系统调用，则将恢复的PC指向它的下一个指令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    <span class="comment">//open interrrupt</span></span><br><span class="line">    <span class="comment">// 关闭 trap，打开中断处理</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line"><span class="comment">// system call</span></span><br><span class="line">    <span class="comment">// 处理系统调用</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常trap,则直接关闭当前进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p-&gt;alarmworking &amp;&amp; p-&gt;alarminterval &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  p-&gt;alarmtick++;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarmtick == p-&gt;alarminterval)&#123;</span><br><span class="line"><span class="comment">//p-&gt;alarmhandler();</span></span><br><span class="line"><span class="comment">//p-&gt;alarmretaddr = p-&gt;trapframe-&gt;epc;</span></span><br><span class="line"><span class="comment">// we set the epc point  to the alarm handler</span></span><br><span class="line"><span class="comment">// when we leave from the trap process,we will get to the alarm handler</span></span><br><span class="line">memmove(&amp;p-&gt;alarmtrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarmhandler;</span><br><span class="line">    p-&gt;alarmtick = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarmworking = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复</span></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>userret</code>：我们从<code>userret</code>的相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">        <span class="meta"># userret(TRAPFRAME, pagetable)</span></span><br><span class="line">        <span class="meta"># switch from kernel to user.</span></span><br><span class="line">        <span class="meta"># usertrapret() calls here.</span></span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, <span class="keyword">for</span> satp.</span><br><span class="line"></span><br><span class="line">        <span class="meta"># switch to the user page table.</span></span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># put the saved user a0 in sscratch, so we</span></span><br><span class="line">        <span class="meta"># can swap it with our a0 (TRAPFRAME) in the last step.</span></span><br><span class="line">        ld t0, <span class="number">112</span>(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore all but a0 from TRAPFRAME</span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld sp, <span class="number">48</span>(a0)</span><br><span class="line">        ld gp, <span class="number">56</span>(a0)</span><br><span class="line">        ld tp, <span class="number">64</span>(a0)</span><br><span class="line">        ld t0, <span class="number">72</span>(a0)</span><br><span class="line">        ld t1, <span class="number">80</span>(a0)</span><br><span class="line">        ld t2, <span class="number">88</span>(a0)</span><br><span class="line">        ld s0, <span class="number">96</span>(a0)</span><br><span class="line">        ld s1, <span class="number">104</span>(a0)</span><br><span class="line">        ld a1, <span class="number">120</span>(a0)</span><br><span class="line">        ld a2, <span class="number">128</span>(a0)</span><br><span class="line">        ld a3, <span class="number">136</span>(a0)</span><br><span class="line">        ld a4, <span class="number">144</span>(a0)</span><br><span class="line">        ld a5, <span class="number">152</span>(a0)</span><br><span class="line">        ld a6, <span class="number">160</span>(a0)</span><br><span class="line">        ld a7, <span class="number">168</span>(a0)</span><br><span class="line">        ld s2, <span class="number">176</span>(a0)</span><br><span class="line">        ld s3, <span class="number">184</span>(a0)</span><br><span class="line">        ld s4, <span class="number">192</span>(a0)</span><br><span class="line">        ld s5, <span class="number">200</span>(a0)</span><br><span class="line">        ld s6, <span class="number">208</span>(a0)</span><br><span class="line">        ld s7, <span class="number">216</span>(a0)</span><br><span class="line">        ld s8, <span class="number">224</span>(a0)</span><br><span class="line">        ld s9, <span class="number">232</span>(a0)</span><br><span class="line">        ld s10, <span class="number">240</span>(a0)</span><br><span class="line">        ld s11, <span class="number">248</span>(a0)</span><br><span class="line">        ld t3, <span class="number">256</span>(a0)</span><br><span class="line">        ld t4, <span class="number">264</span>(a0)</span><br><span class="line">        ld t5, <span class="number">272</span>(a0)</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># restore user a0, and save TRAPFRAME in sscratch</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># return to user mode and user pc.</span></span><br><span class="line">        <span class="meta"># usertrapret() set up sstatus and sepc.</span></span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p>处理流程为首先将用户的页表切换到寄存器中，然后从<code>trapframe</code>中取出已经保存的值，将其恢复到寄存器中，然后将<code>trapframe</code>进行恢复到默认值，将PC的值恢复到之前的值，指令将会继续之前的PC的值进行执行。</p></li><li><p>我们实际在处理sigalarm时，首先需要将<code>sigalarm</code>和<code>sigalarmret</code>函数处理加入到<code>system call</code>中，然后在处理<code>usertrap</code>时，首先我们需要处理来自<code>timer</code>的trap,此时我们可以将<code>trap</code>恢复后的<code>pc</code>指向<code>alarmhandler</code>函数，我们运行时，即可发现可以运行<code>handler</code>函数，但是运行完成后，发现出了不少问题。我们仔细思考就可以发现，因为<code>PC</code>指向的指令地址改变后，我们可以仔细分析一下，函数执行时，我们看到当前栈帧返回时会返回正确的地址，因为此时<code>RA</code>寄存器存放的为正确的return address.但是periodic函数在执行过程中可能会将其中的寄存器污染，所以会出现<code>alarm</code>打印逻辑出错。所以我们在执行<code>handler</code>时，必须要将相关的寄存器进行保存，保存完成后再执行<code>handler</code>，执行完成<code>handler</code>后，我们再恢复寄存器，同时恢复<code>pc</code>.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">periodic()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="number">0</span>:<span class="number">1141</span>                addisp,sp,<span class="number">-16</span></span><br><span class="line">   <span class="number">2</span>:e406                sdra,<span class="number">8</span>(sp)</span><br><span class="line">   <span class="number">4</span>:e022                sds0,<span class="number">0</span>(sp)</span><br><span class="line">   <span class="number">6</span>:<span class="number">0800</span>                addis0,sp,<span class="number">16</span></span><br><span class="line">  count = count + <span class="number">1</span>;</span><br><span class="line">   <span class="number">8</span>:<span class="number">00001797</span>          auipca5,<span class="number">0x1</span></span><br><span class="line">   c:d407a783          lwa5,<span class="number">-704</span>(a5) # d48 &lt;count&gt;</span><br><span class="line">  <span class="number">10</span>:<span class="number">2785</span>                addiwa5,a5,<span class="number">1</span></span><br><span class="line">  <span class="number">12</span>:<span class="number">00001717</span>          auipca4,<span class="number">0x1</span></span><br><span class="line">  <span class="number">16</span>:d2f72b23          swa5,<span class="number">-714</span>(a4) # d48 &lt;count&gt;</span><br><span class="line">  printf(<span class="string">"alarm!\n"</span>);</span><br><span class="line">  <span class="number">1</span>a:<span class="number">00001517</span>          auipca0,<span class="number">0x1</span></span><br><span class="line">  <span class="number">1</span>e:b6650513          addia0,a0,<span class="number">-1178</span> # b80 &lt;malloc+<span class="number">0xea</span>&gt;</span><br><span class="line">  <span class="number">22</span>:<span class="number">00001097</span>          auipcra,<span class="number">0x1</span></span><br><span class="line">  <span class="number">26</span>:<span class="number">9</span>b6080e7          jalr<span class="number">-1610</span>(ra) # <span class="number">9</span>d8 &lt;printf&gt;</span><br><span class="line">  sigreturn();</span><br><span class="line">  <span class="number">2</span>a:<span class="number">00000097</span>          auipcra,<span class="number">0x0</span></span><br><span class="line">  <span class="number">2</span>e:<span class="number">6</span>c6080e7          jalr<span class="number">1734</span>(ra) # <span class="number">6f</span>0 &lt;sigreturn&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>刚开始我的想法是再申请一个物理页，然后用汇编将所有的寄存器的值，都保存到这个新申请的物理页中，待到函数执行完成后，我们再利用系统调用，将该物理页中保存的值再重新加载到寄存器中，刚开始想着是模仿<code>userret</code>和<code>uservec</code>的汇编代码来模仿实现。后来感觉太复杂了，看了提示之后，在进入<code>alarm handler</code>之前所有的寄存器其实都已经全部保存在tramp fram中，我们可以申请新的tramp fram结构，在<code>usertrapret</code>恢复寄存器时，暂时不恢复寄存器的值，只是将<code>PC</code>的值进行跳转。在<code>alarmreturn</code>时，此时我们再将已经保存的tramp fram中的寄存器和<code>PC</code>的值全部切换回去即可。</li></ul><ol><li><code>alarm</code>时，我们将handler和interval进行指定保存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ticks;</span><br><span class="line">    uint64 ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(argaddr(<span class="number">1</span>,&amp;ptr) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br><span class="line">p-&gt;alarmworking = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarminterval = ticks;</span><br><span class="line">p-&gt;alarmhandler = (func)ptr;</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>执行trap时，如果当前的ticks达到<code>alarminterval</code>时，则我们首先将<code>PC</code>的返回值替换为<code>handler</code>的入口地址，同时将当前<code>trap frame</code>的值进行保存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p-&gt;alarmworking &amp;&amp; p-&gt;alarminterval &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  p-&gt;alarmtick++;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarmtick == p-&gt;alarminterval)&#123;</span><br><span class="line"><span class="comment">//p-&gt;alarmhandler();</span></span><br><span class="line"><span class="comment">//p-&gt;alarmretaddr = p-&gt;trapframe-&gt;epc;</span></span><br><span class="line"><span class="comment">// we set the epc point  to the alarm handler</span></span><br><span class="line"><span class="comment">// when we leave from the trap process,we will get to the alarm handler</span></span><br><span class="line">memmove(&amp;p-&gt;alarmtrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarmhandler;</span><br><span class="line">    p-&gt;alarmtick = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarmworking = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>执行<code>sigreturn</code>时，则我们将保存的<code>tramfram</code>切换回去即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;alarmworking)&#123;</span><br><span class="line">memmove(p-&gt;trapframe,&amp;p-&gt;alarmtrap,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    p-&gt;alarmworking = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-challenge"><a href="#Optional-challenge" class="headerlink" title="Optional challenge"></a>Optional challenge</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print <span class="keyword">the</span> names <span class="keyword">of</span> <span class="keyword">the</span> functions <span class="keyword">and</span> <span class="built_in">line</span> numbers <span class="keyword">in</span> backtrace() instead <span class="keyword">of</span> numerical addresses</span><br></pre></td></tr></table></figure>按照要求对<code>backtrace</code>进行扩展，使得其能够打印出相应的文件和行号，刚开始拿到这个以为很简单，但是实际上实现起来还是挺复杂。主要查找的信息来源于<code>addr2line</code>的实现，在github上找了一堆实现<code>addr2line</code>的代码，后来发现一个<code>c++</code>还凑合，就拿过来读了一下，然后通过查找<code>debug_line</code>的具体参数定义，然后找到dwarf 3.0的标准，对战标准和代码把相关的功能全部重新移植到xv6上，虽然代码写的很烂，但是凑合还能用吧，其中<code>debug</code>的时间还挺长。具体实现原理如下：</li><li>改写makefile,把生成kernel的elf文件做到文件系统中，然后系统运行后，通过用户进程调用函数读取和解析elf文件，这里最大的坑是用户进程未初始化时，我直接用内核读取文件，发现会<code>panic</code>,后来仔细检查了很多遍，发现因为在内核文件的读取都会加载进程的文件锁，而这时用户进行还未初始化，这时如果去调用mypoc函数就会出现指针跑飞的问题。解决办法只有等待用户进行调度起来后，可以单独起一个用户进程读取和解析elf文件。</li><li>系统起来后，在内核空间中从文件系统读取elf文件，找到.debug_line这个section，然后按照dwarf 3.0的标准来解析header和opcode，具体可以Google相关的标准，标准本身还是挺复杂的，具体实现时参考这个github的代码：<a href="https://github.com/evmar/maddr" target="_blank" rel="noopener">https://github.com/evmar/maddr</a> ，里面解析opcode时有不少小bug，关键时刻还算看标准靠谱。</li><li>解析完成后，将解析生成的matrix放入到数组中，然后我们对line table按照地址从小到大进行排序，我们解析的line table中也可以看到每行代码可能会对应多个<code>instruction</code>，我们直到<code>pc</code>每次递增的。每次进行查询时，我们在line table表中查找小于等于等于给定地址p的第一个元素，然后返回查询结果即可，查询结果包含了文件名和行号，返回给trace即可。</li><li>熬了几天夜，终于把功能基本实现了，总体来说还算非常蛋疼的功能。<br><img src="https://i.loli.net/2021/08/20/hlpDCfavUjYydiR.png" alt></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;traps&quot;&gt;&lt;a href=&quot;#traps&quot; class=&quot;headerlink&quot; title=&quot;traps&quot;&gt;&lt;/a&gt;traps&lt;/h1&gt;&lt;p&gt;最近封闭在家，没事干，只能刷题图开心，感觉MIT的lab刷起来真心是有意思，有挑战，难度很高，非常有思维挑战性，代码量倒是不是特别大。&lt;br&gt;特别&lt;code&gt;alarm&lt;/code&gt;这个功能，思维确实比较牛逼，不过最重要的还算要看textbook，而不是忙着刷题，先把textbook看熟之后，再来刷题。&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/MIT6.S081/tree/main/lab-traps-handin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git repo&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;RISC-V-assembly&quot;&gt;&lt;a href=&quot;#RISC-V-assembly&quot; class=&quot;headerlink&quot; title=&quot;RISC-V assembly&quot;&gt;&lt;/a&gt;RISC-V assembly&lt;/h2&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 254</title>
    <link href="http://yoursite.com/2021/08/11/314/"/>
    <id>http://yoursite.com/2021/08/11/314/</id>
    <published>2021-08-11T02:42:04.552Z</published>
    <updated>2021-08-15T13:26:34.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-254"><a href="#leetcode-contest-254" class="headerlink" title="leetcode contest 254"></a>leetcode contest 254</h1><p>本周的题目的难度始终，难度不是很大，第三题竟然犯了个很坑爹错误，竟然把乘方数也取模了，结果一直结果不对。结果一直卡壳，以为我的算法错误。<br><img src="https://i.loli.net/2021/08/15/XuFZObePsBH1LwM.png" alt></p><h2 id="5843-作为子字符串出现在单词中的字符串数目"><a href="#5843-作为子字符串出现在单词中的字符串数目" class="headerlink" title="5843. 作为子字符串出现在单词中的字符串数目"></a>5843. 作为子字符串出现在单词中的字符串数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>patterns</code> 和一个字符串 <code>word</code> ，统计 <code>patterns</code> 中有多少个字符串是 <code>word</code> 的子字符串。返回字符串数目。</p><a id="more"></a><p>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：patterns = [<span class="string">"a"</span>,<span class="string">"abc"</span>,<span class="string">"bc"</span>,<span class="string">"d"</span>], <span class="built_in">word</span> = <span class="string">"abc"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">- <span class="string">"a"</span> 是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">- <span class="string">"abc"</span> 是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">- <span class="string">"bc"</span> 是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">- <span class="string">"d"</span> 不是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">patterns 中有 <span class="number">3</span> 个字符串作为子字符串出现在 <span class="built_in">word</span> 中。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：patterns = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>], <span class="built_in">word</span> = <span class="string">"aaaaabbbbb"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- <span class="string">"a"</span> 是 <span class="string">"aaaaabbbbb"</span> 的子字符串。</span><br><span class="line">- <span class="string">"b"</span> 是 <span class="string">"aaaaabbbbb"</span> 的子字符串。</span><br><span class="line">- <span class="string">"c"</span> 不是 <span class="string">"aaaaabbbbb"</span> 的字符串。</span><br><span class="line">patterns 中有 <span class="number">2</span> 个字符串作为子字符串出现在 <span class="built_in">word</span> 中。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：patterns = [<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>], word = <span class="comment">"ab"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：patterns 中的每个字符串都作为子字符串出现在 word <span class="comment">"ab"</span> 中。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= patterns.length &lt;= 100</code></li><li><code>1 &lt;= patterns[i].length &lt;= 100</code></li><li><code>1 &lt;= word.length &lt;= 100</code></li><li><code>patterns[i]</code> 和 <code>word</code> 由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测字符串里面是否含有特定的字符串，用<code>stl</code>库函数<code>find</code>即可。算法时间复杂度为$O(n)$,算法空间复杂度为$O(1)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfStrings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; patterns, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : patterns)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word.find(p) != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5832-构造元素不等于两相邻元素平均值的数组"><a href="#5832-构造元素不等于两相邻元素平均值的数组" class="headerlink" title="5832. 构造元素不等于两相邻元素平均值的数组"></a>5832. 构造元素不等于两相邻元素平均值的数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 下标从 0 开始 的数组 <code>nums</code> ，数组由若干 互不相同的 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 不等于 其两侧相邻元素的 平均值 。</p><p>更公式化的说法是，重新排列的数组应当满足这一属性：对于范围 <code>1 &lt;= i &lt; nums.length - 1</code> 中的每个 <code>i</code> ，<code>(nums[i-1] + nums[i+1]) / 2</code>不等于 <code>nums[i]</code> 均成立 。</p><p>返回满足题意的任一重排结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">1</span>, nums[i] = <span class="number">2</span>, 两相邻元素平均值为 (<span class="number">1</span>+<span class="number">4</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br><span class="line">i=<span class="number">2</span>, nums[i] = <span class="number">4</span>, 两相邻元素平均值为 (<span class="number">2</span>+<span class="number">5</span>) / <span class="number">2</span> = <span class="number">3.5</span></span><br><span class="line">i=<span class="number">3</span>, nums[i] = <span class="number">5</span>, 两相邻元素平均值为 (<span class="number">4</span>+<span class="number">3</span>) / <span class="number">2</span> = <span class="number">3.5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">1</span>, nums[i] = <span class="number">7</span>, 两相邻元素平均值为 (<span class="number">9</span>+<span class="number">6</span>) / <span class="number">2</span> = <span class="number">7.5</span></span><br><span class="line">i=<span class="number">2</span>, nums[i] = <span class="number">6</span>, 两相邻元素平均值为 (<span class="number">7</span>+<span class="number">2</span>) / <span class="number">2</span> = <span class="number">4.5</span></span><br><span class="line">i=<span class="number">3</span>, nums[i] = <span class="number">2</span>, 两相邻元素平均值为 (<span class="number">6</span>+<span class="number">0</span>) / <span class="number">2</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始想了很长时间，后来想了一种简单办法，首先我们将数组按照从小到大排序，数组索引从<code>0</code>开始，然后我们将奇数位的数与前一个数进行交换，这样我们即可满足如下：</li></ol><ul><li>对于索引为奇数位的元素我们发现一定满足：<script type="math/tex; mode=display">nums[i] < nums[i-1] \\nums[i] < nums[i+1] \\nums[i-1] + nums[i+1] > nums[i]*2</script></li><li>对于索引为偶数位的元素我们发现一定满足：<script type="math/tex; mode=display">nums[i] > nums[i-1] \\nums[i] > nums[i+1] \\nums[i-1] + nums[i+1] < nums[i]*2 \\</script></li></ul><ol><li>时间复杂度为$O(nlgn + n)$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rearrangeArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>)&#123;</span><br><span class="line">           swap(nums[i<span class="number">-1</span>],nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5844-数组元素的最小非零乘积"><a href="#5844-数组元素的最小非零乘积" class="headerlink" title="5844. 数组元素的最小非零乘积"></a>5844. 数组元素的最小非零乘积</h2><p>给你一个正整数 <code>p</code>。你有一个下标从 1 开始的数组 <code>nums</code>，这个数组包含范围<code>[1, 2p - 1]</code>内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次：</p><p>从 <code>nums</code>中选择两个元素 <code>x</code> 和 <code>y</code>  。<br>选择 x 中的一位与 <code>y</code> 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。<br>比方说，如果<code>x = 1101</code>且 <code>y = 0011</code>，交换右边数起第 2 位后，我们得到 <code>x = 1111</code> 和 <code>y = 0001</code> 。</p><p>请你算出进行以上操作 任意次 以后，<code>nums</code> 能得到的 最小非零 乘积。将乘积对 <code>109 + 7</code> 取余 后返回。</p><p>注意：答案应为取余 之前 的最小值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：p = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：nums = [<span class="number">1</span>] 。</span><br><span class="line">只有一个元素，所以乘积为该元素。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：p = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：nums = [<span class="number">01</span>, <span class="number">10</span>, <span class="number">11</span>] 。</span><br><span class="line">所有交换要么使乘积变为 <span class="number">0</span> ，要么乘积与初始乘积相同。</span><br><span class="line">所以，数组乘积 <span class="number">1</span> * <span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span> 已经是最小值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：p = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1512</span></span><br><span class="line">解释：nums = [<span class="number">001</span>, <span class="number">010</span>, <span class="number">011</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">111</span>]</span><br><span class="line">- 第一次操作中，我们交换第二个和第五个元素最左边的数位。</span><br><span class="line">    - 结果数组为 [<span class="number">001</span>, <span class="number">110</span>, <span class="number">011</span>, <span class="number">100</span>, <span class="number">001</span>, <span class="number">110</span>, <span class="number">111</span>] 。</span><br><span class="line">- 第二次操作中，我们交换第三个和第四个元素中间的数位。</span><br><span class="line">    - 结果数组为 [<span class="number">001</span>, <span class="number">110</span>, <span class="number">001</span>, <span class="number">110</span>, <span class="number">001</span>, <span class="number">110</span>, <span class="number">111</span>] 。</span><br><span class="line">数组乘积 <span class="number">1</span> * <span class="number">6</span> * <span class="number">1</span> * <span class="number">6</span> * <span class="number">1</span> * <span class="number">6</span> * <span class="number">7</span> = <span class="number">1512</span> 是最小乘积。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= p &lt;= 60</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们仔细观察一下，实际上最后发现所有的数，交换之后最终成为如下形式时，乘积最小：<script type="math/tex; mode=display">000...0001,111...1110,000...0001,111...1110,...,000...0001,111...1110,111...1111</script></li><li>我们知道这种类似的分布以后我们只需数出$(000…0001,111…1110)$数对的数目即可，我们知道从$1$到$2^{p}-1$总共$2^{p-1}-1$对，因此我们可以知道最终的求和公式为如下：<script type="math/tex; mode=display">ans = (2^{p} -1)*(2^{p}-2)^{2^{p-1}-1}</script></li><li>算法负责度为$O(n)$.比赛中竟然把乘方数进行取模，结果怎么算结果都不对。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>) ans = (ans*curr)%mod;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNonZeroProduct</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = fastpow(<span class="number">2</span>,p,mod)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> y = (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;(p<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> fastpow(x<span class="number">-1</span>,y<span class="number">-1</span>,mod)*x%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5845-你能穿过矩阵的最后一天"><a href="#5845-你能穿过矩阵的最后一天" class="headerlink" title="5845. 你能穿过矩阵的最后一天"></a>5845. 你能穿过矩阵的最后一天</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 1 开始的二进制矩阵，其中 <code>0</code> 表示陆地，<code>1</code> 表示水域。同时给你 <code>row</code> 和 <code>col</code> 分别表示矩阵中行和列的数目。</p><p>一开始在第 0 天，整个 矩阵都是 陆地 。但每一天都会有一块新陆地被 水 淹没变成水域。给你一个下标从 1 开始的二维数组 <code>cells</code> ，其中 <code>cells[i] = [ri, ci]</code> 表示在第 <code>i</code> 天，第<code>ri</code> 行 <code>ci</code> 列（下标都是从 1 开始）的陆地会变成 水域 （也就是 0 变成 1 ）。</p><p>你想知道从矩阵最 上面 一行走到最 下面 一行，且只经过陆地格子的 最后一天 是哪一天。你可以从最上面一行的 任意 格子出发，到达最下面一行的 任意 格子。你只能沿着 四个 基本方向移动（也就是上下左右）。</p><p>请返回只经过陆地格子能从最 上面 一行走到最 下面 一行的 最后一天 。</p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">2</span>, col = <span class="number">2</span>, cells = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：上图描述了矩阵从第 <span class="number">0</span> 天开始是如何变化的。</span><br><span class="line">可以从最上面一行到最下面一行的最后一天是第 <span class="number">2</span> 天。</span><br></pre></td></tr></table></figure><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">2</span>, col = <span class="number">2</span>, cells = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：上图描述了矩阵从第 <span class="number">0</span> 天开始是如何变化的。</span><br><span class="line">可以从最上面一行到最下面一行的最后一天是第 <span class="number">1</span> 天。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">3</span>, col = <span class="number">3</span>, cells = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：上图描述了矩阵从第 <span class="number">0</span> 天开始是如何变化的。</span><br><span class="line">可以从最上面一行到最下面一行的最后一天是第 <span class="number">3</span> 天。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= row, col &lt;= 2 * 104</code></li><li><code>4 &lt;= row * col &lt;= 2 * 104</code></li><li><code>cells.length == row * col</code></li><li><code>1 &lt;= ri &lt;= row</code></li><li><code>1 &lt;= ci &lt;= col</code></li><li><code>cells</code> 中的所有格子坐标都是 唯一 的。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/last-day-where-you-can-still-cross" target="_blank" rel="noopener">https://leetcode-cn.com/problems/last-day-where-you-can-still-cross</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 集合</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>二分查找，我们通过<code>bfs</code>检测矩阵的上下是否联通，二分查找需要耗费的时间为$lg(n)$,每次检测需要耗费的时间为$O(row<em>col)$,这种算法较为简单，算法时间复杂度为$O(row</em>col*lgn).</li><li>我们采用倒序的检测方法，每次将水域变成陆地，可以看到假如存在陆地满足上下连通，即是最后一天。此时我们用集合检测即可。实际只需要一点小技巧即可。</li><li>总的来说这题难度较低，不是很难的题目。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; touchButtom,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; touchUp,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">        <span class="keyword">if</span>(x1 &lt; y1)&#123;</span><br><span class="line">            f[x1] = y1;</span><br><span class="line">            touchButtom[y1] = touchButtom[y1]||touchButtom[x1];</span><br><span class="line">            touchUp[y1] = touchUp[y1]||touchUp[x1];</span><br><span class="line">            touchButtom[x1] = touchButtom[x1]||touchButtom[y1];</span><br><span class="line">            touchUp[x1] = touchUp[x1]||touchUp[y1];         </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x1 &gt; y1)&#123;</span><br><span class="line">            f[y1] = x1;</span><br><span class="line">            touchButtom[x1] = touchButtom[x1]||touchButtom[y1];</span><br><span class="line">            touchUp[x1] = touchUp[x1]||touchUp[y1];</span><br><span class="line">            touchButtom[y1] = touchButtom[y1]||touchButtom[x1];</span><br><span class="line">            touchUp[y1] = touchUp[y1]||touchUp[x1];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(touchButtom[y1] &amp;&amp; touchUp[y1]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">latestDayToCross</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cells)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cells.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; grid(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; touchButtom(row*col,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; touchUp(row*col,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(row*col,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cells.size(); ++i)&#123;</span><br><span class="line">            cells[i][<span class="number">0</span>]--;</span><br><span class="line">            cells[i][<span class="number">1</span>]--;</span><br><span class="line">            grid[cells[i][<span class="number">0</span>]][cells[i][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            touchUp[i] = <span class="literal">true</span>;</span><br><span class="line">            touchButtom[(row<span class="number">-1</span>)*col+i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row*col; ++i) f[i] = i;     </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = d[k][<span class="number">0</span>] + i;</span><br><span class="line">                        <span class="keyword">int</span> y = d[k][<span class="number">1</span>] + j;</span><br><span class="line">                        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(uni(f,touchButtom,touchUp,i*col+j,x*col+y))&#123;</span><br><span class="line">                                <span class="keyword">return</span> n;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cells[i][<span class="number">0</span>] + d[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = cells[i][<span class="number">1</span>] + d[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(uni(f,touchButtom,touchUp,cells[i][<span class="number">0</span>]*col + cells[i][<span class="number">1</span>],x*col+y))&#123;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            grid[cells[i][<span class="number">0</span>]][cells[i][<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-254&quot;&gt;&lt;a href=&quot;#leetcode-contest-254&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 254&quot;&gt;&lt;/a&gt;leetcode contest 254&lt;/h1&gt;&lt;p&gt;本周的题目的难度始终，难度不是很大，第三题竟然犯了个很坑爹错误，竟然把乘方数也取模了，结果一直结果不对。结果一直卡壳，以为我的算法错误。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/XuFZObePsBH1LwM.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5843-作为子字符串出现在单词中的字符串数目&quot;&gt;&lt;a href=&quot;#5843-作为子字符串出现在单词中的字符串数目&quot; class=&quot;headerlink&quot; title=&quot;5843. 作为子字符串出现在单词中的字符串数目&quot;&gt;&lt;/a&gt;5843. 作为子字符串出现在单词中的字符串数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;patterns&lt;/code&gt; 和一个字符串 &lt;code&gt;word&lt;/code&gt; ，统计 &lt;code&gt;patterns&lt;/code&gt; 中有多少个字符串是 &lt;code&gt;word&lt;/code&gt; 的子字符串。返回字符串数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 253</title>
    <link href="http://yoursite.com/2021/08/08/313/"/>
    <id>http://yoursite.com/2021/08/08/313/</id>
    <published>2021-08-08T07:36:53.218Z</published>
    <updated>2021-08-08T08:19:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-253"><a href="#leetcode-contest-253" class="headerlink" title="leetcode contest 253"></a>leetcode contest 253</h1><p>本周题目都是手速场，确实难度太低了。</p><h2 id="5838-检查字符串是否为数组前缀"><a href="#5838-检查字符串是否为数组前缀" class="headerlink" title="5838. 检查字符串是否为数组前缀"></a>5838. 检查字符串是否为数组前缀</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>words</code>，请你判断 <code>s</code> 是否为 <code>words</code> 的 前缀字符串 。</p><p>字符串 <code>s</code> 要成为 <code>words</code>的 前缀字符串 ，需要满足：<code>s</code>可以由 <code>words</code> 中的前 <code>k</code>（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 <code>words.length</code> 。</p><a id="more"></a><p>如果 <code>s</code> 是<code>words</code>的 前缀字符串 ，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"iloveleetcode"</span>, <span class="attr">words</span> = [<span class="string">"i"</span>,<span class="string">"love"</span>,<span class="string">"leetcode"</span>,<span class="string">"apples"</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">s 可以由 <span class="string">"i"</span>、<span class="string">"love"</span> 和 <span class="string">"leetcode"</span> 相连得到。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"iloveleetcode"</span>, <span class="attr">words</span> = [<span class="string">"apples"</span>,<span class="string">"i"</span>,<span class="string">"love"</span>,<span class="string">"leetcode"</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：</span><br><span class="line">数组的前缀相连无法得到 s 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 20</code></li><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>words[i]</code> 和 <code>s</code> 仅由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-58/problems/delete-characters-to-make-fancy-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-58/problems/delete-characters-to-make-fancy-string/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>求出字符串数组中所有可能的前缀，然后与目标字符串进行比较即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPrefixString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                curr += words[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5839-移除石子使总数最小"><a href="#5839-移除石子使总数最小" class="headerlink" title="5839. 移除石子使总数最小"></a>5839. 移除石子使总数最小</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>piles</code> ，数组 下标从 <code>0</code> 开始 ，其中 <code>piles[i]</code> 表示第 <code>i</code> 堆石子中的石子数量。另给你一个整数<code>k</code> ，请你执行下述操作 恰好 <code>k</code> 次：</p><p>选出任一石子堆 <code>piles[i]</code>，并从中 移除 <code>floor(piles[i] / 2)</code> 颗石子。<br>注意：你可以对 同一堆 石子多次执行此操作。</p><p>返回执行<code>k</code> 次操作后，剩下石子的 最小 总数。</p><p><code>floor(x)</code> 为 小于 或 等于<code>x</code>的 最大 整数。（即，对 <code>x</code>向下取整）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：可能的执行情景如下：</span><br><span class="line">- 对第 <span class="number">2</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">- 对第 <span class="number">0</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">剩下石子的总数为 <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：可能的执行情景如下：</span><br><span class="line">- 对第 <span class="number">2</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>] 。</span><br><span class="line">- 对第 <span class="number">3</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>] 。</span><br><span class="line">- 对第 <span class="number">0</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>] 。</span><br><span class="line">剩下石子的总数为 <span class="number">12</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= piles.length &lt;= 105</code></li><li><code>1 &lt;= piles[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-253/problems/remove-stones-to-minimize-the-total/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-253/problems/remove-stones-to-minimize-the-total/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>每次从队列中取出最大的元素，然后去掉最大元素的一半，然后将剩余的元素重新放入到队列中，典型的优先级队列。</li><li>时间复杂度为$O(Klgn)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStoneSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            pq.push(piles[i]);</span><br><span class="line">            ans += piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.empty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            ans -= (curr/<span class="number">2</span>);</span><br><span class="line">            pq.push(curr-(curr/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5840-使字符串平衡的最小交换次数"><a href="#5840-使字符串平衡的最小交换次数" class="headerlink" title="5840. 使字符串平衡的最小交换次数"></a>5840. 使字符串平衡的最小交换次数</h2><p>给你一个字符串<code>s</code> ，下标从 <code>0</code> 开始 ，且长度为偶数<code>n</code>。字符串 恰好 由 <code>n / 2</code>个开括号 <code>&#39;[&#39;</code> 和 <code>n / 2</code>个闭括号<code>&#39;]&#39;</code> 组成。</p><p>只有能满足下述所有条件的字符串才能称为 平衡字符串 ：</p><ul><li>字符串是一个空字符串，或者</li><li>字符串可以记作 <code>AB</code>，其中 <code>A</code> 和 <code>B</code> 都是 平衡字符串 ，或者</li><li>字符串可以写成<code>[C]</code> ，其中<code>C</code> 是一个 平衡字符串 。<br>你可以交换 任意 两个下标所对应的括号 任意 次数。</li></ul><p>返回使<code>s</code>变成 平衡字符串 所需要的 最小 交换次数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"][]["</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：交换下标 <span class="number">0</span> 和下标 <span class="number">3</span> 对应的括号，可以使字符串变成平衡字符串。</span><br><span class="line">最终字符串变成 <span class="string">"[[]]"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "]]][[["</span><br><span class="line">输出：2</span><br><span class="line">解释：执行下述操作可以使字符串变成平衡字符串：</span><br><span class="line"><span class="bullet">- </span>交换下标 0 和下标 4 对应的括号，s = "[<span class="string"></span>]][[]" 。</span><br><span class="line"><span class="bullet">- </span>交换下标 1 和下标 5 对应的括号，s = "[<span class="string">[</span>][<span class="symbol"></span>]]" 。</span><br><span class="line">最终字符串变成 "[<span class="string">[</span>][<span class="symbol"></span>]]" 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"[]"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：这个字符串已经是平衡字符串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == s.length</code></li><li><code>2 &lt;= n &lt;= 106</code></li><li><code>n</code>为偶数</li><li><code>s[i]</code> 为<code>&#39;[&#39;</code> 或 <code>&#39;]&#39;</code></li><li>开括号 <code>&#39;[&#39;</code> 的数目为 <code>n / 2</code> ，闭括号 <code>&#39;]&#39;</code> 的数目也是 <code>n / 2</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-58/problems/minimum-total-space-wasted-with-k-resizing-operations/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-58/problems/minimum-total-space-wasted-with-k-resizing-operations/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>本质即为括号匹配问题，我们检测如果发现右括号<code>]</code>没有匹配时，则从字符串的末尾找到一个<code>[</code>来进行交换。</li><li>算法时间复杂度为$O(n)$,空间复杂度为$O(1)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr--;</span><br><span class="line">                <span class="keyword">if</span>(curr &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(r &gt; i &amp;&amp; s[r] == <span class="string">']'</span>) r--;</span><br><span class="line">                    swap(s[i],s[r]);</span><br><span class="line">                    ans++;</span><br><span class="line">                    curr += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5841-找出到每个位置为止最长的有效障碍赛跑路线"><a href="#5841-找出到每个位置为止最长的有效障碍赛跑路线" class="headerlink" title="5841. 找出到每个位置为止最长的有效障碍赛跑路线"></a>5841. 找出到每个位置为止最长的有效障碍赛跑路线</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你打算构建一些障碍赛跑路线。给你一个 下标从<code>0</code> 开始 的整数数组 <code>obstacles</code> ，数组长度为 n ，其中 <code>obstacles[i]</code> 表示第 i 个障碍的高度。</p><p>对于每个介于 0 和 <code>n - 1</code> 之间（包含 <code>0</code>和 <code>n - 1</code>）的下标  i ，在满足下述条件的前提下，请你找出 <code>obstacles</code> 能构成的最长障碍路线的长度：</p><p>你可以选择下标介于 0 到 <code>i</code>之间（包含 0 和 i）的任意个障碍。<br>在这条路线中，必须包含第 <code>i</code>个障碍。<br>你必须按障碍在 <code>obstacles</code>中的 出现顺序 布置这些障碍。<br>除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。<br>返回长度为 n 的答案数组 <code>ans</code> ，其中 <code>ans[i]</code> 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：每个位置的最长有效障碍路线是：</span><br><span class="line">- i = <span class="number">0</span>: [<span class="number">1</span>], [<span class="number">1</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] 长度为 <span class="number">2</span></span><br><span class="line">- i = <span class="number">2</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 长度为 <span class="number">3</span></span><br><span class="line">- i = <span class="number">3</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 长度为 <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：每个位置的最长有效障碍路线是：</span><br><span class="line">- i = <span class="number">0</span>: [<span class="number">2</span>], [<span class="number">2</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">1</span>: [<span class="number">2</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">2</span>] 长度为 <span class="number">2</span></span><br><span class="line">- i = <span class="number">2</span>: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">1</span>] 长度为 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：每个位置的最长有效障碍路线是：</span><br><span class="line">- i = <span class="number">0</span>: [<span class="number">3</span>], [<span class="number">3</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">1</span>: [<span class="number">3</span>,<span class="number">1</span>], [<span class="number">1</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">2</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>], [<span class="number">3</span>,<span class="number">5</span>] 长度为 <span class="number">2</span>, [<span class="number">1</span>,<span class="number">5</span>] 也是有效的障碍赛跑路线</span><br><span class="line">- i = <span class="number">3</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] 长度为 <span class="number">3</span>, [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>] 也是有效的障碍赛跑路线</span><br><span class="line">- i = <span class="number">4</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>], [<span class="number">3</span>,<span class="number">4</span>] 长度为 <span class="number">2</span>, [<span class="number">1</span>,<span class="number">4</span>] 也是有效的障碍赛跑路线</span><br><span class="line">- i = <span class="number">5</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] 长度为 <span class="number">2</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == obstacles.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= obstacles[i] &lt;= <span class="number">107</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/count-number-of-special-subsequences</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  LIS问题</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 典型的LIS问题变形，常见的`LIS`问题中要求每个元素严格递增，但在本题中要求后一个元素大于等于前一个元素。我们用`dp[i]`表示长度为`i+<span class="number">1</span>`的非递减数组中的最后一个元素。我们每次遇到当前元素`curr`时，则我们在已经组成元素查找第一个比`curr`大的元素，并用`curr`去替换该元素，即可得到以`curr`为结尾的最长递增序列。熟悉`lis`问题的人则会对改题目很容易理解。</span><br><span class="line"><span class="number">2.</span> 时间复杂度为$O(nlgn)$,空间复杂度为$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; longestObstacleCourseAtEachPosition(vector&lt;<span class="built_in">int</span>&gt;&amp; obstacles) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = obstacles.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; lcs;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">auto</span> it = upper_bound(lcs.begin(),lcs.end(),obstacles[i]);</span><br><span class="line">            <span class="keyword">if</span>(it == lcs.end())&#123;</span><br><span class="line">                ans[i] = lcs.size() + <span class="number">1</span>;</span><br><span class="line">                lcs.push_back(obstacles[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i] = it - lcs.begin() + <span class="number">1</span>;</span><br><span class="line">                *it = obstacles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-253&quot;&gt;&lt;a href=&quot;#leetcode-contest-253&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 253&quot;&gt;&lt;/a&gt;leetcode contest 253&lt;/h1&gt;&lt;p&gt;本周题目都是手速场，确实难度太低了。&lt;/p&gt;&lt;h2 id=&quot;5838-检查字符串是否为数组前缀&quot;&gt;&lt;a href=&quot;#5838-检查字符串是否为数组前缀&quot; class=&quot;headerlink&quot; title=&quot;5838. 检查字符串是否为数组前缀&quot;&gt;&lt;/a&gt;5838. 检查字符串是否为数组前缀&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个字符串数组 &lt;code&gt;words&lt;/code&gt;，请你判断 &lt;code&gt;s&lt;/code&gt; 是否为 &lt;code&gt;words&lt;/code&gt; 的 前缀字符串 。&lt;/p&gt;&lt;p&gt;字符串 &lt;code&gt;s&lt;/code&gt; 要成为 &lt;code&gt;words&lt;/code&gt;的 前缀字符串 ，需要满足：&lt;code&gt;s&lt;/code&gt;可以由 &lt;code&gt;words&lt;/code&gt; 中的前 &lt;code&gt;k&lt;/code&gt;（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 &lt;code&gt;words.length&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 58</title>
    <link href="http://yoursite.com/2021/08/08/312/"/>
    <id>http://yoursite.com/2021/08/08/312/</id>
    <published>2021-08-08T06:25:48.674Z</published>
    <updated>2021-08-08T12:56:47.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-58"><a href="#leetcode-biweekly-contest-58" class="headerlink" title="leetcode  biweekly contest 58"></a>leetcode  biweekly contest 58</h1><p>本次的双周赛题目，前三题感觉都是正常的题目，第四题是<code>manacher</code>算法，这个算法确实很少会遇到。<br><img src="https://i.loli.net/2021/08/08/jCEKGQTAiPNSqlJ.png" alt></p><h2 id="5193-删除字符使字符串变好"><a href="#5193-删除字符使字符串变好" class="headerlink" title="5193. 删除字符使字符串变好"></a>5193. 删除字符使字符串变好</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个字符串如果没有 三个连续 相同字符，那么它就是一个 好字符串 。</p><p>给你一个字符串 <code>s</code> ，请你从 <code>s</code> 删除 最少 的字符，使它变成一个 好字符串 。</p><a id="more"></a><p>请你返回删除后的字符串。题目数据保证答案总是 唯一的 。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leeetcode"</span></span><br><span class="line">输出：<span class="string">"leetcode"</span></span><br><span class="line">解释：</span><br><span class="line">从第一组 'e' 里面删除一个 'e' ，得到 <span class="string">"leetcode"</span> 。</span><br><span class="line">没有连续三个相同字符，所以返回 <span class="string">"leetcode"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaabaaaa"</span></span><br><span class="line">输出：<span class="string">"aabaa"</span></span><br><span class="line">解释：</span><br><span class="line">从第一组 'a' 里面删除一个 'a' ，得到 <span class="string">"aabaaaa"</span> 。</span><br><span class="line">从第二组 'a' 里面删除两个 'a' ，得到 <span class="string">"aabaa"</span> 。</span><br><span class="line">没有连续三个相同字符，所以返回 <span class="string">"aabaa"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aab"</span></span><br><span class="line">输出：<span class="string">"aab"</span></span><br><span class="line">解释：没有连续三个相同字符，所以返回 <span class="string">"aab"</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= s.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `s` 只包含小写英文字母。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址 </span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-58/problems/delete-characters-to-make-fancy-string/</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;   暴力检测</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 暴力检测其中连续的字符串，去掉多余的字符即可。</span><br><span class="line"><span class="number">2.</span> 算法复杂度为$O(n)$.</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> makeFancyString(<span class="keyword">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">string</span> ans;</span><br><span class="line">        <span class="keyword">char</span> curr;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        curr = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == curr)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; j &lt; <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                ans.push_back(curr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; s.size())&#123;</span><br><span class="line">                curr = s[i];</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5827-检查操作是否合法"><a href="#5827-检查操作是否合法" class="headerlink" title="5827. 检查操作是否合法"></a>5827. 检查操作是否合法</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 0 开始的 <code>8 x 8</code> 网格<code>board</code> ，其中<code>board[r][c]</code>表示游戏棋盘上的格子 <code>(r, c)</code> 。棋盘上空格用 ‘.’ 表示，白色格子用 <code>&#39;W&#39;</code>表示，黑色格子用 <code>&#39;B&#39;</code>表示。</p><p>游戏中每次操作步骤为：选择一个空格子，将它变成你正在执行的颜色（要么白色，要么黑色）。但是，合法 操作必须满足：涂色后这个格子是 好线段的一个端点 （好线段可以是水平的，竖直的或者是对角线）。</p><p>好线段 指的是一个包含 三个或者更多格子（包含端点格子）的线段，线段两个端点格子为 同一种颜色 ，且中间剩余格子的颜色都为 另一种颜色 （线段上不能有任何空格子）。你可以在下图找到好线段的例子：</p><p>给你两个整数 <code>rMove</code> 和 <code>cMove</code> 以及一个字符 <code>color</code> ，表示你正在执行操作的颜色（白或者黑），如果将格子 <code>(rMove, cMove)</code>变成颜色 <code>color</code>后，是一个 合法 操作，那么返回 <code>true</code> ，如果不是合法操作返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"W"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"W"</span>,<span class="string">"W"</span>,<span class="string">"B"</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]], rMove = <span class="number">4</span>, cMove = <span class="number">3</span>, color = <span class="string">"B"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：<span class="string">'.'</span>，<span class="string">'W'</span> 和 <span class="string">'B'</span> 分别用颜色蓝色，白色和黑色表示。格子 (rMove, cMove) 用 <span class="string">'X'</span> 标记。</span><br><span class="line">以选中格子为端点的两个好线段在上图中用红色矩形标注出来了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>]], rMove = <span class="number">4</span>, cMove = <span class="number">4</span>, color = <span class="string">"W"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：虽然选中格子涂色后，棋盘上产生了好线段，但选中格子是作为中间格子，没有产生以选中格子为端点的好线段。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>board.length == board[r].length == 8</code></li><li><code>0 &lt;= rMove, cMove &lt; 8</code></li><li><code>board[rMove][cMove] == &#39;.&#39;</code></li><li><code>color</code> 要么是 <code>&#39;B&#39;</code> 要么是 <code>&#39;W&#39;</code> 。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-58/problems/check-if-move-is-legal/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-58/problems/check-if-move-is-legal/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测是否合法即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测八个方向的线段是否合法即可，感觉题目非常无意义的题目，建议不要出现此类题目。<br>2.算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkMove</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> rMove, <span class="keyword">int</span> cMove, <span class="keyword">char</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = board.size();</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*up*/</span></span><br><span class="line">        i = rMove - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; board[i][cMove] != <span class="string">'.'</span> &amp;&amp; board[i][cMove] != color)&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i != rMove<span class="number">-1</span> &amp;&amp; board[i][cMove] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*down*/</span></span><br><span class="line">        i = rMove + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; row &amp;&amp; board[i][cMove] != <span class="string">'.'</span> &amp;&amp; board[i][cMove] != color)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; row &amp;&amp; i != rMove+<span class="number">1</span> &amp;&amp; board[i][cMove] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*left*/</span></span><br><span class="line">        i = cMove - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; board[rMove][i] != <span class="string">'.'</span> &amp;&amp; board[rMove][i] != color)&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i != cMove<span class="number">-1</span> &amp;&amp; board[rMove][i] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*right*/</span></span><br><span class="line">        i = cMove + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; col &amp;&amp; board[rMove][i] != <span class="string">'.'</span> &amp;&amp; board[rMove][i] != color)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; col &amp;&amp; i != cMove+<span class="number">1</span> &amp;&amp; board[rMove][i] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        i = rMove<span class="number">-1</span>;</span><br><span class="line">        j = cMove<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; board[i][j] != <span class="string">'.'</span> &amp;&amp; board[i][j] != color)&#123;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i != rMove<span class="number">-1</span> &amp;&amp; board[i][j] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        i = rMove+<span class="number">1</span>;</span><br><span class="line">        j = cMove+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; row &amp;&amp; j &lt; col &amp;&amp; board[i][j] != <span class="string">'.'</span> &amp;&amp; board[i][j] != color)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; row &amp;&amp; j &lt; col &amp;&amp; i != rMove+<span class="number">1</span> &amp;&amp; board[i][j] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        i = rMove<span class="number">-1</span>;</span><br><span class="line">        j = cMove+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; col &amp;&amp; board[i][j] != <span class="string">'.'</span> &amp;&amp; board[i][j] != color)&#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; col &amp;&amp; i != rMove<span class="number">-1</span> &amp;&amp; board[i][j] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        i = rMove+<span class="number">1</span>;</span><br><span class="line">        j = cMove<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; board[i][j] != <span class="string">'.'</span> &amp;&amp; board[i][j] != color)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i != rMove+<span class="number">1</span> &amp;&amp; board[i][j] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5828-K-次调整数组大小浪费的最小总空间"><a href="#5828-K-次调整数组大小浪费的最小总空间" class="headerlink" title="5828. K 次调整数组大小浪费的最小总空间"></a>5828. K 次调整数组大小浪费的最小总空间</h2><p>你正在设计一个动态数组。给你一个下标从 0 开始的整数数组 <code>nums</code>，其中 <code>nums[i]</code> 是<code>i</code> 时刻数组中的元素数目。除此以外，你还有一个整数 k ，表示你可以 调整 数组大小的 最多 次数（每次都可以调整成 任意 大小）。</p><p>t 时刻数组的大小 <code>sizet</code>必须大于等于 <code>nums[t]</code>，因为数组需要有足够的空间容纳所有元素。t 时刻 浪费的空间 为 <code>sizet - nums[t]</code> ，总 浪费空间为满足 <code>0 &lt;= t &lt; nums.length</code>的每一个时刻 <code>t</code> 浪费的空间 之和 。</p><p>在调整数组大小不超过<code>k</code> 次的前提下，请你返回 最小总浪费空间 。</p><p>注意：数组最开始时可以为 任意大小 ，且 不计入 调整大小的操作次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">20</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：size = [<span class="number">20</span>,<span class="number">20</span>].</span><br><span class="line">我们可以让数组初始大小为 <span class="number">20</span> 。</span><br><span class="line">总浪费空间为 (<span class="number">20</span> - <span class="number">10</span>) + (<span class="number">20</span> - <span class="number">20</span>) = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：size = [<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>].</span><br><span class="line">我们可以让数组初始大小为 <span class="number">20</span> ，然后时刻 <span class="number">2</span> 调整大小为 <span class="number">30</span> 。</span><br><span class="line">总浪费空间为 (<span class="number">20</span> - <span class="number">10</span>) + (<span class="number">20</span> - <span class="number">20</span>) + (<span class="number">30</span> - <span class="number">30</span>) = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">30</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：size = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>].</span><br><span class="line">我们可以让数组初始大小为 <span class="number">10</span> ，时刻 <span class="number">1</span> 调整大小为 <span class="number">20</span> ，时刻 <span class="number">3</span> 调整大小为 <span class="number">30</span> 。</span><br><span class="line">总浪费空间为 (<span class="number">10</span> - <span class="number">10</span>) + (<span class="number">20</span> - <span class="number">20</span>) + (<span class="number">20</span> - <span class="number">15</span>) + (<span class="number">30</span> - <span class="number">30</span>) + (<span class="number">30</span> - <span class="number">20</span>) = <span class="number">15</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">200</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">106</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= k &lt;= nums.length - <span class="number">1</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-58/problems/minimum-total-space-wasted-with-k-resizing-operations/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  DP</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的`dp`，我们设递推公式为`dp[i][j]`表示前`i`个元素经过`j`次调整后，所能得到的最小浪费空间，则我们可以知道递推公式为为</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = min(dp[i][j],dp[k][j<span class="number">-1</span>] + cost[k+<span class="number">1</span>][j])</span><br><span class="line">$$</span><br><span class="line"><span class="number">2.</span> 我们可以提前计算出数组$cost[i][j]$,表示数组从`i`到`j`调整一次后所需要的最小浪费空间，我们利用递推可以知道:</span><br><span class="line">$$</span><br><span class="line">cost[i][j] = max[i][j]*(j-i+<span class="number">1</span>) - (sum[j] - sum[i<span class="number">-1</span>])</span><br><span class="line">$$</span><br><span class="line">我们可以知道从`i`到`j`调整一次满足题目要求的最小元素应该为$max[i][j]$,即数组从索引`i`到`j`之间的最大元素。$sum[i]$表示数组前`i`个元素的前缀和。</span><br><span class="line"><span class="number">3.</span> 算法时间复杂度为$O(n*(k+n))$,算法的空间复杂度为$O(n*n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minSpaceWastedKResizing(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; dp(n,vector&lt;long long&gt;(k+<span class="number">1</span>,INT_MAX));</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; cost(n,vector&lt;long long&gt;(n));</span><br><span class="line">        vector&lt;long long&gt; sum(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">int</span> curr = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">                curr = max(curr,nums[j]);</span><br><span class="line">                cost[i][j] = curr*(j-i+<span class="number">1</span>) - (sum[j+<span class="number">1</span>] - sum[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = cost[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= k; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> l = i<span class="number">-1</span>; l &gt;= j<span class="number">-1</span>; --l)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j],dp[l][j<span class="number">-1</span>] + cost[l+<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5220-两个回文子字符串长度的最大乘积"><a href="#5220-两个回文子字符串长度的最大乘积" class="headerlink" title="5220. 两个回文子字符串长度的最大乘积"></a>5220. 两个回文子字符串长度的最大乘积</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的字符串<code>s</code> ，你需要找到两个 不重叠的回文 子字符串，它们的长度都必须为 奇数 ，使得它们长度的乘积最大。</p><p>更正式地，你想要选择四个整数 <code>i ，j ，k ，l</code>，使得 <code>0 &lt;= i &lt;= j &lt; k &lt;= l &lt; s.length</code> ，且子字符串 <code>s[i...j]</code>和 <code>s[k...l]</code>都是回文串且长度为奇数。<code>s[i...j]</code> 表示下标从 <code>i</code> 到 <code>j</code> 且 包含 两端下标的子字符串。</p><p>请你返回两个不重叠回文子字符串长度的 最大 乘积。</p><p>回文字符串 指的是一个从前往后读和从后往前读一模一样的字符串。子字符串 指的是一个字符串中一段连续字符。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"ababbb"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：子字符串 <span class="string">"aba"</span> 和 <span class="string">"bbb"</span> 为奇数长度的回文串。乘积为 <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"zaaaxbbby"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：子字符串 <span class="string">"aaa"</span> 和 <span class="string">"bbb"</span> 为奇数长度的回文串。乘积为 <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= s.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `s` 只包含小写英文字母。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/count-number-of-special-subsequences</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  manacher算法</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 求回文字符串的长度，我们先利用`manacher`算法求出每个以索引`i`为中点的最长回文串的半径。这一步的算法时间时间复杂度为$O(n)$.详细解释可以参考[manacher](https:<span class="comment">//oi-wiki.org/string/manacher/),写的非常好，该算法的特点利用回文字符串的对称性，可以快速省去部分检测方法，确实是非常巧妙的算法。主要是如果知道对称性性的基本原理，则还可以将这个算法推导出来。</span></span><br><span class="line"><span class="number">2.</span> 此时我们可以求出每个以前缀`i`的最长回文串的长度$prefix[i]$，我们将字符串翻转，同时求出以`i`为起点的后缀的最长回文串长度$suffix[i]$，此时我们遍历每一个可能的组合:</span><br><span class="line">$$</span><br><span class="line">prod = prefix[i]*suffix[i+<span class="number">1</span>]</span><br><span class="line">$$</span><br><span class="line">求出$prod$的最大值即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; manacher(<span class="built_in">string</span> &amp; s)&#123;</span><br><span class="line">        <span class="built_in">int</span> n = s.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; d1(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; hi(n,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">-1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">int</span> k = i &gt; r? <span class="number">1</span> : min(d1[r+l-i],r - i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>( i &gt;= k &amp;&amp; i + k &lt; n &amp;&amp; s[i-k] == s[i+k]) k++;</span><br><span class="line">            d1[i] = k--;</span><br><span class="line">            <span class="keyword">if</span>(i+k &gt; r)&#123;</span><br><span class="line">                r = i+k;</span><br><span class="line">                l = i-k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> chi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            hi[i] = max(hi[i],hi[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">while</span>(chi + d1[chi] &lt;= i) chi++;</span><br><span class="line">            hi[i] = max(hi[i],(i-chi)*<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long long maxProduct(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = s.size();</span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; prefix = manacher(s);</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; suffix = manacher(s);</span><br><span class="line">        reverse(rhi.begin(),rhi.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            ans = max(ans,(long long)prefix[i]*suffix[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-58&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-58&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 58&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 58&lt;/h1&gt;&lt;p&gt;本次的双周赛题目，前三题感觉都是正常的题目，第四题是&lt;code&gt;manacher&lt;/code&gt;算法，这个算法确实很少会遇到。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/08/jCEKGQTAiPNSqlJ.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5193-删除字符使字符串变好&quot;&gt;&lt;a href=&quot;#5193-删除字符使字符串变好&quot; class=&quot;headerlink&quot; title=&quot;5193. 删除字符使字符串变好&quot;&gt;&lt;/a&gt;5193. 删除字符使字符串变好&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个字符串如果没有 三个连续 相同字符，那么它就是一个 好字符串 。&lt;/p&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你从 &lt;code&gt;s&lt;/code&gt; 删除 最少 的字符，使它变成一个 好字符串 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab3 Pagetable</title>
    <link href="http://yoursite.com/2021/08/06/311/"/>
    <id>http://yoursite.com/2021/08/06/311/</id>
    <published>2021-08-06T06:34:23.578Z</published>
    <updated>2021-08-10T09:56:22.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="page-tables"><a href="#page-tables" class="headerlink" title="page tables"></a>page tables</h1><p>最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把<code>lab3</code>的内容作完了，<code>lab3</code>的难度感觉还是非常大的，不过最终把<code>lab3</code>完成后，就对虚拟内存管理有了深刻的认识。对于<code>vm</code>的那几个函数看了很多遍。调试了很多遍,终于发现问题,然后解决该问题了.<br><img src="https://i.loli.net/2021/08/10/FdEK8BPfDReA5kX.png" alt><br><a href="https://github.com/mike-box/MIT6.S081" target="_blank" rel="noopener">git repo</a></p><h2 id="page"><a href="#page" class="headerlink" title="page"></a>page</h2><p>在<code>xv6</code>系统中，物理内存都被分成了<code>4096</code>byte的页，比如物理地址也分为两部分即物理页码(44bit)和页内偏移地址(12bit)<code>offset</code>。由下图我们可以看到虚拟地址到物理地址的映射。<br><img src="https://i.loli.net/2021/08/07/BxHCM9VbyEvnrqz.png" alt><br>但在<code>xv6</code>系统中虚拟地址实际只用到64位中的低39位，高位的25位并没有用到，因此我们可以知道虚拟页总共有$2^{27}$页，我们假如直接进行地址的话，则可以发现每个页表的大小可能都为$2^{27}$,这对内存来说不可取，实际上我们采用分段式的页表映射。页表中的每一项每一项实际存储的虚拟地址印刷的物理页的索引号。在<code>xv6</code>系统中页表采用三级页表的形式的存储，每一级页表的大小实际刚好为一页物理页的大小，因此每一级页表刚好可以存储存储$2^{9}$项。<br><img src="https://i.loli.net/2021/08/09/PCe5ldv2pAUYZoa.png" alt></p><a id="more"></a><ul><li>我们通过下图可以看到一个虚拟地址实际包含5部分，保留位为25位，紧接着为9位的一级页表内的的<code>offset</code>，紧接着为9位的二级页表内的的<code>offset</code>，紧接着为9位的三级页表内的的<code>offset</code>，三级页表中则存储的为该虚拟地址对应的实际物理页编号，我们取出物理页编号，再加上<code>offset</code>即可得到实际的物理地址。<br><img src="https://i.loli.net/2021/08/07/O6GLjEMNrFSfb9w.png" alt><br>我们可以看到代码中几个比较重要的宏定义<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一个物理页的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="comment">// 物理页的offset</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="comment">//取出物理地址转换为对应的页表项</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="comment">//通过页表得到对应的物理页对应的编号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="comment">// 取出页表项中对应的标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure></li><li>三级页表中同时存储的有<code>flags</code>,<code>flags</code>代表该页表是否有效,我们需要判断每一页的访问权，只需要判断标志位即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U (1L <span class="meta-string">&lt;&lt; 4) // 1 -&gt; user can access</span></span></span><br></pre></td></tr></table></figure>我们通过虚拟地址的12~39位，实际为该虚拟地址的三级页表的偏移地址，通过三级页表的偏移地址，最终可以得到该虚拟地址对应的物理页号。<h3 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a>1. Print a page table</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To <span class="keyword">help</span> you learn about RISC-V page <span class="keyword">tables</span>, <span class="keyword">and</span> perhaps <span class="keyword">to</span> aid future debugging, your <span class="keyword">first</span> task <span class="keyword">is</span> <span class="keyword">to</span> write a <span class="keyword">function</span> that prints the <span class="keyword">contents</span> <span class="keyword">of</span> a page table.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Define</span> a <span class="keyword">function</span> called vmprint(). It should take a pagetable_t argument, <span class="keyword">and</span> print that pagetable <span class="keyword">in</span> the <span class="keyword">format</span> described below. <span class="keyword">Insert</span> <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>) vmprint(p-&gt;pagetable) <span class="keyword">in</span> exec.c just <span class="keyword">before</span> the <span class="keyword">return</span> argc, <span class="keyword">to</span> print the <span class="keyword">first</span> process<span class="string">'s page table. You receive full credit for this assignment if you pass the pte printout test of make grade.</span></span><br></pre></td></tr></table></figure>这部分比较简单，打印出页表的内容，我们知道三级页表的原理，这个即为简单的<code>dfs</code>遍历即可，遍历三级页表中的内容，每一级页表有<code>512</code>项，每一级页表有标志位，判断标志位是否有效，即是否包含PTE_V，则表示该页表有效。如果有效则向下遍历即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pteprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable,<span class="keyword">int</span> level)</span></span>&#123;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = &amp;pagetable[i];</span><br><span class="line">    <span class="comment">// level page table entry</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// page table is valid</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt; level; --j)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">".. "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"..%d: pte %p pa %p\n\r"</span>,i,*pte,(<span class="keyword">pagetable_t</span>)PTE2PA(*pte));</span><br><span class="line">      <span class="keyword">if</span>(level &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">         pteprint((<span class="keyword">pagetable_t</span>)PTE2PA(*pte),level<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2.A kernel page table per process"></a>2.A kernel page table per process</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Xv6 has a single kernel page <span class="keyword">table</span> that<span class="string">'s used whenever it executes in the kernel. The kernel page table is a direct mapping to physical addresses, so that kernel virtual address x maps to physical address x. Xv6 also has a separate page table for each process'</span>s <span class="keyword">user</span> address space, containing <span class="keyword">only</span> mappings <span class="keyword">for</span> that process<span class="string">'s user memory, starting at virtual address zero. Because the kernel page table doesn'</span>t contain these mappings, <span class="keyword">user</span> addresses are <span class="keyword">not</span> <span class="keyword">valid</span> <span class="keyword">in</span> the kernel. Thus, <span class="keyword">when</span> the kernel needs <span class="keyword">to</span> use a <span class="keyword">user</span> pointer passed <span class="keyword">in</span> a <span class="keyword">system</span> <span class="keyword">call</span> (e.g., the buffer pointer passed <span class="keyword">to</span> <span class="keyword">write</span>()), the kernel must first translate the pointer <span class="keyword">to</span> a physical address. The goal <span class="keyword">of</span> this section <span class="keyword">and</span> the next <span class="keyword">is</span> <span class="keyword">to</span> allow the kernel <span class="keyword">to</span> directly dereference <span class="keyword">user</span> pointers.</span><br><span class="line"></span><br><span class="line">Your first job <span class="keyword">is</span> <span class="keyword">to</span> modify the kernel so that every process uses its own <span class="keyword">copy</span> <span class="keyword">of</span> the kernel page <span class="keyword">table</span> <span class="keyword">when</span> executing <span class="keyword">in</span> the kernel. Modify struct proc <span class="keyword">to</span> maintain a kernel page <span class="keyword">table</span> <span class="keyword">for</span> <span class="keyword">each</span> process, <span class="keyword">and</span> modify the scheduler <span class="keyword">to</span> switch kernel page <span class="keyword">tables</span> <span class="keyword">when</span> switching processes. <span class="keyword">For</span> this step, <span class="keyword">each</span> per-process kernel page <span class="keyword">table</span> should be identical <span class="keyword">to</span> the existing <span class="keyword">global</span> kernel page <span class="keyword">table</span>. You pass this part <span class="keyword">of</span> the lab <span class="keyword">if</span> usertests runs correctly.</span><br><span class="line">``` </span><br><span class="line">+ 题目本质是说进行内核空间的虚拟地址和用户空间的虚拟地址因为不在同一个页表里，所以内核的地址空间和用户的地址无法正常进行访问，必须要通过转换，特别在内核态访问用户态传过来的地址时，无法直接访问，需要通过转换才可以，因此我们需要在内核态将用户态的虚拟地址空间也需要做映射，这样我们就可以在内核态直接访问用户态的地址。</span><br><span class="line">+ 在此时，我们需要重新为进行申请一个内核态的页表，每个进程则有一个独立的内核页表，并将访问系统的所有的特殊的接口地址全部映射到该页表中，同时将该进程的内核栈也映射到该页表。每个进程都有一个独立的内核栈，由于内核栈空间与用户空间的地址映射在同一个地址表中，因此可以直接访问。</span><br><span class="line"><span class="number">1.</span> 为进程建立一个内核页表，并做好地址映射。新建页表，并做好内核地址的映射。</span><br><span class="line">```c++</span><br><span class="line">pagetable_t</span><br><span class="line">prockvminit()&#123;</span><br><span class="line">pagetable_t pagetable = (pagetable_t) kalloc();</span><br><span class="line"><span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">panic("kalloc");</span><br><span class="line"></span><br><span class="line">// <span class="keyword">each</span> page size <span class="keyword">is</span> <span class="number">4096</span> byte = <span class="number">4</span>KB</span><br><span class="line">// kernel page <span class="keyword">table</span></span><br><span class="line">memset(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">// uart registers</span><br><span class="line">// uart mmmap</span><br><span class="line">prockvmmap(pagetable,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// virtio mmio disk interface</span><br><span class="line">prockvmmap(pagetable,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// CLINT</span><br><span class="line">//prockvmmap(pagetable,CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// PLIC</span><br><span class="line">prockvmmap(pagetable,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// map kernel <span class="type">text</span> executable <span class="keyword">and</span> <span class="keyword">read</span>-<span class="keyword">only</span>.</span><br><span class="line">prockvmmap(pagetable,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">// map kernel data <span class="keyword">and</span> the physical RAM w<span class="string">e'll make use of.</span></span><br><span class="line"><span class="string">prockvmmap(pagetable,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// map the trampoline for trap entry/exit to</span></span><br><span class="line"><span class="string">// the highest virtual address in the kernel.</span></span><br><span class="line"><span class="string">prockvmmap(pagetable,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return pagetable;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void</span></span><br><span class="line"><span class="string">prockvmmap(pagetable_t pagetable,uint64 va, uint64 pa, uint64 sz, int perm)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  if(mappages(pagetable, va, sz, pa, perm) != 0)&#123;</span></span><br><span class="line"><span class="string">  printf("total free = %d \n\r",totalfree());</span></span><br><span class="line"><span class="string">  printf("va = %p sz = %p \n\r",va,sz);</span></span><br><span class="line"><span class="string">    panic("prockvmmap");</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>在进程初始化时，我们可以保持不变，初始化时即为每个进程分配内核栈，映射到全局的<code>kernel_table</code>中,我们在进行进程<code>alloc</code>时，可以将该内核栈物理页再做一遍映射，映射到进程的内核表中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">procinit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">"nextpid"</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">"proc"</span>);</span><br><span class="line">  p-&gt;kallocstats = <span class="number">0</span>;</span><br><span class="line">    p-&gt;kfreestats = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// map kernel stack to the kernel page table</span></span><br><span class="line">  <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"kalloc"</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">  kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map kernel stack to the kernel page table</span></span><br><span class="line"> p-&gt;kpagetable = prockvminit();</span><br><span class="line"> prockvmmap(p-&gt;kpagetable,p-&gt;kstack,kvmpa(p-&gt;kstack),PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line"> <span class="keyword">if</span>((p-&gt;trapframe = (struct trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">   release(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// An empty user page table.</span></span><br><span class="line"> p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">   freeproc(p);</span><br><span class="line">   release(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>进程释放时，也需要对该进程的内核页表进行释放,但是释放时由于内核空间只是做了物理页的映射，因此我们只需要释放页表的空间即可，不需要释放物理页的空间。但在代码中加入了对每个进程执行<code>kalloc</code>和<code>kfree</code>的次数统计,发现实际确实存在内存泄漏,申请的物理页没有被释放的问题.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release trap frame</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="keyword">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//release user page table</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//release kernel page table and kernel stack</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpagetable) &#123; </span><br><span class="line">  procfreekpt(p-&gt;kpagetable);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;kpagetable = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li>我们用一个遍历即可，但是总感觉这个函数写的有点问题，没有释放所有的物理页，存在内存泄漏的问题，这个问题查找了很长时间没有解决。从github上下载了几个代码运行了一下，发现也都有问题。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages except leaf</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">procfreekpt</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; (PTE_R|PTE_W|PTE_X)) &#123;</span><br><span class="line">  uint64 child = PTE2PA(pte);</span><br><span class="line">  procfreekpt((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">  pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>进程调度时,当前进程如果被调度时,则此时我们需要将该进行的内核页表的地址加载到页表的寄存器中,此时我们访问地址进行转换时,则通过该页表查找物理页的地址.我们可以看到在完成上下文切换前,将页表加载完成即可.当前如果所有的进程都空闲时,则我们将全局的<code>kernel pagetable</code>进行加载.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">       p-&gt;state = RUNNING;</span><br><span class="line">       c-&gt;proc = p;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// load kernel pagetable address into page table</span></span><br><span class="line">    prockvminithart(p-&gt;kpagetable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load process kernel page table</span></span><br><span class="line">       swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Process is done running for now.</span></span><br><span class="line">       <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">       c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// found</span></span><br><span class="line">       found = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     release(&amp;p-&gt;lock);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// the current has no process runing</span></span><br><span class="line">   <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// use kernel pagetable when no process runing</span></span><br><span class="line">  kvminithart();</span><br><span class="line">  </span><br><span class="line">     intr_on();</span><br><span class="line">  <span class="comment">// load kernel page table</span></span><br><span class="line">     <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"wfi"</span>)</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-copyin-copyinstr"><a href="#3-copyin-copyinstr" class="headerlink" title="3.copyin/copyinstr"></a>3.copyin/copyinstr</h3></li><li>需要自己重新写<code>copyin</code>和<code>copyinstr</code>的代码，这个其实比较简单，在上一个练习中我们将内核中的所有的地址全部挂接到内核表中，在这个练习中我们需要将所有的用户空间的地址要全部映射到内核的页表中，这样在进程运行时，内核即可进行对用户空间的虚拟地址进行访问.我们可以重写一个函数对页表的物理页进行映射.下面函数的作用即是将一个页表中的虚地址全部映射到一个页表中.实际只做了物理页的映射,而并有实际的物理页的申请.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">procuvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> uvm,<span class="keyword">pagetable_t</span> kvm,uint64 old_sz, uint64 new_sz)</span></span>&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line">uint64 pa, i;</span><br><span class="line">uint flags;</span><br><span class="line"></span><br><span class="line">old_sz = PGROUNDUP(old_sz);</span><br><span class="line"><span class="keyword">if</span> (new_sz &lt;= old_sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = old_sz; i &lt; new_sz; i += PGSIZE)&#123;</span><br><span class="line"><span class="keyword">if</span>((pte = walk(uvm, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"procuvmcopy: pte should exist"</span>);</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"procuvmcopy: page not present"</span>);</span><br><span class="line">pa = PTE2PA(*pte);</span><br><span class="line">flags = PTE_FLAGS(*pte);</span><br><span class="line"><span class="keyword">if</span>(mappages(kvm, i, PGSIZE, pa, flags&amp;(~PTE_U)) != <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">"procuvmcopy: remap"</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">uvmunmap(kvm, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>我们仔细阅读提示,发现有几个函数需要进行此类操作和映射.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Replace copyin() with a call to copyin_new first, and make it work, before moving on to copyinstr.</span><br><span class="line">At each point where the kernel changes a process's user mappings, change the process's kernel page table in the same way. Such points include fork(), exec(), and sbrk().</span><br><span class="line">Don't forget that to include the first process's user page table in its kernel page table in userinit.</span><br><span class="line">What permissions <span class="keyword">do</span> the PTEs <span class="keyword">for</span> user addresses need in a process's kernel page table? (A page with PTE_U <span class="built_in">set</span> cannot be accessed in kernel mode.)</span><br><span class="line">Don't forget about the above-mentioned PLIC limit.</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>userinit</code>函数的修改,我们需要将<code>initcode</code>中加载的一个物理页进行<code>copy</code>映射.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init's instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// copy one page of the </span></span><br><span class="line">  procuvmcopy(p-&gt;pagetable, p-&gt;kpagetable,<span class="number">0</span>,PGSIZE) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first "return" from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">"initcode"</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br></pre></td></tr></table></figure></li><li><code>fork()</code>函数的修改, 我们发现<code>uvmcopy</code>时需要将父进程的用户空间页表全部拷贝到子进程,我们在完成拷贝时,则需要将该进程的用户空间的页表也全部拷贝一遍.将所有的页全部拷贝映射一遍即可.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Copy user memory mapper the kernel page table to child</span></span><br><span class="line">  <span class="keyword">if</span>(procuvmcopy(np-&gt;pagetable, np-&gt;kpagetable,<span class="number">0</span>,np-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><code>exec()</code>函数,我们可以看到<code>exec</code>函数函数执行时,首先会将<code>elf</code>文件里面的所有的段加载到内存中,并将其全部映射到进程的用户态页表中.首先我们需要将该进程的所有的内核的页表中所有的物理页映射全部去掉,然后就重新将用户空间的页表全部重新映射到内核的页表中.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">'/'</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we remove the old mapper and We mapper new pages to the kernel page table</span></span><br><span class="line">  uvmunmap(p-&gt;kpagetable, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(procuvmcopy(p-&gt;pagetable,p-&gt;kpagetable,<span class="number">0</span>,p-&gt;sz) &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">  </span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp;          <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure></li><li><code>sbrk</code>函数,我们实际需要修改<code>sys_sbrk</code>函数,当用户空间的物理内存增长时,此时我们需要将新增的地址空间页全部映射到内核的页表中,如果用户的物理内存缩小时,则此时我们需要将已经去掉的地址空间的映射全部取消掉.我们判断地址增长的时候会判断该地址是否增长超过了系统的限制.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">growproc(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// check the virtual address is no more than 0x0c000000L</span></span><br><span class="line">  <span class="keyword">if</span>((sz + n) &gt;= PLIC)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// malloc </span></span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// mapper user page to kernel page table</span></span><br><span class="line"><span class="keyword">if</span>((procuvmcopy(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, sz)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line"><span class="comment">// remove all the pages from the kernel table</span></span><br><span class="line">uvmunmap(p-&gt;kpagetable,PGROUNDUP(sz),(PGROUNDUP(p-&gt;sz)-PGROUNDUP(sz))/PGSIZE,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>总的来说这一章的<code>lab</code>还是非常有难度的,特别时调试的部分,花了很长时间都没有非常好的结果,感觉是目前遇到的难度最大的<code>lab</code>.<h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;page-tables&quot;&gt;&lt;a href=&quot;#page-tables&quot; class=&quot;headerlink&quot; title=&quot;page tables&quot;&gt;&lt;/a&gt;page tables&lt;/h1&gt;&lt;p&gt;最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把&lt;code&gt;lab3&lt;/code&gt;的内容作完了，&lt;code&gt;lab3&lt;/code&gt;的难度感觉还是非常大的，不过最终把&lt;code&gt;lab3&lt;/code&gt;完成后，就对虚拟内存管理有了深刻的认识。对于&lt;code&gt;vm&lt;/code&gt;的那几个函数看了很多遍。调试了很多遍,终于发现问题,然后解决该问题了.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/10/FdEK8BPfDReA5kX.png&quot; alt&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/MIT6.S081&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git repo&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;page&quot;&gt;&lt;a href=&quot;#page&quot; class=&quot;headerlink&quot; title=&quot;page&quot;&gt;&lt;/a&gt;page&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;xv6&lt;/code&gt;系统中，物理内存都被分成了&lt;code&gt;4096&lt;/code&gt;byte的页，比如物理地址也分为两部分即物理页码(44bit)和页内偏移地址(12bit)&lt;code&gt;offset&lt;/code&gt;。由下图我们可以看到虚拟地址到物理地址的映射。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/07/BxHCM9VbyEvnrqz.png&quot; alt&gt;&lt;br&gt;但在&lt;code&gt;xv6&lt;/code&gt;系统中虚拟地址实际只用到64位中的低39位，高位的25位并没有用到，因此我们可以知道虚拟页总共有$2^{27}$页，我们假如直接进行地址的话，则可以发现每个页表的大小可能都为$2^{27}$,这对内存来说不可取，实际上我们采用分段式的页表映射。页表中的每一项每一项实际存储的虚拟地址印刷的物理页的索引号。在&lt;code&gt;xv6&lt;/code&gt;系统中页表采用三级页表的形式的存储，每一级页表的大小实际刚好为一页物理页的大小，因此每一级页表刚好可以存储存储$2^{9}$项。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/09/PCe5ldv2pAUYZoa.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 252</title>
    <link href="http://yoursite.com/2021/08/01/310/"/>
    <id>http://yoursite.com/2021/08/01/310/</id>
    <published>2021-08-01T08:00:59.210Z</published>
    <updated>2021-08-01T09:01:24.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-252"><a href="#leetcode-contest-252" class="headerlink" title="leetcode  contest 252"></a>leetcode  contest 252</h1><p>本周周赛题目放水严重，基本上都是<code>mid</code>难度而已，不过自己还是太水,不晓得积分到达2200.不过感觉参加的周赛越多，排名和积分掉落的可能性越大。<br><img src="https://i.loli.net/2021/08/01/jHsWTAZgwkRiSNY.png" alt></p><h2 id="5830-三除数"><a href="#5830-三除数" class="headerlink" title="5830. 三除数"></a>5830. 三除数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code> 。如果 <code>n</code> 恰好有三个正除数 ，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>如果存在整数 <code>k</code>，满足 <code>n = k * m</code>，那么整数<code>m</code>就是 <code>n</code> 的一个 除数 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">2</span> 只有两个除数：<span class="number">1</span> 和 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">4</span> 有三个除数：<span class="number">1</span>、<span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/three-divisors</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   直接换算</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接暴力检测除数的个数即可，算法时间复杂度为$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> isThree(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i != n / i)&#123;</span><br><span class="line">                    <span class="comment">// 此时 i 与 n / i 为不同整数</span></span><br><span class="line">                    cnt += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时 i 与 n / i 相等</span></span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5831-你可以工作的最大周数"><a href="#5831-你可以工作的最大周数" class="headerlink" title="5831. 你可以工作的最大周数"></a>5831. 你可以工作的最大周数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你 <code>n</code>个项目，编号从 0 到 <code>n - 1</code>。同时给你一个整数数组 <code>milestones</code> ，其中每个<code>milestones[i]</code>表示第 i 个项目中的阶段任务数量。</p><p>你可以按下面两个规则参与项目中的工作：</p><ul><li>每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。</li><li>在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。<br>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</li></ul><p>返回在不违反上面规则的情况下你 最多 能工作多少周。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：milestones = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">​​​​- 第 <span class="number">1</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">2</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">3</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">4</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">5</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">6</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">总周数是 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：milestones = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">- 第 <span class="number">1</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">2</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">3</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">4</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">5</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">6</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">7</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">总周数是 <span class="number">7</span> 。</span><br><span class="line">注意，你不能在第 <span class="number">8</span> 周参与完成项目 <span class="number">0</span> 中的最后一个阶段任务，因为这会违反规则。</span><br><span class="line">因此，项目 <span class="number">0</span> 中会有一个阶段任务维持未完成状态。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == milestones.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= milestones[i] &lt;= 109</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题 + 贪心算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接假设需要将相邻的两周分配成为不同的任务即可，我们采购从高到底进行分配，我们可以看到，加入数量最多的任务可以被完成，则剩余的任务一定可以被完成。</li><li>我们实际可以看到剩余的任务为$rest = sum - longest$,如果$rest &gt;= longest - 1$,我们把剩余的任务看成一组，我们可以看到总有办法可以让相邻的两个任务交替运行且不相等。</li><li>算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">numberOfWeeks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; milestones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = milestones.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        sort(milestones.begin(),milestones.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum += milestones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(milestones.back()*<span class="number">2</span> &gt; sum)&#123;</span><br><span class="line">            <span class="keyword">return</span> (sum - milestones.back())*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5187-收集足够苹果的最小花园周长"><a href="#5187-收集足够苹果的最小花园周长" class="headerlink" title="5187. 收集足够苹果的最小花园周长"></a>5187. 收集足够苹果的最小花园周长</h2><p>给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 <code>(i, j)</code>处的苹果树有<code>|i| + |j|</code>个苹果。</p><p>你将会买下正中心坐标是 <code>(0, 0)</code>的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。</p><p>给你一个整数 <code>neededApples</code>，请你返回土地的 最小周长 ，使得 至少 有 <code>neededApples</code> 个苹果在土地 里面或者边缘上。</p><p><code>|x|</code> 的值定义为：</p><p>如果 <code>x &gt;= 0</code>，那么值为 <code>x</code><br>如果 <code>x &lt; 0</code>，那么值为 <code>-x</code></p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：neededApples = <span class="number">1</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：边长长度为 <span class="number">1</span> 的正方形不包含任何苹果。</span><br><span class="line">但是边长为 <span class="number">2</span> 的正方形包含 <span class="number">12</span> 个苹果（如上图所示）。</span><br><span class="line">周长为 <span class="number">2</span> * <span class="number">4</span> = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：neededApples = <span class="number">13</span></span><br><span class="line">输出：<span class="number">16</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：neededApples = <span class="number">1000000000</span></span><br><span class="line">输出：<span class="number">5040</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= neededApples &lt;= 1015</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的数学问题，我们先观察规律求出数列的通项公式，我们设正方形的边上为$2n$,则我们可以先观察正方形右下部分的数字分布规律，当前正方形的右上方也为正方形，边长为$n$.<script type="math/tex; mode=display">0 ,1 ,2 ,3, ... ,n \\1 ,2 ,3 ,4, ... ,n+1 \\2 ,3 ,4 ,5, ... ,n+2 \\... \\n, n+1, n+2, n+3, ... ,n+n \\</script>所以我们对每一列求数列之和为:<script type="math/tex; mode=display">sum = \frac{(n+1)(0+n)}{2} + \frac{(n+1)(1+n+1)}{2}+ \frac{(n+1)(2+n+2)}{2} + ... + \frac{(n+1)(n+n+n)}{2} \\= \frac{(n+1)(\frac{(n+1)(n+3*n)}{2})}{2} \\= n*(n+1)^{2}</script>我们求出了一部分的通项和，此时我们需要相加，并减去充分的边缘。<script type="math/tex; mode=display">total = 4*n*(n+1)^{2} - 4*\frac{(n+1)*(0+n)}{2} \\= 4*n*(n+1)^{2} - 2n*(n+1) \\= 2n*(2n+1)*(n+1)</script></li><li>由<code>1</code>式我们得出通项公式，则此时我们即可利用二分查找的方式，来快速确定周长小于等于$neededApples$的正方形。</li><li>算法时间复杂度为$O(n^{\frac{1}{3}})$.</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">minimumPerimeter</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> neededApples)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">2</span>*mid*(<span class="number">2</span>*mid + <span class="number">1</span>)*(mid + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(curr &gt;= neededApples)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans*<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5833-统计特殊子序列的数目"><a href="#5833-统计特殊子序列的数目" class="headerlink" title="5833. 统计特殊子序列的数目"></a>5833. 统计特殊子序列的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>特殊序列 是由 正整数 个<code>0</code> ，紧接着 正整数 个 <code>1</code> ，最后 正整数 个 <code>2</code> 组成的序列。</p><ul><li>比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。</li><li>相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。</li><li>给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。</li></ul><p>一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：特殊子序列为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]，[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 和 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：数组 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>] 中没有特殊子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：特殊子序列包括：</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 2</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-special-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-number-of-special-subsequences</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>最后一题为简单的<code>dp</code>，感觉可能难度只有<code>mid</code>.我们设<code>dp[i][j]</code>表示前<code>i</code>个元素中组成以<code>j</code>为结尾的合法的字串的个数。则我们可以知道:</li></ol><ul><li>当<code>nums[i] == 0</code>时，则我们可以知道要么当前的<code>0</code>作为独立的字符串开始，要么当前的<code>0</code>可以加在其余为<code>0</code>为结尾的字串中，要么当前的<code>0</code>不要，此时我们可以知道:<script type="math/tex; mode=display">dp[i][0] = 1 + dp[i-1][0] + dp[i-1][0]</script></li><li>当<code>nums[i] == 1</code>时，则我们可以知道要么当前的<code>1</code>可以加在其余为<code>1</code>为结尾的字串中，要么当前的<code>1</code>加在以<code>0</code>为结尾的字串中，要么当前的<code>1</code>不要，此时我们可以知道:<script type="math/tex; mode=display">dp[i][1] = dp[i-1][1] + dp[i-1][0] + dp[i-1][1]</script></li><li>当<code>nums[i] == 2</code>时，则我们可以知道要么当前的<code>2</code>可以加在其余为<code>2</code>为结尾的字串中，要么当前的<code>2</code>加在以<code>1</code>为结尾的字串中，要么当前的<code>2</code>不要，此时我们可以知道:<script type="math/tex; mode=display">dp[i][1] = dp[i-1][2] + dp[i-1][1] + dp[i-1][2]</script></li></ul><ol><li>本身来说是非常常规的<code>dp</code>，算法时间复杂度为$O(3n)$,空间复杂度为$O(3n)$. <h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSpecialSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">0</span>] + dp[i][<span class="number">0</span>] + <span class="number">1</span>)%mod;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">1</span>] = (dp[i][<span class="number">1</span>] + dp[i][<span class="number">1</span>] + dp[i][<span class="number">0</span>])%mod;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">2</span>] = (dp[i][<span class="number">2</span>] + dp[i][<span class="number">1</span>] + dp[i][<span class="number">2</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-252&quot;&gt;&lt;a href=&quot;#leetcode-contest-252&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 252&quot;&gt;&lt;/a&gt;leetcode  contest 252&lt;/h1&gt;&lt;p&gt;本周周赛题目放水严重，基本上都是&lt;code&gt;mid&lt;/code&gt;难度而已，不过自己还是太水,不晓得积分到达2200.不过感觉参加的周赛越多，排名和积分掉落的可能性越大。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/01/jHsWTAZgwkRiSNY.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5830-三除数&quot;&gt;&lt;a href=&quot;#5830-三除数&quot; class=&quot;headerlink&quot; title=&quot;5830. 三除数&quot;&gt;&lt;/a&gt;5830. 三除数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数&lt;code&gt;n&lt;/code&gt; 。如果 &lt;code&gt;n&lt;/code&gt; 恰好有三个正除数 ，返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果存在整数 &lt;code&gt;k&lt;/code&gt;，满足 &lt;code&gt;n = k * m&lt;/code&gt;，那么整数&lt;code&gt;m&lt;/code&gt;就是 &lt;code&gt;n&lt;/code&gt; 的一个 除数 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 57</title>
    <link href="http://yoursite.com/2021/07/25/309/"/>
    <id>http://yoursite.com/2021/07/25/309/</id>
    <published>2021-07-25T06:38:08.473Z</published>
    <updated>2021-07-25T07:34:47.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-251"><a href="#leetcode-contest-251" class="headerlink" title="leetcode  contest 251"></a>leetcode  contest 251</h1><p>周赛的题目质量依然很好，最后一题还是依靠自己的思考给解出来了，感觉这才是值得自己思考的地方，叶看到了自己的进步。<br><img src="https://i.loli.net/2021/07/25/2xsDzHhLZqYRyJG.png" alt></p><h2 id="5823-字符串转化后的各位数字之和"><a href="#5823-字符串转化后的各位数字之和" class="headerlink" title="5823. 字符串转化后的各位数字之和"></a>5823. 字符串转化后的各位数字之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由小写字母组成的字符串 <code>s</code>，以及一个整数 <code>k</code> 。</p><p>首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，’a’ 用 1 替换，’b’ 用 2 替换，… ‘z’ 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。</p><a id="more"></a><p>例如，如果 <code>s = &quot;zbax&quot;</code> 且<code>k = 2</code>，那么执行下述步骤后得到的结果是整数 8 ：</p><ul><li>转化：<code>&quot;zbax&quot; ➝ &quot;(26)(2)(1)(24)&quot; ➝ &quot;262124&quot; ➝ 262124</code></li><li>转换 <code>#1：262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17</code></li><li>转换 <code>#2：17 ➝ 1 + 7 ➝ 8</code><br>返回执行上述操作后得到的结果整数。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"iiii"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">36</span></span><br><span class="line">解释：操作如下：</span><br><span class="line">- 转化：<span class="string">"iiii"</span> ➝ <span class="string">"(9)(9)(9)(9)"</span> ➝ <span class="string">"9999"</span> ➝ <span class="number">9999</span></span><br><span class="line">- 转换 #<span class="number">1</span>：<span class="number">9999</span> ➝ <span class="number">9</span> + <span class="number">9</span> + <span class="number">9</span> + <span class="number">9</span> ➝ <span class="number">36</span></span><br><span class="line">因此，结果整数为 <span class="number">36</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：操作如下：</span><br><span class="line">- 转化：<span class="string">"leetcode"</span> ➝ <span class="string">"(12)(5)(5)(20)(3)(15)(4)(5)"</span> ➝ <span class="string">"12552031545"</span> ➝ <span class="number">12552031545</span></span><br><span class="line">- 转换 #<span class="number">1</span>：<span class="number">12552031545</span> ➝ <span class="number">1</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">2</span> + <span class="number">0</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">5</span> + <span class="number">4</span> + <span class="number">5</span> ➝ <span class="number">33</span></span><br><span class="line">- 转换 #<span class="number">2</span>：<span class="number">33</span> ➝ <span class="number">3</span> + <span class="number">3</span> ➝ <span class="number">6</span></span><br><span class="line">因此，结果整数为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 10</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-digits-of-string-after-convert" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-digits-of-string-after-convert</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  直接换算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一步首先我们需要将字母全部转换为数字。</li><li>我们依次执行<code>k</code>次变换，每次对数字求和然后转换为新的字符串。算法时间复杂度为$O(nk)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLucky</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            curr = curr + to_string(c-<span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : curr)&#123;</span><br><span class="line">                sum += c - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = to_string(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5824-子字符串突变后可能得到的最大整数"><a href="#5824-子字符串突变后可能得到的最大整数" class="headerlink" title="5824. 子字符串突变后可能得到的最大整数"></a>5824. 子字符串突变后可能得到的最大整数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>num</code>，该字符串表示一个大整数。另给你一个长度为 10 且 下标从 0  开始 的整数数组 <code>change</code> ，该数组将 0-9 中的每个数字映射到另一个数字。更规范的说法是，数字 d 映射为数字 <code>change[d]</code> 。</p><p>你可以选择 突变 <code>num</code>的任一子字符串。突变 子字符串意味着将每位数字 num[i] 替换为该数字在 <code>change</code>中的映射（也就是说，将 <code>num[i]</code>替换为 <code>change[num[i]]</code>）。</p><p>请你找出在对 num 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 最大整数 ，并用字符串表示返回。</p><p>子字符串 是字符串中的一个连续序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"132"</span>, change = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="string">"832"</span></span><br><span class="line">解释：替换子字符串 <span class="string">"1"</span>：</span><br><span class="line">- <span class="number">1</span> 映射为 change[<span class="number">1</span>] = <span class="number">8</span> 。</span><br><span class="line">因此 <span class="string">"132"</span> 变为 <span class="string">"832"</span> 。</span><br><span class="line"><span class="string">"832"</span> 是可以构造的最大整数，所以返回它的字符串表示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"021"</span>, change = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="string">"934"</span></span><br><span class="line">解释：替换子字符串 <span class="string">"021"</span>：</span><br><span class="line">- <span class="number">0</span> 映射为 change[<span class="number">0</span>] = <span class="number">9</span> 。</span><br><span class="line">- <span class="number">2</span> 映射为 change[<span class="number">2</span>] = <span class="number">3</span> 。</span><br><span class="line">- <span class="number">1</span> 映射为 change[<span class="number">1</span>] = <span class="number">4</span> 。</span><br><span class="line">因此，<span class="string">"021"</span> 变为 <span class="string">"934"</span> 。</span><br><span class="line"><span class="string">"934"</span> 是可以构造的最大整数，所以返回它的字符串表示。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"5"</span>, change = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="string">"5"</span></span><br><span class="line">解释：<span class="string">"5"</span> 已经是可以构造的最大整数，所以返回它的字符串表示。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 105</code></li><li><code>num</code> 仅由数字 0-9 组成</li><li><code>change.length == 10</code></li><li><code>0 &lt;= change[d] &lt;= 9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-number-after-mutating-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-number-after-mutating-substring</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质为贪心算法，我们优先找到最左侧可以替换为较大数字的字符，直到出现当前的字符<code>c</code>比<code>change[c]</code>大为止则结束。</li><li>算法时间复杂度为$O(n)$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maximumNumber</span><span class="params">(<span class="built_in">string</span> num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; change)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">bool</span> start = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = num[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(change[x] &gt; x)&#123;</span><br><span class="line">                num[i] = change[x] + <span class="string">'0'</span>;</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(change[x] &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(start) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5825-最大兼容性评分和"><a href="#5825-最大兼容性评分和" class="headerlink" title="5825. 最大兼容性评分和"></a>5825. 最大兼容性评分和</h2><p>有一份由 n 个问题组成的调查问卷，每个问题的答案要么是 0（<code>no</code>，否），要么是 1（<code>yes</code>，是）。</p><p>这份调查问卷被分发给 <code>m</code> 名学生和 <code>m</code> 名导师，学生和导师的编号都是从 0 到 m - 1 。学生的答案用一个二维整数数组 <code>students</code>表示，其中 <code>students[i]</code>是一个整数数组，包含第 i 名学生对调查问卷给出的答案（下标从 0 开始）。导师的答案用一个二维整数数组<code>mentors</code> 表示，其中 <code>mentors[j]</code>是一个整数数组，包含第 <code>j</code> 名导师对调查问卷给出的答案（下标从 0 开始）。</p><p>每个学生都会被分配给 一名 导师，而每位导师也会分配到 一名 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。</p><ul><li>例如，学生答案为<code>[1, 0, 1]</code> 而导师答案为 <code>[0, 0, 1]</code> ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。<br>请你找出最优的学生与导师的配对方案，以 最大程度上 提高 兼容性评分和 。</li></ul><p>给你 <code>students</code> 和 <code>mentors</code> ，返回可以得到的 最大兼容性评分和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：students = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]], mentors = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：按下述方式分配学生和导师：</span><br><span class="line">- 学生 <span class="number">0</span> 分配给导师 <span class="number">2</span> ，兼容性评分为 <span class="number">3</span> 。</span><br><span class="line">- 学生 <span class="number">1</span> 分配给导师 <span class="number">0</span> ，兼容性评分为 <span class="number">2</span> 。</span><br><span class="line">- 学生 <span class="number">2</span> 分配给导师 <span class="number">1</span> ，兼容性评分为 <span class="number">3</span> 。</span><br><span class="line">最大兼容性评分和为 <span class="number">3</span> + <span class="number">2</span> + <span class="number">3</span> = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：students = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>]], mentors = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：任意学生与导师配对的兼容性评分都是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == students.length == mentors.length</code></li><li><code>n == students[i].length == mentors[j].length</code></li><li><code>1 &lt;= m, n &lt;= 8</code></li><li><code>students[i][k] 为 0 或 1</code></li><li><code>mentors[j][k] 为 0 或 1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-compatibility-score-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-compatibility-score-sum</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩<code>dp</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的状态压缩<code>dp</code>,我们用<code>dp[x][y]</code>表示<code>x</code>表示的学生的二进制位图与<code>y</code>所表示的导师的二进制位图两者进行配对时的最大值，则此时我们可以直到<code>x</code>表示的学生个数一定与<code>y</code>表示的导师的个数相等。</li><li>我们可以直到递推公式如下：<script type="math/tex; mode=display">dp[x][y] = max(dp[x][y], dp[a][b] + score[x\oplus a][y\oplus b])</script>其中<code>a</code>为<code>x</code>的子集，<code>b</code>为<code>y</code>的子集。</li><li>算法时间复杂度为$O(n^{2}<em>2^{2</em>m})$,空间复杂度为$O(2^{2m})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            x = x&amp;(x<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCompatibilitySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; students, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mentors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = students.size();</span><br><span class="line">        <span class="keyword">int</span> n = students[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span>&lt;&lt;m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(mask,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(mask));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; score(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(students[i][k] == mentors[j][k])&#123;</span><br><span class="line">                        val++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                score[i][j] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = countOne(i);</span><br><span class="line">                <span class="keyword">int</span> y = countOne(j);</span><br><span class="line">                <span class="keyword">if</span>(x != y) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; m; ++a)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; m; ++b)&#123;</span><br><span class="line">                        <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;a))&amp;&amp;(j&amp;(<span class="number">1</span>&lt;&lt;b)))&#123;</span><br><span class="line">                            <span class="keyword">int</span> cx = i&amp;(~(<span class="number">1</span>&lt;&lt;a));</span><br><span class="line">                            <span class="keyword">int</span> cy = j&amp;(~(<span class="number">1</span>&lt;&lt;b));</span><br><span class="line">                            dp[i][j] = max(dp[i][j],dp[cx][cy] + score[a][b]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[mask<span class="number">-1</span>][mask<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5826-删除系统中的重复文件夹"><a href="#5826-删除系统中的重复文件夹" class="headerlink" title="5826. 删除系统中的重复文件夹"></a>5826. 删除系统中的重复文件夹</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组<code>paths</code>，其中 <code>paths[i]</code>是一个表示文件系统中第 i 个文件夹的绝对路径的数组。</p><ul><li><p>例如，<code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code>表示路径 <code>&quot;/one/two/three&quot;</code> 。<br>如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标记 为待删除。</p></li><li><p>例如，下面文件结构中的文件夹 <code>&quot;/a&quot;</code> 和 <code>&quot;/b&quot;</code> 相同。它们（以及它们的子文件夹）应该被 全部 标记为待删除：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/a</span></span><br><span class="line"><span class="string">/a/x</span></span><br><span class="line"><span class="string">/a/x/y</span></span><br><span class="line"><span class="string">/a/z</span></span><br><span class="line"><span class="string">/b</span></span><br><span class="line"><span class="string">/b/x</span></span><br><span class="line"><span class="string">/b/x/y</span></span><br><span class="line"><span class="string">/b/z</span></span><br></pre></td></tr></table></figure></li><li>然而，如果文件结构中还包含路径 <code>&quot;/b/w&quot;</code> ，那么文件夹 <code>&quot;/a&quot;</code> 和 <code>&quot;/b&quot;</code> 就不相同。注意，即便添加了新的文件夹 <code>&quot;/b/w&quot;</code>，仍然认为 <code>&quot;/a/x&quot;</code>和 <code>&quot;/b/x&quot;</code>相同。<br>一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 删除 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。</li></ul><p>返回二维数组<code>ans</code> ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 任意顺序 返回。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"c"</span>],[<span class="string">"d"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"b"</span>],[<span class="string">"d"</span>,<span class="string">"a"</span>]]</span><br><span class="line">输出：[[<span class="string">"d"</span>],[<span class="string">"d"</span>,<span class="string">"a"</span>]]</span><br><span class="line">解释：文件结构如上所示。</span><br><span class="line">文件夹 <span class="string">"/a"</span> 和 <span class="string">"/c"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 <span class="string">"b"</span> 的空文件夹。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"c"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"b"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"x"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"w"</span>],[<span class="string">"w"</span>,<span class="string">"y"</span>]]</span><br><span class="line">输出：[[<span class="string">"c"</span>],[<span class="string">"c"</span>,<span class="string">"b"</span>],[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>]]</span><br><span class="line">解释：文件结构如上所示。</span><br><span class="line">文件夹 <span class="string">"/a/b/x"</span> 和 <span class="string">"/w"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 <span class="string">"y"</span> 的空文件夹。</span><br><span class="line">注意，文件夹 <span class="string">"/a"</span> 和 <span class="string">"/c"</span> 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>],[<span class="string">"c"</span>],[<span class="string">"a"</span>]]</span><br><span class="line">输出：[[<span class="string">"c"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>],[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>]]</span><br><span class="line">解释：文件系统中所有文件夹互不相同。</span><br><span class="line">注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"a"</span>,<span class="string">"z"</span>],[<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：文件结构如上所示。</span><br><span class="line">文件夹 <span class="string">"/a/x"</span> 和 <span class="string">"/b/x"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 <span class="string">"y"</span> 的空文件夹。</span><br><span class="line">文件夹 <span class="string">"/a"</span> 和 <span class="string">"/b"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 <span class="string">"z"</span> 的空文件夹以及上面提到的文件夹 <span class="string">"x"</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"a"</span>,<span class="string">"z"</span>],[<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>],[<span class="string">"b"</span>,<span class="string">"w"</span>]]</span><br><span class="line">输出：[[<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"w"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>],[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"z"</span>]]</span><br><span class="line">解释：本例与上例的结构基本相同，除了新增 <span class="string">"/b/w"</span> 文件夹。</span><br><span class="line">文件夹 <span class="string">"/a/x"</span> 和 <span class="string">"/b/x"</span> 仍然会被标记，但 <span class="string">"/a"</span> 和 <span class="string">"/b"</span> 不再被标记，因为 <span class="string">"/b"</span> 中有名为 <span class="string">"w"</span> 的空文件夹而 <span class="string">"/a"</span> 没有。</span><br><span class="line">注意，<span class="string">"/a/z"</span> 和 <span class="string">"/b/z"</span> 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= paths.length &lt;= 2 * 104</code></li><li><code>1 &lt;= paths[i].length &lt;= 500</code></li><li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li><li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 105</code></li><li><code>path[i][j]</code>由小写英文字母组成</li><li>不会存在两个路径都指向同一个文件夹的情况</li><li>对于不在根层级的任意文件夹，其父文件夹也会包含在输入中</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/delete-duplicate-folders-in-system" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-duplicate-folders-in-system</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS + hash</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>如果了解了题目的本意本题应该不是很难，难点在于如何序列化的编码表示一颗多叉树的子树，在此时处理中我们字符串来表示一棵二叉树，用递归来处理，假设以<code>root</code>为根的节点的多叉树的子树的字符串表示分别为$[s_{1},s_{2},s_{3},…,s{k}]$,根节点的关键字为$val$,我们编码如下：</li></ol><ul><li>以<code>root</code>为根节点的所有的子树且不包含<code>root</code>的字符串编码依次以用<code>,</code>进行相连，编码表示为:<script type="math/tex; mode=display">s_{1} , s_{2} , s_{3} .... ,s{k}</script></li><li><ul><li>以<code>root</code>为根节点的所有的子树且包含<code>root</code>的字符串编码依次以用<code>.</code>进行相连，<code>root</code>节点且包含<code>root</code>节点的子树编码表示为:<script type="math/tex; mode=display">val．s_{1}，s_{2}，s_{3} ....，s{k}</script>采用以上编码即可唯一的标识一颗多叉树，关键一点记住所有的孩子节点都按照字典序进行排序。这样可以防止乱序，但是节点还是相等。这种编码很简单，但是感觉容易出效率问题，最好还是老老实实用字符串<code>hash</code>这种快速的映射方法。</li></ul></li></ul><ol><li>我们首先读取所有的<code>path</code>，然后按照顺序进行建立二叉树；我们第一遍用<code>dfs</code>遍历二叉树，可以得到所有子树的字符串编码，此时我们进行判断，判定子树的字符串编码是否已经存在，如果已经存在，我们则认为当前根结点可以设置为待删除节点，如果不存在则我们更新字典库；最后一次<code>dfs</code>时，我们判断当前节点是否被标记，如果已经被标记，则我们直接跳过即可，依次即可得到最终去重后的树的遍历结果。</li><li>算法时间复杂度为$O(2N + NlgN)$,空间复杂度为$O(N)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> val;</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,Node *&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insertTree</span><span class="params">(Node * root,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; path)</span></span>&#123;</span><br><span class="line">        Node * node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;child.count(path[i]))&#123;</span><br><span class="line">                node-&gt;child[path[i]] = <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;child[path[i]];</span><br><span class="line">            node-&gt;val = path[i];</span><br><span class="line">            node-&gt;valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs1</span><span class="params">(Node * root,<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,Node *&gt; &amp; key)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> stree;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;child.size() == <span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : root-&gt;child)&#123;</span><br><span class="line">            stree += dfs1(v.second,key) + <span class="string">","</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key.count(stree)) &#123;</span><br><span class="line">            root-&gt;valid = <span class="literal">false</span>;</span><br><span class="line">            key[stree]-&gt;valid = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            key[stree] = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="string">"."</span> + stree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs2</span><span class="params">(Node *root,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; curr,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;valid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : root-&gt;child)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second-&gt;valid)&#123;</span><br><span class="line">                curr.push_back(v.first);</span><br><span class="line">                res.push_back(curr);</span><br><span class="line">                dfs2(v.second,curr,res);</span><br><span class="line">                curr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; deleteDuplicateFolder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = paths.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,Node *&gt; key;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr;</span><br><span class="line">       </span><br><span class="line">        Node * root = <span class="keyword">new</span> Node(); </span><br><span class="line">        root-&gt;val = <span class="string">""</span>;</span><br><span class="line">        root-&gt;valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            insertTree(root,paths[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(root,key);</span><br><span class="line">        dfs2(root,arr,ans);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-251&quot;&gt;&lt;a href=&quot;#leetcode-contest-251&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 251&quot;&gt;&lt;/a&gt;leetcode  contest 251&lt;/h1&gt;&lt;p&gt;周赛的题目质量依然很好，最后一题还是依靠自己的思考给解出来了，感觉这才是值得自己思考的地方，叶看到了自己的进步。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/25/2xsDzHhLZqYRyJG.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5823-字符串转化后的各位数字之和&quot;&gt;&lt;a href=&quot;#5823-字符串转化后的各位数字之和&quot; class=&quot;headerlink&quot; title=&quot;5823. 字符串转化后的各位数字之和&quot;&gt;&lt;/a&gt;5823. 字符串转化后的各位数字之和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由小写字母组成的字符串 &lt;code&gt;s&lt;/code&gt;，以及一个整数 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，’a’ 用 1 替换，’b’ 用 2 替换，… ‘z’ 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 57</title>
    <link href="http://yoursite.com/2021/07/24/308/"/>
    <id>http://yoursite.com/2021/07/24/308/</id>
    <published>2021-07-24T15:36:28.653Z</published>
    <updated>2021-07-24T16:11:12.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-57"><a href="#leetcode-biweekly-contest-57" class="headerlink" title="leetcode  biweekly contest 57"></a>leetcode  biweekly contest 57</h1><p>双周赛的题目还是简单啊，基本上思路都不是很复杂，又AK了一次。整体思路不是很难。<br><img src="https://i.loli.net/2021/07/25/myIAJqo7MT16ZB3.png" alt></p><h2 id="5804-检查是否所有字符出现次数相同"><a href="#5804-检查是否所有字符出现次数相同" class="headerlink" title="5804. 检查是否所有字符出现次数相同"></a>5804. 检查是否所有字符出现次数相同</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，如果 <code>s</code>是一个 好 字符串，请你返回<code>true</code>，否则请返回 <code>false</code>。</p><p>如果 <code>s</code> 中出现过的 所有 字符的出现次数 相同 ，那么我们称字符串 <code>s</code>是 好 字符串。</p><a id="more"></a><p>示例 1：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abacbc"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：s 中出现过的字符为 <span class="string">'a'</span>，<span class="string">'b'</span> 和 <span class="string">'c'</span> 。s 中所有字符均出现 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaabb"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：s 中出现过的字符为 <span class="string">'a'</span> 和 <span class="string">'b'</span> 。</span><br><span class="line"><span class="string">'a'</span> 出现了 <span class="number">3</span> 次，<span class="string">'b'</span> 出现了 <span class="number">2</span> 次，两者出现次数不同。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= s.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `s` 只包含小写英文字母。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址 </span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/maximum-number-of-words-you-can-type</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;   暴力检测</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 统计字符串中所有字符的个数即可得到结果。</span><br><span class="line"><span class="number">2.</span> 算法时间复杂度为$O(n)$,空间复杂度为$O(<span class="number">26</span>)$.</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> areOccurrencesEqual(<span class="keyword">string</span> s) &#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(auto c : s) cnt[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = cnt.begin()-&gt;second;</span><br><span class="line">        <span class="keyword">for</span>(auto v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second != x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5805-最小未被占据椅子的编号"><a href="#5805-最小未被占据椅子的编号" class="headerlink" title="5805. 最小未被占据椅子的编号"></a>5805. 最小未被占据椅子的编号</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有 n 个朋友在举办一个派对，这些朋友从 <code>0</code> 到 <code>n - 1</code>编号。派对里有 无数 张椅子，编号为 0 到<code>infinity</code>。当一个朋友到达派对时，他会占据 编号最小 且未被占据的椅子。</p><p>比方说，当一个朋友到达时，如果椅子 <code>0</code> ，<code>1</code>和 <code>5</code>被占据了，那么他会占据 2 号椅子。<br>当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。</p><p>给你一个下标从 0 开始的二维整数数组 <code>times</code>，其中<code>times[i] = [arrivali, leavingi]</code>表示第 i 个朋友到达和离开的时刻，同时给你一个整数 targetFriend 。所有到达时间 互不相同 。</p><p>请你返回编号为 <code>targetFriend</code> 的朋友占据的 椅子编号 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：times = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">6</span>]], targetFriend = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">1</span> 到达，占据椅子 <span class="number">0</span> 。</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">2</span> 到达，占据椅子 <span class="number">1</span> 。</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">3</span> 离开，椅子 <span class="number">1</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">4</span> 离开，椅子 <span class="number">0</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">2</span> 时刻 <span class="number">4</span> 到达，占据椅子 <span class="number">0</span> 。</span><br><span class="line">朋友 <span class="number">1</span> 占据椅子 <span class="number">1</span> ，所以返回 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">输入：times = [[<span class="number">3</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>]], targetFriend = <span class="number">0</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">1</span> 到达，占据椅子 <span class="number">0</span> 。</span><br><span class="line">- 朋友 <span class="number">2</span> 时刻 <span class="number">2</span> 到达，占据椅子 <span class="number">1</span> 。</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">3</span> 到达，占据椅子 <span class="number">2</span> 。</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">5</span> 离开，椅子 <span class="number">0</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">2</span> 时刻 <span class="number">6</span> 离开，椅子 <span class="number">1</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">10</span> 离开，椅子 <span class="number">2</span> 变成未占据。</span><br><span class="line">朋友 <span class="number">0</span> 占据椅子 <span class="number">2</span> ，所以返回 <span class="number">2</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == times.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">104</span>`</span><br><span class="line">+ `times[i].length == <span class="number">2</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= arrivali &lt; leavingi &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= targetFriend &lt;= n - <span class="number">1</span>`</span><br><span class="line">+ 每个 `arrivali` 时刻 互不相同 。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/add-minimum-number-of-rungs</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  贪心 + 优先级队列</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 仔细观察题目，基本就是套路的优先级队列，我们设两个优先级队列，队列`<span class="number">1</span>`保存当前空闲的椅子的编号，并按照标号从小到大排列我们每次可以从队列中取得标号最小的椅子；队列`<span class="number">2</span>`保存当前已经已经占用的椅子的标号，按照椅子释放的时间先后进行排序，我们每次可以取得当前最近会被释放的椅子的编号。</span><br><span class="line"><span class="number">2.</span> 我们首先将所有的朋友按照到达时间的先后进行排序，每次排序完成后，我们每次从队列`<span class="number">1</span>`中取椅子之前，首先将队列`<span class="number">2</span>`中所有释放时间小于等于当前达到时间的椅子全部出队列，并将这些已经释放椅子的编号放入到队列`<span class="number">1</span>`中；然后我们再从队列中取出编号最小的椅子，同时将该椅子的释放时间进入到队列`<span class="number">2</span>`中。按照如上贪心算法即可得到最优结果。</span><br><span class="line"><span class="number">3.</span> 算法时间复杂度为$O(<span class="number">2</span>*(n + nlgn))$,空间复杂度为$O(<span class="number">2</span>n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line">struct cmp&#123;</span><br><span class="line">    <span class="built_in">bool</span> operator()(pii &amp; a,pii &amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> smallestChair(vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; times, <span class="built_in">int</span> targetFriend) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;<span class="built_in">int</span>,vector&lt;<span class="built_in">int</span>&gt;,greater&lt;<span class="built_in">int</span>&gt;&gt; pq1;</span><br><span class="line">        priority_queue&lt;pii,vector&lt;pii&gt;,cmp&gt; pq2;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> n = times.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            times[i].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(times.begin(),times.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) pq1.push(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!pq2.empty() &amp;&amp; pq2.top().first &lt;= times[i][<span class="number">0</span>])&#123;</span><br><span class="line">                pq1.push(pq2.top().second);</span><br><span class="line">                pq2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> x = pq1.top();</span><br><span class="line">            <span class="keyword">if</span>(targetFriend == times[i][<span class="number">2</span>]) ans = x;</span><br><span class="line">            pq1.pop();</span><br><span class="line">            pq2.push(make_pair(times[i][<span class="number">1</span>],x));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5806-描述绘画结果"><a href="#5806-描述绘画结果" class="headerlink" title="5806. 描述绘画结果"></a>5806. 描述绘画结果</h2><p>给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有 独一无二 的颜色。给你二维整数数组<code>segments</code>，其中 <code>segments[i] = [starti, endi, colori]</code>表示线段为 半开区间 <code>[starti, endi)</code>且颜色为 <code>colori</code> 。</p><p>线段间重叠部分的颜色会被 混合 。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个 集合 表示这个混合颜色。</p><p>比方说，如果颜色 2 ，4 和 6 被混合，那么结果颜色为 <code>{2,4,6}</code>。<br>为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的 和 来表示颜色集合。</p><p>你想要用 最少数目 不重叠 半开区间 来 表示 这幅混合颜色的画。这些线段可以用二维数组 <code>painting</code>表示，其中<code>painting[j] = [leftj, rightj, mixj]</code> 表示一个 半开区间<code>[leftj, rightj)</code> 的颜色 和 为 <code>mixj</code> 。</p><p>比方说，这幅画由 <code>segments = [[1,4,5],[1,7,7]]</code>组成，那么它可以表示为 <code>painting = [[1,4,12],[4,7,7]]</code> ，因为：<br>[1,4) 由颜色 {5,7} 组成（和为 12），分别来自第一个线段和第二个线段。<br>[4,7) 由颜色 {7} 组成，来自第二个线段。<br>请你返回二维数组<code>painting</code>，它表示最终绘画的结果（没有 被涂色的部分不出现在结果中）。你可以按 任意顺序 返回最终数组的结果。</p><p>半开区间 <code>[a, b)</code> 是数轴上点 <code>a</code>和点<code>b</code>之间的部分，包含 点 a 且 不包含 点 b 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：segments = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">14</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">16</span>]]</span><br><span class="line">解释：绘画借故偶可以表示为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">4</span>) 颜色为 &#123;<span class="number">5</span>,<span class="number">9</span>&#125; （和为 <span class="number">14</span>），分别来自第一和第二个线段。</span><br><span class="line">- [<span class="number">4</span>,<span class="number">7</span>) 颜色为 &#123;<span class="number">7</span>,<span class="number">9</span>&#125; （和为 <span class="number">16</span>），分别来自第二和第三个线段。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：segments = [[<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>],[<span class="number">6</span>,<span class="number">8</span>,<span class="number">15</span>],[<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">24</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>],[<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>]]</span><br><span class="line">解释：绘画结果可以以表示为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">6</span>) 颜色为 <span class="number">9</span> ，来自第一个线段。</span><br><span class="line">- [<span class="number">6</span>,<span class="number">7</span>) 颜色为 &#123;<span class="number">9</span>,<span class="number">15</span>&#125; （和为 <span class="number">24</span>），来自第一和第二个线段。</span><br><span class="line">- [<span class="number">7</span>,<span class="number">8</span>) 颜色为 <span class="number">15</span> ，来自第二个线段。</span><br><span class="line">- [<span class="number">8</span>,<span class="number">10</span>) 颜色为 <span class="number">7</span> ，来自第三个线段。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：segments = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">12</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">12</span>]]</span><br><span class="line">解释：绘画结果可以表示为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">4</span>) 颜色为 &#123;<span class="number">5</span>,<span class="number">7</span>&#125; （和为 <span class="number">12</span>），分别来自第一和第二个线段。</span><br><span class="line">- [<span class="number">4</span>,<span class="number">7</span>) 颜色为 &#123;<span class="number">1</span>,<span class="number">11</span>&#125; （和为 <span class="number">12</span>），分别来自第三和第四个线段。</span><br><span class="line">注意，只返回一个单独的线段 [<span class="number">1</span>,<span class="number">7</span>) 是不正确的，因为混合颜色的集合不相同。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= segments.length &lt;= 2 * 104</code></li><li><code>segments[i].length == 3</code></li><li><code>1 &lt;= starti &lt; endi &lt;= 105</code></li><li><code>1 &lt;= colori &lt;= 109</code></li><li>每种颜色 <code>colori</code>互不相同。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-points-with-cost" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-points-with-cost</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 差分数组</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的差分数组题目。感觉看到类似的线段区间的题目基本上都可以用差分数组搞定。跟求区间内重合的线段的次数基本上一样的题目。</li><li>我们将区间进行标记，对于区间的左端点则标记为$colori$,区间的右端点标记为$-colori$,当我们到达一个新的区间的左端点时，则此时和肯定会增加，在区间右端点时则减去该线段的贡献。基本上就是套路题目吧。</li><li>因为用了<code>map</code>，所以时间复杂度为$O(nlg)$，用数组的话时间复杂度可以优化到$O(n)$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; splitPainting(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; segments) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = segments.size();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cnt[segments[i][<span class="number">0</span>]].push_back(segments[i][<span class="number">2</span>]);</span><br><span class="line">            cnt[segments[i][<span class="number">1</span>]].push_back(-segments[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            l = r;</span><br><span class="line">            r = v.first;</span><br><span class="line">            <span class="keyword">if</span>(l &gt; <span class="number">0</span> &amp;&amp; sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr = &#123;l,r,sum&#125;;</span><br><span class="line">                ans.push_back(arr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : v.second)&#123;</span><br><span class="line">                sum += x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5196-队列中可以看到的人数"><a href="#5196-队列中可以看到的人数" class="headerlink" title="5196. 队列中可以看到的人数"></a>5196. 队列中可以看到的人数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有 <code>n</code> 个人排成一个队列，从左到右 编号为 0 到 <code>n - 1</code>。给你以一个整数数组 <code>heights</code> ，每个整数 互不相同，<code>heights[i]</code> 表示第 i 个人的高度。</p><p>一个人能 看到 他右边另一个人的条件是这两人之间的所有人都比他们两人 矮 。更正式的，第 i 个人能看到第 j 个人的条件是 <code>i &lt; j</code> 且<code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>。</p><p>请你返回一个长度为 n 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 i 个人在他右侧队列中能 看到 的 人数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">10</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 个人能看到编号为 <span class="number">1</span> ，<span class="number">2</span> 和 <span class="number">4</span> 的人。</span><br><span class="line">第 <span class="number">1</span> 个人能看到编号为 <span class="number">2</span> 的人。</span><br><span class="line">第 <span class="number">2</span> 个人能看到编号为 <span class="number">3</span> 和 <span class="number">4</span> 的人。</span><br><span class="line">第 <span class="number">3</span> 个人能看到编号为 <span class="number">4</span> 的人。</span><br><span class="line">第 <span class="number">4</span> 个人能看到编号为 <span class="number">5</span> 的人。</span><br><span class="line">第 <span class="number">5</span> 个人谁也看不到因为他右边没人。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == heights.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= heights[i] &lt;= <span class="number">105</span>`</span><br><span class="line">+ `heights` 中所有数 互不相同 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-57/problems/number-of-visible-people-in-a-queue/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  单调栈</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 典型的单调栈，不过稍微复杂一点，需要稍微处理.由于我们用单调栈保存右边身高的人，并按照从小到大进行排列。我们每次将找到第一个大于等于当前的人的高度的人，则我们记数当前从队列中弹出的人数加`<span class="number">1</span>`即为可以看见的人数。比赛的时候竟然很搓的二分查找搞定。</span><br><span class="line"><span class="number">2.</span> 时间复杂度为$O(N)$,空间复杂为$O(N)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; canSeePersonsCount(vector&lt;<span class="built_in">int</span>&gt;&amp; heights) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = heights.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        arr.push_back(heights[n<span class="number">-1</span>]);</span><br><span class="line">        ans[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!arr.empty() &amp;&amp; heights[i] &gt;= arr.back())&#123;</span><br><span class="line">                ans[i]++;</span><br><span class="line">                arr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!arr.empty()) ans[i]++;</span><br><span class="line">            arr.push_back(heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-57&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-57&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 57&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 57&lt;/h1&gt;&lt;p&gt;双周赛的题目还是简单啊，基本上思路都不是很复杂，又AK了一次。整体思路不是很难。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/25/myIAJqo7MT16ZB3.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5804-检查是否所有字符出现次数相同&quot;&gt;&lt;a href=&quot;#5804-检查是否所有字符出现次数相同&quot; class=&quot;headerlink&quot; title=&quot;5804. 检查是否所有字符出现次数相同&quot;&gt;&lt;/a&gt;5804. 检查是否所有字符出现次数相同&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，如果 &lt;code&gt;s&lt;/code&gt;是一个 好 字符串，请你返回&lt;code&gt;true&lt;/code&gt;，否则请返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果 &lt;code&gt;s&lt;/code&gt; 中出现过的 所有 字符的出现次数 相同 ，那么我们称字符串 &lt;code&gt;s&lt;/code&gt;是 好 字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 250</title>
    <link href="http://yoursite.com/2021/07/18/307/"/>
    <id>http://yoursite.com/2021/07/18/307/</id>
    <published>2021-07-18T06:22:38.780Z</published>
    <updated>2021-07-18T11:48:23.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-250"><a href="#leetcode-contest-250" class="headerlink" title="leetcode  contest  250"></a>leetcode  contest  250</h1><p>周赛的题目质量还是非常高，还是前3题，不过第三题竟然用了最复杂的线段树搞定。真心是。<br><img src="https://i.loli.net/2021/07/18/Jlbu3VOKG9SYHrE.png" alt></p><h2 id="5161-可以输入的最大单词数"><a href="#5161-可以输入的最大单词数" class="headerlink" title="5161. 可以输入的最大单词数"></a>5161. 可以输入的最大单词数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。</p><p>给你一个由若干单词组成的字符串 <code>text</code> ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 <code>brokenLetters</code> ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 <code>text</code> 中单词的数目。</p><a id="more"></a><p>示例 1：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"hello world"</span>, brokenLetters = <span class="string">"ad"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：无法输入 <span class="string">"world"</span> ，因为字母键 <span class="string">'d'</span> 已损坏。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"leet code"</span>, brokenLetters = <span class="string">"lt"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：无法输入 <span class="string">"leet"</span> ，因为字母键 <span class="string">'l'</span> 和 <span class="string">'t'</span> 已损坏。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"leet code"</span>, brokenLetters = <span class="string">"e"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无法输入任何单词，因为字母键 <span class="string">'e'</span> 已损坏。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= text.length &lt;= 104</code></li><li><code>0 &lt;= brokenLetters.length &lt;= 26</code></li><li><code>text</code> 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格</li><li>每个单词仅由小写英文字母组成</li><li><code>brokenLetters</code> 由 互不相同 的小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-words-you-can-type" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-words-you-can-type</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>通过split函数分离出单词，然后依次检验每个单词是否合法即可统计出合法的单词数目。</li><li>算法时间复杂度为$O(n)$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">string</span> &amp; str)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; str.size() &amp;&amp; str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = i;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; str.size() &amp;&amp; str[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; curr)&#123;</span><br><span class="line">                ans.push_back(str.substr(curr,i-curr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canBeTypedWords</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">string</span> brokenLetters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; valid(<span class="number">26</span>,<span class="literal">true</span>);        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; curr = split(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : brokenLetters)&#123;</span><br><span class="line">            valid[c-<span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curr[i].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!valid[curr[i][j]-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                    isValid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5814-新增的最少台阶数"><a href="#5814-新增的最少台阶数" class="headerlink" title="5814. 新增的最少台阶数"></a>5814. 新增的最少台阶数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 严格递增 的整数数组 <code>rungs</code> ，用于表示梯子上每一台阶的 高度 。当前你正站在高度为 0 的地板上，并打算爬到最后一个台阶。</p><p>另给你一个整数 <code>dist</code> 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）不超过 <code>dist</code> 高度的台阶。当然，你也可以在任何正 整数 高度处插入尚不存在的新台阶。</p><p>返回爬到最后一阶时必须添加到梯子上的 最少 台阶数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>], dist = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">现在无法到达最后一阶。</span><br><span class="line">在高度为 <span class="number">7</span> 和 <span class="number">8</span> 的位置增设新的台阶，以爬上梯子。 </span><br><span class="line">梯子在高度为 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>] 的位置上有台阶。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>], dist = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">这个梯子无需增设新台阶也可以爬上去。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], dist = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">现在无法从地板到达梯子的第一阶。 </span><br><span class="line">在高度为 <span class="number">1</span> 的位置增设新的台阶，以爬上梯子。 </span><br><span class="line">梯子在高度为 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>] 的位置上有台阶。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">5</span>], dist = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：这个梯子无需增设新台阶也可以爬上去。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= rungs.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= rungs[i] &lt;= <span class="number">109</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= dist &lt;= <span class="number">109</span>`</span><br><span class="line">+ `rungs` 严格递增</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/add-minimum-number-of-rungs</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  贪心算法</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接模拟即可，题目要求两个台阶的高度不超过`dist`，则我们可以知道根据贪心算法，我们应该尽可能的跨向高度更高的梯子，$x$与$y$两者之间所需要加的梯子即为向下取整即可，$\frac&#123;y-x<span class="number">-1</span>&#125;&#123;dist&#125;$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> addRungs(vector&lt;<span class="built_in">int</span>&gt;&amp; rungs, <span class="built_in">int</span> dist) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = rungs.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += (rungs[i] - h <span class="number">-1</span>)/dist;</span><br><span class="line">            h = rungs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5815-扣分后的最大得分"><a href="#5815-扣分后的最大得分" class="headerlink" title="5815. 扣分后的最大得分"></a>5815. 扣分后的最大得分</h2><p>给你一个 <code>m x n</code>的整数矩阵 <code>points</code> （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。</p><p>你的得分方式为：每一行 中选取一个格子，选中坐标为 <code>(r, c)</code>的格子会给你的总得分 增加 <code>points[r][c]</code> 。</p><p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code>和 <code>r + 1</code> （其中 <code>0 &lt;= r &lt; m - 1</code>），选中坐标为 <code>(r, c1)</code>和 <code>(r + 1, c2)</code>的格子，你的总得分 减少 <code>abs(c1 - c2)</code>。</p><p>请你返回你能得到的 最大 得分。</p><p><code>abs(x)</code> 定义为：</p><ul><li>如果 <code>x &gt;= 0</code>，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：</span><br><span class="line">蓝色格子是最优方案选中的格子，坐标分别为 (<span class="number">0</span>, <span class="number">2</span>)，(<span class="number">1</span>, <span class="number">1</span>) 和 (<span class="number">2</span>, <span class="number">0</span>) 。</span><br><span class="line">你的总得分增加 <span class="number">3</span> + <span class="number">5</span> + <span class="number">3</span> = <span class="number">11</span> 。</span><br><span class="line">但是你的总得分需要扣除 abs(<span class="number">2</span> - <span class="number">1</span>) + abs(<span class="number">1</span> - <span class="number">0</span>) = <span class="number">2</span> 。</span><br><span class="line">你的最终得分为 <span class="number">11</span> - <span class="number">2</span> = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：</span><br><span class="line">蓝色格子是最优方案选中的格子，坐标分别为 (<span class="number">0</span>, <span class="number">1</span>)，(<span class="number">1</span>, <span class="number">1</span>) 和 (<span class="number">2</span>, <span class="number">0</span>) 。</span><br><span class="line">你的总得分增加 <span class="number">5</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">12</span> 。</span><br><span class="line">但是你的总得分需要扣除 abs(<span class="number">1</span> - <span class="number">1</span>) + abs(<span class="number">1</span> - <span class="number">0</span>) = <span class="number">1</span> 。</span><br><span class="line">你的最终得分为 <span class="number">12</span> - <span class="number">1</span> = <span class="number">11</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == points.length</code></li><li><code>n == points[r].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>0 &lt;= points[r][c] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-points-with-cost" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-points-with-cost</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划<code>dp</code>.</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划<code>dp</code>，我们如果直接利用动态规划转移方程，则会超时，时间复杂度为$O(m*n^{2})$,应该如何优化利用前缀，我们可以知道递推公式为:<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j],max(dp[i-1][k] - k) + points[i][j]) \quad (k\le j) \\dp[i][j] = max(dp[i][j],max(dp[i-1][k] - (n-1-k)) + points[i][j]) \quad (k\ge j) \\</script></li><li>我们利用前缀，可以快速的求出前<code>k</code>项中的$(dp[i-1][k] - k)$的最大值，同时可以利用后缀快速的求出后$n-k$项中的$dp[i-1][k] - (n-1-k)$的最大值。</li><li>时间复杂度为$O(m*n)$,空间复杂度为$O(n)$.比赛中竟然用了坑爹的线段树，快速的把这个题搞定，还是没有仔细思考到点，本来是很简单的题目,线段树只能说真心是利器什么题目都可以搞定。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = points.size();</span><br><span class="line">        <span class="keyword">int</span> col = points[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(col,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp(col,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> maxCurr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                maxCurr = max(maxCurr,dp[j]);</span><br><span class="line">                ndp[j] = max(ndp[j],maxCurr + points[i][j]);</span><br><span class="line">                maxCurr--;</span><br><span class="line">            &#125;</span><br><span class="line">            maxCurr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                maxCurr = max(maxCurr,dp[j]);</span><br><span class="line">                ndp[j] = max(ndp[j],maxCurr + points[i][j]);</span><br><span class="line">                maxCurr--;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> add;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2 + 1)</span></span><br><span class="line"></span><br><span class="line">segTreeNode tree[MAXN*<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lmax = tree[CHL(idx)].val + tree[CHL(idx)].add;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rmax = tree[CHR(idx)].val + tree[CHR(idx)].add;</span><br><span class="line">    tree[idx].val = max(lmax,rmax);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp; arr)</span></span>&#123;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[idx].l = l;</span><br><span class="line">        tree[idx].r = r;</span><br><span class="line">        tree[idx].val = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(CHL(idx),l,mid,arr);</span><br><span class="line">    buildTree(CHR(idx),mid+<span class="number">1</span>,r,arr);</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">addTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt; l) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt;= l &amp;&amp; tree[idx].r &lt;= r)&#123;</span><br><span class="line">        tree[idx].add += val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        addTree(CHL(idx),l,r,val);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        addTree(CHR(idx),l,r,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        addTree(CHL(idx),l,mid,val);</span><br><span class="line">        addTree(CHR(idx),mid+<span class="number">1</span>,r,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt;= l &amp;&amp; tree[idx].r &lt;= r) <span class="keyword">return</span> tree[idx].val + tree[idx].add;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(CHL(idx),l,r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(CHR(idx),l,r);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lmax = queryTree(CHL(idx),l,mid);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rmax = queryTree(CHR(idx),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> max(lmax,rmax) + tree[idx].add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = points.size();</span><br><span class="line">        <span class="keyword">int</span> col = points[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = points[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; curr = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                curr[j] -= j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(tree,<span class="number">0</span>,col*<span class="number">4</span>);</span><br><span class="line">            buildTree(<span class="number">1</span>,<span class="number">0</span>,col<span class="number">-1</span>,curr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                dp[i][j] = queryTree(<span class="number">1</span>,<span class="number">0</span>,col<span class="number">-1</span>) + points[i][j];</span><br><span class="line">                addTree(<span class="number">1</span>,<span class="number">0</span>,j,<span class="number">-1</span>);</span><br><span class="line">                addTree(<span class="number">1</span>,j+<span class="number">1</span>,col<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[row<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5816-查询最大基因差"><a href="#5816-查询最大基因差" class="headerlink" title="5816. 查询最大基因差"></a>5816. 查询最大基因差</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵 n 个节点的有根树，节点编号从 <code>0</code> 到 <code>n - 1</code>。每个节点的编号表示这个节点的 独一无二的基因值 （也就是说节点<code>x</code> 的基因值为 x）。两个基因值的 基因差 是两者的 异或和 。给你整数数组 <code>parents</code>，其中 <code>parents[i]</code>是节点 i 的父节点。如果节点 x 是树的 根 ，那么 <code>parents[x] == -1</code> 。</p><p>给你查询数组<code>queries</code> ，其中 <code>queries[i] = [nodei, vali]</code> 。对于查询<code>i</code>，请你找到 <code>vali</code> 和 <code>pi</code> 的 最大基因差 ，其中 <code>pi</code> 是节点<code>nodei</code>到根之间的任意节点（包含 <code>nodei</code> 和根节点）。更正式的，你想要最大化 <code>vali XOR pi</code> 。</p><p>请你返回数组 <code>ans</code>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], queries = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">解释：查询数组处理如下：</span><br><span class="line">- [<span class="number">0</span>,<span class="number">2</span>]：最大基因差的对应节点为 <span class="number">0</span> ，基因差为 <span class="number">2</span> XOR <span class="number">0</span> = <span class="number">2</span> 。</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>]：最大基因差的对应节点为 <span class="number">1</span> ，基因差为 <span class="number">2</span> XOR <span class="number">1</span> = <span class="number">3</span> 。</span><br><span class="line">- [<span class="number">2</span>,<span class="number">5</span>]：最大基因差的对应节点为 <span class="number">2</span> ，基因差为 <span class="number">5</span> XOR <span class="number">2</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>], queries = [[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">15</span>],[<span class="number">0</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>]</span><br><span class="line">解释：查询数组处理如下：</span><br><span class="line">- [<span class="number">4</span>,<span class="number">6</span>]：最大基因差的对应节点为 <span class="number">0</span> ，基因差为 <span class="number">6</span> XOR <span class="number">0</span> = <span class="number">6</span> 。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">15</span>]：最大基因差的对应节点为 <span class="number">1</span> ，基因差为 <span class="number">15</span> XOR <span class="number">1</span> = <span class="number">14</span> 。</span><br><span class="line">- [<span class="number">0</span>,<span class="number">5</span>]：最大基因差的对应节点为 <span class="number">2</span> ，基因差为 <span class="number">5</span> XOR <span class="number">2</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= parents.length &lt;= 105</code></li><li>对于每个 不是 根节点的 <code>i</code> ，有 <code>0 &lt;= parents[i] &lt;= parents.length - 1</code> 。</li><li><code>parents[root] == -1</code></li><li><code>1 &lt;= queries.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nodei &lt;= parents.length - 1</code></li><li><code>0 &lt;= vali &lt;= 2 * 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-genetic-difference-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-genetic-difference-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS + Trie树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目类似的题目见过，跟<code>google kickstart 2021 roundB</code>的$D$题非常像，感觉难度并不是很大。并且基本上一看到求异或最大值的题目，基本上可以肯定是需要用<code>trie</code>树的结构的。</li><li>我们首先将所有的查询离线化处理，即保存当前节点的所有查询。我们通过从根节点开始<code>dfs</code>遍历，每遍历一个节点<code>x</code>，则我们将节点<code>x</code>的值加入到<code>trie</code>树中，当遍历到当前节点<code>node</code>时，我们利用<code>trie</code>树去查询，跟节点<code>node</code>相关的值$val$进行查询,我们利用<code>dfs</code>遍历，每退出一个节点<code>x</code>时，则将<code>x</code>从<code>trie</code>树中删除。</li><li>本题的难点在于如何从<code>trie</code>中删除一个值<code>val</code>，这时就需要一点技巧来处理，我们为每个<code>trie</code>节点增加一个<code>count</code>的值，利用<code>count</code>记录以当前节点为根的子数下存在有多少个值。我们每次在节点<code>node</code>下增加一个<code>val</code>时，则我们将<code>count + 1</code>;我们每次在节点<code>node</code>下删除一个<code>val</code>时，则我们将<code>count - 1</code>。如果发现<code>count = 0</code>则我们直接将该节点<code>node</code>从树中删除即可。</li><li>空间复杂度为$O((N + Q)*32)$,空间复杂度为$(N + Q + 2^{K})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">31</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    TrieNode * next[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertTrie</span><span class="params">(TrieNode * root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;next[idx])&#123;</span><br><span class="line">            node-&gt;next[idx] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;cnt++;</span><br><span class="line">        node = node-&gt;next[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;cnt++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eraseTrie</span><span class="params">(TrieNode * root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    node-&gt;cnt--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        node = node-&gt;next[idx];</span><br><span class="line">        node-&gt;cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next[idx]-&gt;cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            node-&gt;next[idx] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchTrie</span><span class="params">(TrieNode * root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next[<span class="number">1</span>^idx])&#123;</span><br><span class="line">            node = node-&gt;next[<span class="number">1</span>^idx];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = node-&gt;next[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,TrieNode * trie,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; graph,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; cnt,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(root))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y] : cnt[root])&#123;</span><br><span class="line">                ans[x] = y^searchTrie(trie,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[root])&#123;</span><br><span class="line">            insertTrie(trie,v);</span><br><span class="line">            dfs(v,trie,graph,cnt,ans);</span><br><span class="line">            eraseTrie(trie,v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxGeneticDifference(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parents, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = parents.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); ++i)&#123;</span><br><span class="line">            cnt[queries[i][<span class="number">0</span>]].push_back(&#123;i,queries[i][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parents[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                graph[parents[i]].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TrieNode * trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        insertTrie(trie,root);</span><br><span class="line">        dfs(root,trie,graph,cnt,ans);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-250&quot;&gt;&lt;a href=&quot;#leetcode-contest-250&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  250&quot;&gt;&lt;/a&gt;leetcode  contest  250&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是非常高，还是前3题，不过第三题竟然用了最复杂的线段树搞定。真心是。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/18/Jlbu3VOKG9SYHrE.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5161-可以输入的最大单词数&quot;&gt;&lt;a href=&quot;#5161-可以输入的最大单词数&quot; class=&quot;headerlink&quot; title=&quot;5161. 可以输入的最大单词数&quot;&gt;&lt;/a&gt;5161. 可以输入的最大单词数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。&lt;/p&gt;&lt;p&gt;给你一个由若干单词组成的字符串 &lt;code&gt;text&lt;/code&gt; ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 &lt;code&gt;brokenLetters&lt;/code&gt; ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 &lt;code&gt;text&lt;/code&gt; 中单词的数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Kickstart】 Kickstart 2021 roundD</title>
    <link href="http://yoursite.com/2021/07/14/306/"/>
    <id>http://yoursite.com/2021/07/14/306/</id>
    <published>2021-07-14T14:28:50.732Z</published>
    <updated>2021-07-16T05:19:50.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kickstart-2021-roundD"><a href="#kickstart-2021-roundD" class="headerlink" title="kickstart 2021 roundD"></a>kickstart 2021 roundD</h1><p><code>kick start</code>的题目质量非常高，感觉前三题没有问题，自己可以确定前三题做出来。前两题做出来了，后来因为有事，三四题就没有做。第三题不用看解答就能干出来。<br><img src="https://i.loli.net/2021/07/16/K4dX5Q7H2qkVMEr.png" alt></p><h2 id="Arithmetic-Square"><a href="#Arithmetic-Square" class="headerlink" title="Arithmetic Square"></a>Arithmetic Square</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/07/14/fZaIpsXUNkRwHCv.png" alt></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813</a></p><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一题比较简单，大意就是给定一个<code>3x3</code>的矩阵，求问修改最中间的数，使得上下和对角线的三个数字组成的等差序列最多。暴力尝试所有可能的等差数列即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; matrix(<span class="number">3</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;matrix[<span class="number">0</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">0</span>][<span class="number">1</span>]&gt;&gt;matrix[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;matrix[<span class="number">1</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;matrix[<span class="number">2</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">2</span>][<span class="number">1</span>]&gt;&gt;matrix[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">0</span>][<span class="number">1</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>]) == (matrix[<span class="number">0</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">1</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">2</span>][<span class="number">1</span>] - matrix[<span class="number">2</span>][<span class="number">0</span>]) == (matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">2</span>][<span class="number">1</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">1</span>][<span class="number">0</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>]) == (matrix[<span class="number">2</span>][<span class="number">0</span>] - matrix[<span class="number">1</span>][<span class="number">0</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">1</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">2</span>]) == (matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">1</span>][<span class="number">2</span>])) ans++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = matrix[<span class="number">1</span>][<span class="number">2</span>] - matrix[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[a/<span class="number">2</span> + matrix[<span class="number">1</span>][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = matrix[<span class="number">2</span>][<span class="number">1</span>] - matrix[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[b/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">1</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(c%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[c/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = matrix[<span class="number">2</span>][<span class="number">0</span>] - matrix[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(d%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[d/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">2</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        curr = max(curr,v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += curr;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Cutting-Intervals"><a href="#Cutting-Intervals" class="headerlink" title="Cutting Intervals"></a>Cutting Intervals</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/07/14/r3pNfjUB9gtw6TE.png" alt></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b933" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b933</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 差分数组 + 贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>给定一系列的二维空间中的线段，在限定的切割操作中，求问最多可以把这些线段切成多少段？</li><li>我们可以参考线段的切割情况如下：<br><img src="https://i.loli.net/2021/07/16/uNaOd3vMG4fDtXi.png" alt><br>我们可以看到可以利用查分数组，即可计算连续的区间内每切一次可以增加多少条线段，我们设区间$[x,y]$总共有<code>d</code>条线段重合，则我们首先可以知道在区间$[x+1,y-1]$我们每切割一次则可以增加<code>d</code>条线段，但在区间两个端点处需要特殊处理，我们此时需要判断在点$y$处需要特殊处理，因为端点处；我们首先讲可以进行切割的区间加入到待选队列中，并按照重合的次数进行排序。但是我们需要注意的是区间的右端点，需要将右端点为结束端点的线段去掉。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">__</span>|<span class="string">__</span>|<span class="string">________</span>|<span class="string">  </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">  </span>|<span class="string">  </span>|<span class="string">________</span>|<span class="string">__</span>|<span class="string">________</span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string">  </span>|<span class="string">——</span>|<span class="string">————————</span>|<span class="string">——</span>|<span class="string">        </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string">  </span>|<span class="string">  </span>|<span class="string">        </span>|<span class="string">__</span>|<span class="string">________</span>|<span class="string">_____</span>|</span><br><span class="line">1  2  3        6  7        10    12</span><br></pre></td></tr></table></figure></li><li>如上图所示，我们可以看到在区间<code>[1,2]</code>之间只有1条线段重合，在区间<code>[2,3]</code>之间有两条线段重合，在区间<code>[3,6]</code>之间只有3条线段重合，<code>[6,7]</code>之间有3条线段重合，<code>[7,10]</code>之间有两条线段重合，<code>[10,12]</code>之间有两条线段重合。我们知道区间分布如下：</li></ol><ul><li><code>[1,2]</code>无法分割。</li><li><code>[2,3]</code>无法分割。</li><li><code>[3,6]</code>在<code>(4,5)</code>处每分割一次即可增加3个线段但在<code>6</code>处进行分割只能增加两条线段。</li><li><code>[7，10]</code>在(8,9)处分割每分割一次即可增加2个线段，但在<code>10</code>分割只能增加<code>1</code>个线段</li><li><code>[10,12]</code>在(11)处分割每分割一次即可增加<code>1</code>个线段，但在<code>12</code>处无法分割。</li></ul><ol><li>我们利用查分数组很快即可以计算出每个区间内重叠的线段的次数，并按照次数的大小进行排序即可，我们使用贪心策略，每次选取分割区间最大的点即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,c;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; prev;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; arrl;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; arrr;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="comment">// 查分数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l,r;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        prev[l]++;</span><br><span class="line">        prev[r]--;</span><br><span class="line">        arrl[l]++;</span><br><span class="line">        arrr[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans = n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录左端点与右端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : prev)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">            left = v.first;</span><br><span class="line">            curr += v.second;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[curr] += v.first - left - <span class="number">1</span>;</span><br><span class="line">            arr[curr-arrr[v.first]]++;</span><br><span class="line">            left = v.first;</span><br><span class="line">            curr += v.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 贪心策略每次取切割可以得到的最大线段的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = arr.rbegin(); it != arr.rend(); it++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = min(c,it-&gt;second);</span><br><span class="line">        ans += x*it-&gt;first;</span><br><span class="line">        c -= x;</span><br><span class="line">        <span class="keyword">if</span>(c &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Final-Exam"><a href="#Final-Exam" class="headerlink" title="Final Exam"></a>Final Exam</h2><p><img src="https://i.loli.net/2021/07/14/UkblX734ZqG61JF.png" alt></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bffc" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bffc</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>感觉第三题要比第二题简单许多，就是一个典型的二分查找的应用即可。我们知道给定难度<code>P</code>,则我们知道绝对值最小值得点肯定在距离点<code>p</code>最近的两个区间，我们利用二分查找，查找距离点<code>p</code>最近的两个区间$[l_{1},r_{1}],[l_{2},r_{2}]$且满足$l_{1}\le r_{1}\le l_{2}\le r_{2}$，如果点<code>p</code>在区间$[l_{1},r_{1}]$范围内，则我们可以知道当前最小的绝对值为<code>0</code>，则我们将<code>p</code>从区间内取出，并将原有区间$[l_{1},r_{1}]$划分为两个新的区间$[l_{1},p-1],[p+1,r_{1}]$,并将这两个新的区间加入到待选序列中。<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">_____</span><span class="strong">___  |    __</span><span class="strong">_____</span><span class="emphasis">___</span></span><br><span class="line">[l1,r1]  p       [l2,r2]</span><br></pre></td></tr></table></figure></li><li>如果不在区间内，则肯定距离<code>p</code>最近的点要么为$r_{1},l_{2}$,则我们优先从这两个点中选择距离最近的点即可，假设$r_{1}$距离点<code>p</code>最近，则我们将$r_{1}$从区间内取出，然后再更新区间为$[l_{1},r_{1}-1]$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">map</span>&lt;LL,LL&gt; pb;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; ans;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; arr = <span class="built_in">vector</span>&lt;LL&gt;(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        LL a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        pb[b] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">auto</span> it = pb.lower_bound(arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(it == pb.end())&#123;</span><br><span class="line">            it--;</span><br><span class="line">            ans.push_back(it-&gt;first);</span><br><span class="line">            LL a = it-&gt;first;</span><br><span class="line">            LL b = it-&gt;second;</span><br><span class="line">            pb.erase(a);</span><br><span class="line">            a--;</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= b) pb[a] = b;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            LL a = it-&gt;first;</span><br><span class="line">            LL b = it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second &gt; arr[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(it == pb.begin())&#123;</span><br><span class="line">                    ans.push_back(b);</span><br><span class="line">                    b++;</span><br><span class="line">                    pb.erase(a);</span><br><span class="line">                    <span class="keyword">if</span>(b &lt;= a) pb[a] = b;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    it--;</span><br><span class="line">                    LL c = it-&gt;first;</span><br><span class="line">                    LL d = it-&gt;second;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i]-c) &gt; <span class="built_in">abs</span>(arr[i] - b))&#123;</span><br><span class="line">                        ans.push_back(b);</span><br><span class="line">                        b++;</span><br><span class="line">                        pb.erase(a);</span><br><span class="line">                        <span class="keyword">if</span>(b &lt;= a) pb[a] = b;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ans.push_back(c);</span><br><span class="line">                        pb.erase(c);</span><br><span class="line">                        c--;</span><br><span class="line">                        <span class="keyword">if</span>(d &lt;= c) pb[c] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(arr[i]);</span><br><span class="line">                LL c = arr[i] - <span class="number">1</span>;</span><br><span class="line">                LL d = arr[i] + <span class="number">1</span>;</span><br><span class="line">                pb.erase(a);</span><br><span class="line">                <span class="keyword">if</span>(c &gt;= b) pb[c] = b;</span><br><span class="line">                <span class="keyword">if</span>(d &lt;= a) pb[a] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kickstart-2021-roundD&quot;&gt;&lt;a href=&quot;#kickstart-2021-roundD&quot; class=&quot;headerlink&quot; title=&quot;kickstart 2021 roundD&quot;&gt;&lt;/a&gt;kickstart 2021 roundD&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kick start&lt;/code&gt;的题目质量非常高，感觉前三题没有问题，自己可以确定前三题做出来。前两题做出来了，后来因为有事，三四题就没有做。第三题不用看解答就能干出来。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/16/K4dX5Q7H2qkVMEr.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;Arithmetic-Square&quot;&gt;&lt;a href=&quot;#Arithmetic-Square&quot; class=&quot;headerlink&quot; title=&quot;Arithmetic Square&quot;&gt;&lt;/a&gt;Arithmetic Square&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/14/fZaIpsXUNkRwHCv.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 249</title>
    <link href="http://yoursite.com/2021/07/11/305/"/>
    <id>http://yoursite.com/2021/07/11/305/</id>
    <published>2021-07-11T15:54:04.710Z</published>
    <updated>2021-07-13T16:02:49.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-249"><a href="#leetcode-contest-249" class="headerlink" title="leetcode  contest  249"></a>leetcode  contest  249</h1><p>周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。<br><img src="https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png" alt></p><h2 id="5808-数组串联"><a href="#5808-数组串联" class="headerlink" title="5808. 数组串联"></a>5808. 数组串联</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为<code>2n</code>的答案数组<code>ans</code> ，数组下标 从 <code>0</code>开始计数 ，对于所有 <code>0 &lt;= i &lt; n</code>的 i ，满足下述所有要求：</p><a id="more"></a><ul><li><code>ans[i] == nums[i]</code></li><li><code>ans[i + n] == nums[i]</code><br>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 串联 形成。</li></ul><p>返回数组 <code>ans</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/concatenation-of-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/concatenation-of-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测代码即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getConcatenation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5809-长度为-3-的不同回文子序列"><a href="#5809-长度为-3-的不同回文子序列" class="headerlink" title="5809. 长度为 3 的不同回文子序列"></a>5809. 长度为 3 的不同回文子序列</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 长度为 3 的不同回文子序列 的个数。</p><p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p><p>回文 是正着读和反着读一样的字符串。</p><p>子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p><p>例如，<code>&quot;ace&quot;</code> 是<code>&quot;abcde&quot;</code> 的一个子序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabca"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：长度为 <span class="number">3</span> 的 <span class="number">3</span> 个回文子序列分别是：</span><br><span class="line">- <span class="string">"aba"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aaa"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aca"</span> (<span class="string">"aabca"</span> 的子序列)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"adc"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"adc"</span> 不存在长度为 <span class="number">3</span> 的回文子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "bbcbaba"</span><br><span class="line">输出：4</span><br><span class="line">解释：长度为 3 的 4 个回文子序列分别是：</span><br><span class="line">-<span class="ruby"> <span class="string">"bbb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bcb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bab"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"aba"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 105</code></li><li><code>s</code>仅由小写英文字母组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的滑动窗口，我们设<code>left[i]</code>表示字符串索引从<code>0</code>到<code>i</code>截至时，所拥有的字符的状态，<code>right[i]</code>表示字符串索引从<code>i</code>到<code>n-1</code>截至时所拥有的字符的状态，我们用二进制位图表示字符的状态则我们可以知道前缀和后缀的递推公式如下：<script type="math/tex; mode=display">left[i] = left[i-1] | (1<<(s[i] - a)) \\right[i] = right[i+1] | (1<<(s[i] - a))</script></li><li>我们在判断是否存在字符串时，我们遍历当前位置<code>i</code>左右两边的位图，判断每一位是否左右都包含相同的字符。</li><li>我们可以用<code>hash</code>值来存储<code>3</code>位的字符串，算法时间复杂度为$O(26n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPalindromicSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            right[i] |= (<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = (<span class="number">1</span>&lt;&lt;(s[<span class="number">0</span>] - <span class="string">'a'</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((left[i<span class="number">-1</span>]&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;(right[i+<span class="number">1</span>]&amp;(<span class="number">1</span>&lt;&lt;j)))&#123;</span><br><span class="line">                    cnt.insert(j*<span class="number">26</span>*<span class="number">26</span> + (s[i]-<span class="string">'a'</span>)*<span class="number">26</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>];</span><br><span class="line">            left[i] |=(<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5811-用三种不同颜色为网格涂色"><a href="#5811-用三种不同颜色为网格涂色" class="headerlink" title="5811. 用三种不同颜色为网格涂色"></a>5811. 用三种不同颜色为网格涂色</h2><p>给你两个整数 <code>m</code>和<code>n</code> 。构造一个 <code>m x n</code>的网格，其中每个单元格最开始是白色。请你用 红、绿、蓝 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p><p>涂色方案需要满足：不存在相邻两个单元格颜色相同的情况 。返回网格涂色的方法数。因为答案可能非常大， 返回 对 <code>109 + 7</code>取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：如上图所示，存在三种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：如上图所示，存在六种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">5</span>, n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">580986</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= m &lt;= 5</code></li><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划<code>dp</code>.</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划，此题跟力扣上某个题目很像，基本上是那个题目的改进版本即可，我们设$dp[i][state]$表示第<code>i</code>列的状态为<code>state</code>时所有的方案数。则我们可以知道第<code>i+1</code>列的状态其实只与第<code>i</code>列的状态有关，所有我们很容易想到<code>dp</code>。</li><li>首先我们做预处理，即计算处装$state_x$所表示的状态下，后一列有哪些状态能够与$state_x$可以兼容符合题目要求，这个其实非常简单，我们只需要遍历所有的状态组合即可，我们可以求处哪些状态能够兼容，这个计算过程非常简单，双层遍历即可。</li><li>我们可以利用<code>dp</code>的递推关系，如果状态$x$能够与状态$y$兼容，则我们可以知道如下递推公式:<script type="math/tex; mode=display">dp[i+1][y] = (dp[i+1][y] + dp[i][x])</script>根据递推公式则可以很快的计算出结果。</li><li>时间复杂度为$O(3^{2m} + O(n*3^{2m}))$,空间复杂度为$O(3^{2m} + n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">colorTheGrid</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">                <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    arr1.push_back(x%<span class="number">3</span>);</span><br><span class="line">                    arr2.push_back(y%<span class="number">3</span>);</span><br><span class="line">                    x = x/<span class="number">3</span>;</span><br><span class="line">                    y = y/<span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr1[k] == arr2[k]) &#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; (arr1[k] == arr1[k<span class="number">-1</span>] || arr2[k] == arr2[k<span class="number">-1</span>]))&#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">                    next[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(mask);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : next)&#123;</span><br><span class="line">            dp[v.first] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp(mask);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> v : next[j])&#123;</span><br><span class="line">                        ndp[v] = (ndp[v] + dp[j])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5810-合并多棵二叉搜索树"><a href="#5810-合并多棵二叉搜索树" class="headerlink" title="5810. 合并多棵二叉搜索树"></a>5810. 合并多棵二叉搜索树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 n 个 二叉搜索树的根节点 ，存储在数组 <code>trees</code> 中（下标从 0 开始），对应 n 棵不同的二叉搜索树。<code>trees</code>中的每棵二叉搜索树 最多有 3 个节点 ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p><ul><li>选择两个 不同的 下标 <code>i</code>和 <code>j</code> ，要求满足在 <code>trees[i]</code>中的某个 叶节点 的值等于 <code>trees[j]</code>的 根节点的值 。</li><li>用 <code>trees[j]</code> 替换 <code>trees[i]</code>中的那个叶节点。</li><li>从 <code>trees</code> 中移除 <code>trees[j]</code>。<br>如果在执行<code>n - 1</code>次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 根节点 ；如果无法构造一棵有效的二叉搜索树，返回 <code>null</code> 。</li></ul><p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p><ul><li>任意节点的左子树中的值都 严格小于 此节点的值。</li><li>任意节点的右子树中的值都 严格大于 此节点的值。</li><li>叶节点是不含子节点的节点。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">第一步操作中，选出 i=<span class="number">1</span> 和 j=<span class="number">0</span> ，并将 trees[<span class="number">0</span>] 合并到 trees[<span class="number">1</span>] 中。</span><br><span class="line">删除 trees[<span class="number">0</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">在第二步操作中，选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，然后将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 <span class="literal">null</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = <span class="string">[[5,4],[3]]</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：无法执行任何操作。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：trees 中只有一棵树，且这棵树已经是一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == trees.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li><li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li><li>输入中的所有树都是 有效的二叉树搜索树 。</li><li><code>1 &lt;= TreeNode.val &lt;= 5 * 104</code>.</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>确实感觉看了别人的思路感觉非常简单，主要是记住有以下几点:</li></ol><ul><li>二叉树的根节点的值均不相同，如果存在值相同的根节点，则不可能构成二叉查找树。</li><li>二叉树的叶子节点的值均不相同，如果存在值相同的叶子节点，则不可能构成二叉查找树。</li><li>二叉树的根节点如果可以唯一可以在叶子节点中查找到，则该节点一定不是最终二叉树的根节点，因此我们需要过滤掉那些根节点在叶子节点集合中的二叉树，最终应该只剩下一棵二叉树，该二叉树的根节点即有可能为最终的根节点。</li></ul><ol><li>我们可以利用<code>bfs</code>来重建二叉树，检测是否所有的节点都被用到。然后我们利用中序遍历，遍历所有的节点的值即可，检测其是否按照从小到大的顺序排列。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            dfs(root-&gt;left,res);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            dfs(root-&gt;right,res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">canMerge</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; trees)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,TreeNode *&gt; root;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; leaf;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt; arr;</span><br><span class="line">        TreeNode * node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n = trees.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = trees[i]-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(root.count(val)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            root[val] = trees[i];</span><br><span class="line">            <span class="keyword">if</span>(trees[i]-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">int</span> lval = trees[i]-&gt;left-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(leaf.count(lval)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                leaf.insert(lval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(trees[i]-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> rval = trees[i]-&gt;right-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(leaf.count(rval)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                leaf.insert(rval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the root</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v: root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!leaf.count(v.first))&#123;</span><br><span class="line">                arr.push_back(v.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode * ret = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; qu;</span><br><span class="line">        qu.push(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            TreeNode * node = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            root.erase(node-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root.count(node-&gt;left-&gt;val))&#123;</span><br><span class="line">                    node-&gt;left = root[node-&gt;left-&gt;val];</span><br><span class="line">                    qu.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root.count(node-&gt;right-&gt;val))&#123;</span><br><span class="line">                    node-&gt;right = root[node-&gt;right-&gt;val];</span><br><span class="line">                    qu.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        dfs(ret,res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] &lt;= res[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-249&quot;&gt;&lt;a href=&quot;#leetcode-contest-249&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  249&quot;&gt;&lt;/a&gt;leetcode  contest  249&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5808-数组串联&quot;&gt;&lt;a href=&quot;#5808-数组串联&quot; class=&quot;headerlink&quot; title=&quot;5808. 数组串联&quot;&gt;&lt;/a&gt;5808. 数组串联&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;nums&lt;/code&gt; 。请你构建一个长度为&lt;code&gt;2n&lt;/code&gt;的答案数组&lt;code&gt;ans&lt;/code&gt; ，数组下标 从 &lt;code&gt;0&lt;/code&gt;开始计数 ，对于所有 &lt;code&gt;0 &amp;lt;= i &amp;lt; n&lt;/code&gt;的 i ，满足下述所有要求：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 249</title>
    <link href="http://yoursite.com/2021/07/11/304/"/>
    <id>http://yoursite.com/2021/07/11/304/</id>
    <published>2021-07-11T15:02:27.779Z</published>
    <updated>2021-07-11T15:52:01.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-249"><a href="#leetcode-contest-249" class="headerlink" title="leetcode  contest  249"></a>leetcode  contest  249</h1><p>周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。<br><img src="https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png" alt></p><h2 id="5808-数组串联"><a href="#5808-数组串联" class="headerlink" title="5808. 数组串联"></a>5808. 数组串联</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为<code>2n</code>的答案数组<code>ans</code> ，数组下标 从 <code>0</code>开始计数 ，对于所有 <code>0 &lt;= i &lt; n</code>的 i ，满足下述所有要求：</p><a id="more"></a><ul><li><code>ans[i] == nums[i]</code></li><li><code>ans[i + n] == nums[i]</code><br>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 串联 形成。</li></ul><p>返回数组 <code>ans</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/concatenation-of-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/concatenation-of-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测代码即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getConcatenation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5809-长度为-3-的不同回文子序列"><a href="#5809-长度为-3-的不同回文子序列" class="headerlink" title="5809. 长度为 3 的不同回文子序列"></a>5809. 长度为 3 的不同回文子序列</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 长度为 3 的不同回文子序列 的个数。</p><p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p><p>回文 是正着读和反着读一样的字符串。</p><p>子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p><p>例如，<code>&quot;ace&quot;</code> 是<code>&quot;abcde&quot;</code> 的一个子序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabca"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：长度为 <span class="number">3</span> 的 <span class="number">3</span> 个回文子序列分别是：</span><br><span class="line">- <span class="string">"aba"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aaa"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aca"</span> (<span class="string">"aabca"</span> 的子序列)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"adc"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"adc"</span> 不存在长度为 <span class="number">3</span> 的回文子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "bbcbaba"</span><br><span class="line">输出：4</span><br><span class="line">解释：长度为 3 的 4 个回文子序列分别是：</span><br><span class="line">-<span class="ruby"> <span class="string">"bbb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bcb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bab"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"aba"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 105</code></li><li><code>s</code>仅由小写英文字母组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的滑动窗口，我们设<code>left[i]</code>表示字符串索引从<code>0</code>到<code>i</code>截至时，所拥有的字符的状态，<code>right[i]</code>表示字符串索引从<code>i</code>到<code>n-1</code>截至时所拥有的字符的状态，我们用二进制位图表示字符的状态则我们可以知道前缀和后缀的递推公式如下：<script type="math/tex; mode=display">left[i] = left[i-1] | (1<<(s[i] - a)) \\right[i] = right[i+1] | (1<<(s[i] - a))</script></li><li>我们在判断是否存在字符串时，我们遍历当前位置<code>i</code>左右两边的位图，判断每一位是否左右都包含相同的字符。</li><li>我们可以用<code>hash</code>值来存储<code>3</code>位的字符串，算法时间复杂度为$O(26n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPalindromicSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            right[i] |= (<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = (<span class="number">1</span>&lt;&lt;(s[<span class="number">0</span>] - <span class="string">'a'</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((left[i<span class="number">-1</span>]&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;(right[i+<span class="number">1</span>]&amp;(<span class="number">1</span>&lt;&lt;j)))&#123;</span><br><span class="line">                    cnt.insert(j*<span class="number">26</span>*<span class="number">26</span> + (s[i]-<span class="string">'a'</span>)*<span class="number">26</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>];</span><br><span class="line">            left[i] |=(<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5811-用三种不同颜色为网格涂色"><a href="#5811-用三种不同颜色为网格涂色" class="headerlink" title="5811. 用三种不同颜色为网格涂色"></a>5811. 用三种不同颜色为网格涂色</h2><p>给你两个整数 <code>m</code>和<code>n</code> 。构造一个 <code>m x n</code>的网格，其中每个单元格最开始是白色。请你用 红、绿、蓝 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p><p>涂色方案需要满足：不存在相邻两个单元格颜色相同的情况 。返回网格涂色的方法数。因为答案可能非常大， 返回 对 <code>109 + 7</code>取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：如上图所示，存在三种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：如上图所示，存在六种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">5</span>, n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">580986</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= m &lt;= 5</code></li><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划<code>dp</code>.</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划，此题跟力扣上某个题目很像，基本上是那个题目的改进版本即可，我们设$dp[i][state]$表示第<code>i</code>列的状态为<code>state</code>时所有的方案数。则我们可以知道第<code>i+1</code>列的状态其实只与第<code>i</code>列的状态有关，所有我们很容易想到<code>dp</code>。</li><li>首先我们做预处理，即计算处装$state_x$所表示的状态下，后一列有哪些状态能够与$state_x$可以兼容符合题目要求，这个其实非常简单，我们只需要遍历所有的状态组合即可，我们可以求处哪些状态能够兼容，这个计算过程非常简单，双层遍历即可。</li><li>我们可以利用<code>dp</code>的递推关系，如果状态$x$能够与状态$y$兼容，则我们可以知道如下递推公式:<script type="math/tex; mode=display">dp[i+1][y] = (dp[i+1][y] + dp[i][x])</script>根据递推公式则可以很快的计算出结果。</li><li>时间复杂度为$O(3^{2m} + O(n*3^{2m}))$,空间复杂度为$O(3^{2m} + n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">colorTheGrid</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">                <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    arr1.push_back(x%<span class="number">3</span>);</span><br><span class="line">                    arr2.push_back(y%<span class="number">3</span>);</span><br><span class="line">                    x = x/<span class="number">3</span>;</span><br><span class="line">                    y = y/<span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr1[k] == arr2[k]) &#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; (arr1[k] == arr1[k<span class="number">-1</span>] || arr2[k] == arr2[k<span class="number">-1</span>]))&#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">                    next[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(mask);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : next)&#123;</span><br><span class="line">            dp[v.first] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp(mask);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> v : next[j])&#123;</span><br><span class="line">                        ndp[v] = (ndp[v] + dp[j])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5810-合并多棵二叉搜索树"><a href="#5810-合并多棵二叉搜索树" class="headerlink" title="5810. 合并多棵二叉搜索树"></a>5810. 合并多棵二叉搜索树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 n 个 二叉搜索树的根节点 ，存储在数组 <code>trees</code> 中（下标从 0 开始），对应 n 棵不同的二叉搜索树。<code>trees</code>中的每棵二叉搜索树 最多有 3 个节点 ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p><ul><li>选择两个 不同的 下标 <code>i</code>和 <code>j</code> ，要求满足在 <code>trees[i]</code>中的某个 叶节点 的值等于 <code>trees[j]</code>的 根节点的值 。</li><li>用 <code>trees[j]</code> 替换 <code>trees[i]</code>中的那个叶节点。</li><li>从 <code>trees</code> 中移除 <code>trees[j]</code>。<br>如果在执行<code>n - 1</code>次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 根节点 ；如果无法构造一棵有效的二叉搜索树，返回 <code>null</code> 。</li></ul><p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p><ul><li>任意节点的左子树中的值都 严格小于 此节点的值。</li><li>任意节点的右子树中的值都 严格大于 此节点的值。</li><li>叶节点是不含子节点的节点。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">第一步操作中，选出 i=<span class="number">1</span> 和 j=<span class="number">0</span> ，并将 trees[<span class="number">0</span>] 合并到 trees[<span class="number">1</span>] 中。</span><br><span class="line">删除 trees[<span class="number">0</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">在第二步操作中，选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，然后将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 <span class="literal">null</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = <span class="string">[[5,4],[3]]</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：无法执行任何操作。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：trees 中只有一棵树，且这棵树已经是一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == trees.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li><li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li><li>输入中的所有树都是 有效的二叉树搜索树 。</li><li><code>1 &lt;= TreeNode.val &lt;= 5 * 104</code>.</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-249&quot;&gt;&lt;a href=&quot;#leetcode-contest-249&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  249&quot;&gt;&lt;/a&gt;leetcode  contest  249&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5808-数组串联&quot;&gt;&lt;a href=&quot;#5808-数组串联&quot; class=&quot;headerlink&quot; title=&quot;5808. 数组串联&quot;&gt;&lt;/a&gt;5808. 数组串联&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;nums&lt;/code&gt; 。请你构建一个长度为&lt;code&gt;2n&lt;/code&gt;的答案数组&lt;code&gt;ans&lt;/code&gt; ，数组下标 从 &lt;code&gt;0&lt;/code&gt;开始计数 ，对于所有 &lt;code&gt;0 &amp;lt;= i &amp;lt; n&lt;/code&gt;的 i ，满足下述所有要求：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
