<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-07T15:51:58.695Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Google】 Google</title>
    <link href="http://yoursite.com/2021/04/06/271/"/>
    <id>http://yoursite.com/2021/04/06/271/</id>
    <published>2021-04-06T05:05:05.749Z</published>
    <updated>2021-04-07T15:51:58.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-mock-view"><a href="#Google-mock-view" class="headerlink" title="Google mock view"></a>Google mock view</h1><p>前段时间做了一下<code>google</code>的<code>mock interview</code>,其中有道题目印象深刻。</p><h2 id="1-区间查询"><a href="#1-区间查询" class="headerlink" title="1. 区间查询"></a>1. 区间查询</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定长度为<code>n</code>的数组<code>A</code>，给定组数$[i,j]$，求以下结果:</p><script type="math/tex; mode=display">query(i,j) = \prod_{k=1}^{j-i+1}(A_{i+k-1}^{k})</script><p>所求结果对$10^{9} + 7$取模, 其中满足以下：</p><a id="more"></a><ul><li>$i \le j$</li><li>$1 \le n \le 10^{5}$</li><li>$0 \le A[i] \le 10^{9}$ <h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/truncate-sentence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/truncate-sentence</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>线段树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote></li></ul><ol><li>首先看到类似的求区间的数列我们首先想到的就是用线段树。我们首先用数学分解的方法来将公式进行分解和变换：<script type="math/tex; mode=display">A[i,j] = \prod_{k=i}^{j}(A_{k}^{k-i+1}) \\= \prod_{m=i}^{s-1}(A_{m}^{m+1-i}) * \prod_{n=s}^{j}(A_{n}^{n+1-i}) \\= \prod_{m=i}^{s-1}(A_{m}^{m+1-i}) * \prod_{n=s}^{j}(A_{n}^{n+1-s})*(\prod_{n=s}^{j}A_{n})^{s-i} \\</script>由上述变换我们就可以知道如何通过线段树对其进行分解，我们设线段树的每个非叶子节点，包含的范围为$(i,j)$,且包含两个值：<script type="math/tex; mode=display">prod_{(i,j)} = \prod_{k=i}^{j}A_{k}\\val_{(i,j)} = \prod_{k=i}^{j}A_{k}^{k+1-i}\\</script>有了上述变换以后我们可以知道线段树的变化，假如本次我们需要查询的区间为$(i,j)$,假设线段从$mid$处断开分为两个子节点，则我们可以知道如下的求和公式：<script type="math/tex; mode=display">prod_{(i,j)} = \prod_{k=i}^{j}A_{k} = \prod_{k=i}^{mid}A_{k}*\prod_{k=mid+1}^{j}A_{k} \\= prod_{(i,mid)}*prod_{(mid+1,j)} \\</script>而$val$可以变换如下：<script type="math/tex; mode=display">val_{(i,j)} = \prod_{k=i}^{j}A_{k}^{k+1-i} =  \prod_{k=i}^{mid}(A_{k}^{k+1-i}) * \prod_{k=mid+1}^{j}(A_{k}^{k+1-i}) \\=  \prod_{k=i}^{mid}(A_{k}^{k+1-i}) * \prod_{k=mid+1}^{j}(A_{k}^{k+1-(mid+1)})*(\prod_{k=mid+1}^{j}A_{k})^{mid+1-i} \\= val_{(i,mid)}*val_{(mid+1,j)}*(prod_{(mid+1,j)})^{mid+1-i}</script>根据以上变换，我们则可以轻易的用线段树可以在$lg(n)$的时间复杂度内求出所有的查询。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">2000000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> prod;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2+1)</span></span><br><span class="line">segTreeNode tree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i != <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ret = (ret*x)%mod;</span><br><span class="line">        x = (x*x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> d = mid - tree[idx].l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pl = tree[CHL(idx)].prod;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pr = tree[CHR(idx)].prod;</span><br><span class="line">    tree[idx].prod = pl*pr%MOD;</span><br><span class="line">    tree[idx].val = tree[CHL(idx)].val*tree[CHR(idx)].val*fastpow(pr,d,MOD)%MOD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].val = <span class="number">1</span>;</span><br><span class="line">    tree[idx].prod = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[idx].val = arr[l];</span><br><span class="line">        tree[idx].prod = arr[l];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(l,mid,arr,CHL(idx));</span><br><span class="line">    buildTree(mid+<span class="number">1</span>,r,arr,CHR(idx));</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; l || tree[idx].l &gt; r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tree[idx].l &amp;&amp;  tree[idx].r &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d = tree[idx].l - l;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].val*fastpow(tree[idx].prod,d,MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(l,r,CHR(idx));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(l,r,CHL(idx));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lval = queryTree(l,r,CHL(idx));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rval = queryTree(l,r,CHR(idx));</span><br><span class="line">        <span class="keyword">return</span> lval*rval%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    buildTree(<span class="number">0</span>,n<span class="number">-1</span>,arr,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l--;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;queryTree(l,r,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Google-mock-view&quot;&gt;&lt;a href=&quot;#Google-mock-view&quot; class=&quot;headerlink&quot; title=&quot;Google mock view&quot;&gt;&lt;/a&gt;Google mock view&lt;/h1&gt;&lt;p&gt;前段时间做了一下&lt;code&gt;google&lt;/code&gt;的&lt;code&gt;mock interview&lt;/code&gt;,其中有道题目印象深刻。&lt;/p&gt;&lt;h2 id=&quot;1-区间查询&quot;&gt;&lt;a href=&quot;#1-区间查询&quot; class=&quot;headerlink&quot; title=&quot;1. 区间查询&quot;&gt;&lt;/a&gt;1. 区间查询&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定长度为&lt;code&gt;n&lt;/code&gt;的数组&lt;code&gt;A&lt;/code&gt;，给定组数$[i,j]$，求以下结果:&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
query(i,j) = \prod_{k=1}^{j-i+1}(A_{i+k-1}^{k})&lt;/script&gt;&lt;p&gt;所求结果对$10^{9} + 7$取模, 其中满足以下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  LCCUP 2021</title>
    <link href="http://yoursite.com/2021/04/06/270/"/>
    <id>http://yoursite.com/2021/04/06/270/</id>
    <published>2021-04-06T00:39:47.905Z</published>
    <updated>2021-04-08T09:58:12.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-LCCUP-2021"><a href="#leetcode-LCCUP-2021" class="headerlink" title="leetcode  LCCUP 2021"></a>leetcode  LCCUP 2021</h1><p>总共5道题目，还是依旧三道题，后面两道题思考量确实很大，前三题基本上都是<code>mid</code>难度的题目。</p><h2 id="1-采购方案"><a href="#1-采购方案" class="headerlink" title="1. 采购方案"></a>1. 采购方案</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小力将 N 个零件的报价存于数组 <code>nums</code>。小力预算为 <code>target</code>，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 <code>1e9 + 7 (1000000007)</code>为底取模，如：计算初始结果为：<code>1000000008</code>，请返回 <code>1</code></p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：预算内仅能购买 nums[<span class="number">0</span>] 与 nums[<span class="number">2</span>]。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：符合预算的采购方案如下：</span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">nums[<span class="number">1</span>] + nums[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">nums[<span class="number">2</span>] + nums[<span class="number">3</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i], target &lt;= 10^5</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/truncate-sentence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/truncate-sentence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  两数求和问题，双指针或者二分查找</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的两数求和问题，常见的就是用双指针或者二分查找，在这里比较简单的是用双指针问题，固定一个较大的数<code>x</code>，查找用多少个数满足$x+y &lt; target$.</li><li>算法时间复杂度$O(nlgn)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; i &amp;&amp; nums[i] + nums[l] &lt;= target) l++;</span><br><span class="line">            <span class="keyword">if</span>(l == i) l--;</span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; nums[i] + nums[l] &gt; target) l--;</span><br><span class="line">            <span class="keyword">if</span>(l &gt;= <span class="number">0</span>) ans = (ans + l + <span class="number">1</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="2-乐团站位"><a href="#2-乐团站位" class="headerlink" title="2. 乐团站位"></a>2. 乐团站位</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>某乐团的演出场地可视作 <code>num * num</code> 的二维矩阵 <code>grid</code>（左上角坐标为 <code>[0,0]</code>)，每个位置站有一位成员。乐团共有 <code>9</code> 种乐器，乐器编号为 <code>1~9</code>，每位成员持有 <code>1</code> 个乐器。</p><p>为保证声乐混合效果，成员站位规则为：自 <code>grid</code> 左上角开始顺时针螺旋形向内循环以 <code>1，2，...，9</code>循环重复排列。例如当 <code>num = 5</code>时，站位如图所示</p><p>请返回位于场地坐标<code>[Xpos,Ypos]</code>的成员所持乐器编号。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">3</span>, Xpos = <span class="number">0</span>, Ypos = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">4</span>, Xpos = <span class="number">1</span>, Ypos = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= num &lt;= 10^9</code></li><li><code>0 &lt;= Xpos, Ypos &lt; num</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-the-users-active-minutes</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>思路很简单，我们首先找到该坐标属于从外往里数第几个正方形，然后属于该正方形中的第几个元素即可。<br><img src="https://i.loli.net/2021/04/06/uoGFLZHMPvskAn7.jpg" alt></li><li>第几圈我们仔细观察一下可以知道$level = min(x,y,num-1-x,num-1-y)$,第$level$个正方形的边长为$ edge = num - 2<em>level$,此时我们知道<code>level</code>以外的所有正方形的周长的综合为$sum = num</em>num - edge<em>edge$,此时我们知道从第<code>level</code>层的正方形的起始点应该为$num</em>num - edge*edge + 1$,此时我们在分别判断$(x,y)$按照顺时针旋转属于该正方形的第几条边即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orchestraLayout</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> xPos, <span class="keyword">int</span> yPos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> level = min(min(xPos,yPos),min(num-xPos<span class="number">-1</span>,num<span class="number">-1</span>-yPos));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> edge  = num - <span class="number">2</span>*level;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = (<span class="keyword">long</span> <span class="keyword">long</span>)(num)*num - (<span class="keyword">long</span> <span class="keyword">long</span>)(edge)*edge;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*move to (0,0)*/</span></span><br><span class="line">        xPos -= level;</span><br><span class="line">        yPos -= level;</span><br><span class="line">        <span class="keyword">if</span>(xPos == <span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            curr += yPos + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(yPos == edge - <span class="number">1</span>)&#123; <span class="comment">// 2</span></span><br><span class="line">            curr += (edge <span class="number">-1</span>) + xPos + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xPos == edge - <span class="number">1</span>)&#123; <span class="comment">// 3</span></span><br><span class="line">            curr += (edge <span class="number">-1</span>)*<span class="number">2</span> + edge - yPos;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(yPos == <span class="number">0</span>)&#123; <span class="comment">// 4</span></span><br><span class="line">            curr += (edge <span class="number">-1</span>)*<span class="number">3</span> + edge - xPos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (curr%<span class="number">9</span>) == <span class="number">0</span> ? <span class="number">9</span> : (curr%<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-30-魔塔游戏"><a href="#LCP-30-魔塔游戏" class="headerlink" title="LCP 30. 魔塔游戏"></a>LCP 30. 魔塔游戏</h2><p>小扣当前位于魔塔游戏第一层，共有 <code>N</code> 个房间，编号为 <code>0 ~ N-1</code>。每个房间的补血道具/怪物对于血量影响记于数组<code>nums</code>，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；<code>0</code> 表示房间对血量无影响。</p><p>小扣初始血量为<code>1</code>，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 <code>-1</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">-250</span>,<span class="number">-60</span>,<span class="number">-140</span>,<span class="number">-50</span>,<span class="number">-50</span>,<span class="number">100</span>,<span class="number">150</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：初始血量为 <span class="number">1</span>。至少需要将 nums[<span class="number">3</span>] 调整至访问顺序末尾以满足要求。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-200</span>,<span class="number">-300</span>,<span class="number">400</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">解释：调整访问顺序也无法完成全部房间的访问。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/p0NxJO" target="_blank" rel="noopener">https://leetcode-cn.com/problems/p0NxJO</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>思考一下，如何才能满足能够通过这一层，我们将所有的伤害和血量增加加起来的和满足大于<code>0</code>则表示一定可以通过这一层，否则则表示我们不能通过这一层。</li><li>假如我们当前遇到血量不足时，我们最优策略应该即把伤害值最大的房间往后移，根据这个贪心策略，我们利用优先级的特性，每次将所有的伤害均进入优先级队列，穿越房间时，如果发现当前血量不足，则我们从队列弹出最大的伤害值，并将当前的血量进行恢复，一直回到当前的持有的血量大于<code>0</code>为止。</li><li>算法的时间复杂度为$O(nlgn)$.空间复杂度为$O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicTower</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            sum += v;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.push(-v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!pq.empty() &amp;&amp; sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    sum += pq.top();</span><br><span class="line">                    pq.pop();</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-31-变换的迷宫"><a href="#LCP-31-变换的迷宫" class="headerlink" title="LCP 31. 变换的迷宫"></a>LCP 31. 变换的迷宫</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>某解密游戏中，有一个 <code>N*M</code> 的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于 <code>(n-1,m-1)</code>位置。迷宫变化规律记录于 <code>maze</code>中，<code>maze[i]</code>表示 <code>i</code>时刻迷宫的地形状态，<code>&quot;.&quot;</code>表示可通行空地，<code>&quot;#&quot;</code> 表示陷阱。</p><p>地形图初始状态记作 <code>maze[0]</code>，此时小力位于起点 <code>(0,0)</code>。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。</p><p>小力背包有以下两个魔法卷轴（卷轴使用一次后消失）：</p><ul><li>临时消除术：将指定位置在下一个时刻变为空地；</li><li>永久消除术：将指定位置永久变为空地。<br>请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？</li></ul><p>注意： 输入数据保证起点和终点在所有时刻均为空地。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">".#."</span>,<span class="string">"#.."</span>],[<span class="string">"..."</span>,<span class="string">".#."</span>],[<span class="string">".##"</span>,<span class="string">".#."</span>],[<span class="string">"..#"</span>,<span class="string">".#."</span>]]</span><br><span class="line"></span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">解释：</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">".#."</span>,<span class="string">"..."</span>],[<span class="string">"..."</span>,<span class="string">"..."</span>]]</span><br><span class="line"></span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">解释：由于时间不够，小力无法到达终点逃出迷宫。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">"..."</span>,<span class="string">"..."</span>,<span class="string">"..."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>]]</span><br><span class="line"></span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">解释：由于道路不通，小力无法到达终点逃出迷宫。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= maze.length &lt;= 100</code></li><li><code>1 &lt;= maze[i].length, maze[i][j].length &lt;= 50</code></li><li><code>maze[i][j]</code> 仅包含 <code>&quot;.&quot;、&quot;#&quot;</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/Db3wC1" target="_blank" rel="noopener">https://leetcode-cn.com/problems/Db3wC1</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p><code>dfs</code>记忆式搜索。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本题的思考难度还是非常大的，难点在于如何处理永久将某一位置变为空地，假如我们直接设遍历所有的状态，则可能会超时。难点在于如何思考和优化，参考了一下第二名的代码，非常简洁。</li></ol><ul><li>对于临时消除的这个问题，非常好处理，设立一个标志位，表示当前是否可以进行临时消除即可。</li><li>对于永久消除的这个问题，我们最难思考的是，假设我们在某一个时刻$t_{0}$对坐标$(x,y)$进行了消除，则我们经历了$t_{1},t_{2},t_{3}…,t_{i}$跳跃了坐标$(x_{1},y_{1})，(x_{2},y_{2})，(x_{3},y_{3})…(x_{i},y_{i})，$后，我们又回到了坐标$(x,y)$,则此时我们如何判断$(x,y)$已经被永久消除，这个是最难的思考点。题解中给出的假设我们在$t_{0}$时候已经对坐标$(x,y)$进行了消除，我们在$t_{i}$时候刻后经历了其他不同的坐标后又回到原始坐标$(x,y)$,我们完全可以可以在一直$t_{1},t_{2},t_{3}…,t_{i}$一直呆在原始坐标$(x,y)$处，因此我们可以判断，假如它从永久消除的坐标$(x,y)$跳出后，就不会再跳回原始坐标$(x,y)$.</li><li>因此我们需要增设一个状态$usedStay$,如果$usedStay = 1$，表示我们已经用了永久消除当前可以一直停留在原地，如果$usedStay = 0$则表示为未用永久消除术或者用了永久消除但已经跳出释放永久消除的格子。</li></ul><ol><li>我们设$dp[t][x][y][tmpuse][alluse][usedstay]$表示在<code>t</code>时候到达坐标$(x,y)$,且手中持有的临时消除的次数为$tmpuse$,手中持有的永久消除的次数为$alluse$,当前的是否使用永久消除术且可以停留在原地的状态为$usedstay$.</li><li>时间复杂度为$O(n<em>row</em>col<em>2</em>2<em>2</em>4)$,在我们当前的数值的允许范围内可以完成全部搜索。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">51</span>][<span class="number">51</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> n,row,col;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; matrix;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> tmp_use,<span class="keyword">int</span> all_use,<span class="keyword">int</span> used_stay)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[t][x][y][tmp_use][all_use][used_stay]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        dp[t][x][y][tmp_use][all_use][used_stay] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t == n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*check if we can stay at the same positon (x,y) in the next time t+1*/</span></span><br><span class="line">        <span class="keyword">if</span>(used_stay || matrix[t+<span class="number">1</span>][x][y] == <span class="string">'.'</span>) </span><br><span class="line">            dfs(t+<span class="number">1</span>,x,y,tmp_use,all_use,used_stay);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*check if we can move to other position in the next time*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = x + d[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y1 = y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x1 &lt; <span class="number">0</span> || y1 &lt; <span class="number">0</span> || x1 &gt;= row || y1 &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[t+<span class="number">1</span>][x1][y1] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="comment">/*we just move to other postion (x1,y1)*/</span></span><br><span class="line">                dfs(t+<span class="number">1</span>,x1,y1,tmp_use,all_use,<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/*we use temple erase (x1,y1) at this time,the next time it can move to (x1,y1)*/</span></span><br><span class="line">                <span class="keyword">if</span>(tmp_use &gt; <span class="number">0</span>) dfs(t+<span class="number">1</span>,x1,y1,<span class="number">0</span>,all_use,<span class="number">0</span>);</span><br><span class="line">                <span class="comment">/*we use all erase (x1,y1) at this time, the next time it can move to (x1,y1) and it can stay at (x1,y1) all over the life*/</span></span><br><span class="line">                <span class="keyword">if</span>(all_use &gt; <span class="number">0</span>) dfs(t+<span class="number">1</span>,x1,y1,tmp_use,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">escapeMaze</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; maze)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = maze.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;row = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;col = maze[<span class="number">0</span>][<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;matrix = maze;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; ++l)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i][row<span class="number">-1</span>][col<span class="number">-1</span>][j][k][l]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-32-批量处理任务"><a href="#LCP-32-批量处理任务" class="headerlink" title="LCP 32. 批量处理任务"></a>LCP 32. 批量处理任务</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>某实验室计算机待处理任务以<code>[start,end,period]</code>格式记于二维数组 <code>tasks</code>，表示完成该任务的时间范围为起始时间 <code>start</code> 至结束时间 <code>end</code>之间，需要计算机投入 <code>period</code> 的时长，注意：</p><ul><li><code>period</code> 可为不连续时间</li><li>首尾时间均包含在内</li><li>处于开机状态的计算机可同时处理任意多个任务，请返回电脑最少开机多久，可处理完所有任务。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">tasks[<span class="number">0</span>] 选择时间点 <span class="number">2</span>、<span class="number">3</span>；</span><br><span class="line">tasks[<span class="number">1</span>] 选择时间点 <span class="number">2</span>、<span class="number">3</span>、<span class="number">5</span>；</span><br><span class="line">tasks[<span class="number">2</span>] 选择时间点 <span class="number">5</span>、<span class="number">6</span>；</span><br><span class="line">因此计算机仅需在时间点 <span class="number">2</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span> 四个时刻保持开机即可完成任务。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">tasks[<span class="number">0</span>] 选择时间点 <span class="number">2</span> 或 <span class="number">3</span>；</span><br><span class="line">tasks[<span class="number">1</span>] 选择时间点 <span class="number">5</span>；</span><br><span class="line">tasks[<span class="number">2</span>] 选择时间点 <span class="number">5</span>、<span class="number">6</span>；</span><br><span class="line">因此计算机仅需在时间点 <span class="number">2</span>、<span class="number">5</span>、<span class="number">6</span> 或 <span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span> 三个时刻保持开机即可完成任务。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= tasks.length &lt;= 10^5</code></li><li><code>tasks[i].length == 3</code></li><li><code>0 &lt;= tasks[i][0] &lt;= tasks[i][1] &lt;= 10^9</code></li><li><code>1 &lt;= tasks[i][2] &lt;= tasks[i][1]-tasks[i][0] + 1</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/t3fKg1" target="_blank" rel="noopener">https://leetcode-cn.com/problems/t3fKg1</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>贪心算法，线段树</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们可以知道每一个任务对应着一个线段，所有的运行时间点我们也可以看作为离散的线段，所谓的开机时间满足要求，只需要在线段范围$[l,r]$内运行的时间点组成的离散的小线段的总长度大于等于$period$即可，仔细分析一下，我们可以利用类似于差分数组的方法，我们按照任务的结束时间的先后顺序进行排序，每遇到一个任务结束的右端点$r_{i}$时，我们首先查询当前任务运行时间范围$[l_{i},r_{i}]$内已经运行的开机时间是否满足$period_{i}$,如果不满足，则我们从右端$r_{i}$向左开始在空闲的时间内依次添加开机时间直到$[l_{i},r_{i}]$范围的开机时间满足$period_{i}$即可。</li><li>我们可以用数组表示当前已经开机时间点离散小线段，比如$arr[i] = {l_{i},r_{i}}$表示当前在$[l_{i},r_{i}]$设备已经在开机运行，则此时该时间段内连续的运行时间即为$r_{i}-l_{i} + 1$，我们用前缀和$pre[i]$表示前<code>i</code>个开机运行线段的运行时间的总和.我们每次固定当前的右端点，然后利用二分查找和前缀和可以快速查找在$[l_{i},r_{i}]$范围内已经开机运行的时间的总和，然后即可求出当前任务中我们还需要再开机运行多长时间，依次进行叠加即可求出所满足要求，这个算法是参考@cuiaoxiang的，不过算法时间复杂度较高，时间复杂度感觉应该是$o(n^{2})$因为其中涉及到线段的合并的问题，但是实际上我们可以进行优化，最终结果是可以过测试用例的。</li><li>线段树，线段树的解法就复杂的多了，可以参考@restant的解法，写的实在太复杂，不过原理应该差不多。<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">processTasks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tasks.size();</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : tasks) v[<span class="number">0</span>]--;</span><br><span class="line">        sort(tasks.begin(),tasks.end(),[&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; used;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; n; i = j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*we find the most running time from task[i][1] which we need to add*/</span></span><br><span class="line">            <span class="keyword">for</span>(j = i; j &lt; n &amp;&amp; tasks[j][<span class="number">1</span>] == tasks[i][<span class="number">1</span>]; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> s = tasks[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> t = tasks[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> p = tasks[j][<span class="number">2</span>];</span><br><span class="line">                <span class="comment">/*search last segment greater than x*/</span></span><br><span class="line">                <span class="keyword">int</span> k = lower_bound(used.begin(),used.end(),pii&#123;s,<span class="number">0</span>&#125;) - used.begin();</span><br><span class="line">                <span class="keyword">int</span> m = used.size();</span><br><span class="line">                <span class="keyword">int</span> curr = pre[m] - pre[k];</span><br><span class="line">                <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; used[k<span class="number">-1</span>].second &gt;= s) curr += used[k<span class="number">-1</span>].second - s;</span><br><span class="line">                <span class="keyword">if</span>(p &gt; curr)  mx = max(mx,p-curr);</span><br><span class="line">            &#125;</span><br><span class="line">            ret += mx;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(mx &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = tasks[i][<span class="number">1</span>]-mx;</span><br><span class="line">                <span class="keyword">int</span> y = tasks[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span>(used.size() &amp;&amp; used.back().second &gt;= x)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> [u,v] = used.back();</span><br><span class="line">                    used.pop_back();</span><br><span class="line">                    pre.pop_back();</span><br><span class="line">                    x = u - (v-x);</span><br><span class="line">                &#125;</span><br><span class="line">                used.push_back(&#123;x,y&#125;);</span><br><span class="line">                pre.push_back(pre.back() + y - x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (t&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((t&lt;&lt;1)|1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, p;</span><br><span class="line">&#125;a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NMB</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> add ,sum, id;</span><br><span class="line">&#125;tree[<span class="number">100005</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[ls].add += tree[t].add;</span><br><span class="line">tree[ls].sum += tree[t].add;</span><br><span class="line">tree[rs].add += tree[t].add;</span><br><span class="line">tree[rs].sum += tree[t].add;</span><br><span class="line">tree[t].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[ls].sum &lt; tree[rs].sum)</span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = tree[ls].sum;</span><br><span class="line">tree[t].id = tree[ls].id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = tree[rs].sum;</span><br><span class="line">tree[t].id = tree[rs].id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[t].add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) </span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = a[l].r - a[l].p + <span class="number">1</span>;</span><br><span class="line">tree[t].id = l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build_tree(l,mid,ls);</span><br><span class="line">build_tree(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> tree[t].sum;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">down(t);</span><br><span class="line"><span class="keyword">if</span> (ll&lt;=mid) <span class="keyword">return</span> find(ll,l,mid,ls);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> find(ll,mid+<span class="number">1</span>,r,rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">down(t);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ll&lt;=mid) modify(ll,c,l,mid,ls);</span><br><span class="line"><span class="keyword">else</span> modify(ll,c,mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(t); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr)</span><br><span class="line">&#123;</span><br><span class="line">tree[t].add += c;</span><br><span class="line">tree[t].sum += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">down(t);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ll &lt;= mid) change(ll,rr,c,l,mid,ls);</span><br><span class="line"><span class="keyword">if</span> (rr&gt;mid)  change(ll,rr,c,mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = n + <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;</span><br><span class="line">ans += R - L + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> ((l + r) &gt;&gt; <span class="number">1</span> != mid)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid].l &gt;= L) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r; a[i].l &lt;= R &amp;&amp; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p = find(i, <span class="number">1</span>, n, <span class="number">1</span>) + (R - a[i].l + <span class="number">1</span>); </span><br><span class="line">modify(i, p, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">1</span>) change(<span class="number">1</span>, r - <span class="number">1</span>, R - L + <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">processTasks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">n = tasks.size();</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ;++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i].l = tasks[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">a[i].r = tasks[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">a[i].p = tasks[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">build_tree(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = tree[<span class="number">1</span>].id;</span><br><span class="line"><span class="keyword">int</span> L = find(x, <span class="number">1</span>, n ,<span class="number">1</span>), R = a[x].r;</span><br><span class="line">Work(L,R);</span><br><span class="line">modify(x,(<span class="keyword">int</span>)<span class="number">1e9</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-LCCUP-2021&quot;&gt;&lt;a href=&quot;#leetcode-LCCUP-2021&quot; class=&quot;headerlink&quot; title=&quot;leetcode  LCCUP 2021&quot;&gt;&lt;/a&gt;leetcode  LCCUP 2021&lt;/h1&gt;&lt;p&gt;总共5道题目，还是依旧三道题，后面两道题思考量确实很大，前三题基本上都是&lt;code&gt;mid&lt;/code&gt;难度的题目。&lt;/p&gt;&lt;h2 id=&quot;1-采购方案&quot;&gt;&lt;a href=&quot;#1-采购方案&quot; class=&quot;headerlink&quot; title=&quot;1. 采购方案&quot;&gt;&lt;/a&gt;1. 采购方案&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;小力将 N 个零件的报价存于数组 &lt;code&gt;nums&lt;/code&gt;。小力预算为 &lt;code&gt;target&lt;/code&gt;，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。&lt;/p&gt;&lt;p&gt;注意：答案需要以 &lt;code&gt;1e9 + 7 (1000000007)&lt;/code&gt;为底取模，如：计算初始结果为：&lt;code&gt;1000000008&lt;/code&gt;，请返回 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 49</title>
    <link href="http://yoursite.com/2021/04/04/268/"/>
    <id>http://yoursite.com/2021/04/04/268/</id>
    <published>2021-04-04T12:18:32.818Z</published>
    <updated>2021-04-05T15:17:52.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-49"><a href="#leetcode-biweekly-contest-49" class="headerlink" title="leetcode biweekly contest 49"></a>leetcode biweekly contest 49</h1><p>还是依旧三道题，最后一题的状态压缩<code>dp</code>确实非常难以想到。前三题非常简单，最后一题比较难。</p><h2 id="5705-判断国际象棋棋盘中一个格子的颜色"><a href="#5705-判断国际象棋棋盘中一个格子的颜色" class="headerlink" title="5705. 判断国际象棋棋盘中一个格子的颜色"></a>5705. 判断国际象棋棋盘中一个格子的颜色</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个坐标<code>coordinates</code>，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。<br>如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 <code>false</code>。<br>给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。</p><a id="more"></a><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coordinates</span> = <span class="string">"a1"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：如上图棋盘所示，<span class="string">"a1"</span> 坐标的格子是黑色的，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coordinates</span> = <span class="string">"h3"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：如上图棋盘所示，<span class="string">"h3"</span> 坐标的格子是白色的，所以返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coordinates</span> = <span class="string">"c7"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>coordinates.length == 2</code></li><li><code>&#39;a&#39; &lt;= coordinates[0] &lt;= &#39;h&#39;</code></li><li><code>&#39;1&#39; &lt;= coordinates[1] &lt;= &#39;8&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/determine-color-of-a-chessboard-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/determine-color-of-a-chessboard-square</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>行号与列号的奇偶性相同时，则为黑色，否则则为白色。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">squareIsWhite</span><span class="params">(<span class="built_in">string</span> coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = coordinates[<span class="number">0</span>] - <span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = coordinates[<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>((x&amp;<span class="number">1</span>)^(y&amp;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5706-句子相似性-III"><a href="#5706-句子相似性-III" class="headerlink" title="5706. 句子相似性 III"></a>5706. 句子相似性 III</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>&quot;Hello World&quot; ，&quot;HELLO&quot; ，&quot;hello world hello world&quot;</code> 都是句子。每个单词都 只 包含大写和小写英文字母。</p><p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 相似的 。比方说，<code>sentence1 = &quot;Hello my name is Jane&quot;</code>且 <code>sentence2 = &quot;Hello Jane&quot;</code> ，我们可以往 sentence2 中 “Hello” 和 “Jane” 之间插入 “my name is” 得到 sentence1 。<br><code>给你两个句子</code>sentence1 <code>和</code>sentence2<code>，如果</code>sentence1<code>和</code>sentence2` 是相似的，请你返回 true ，否则返回 false 。</p><p>示例 1：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：se<span class="symbol">ntence1</span> = <span class="string">"My name is Haley"</span>, se<span class="symbol">ntence2</span> = <span class="string">"My Haley"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：可以往 se<span class="symbol">ntence2</span> 中 <span class="string">"My"</span> 和 <span class="string">"Haley"</span> 之间插入 <span class="string">"name is"</span> ，得到 se<span class="symbol">ntence1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence1</span> = <span class="string">"of"</span>, <span class="attr">sentence2</span> = <span class="string">"A lot of words"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：se<span class="symbol">ntence1</span> = <span class="string">"Eating right now"</span>, se<span class="symbol">ntence2</span> = <span class="string">"Eating"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：可以往 se<span class="symbol">ntence2</span> 的结尾插入 <span class="string">"right now"</span> 得到 se<span class="symbol">ntence1</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence1</span> = <span class="string">"Luky"</span>, <span class="attr">sentence2</span> = <span class="string">"Lucccky"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li><li><code>sentence1</code> 和 <code>sentence2</code> 都只包含大小写英文字母和空格。</li><li><code>sentence1</code> 和 <code>sentence2</code> 中的单词都只由单个空格隔开。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sentence-similarity-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sentence-similarity-iii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的不好，没啥好说的，只需要判断两个句子的首尾相等的部分去掉即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areSentencesSimilar</span><span class="params">(<span class="built_in">string</span> sentence1, <span class="built_in">string</span> sentence2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = sentence1.size();</span><br><span class="line">        <span class="keyword">int</span> n = sentence2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sentence1.size();)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; sentence1[i] == <span class="string">' '</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; sentence1[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                curr.push_back(sentence1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt; <span class="number">0</span>) arr1.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sentence2.size();)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; sentence2[i] == <span class="string">' '</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; sentence2[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                curr.push_back(sentence2[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt; <span class="number">0</span>) arr2.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**/</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r1 = arr1.size();</span><br><span class="line">        <span class="keyword">int</span> r2 = arr2.size();</span><br><span class="line">        <span class="comment">/*left*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1 &amp;&amp; i &lt; r2; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] == arr2[i]) l = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*right*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr1.size()<span class="number">-1</span>,j = arr2.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] == arr2[j])&#123;</span><br><span class="line">                r1 = i;</span><br><span class="line">                r2 = j;</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == (arr1.size()<span class="number">-1</span>) || l == (arr2.size()<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="number">0</span> || r2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((r1 - l) == <span class="number">1</span> || (r2-l) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5708-统计一个数组中好对子的数目"><a href="#5708-统计一个数组中好对子的数目" class="headerlink" title="5708. 统计一个数组中好对子的数目"></a>5708. 统计一个数组中好对子的数目</h2><p>给你一个数组 nums ，数组中只包含非负整数。定义<code>rev(x)</code>的值为将整数 x 各个数字位反转得到的结果。比方说 <code>rev(123) = 321</code> ， <code>rev(120) = 21</code> 。我们称满足下面条件的下标对 <code>(i, j)</code>是 好的 ：</p><ul><li><code>0 &lt;= i &lt; j &lt; nums.length</code></li><li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code><br>请你返回好下标对的数目。由于结果可能会很大，请将结果对 <code>109 + 7</code>取余 后返回。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">42</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">97</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：两个坐标对为：</span><br><span class="line"> - (<span class="number">0</span>,<span class="number">3</span>)：<span class="number">42</span> + rev(<span class="number">97</span>) = <span class="number">42</span> + <span class="number">79</span> = <span class="number">121</span>, <span class="number">97</span> + rev(<span class="number">42</span>) = <span class="number">97</span> + <span class="number">24</span> = <span class="number">121</span> 。</span><br><span class="line"> - (<span class="number">1</span>,<span class="number">2</span>)：<span class="number">11</span> + rev(<span class="number">1</span>) = <span class="number">11</span> + <span class="number">1</span> = <span class="number">12</span>, <span class="number">1</span> + rev(<span class="number">11</span>) = <span class="number">1</span> + <span class="number">11</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">13</span>,<span class="number">10</span>,<span class="number">35</span>,<span class="number">24</span>,<span class="number">76</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-nice-pairs-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-nice-pairs-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简单，题目中要求给定的公式为：<script type="math/tex; mode=display">nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</script>我们只需要将上述公式变换一下：<script type="math/tex; mode=display">nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])</script>因此我们统计数组中所有等式$nums[i] - rev(nums[i])$的值的个数，利用数学组合定理即可求出所有可能的数目。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNicePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curr = curr*<span class="number">10</span> + (x%<span class="number">10</span>);</span><br><span class="line">                x = x/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cnt[nums[i]-arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            ans = (ans + v.second*(v.second<span class="number">-1</span>)/<span class="number">2</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5707-得到新鲜甜甜圈的最多组数"><a href="#5707-得到新鲜甜甜圈的最多组数" class="headerlink" title="5707. 得到新鲜甜甜圈的最多组数"></a>5707. 得到新鲜甜甜圈的最多组数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一个甜甜圈商店，每批次都烤<code>batchSize</code> 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 所有 甜甜圈都必须已经全部销售完毕。给你一个整数 <code>batchSize</code> 和一个整数数组 <code>groups</code> ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 <code>groups[i]</code>表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。<br>当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。<br>你可以随意安排每批顾客到来的顺序。请你返回在此前提下，最多 有多少组人会感到开心。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：batchSize = <span class="number">3</span>, groups = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你可以将这些批次的顾客顺序安排为 [<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>] 。那么第 <span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">6</span> 组都会感到开心。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：batchSize = <span class="number">4</span>, groups = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= batchSize &lt;= 9</code></li><li><code>1 &lt;= groups.length &lt;= 30</code></li><li><code>1 &lt;= groups[i] &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-groups-getting-fresh-donuts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-groups-getting-fresh-donuts</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>状态压缩<code>dp</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目说的还是太复杂了，本质就是求将数组划分为能被<code>k</code>整除的非连续子数组的最大数目，以前见到过连续的子数组划分，遇到类似的题目确实不好想到。</li><li>我们可以看到假设只有<code>20</code>个元素时，则此时非常好解决，我们只需要利用二进制掩码解决所有可能的分组即可或者常规的<code>dfs</code>即可。</li><li>我们如何优化状态，减少所有可能的状态，即可对算法时间复杂度进行优化：</li></ol><ul><li>首先进行剪枝，我们知道如果当前的<code>group</code>刚好能被<code>batchSize</code>整除，或者刚好两个数相加能被<code>batchSize</code>整除的，我们优先将这两类数目去除掉。</li><li>我们对于状态如何定义，因为题目中并没有要求数字有序，数字可以为乱序，此时我们则看到题目中给定的条件为$1 &lt;= batchSize &lt;= 9$,则我们可以将数组按照对<code>batchSize</code>取模的结果进行分类，对其分类作为状态<code>dp</code>，则此时所有可能的最大状态为$3^{10}$，这个数字实际在可以接受的范围内，因此采用这个即可，看了所有的解答，基本上都在用各种方法对状态进行编码压缩，也可以直接用字符串对状态进行编码，也可以用类似于<code>K-R</code>的字符串的搜索方法对其进行编码，然后遍历所有可能的状态，各式各样的状态编码和压缩，当然最直接和最简单的就是直接暴力将用<code>treeMap</code>将数组作为状态，同时求出当前状态下所能够得到的最大可能分组以及剩余的余数，刚刚时间卡住可以过时间复杂度。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; dp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cnt, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = dp.find(cnt);</span><br><span class="line">        <span class="keyword">if</span>(it != end(dp)) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cnt[i] -= <span class="number">1</span>;</span><br><span class="line">            res = max(res,(left == <span class="number">0</span>) + dfs(cnt,(left + i)%cnt.size()));</span><br><span class="line">            cnt[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[cnt] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxHappyGroups</span><span class="params">(<span class="keyword">int</span> batchSize, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; groups)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(batchSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> group : groups)&#123;</span><br><span class="line">            ++cnt[group % batchSize];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = cnt[<span class="number">0</span>];</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (batchSize<span class="number">-1</span>)/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = min(cnt[i],cnt[batchSize-i]);</span><br><span class="line">            ans += m;</span><br><span class="line">            cnt[i] -= m;</span><br><span class="line">            cnt[batchSize-i] -= m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + dfs(cnt, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-49&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-49&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 49&quot;&gt;&lt;/a&gt;leetcode biweekly contest 49&lt;/h1&gt;&lt;p&gt;还是依旧三道题，最后一题的状态压缩&lt;code&gt;dp&lt;/code&gt;确实非常难以想到。前三题非常简单，最后一题比较难。&lt;/p&gt;&lt;h2 id=&quot;5705-判断国际象棋棋盘中一个格子的颜色&quot;&gt;&lt;a href=&quot;#5705-判断国际象棋棋盘中一个格子的颜色&quot; class=&quot;headerlink&quot; title=&quot;5705. 判断国际象棋棋盘中一个格子的颜色&quot;&gt;&lt;/a&gt;5705. 判断国际象棋棋盘中一个格子的颜色&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个坐标&lt;code&gt;coordinates&lt;/code&gt;，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。&lt;br&gt;如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 &lt;code&gt;false&lt;/code&gt;。&lt;br&gt;给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly  Contest 235</title>
    <link href="http://yoursite.com/2021/04/04/269/"/>
    <id>http://yoursite.com/2021/04/04/269/</id>
    <published>2021-04-04T01:30:40.110Z</published>
    <updated>2021-04-04T13:59:32.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-weekly-contest-235"><a href="#leetcode-weekly-contest-235" class="headerlink" title="leetcode weekly contest 235"></a>leetcode weekly contest 235</h1><p>还是依旧三道题，最后一题的思考确实比较难。</p><h2 id="5722-截断句子"><a href="#5722-截断句子" class="headerlink" title="5722. 截断句子"></a>5722. 截断句子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p><p>例如，<code>&quot;Hello World&quot;、&quot;HELLO&quot;</code> 和 <code>&quot;hello world hello world&quot;</code>都是句子。<br>给你一个句子 <code>s​​​​​​</code> 和一个整数<code>k​​​​​​</code> ，请你将 <code>s​​</code> 截断 ​，​​​使截断后的句子仅含 前 <code>k​​​​​​</code> 个单词。返回 截断 <code>s​​​​​​</code> 后得到的句子。</p><a id="more"></a><p>示例 1：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"Hello how are you Contestant"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="comment">"Hello how are you"</span></span><br><span class="line">解释：</span><br><span class="line">s 中的单词为 [<span class="comment">"Hello"</span>, <span class="comment">"how"</span> <span class="comment">"are"</span>, <span class="comment">"you"</span>, <span class="comment">"Contestant"</span>]</span><br><span class="line">前 <span class="number">4</span> 个单词为 [<span class="comment">"Hello"</span>, <span class="comment">"how"</span>, <span class="comment">"are"</span>, <span class="comment">"you"</span>]</span><br><span class="line">因此，应当返回 <span class="comment">"Hello how are you"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"What is the solution to this problem"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="comment">"What is the solution"</span></span><br><span class="line">解释：</span><br><span class="line">s 中的单词为 [<span class="comment">"What"</span>, <span class="comment">"is"</span> <span class="comment">"the"</span>, <span class="comment">"solution"</span>, <span class="comment">"to"</span>, <span class="comment">"this"</span>, <span class="comment">"problem"</span>]</span><br><span class="line">前 <span class="number">4</span> 个单词为 [<span class="comment">"What"</span>, <span class="comment">"is"</span>, <span class="comment">"the"</span>, <span class="comment">"solution"</span>]</span><br><span class="line">因此，应当返回 <span class="comment">"What is the solution"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "chopper <span class="keyword">is</span> <span class="keyword">not</span> a tanuki", k = 5</span><br><span class="line">输出："chopper <span class="keyword">is</span> <span class="keyword">not</span> a tanuki"</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>k</code> 的取值范围是 <code>[1,  s 中单词的数目]</code></li><li><code>s</code> 仅由大小写英文字母和空格组成</li><li><code>s</code> 中的单词之间由单个空格隔开</li><li>不存在前导或尾随空格</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/truncate-sentence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/truncate-sentence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>遇到第<code>k</code>个空格则推出即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">truncateSentence</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>) k--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> s.substr(<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5723-查找用户活跃分钟数"><a href="#5723-查找用户活跃分钟数" class="headerlink" title="5723. 查找用户活跃分钟数"></a>5723. 查找用户活跃分钟数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你用户在 <code>LeetCode</code>的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 <code>logs[i] = [IDi, timei]</code> 表示 ID 为 IDi 的用户在 timei 分钟时执行了某个操作。</p><p>多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。</p><p>指定用户的 用户活跃分钟数<code>（user active minutes，UAM）</code> 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p><p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 <code>answer</code> ，对于每个 <code>j（1 &lt;= j &lt;= k）</code>，<code>answer[j]</code>表示 用户活跃分钟数 等于 <code>j</code> 的用户数。</p><p>返回上面描述的答案数组 <code>answer</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>]], k = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">ID=<span class="number">0</span> 的用户执行操作的分钟分别是：<span class="number">5</span> 、<span class="number">2</span> 和 <span class="number">5</span> 。因此，该用户的用户活跃分钟数为 <span class="number">2</span>（分钟 <span class="number">5</span> 只计数一次）</span><br><span class="line">ID=<span class="number">1</span> 的用户执行操作的分钟分别是：<span class="number">2</span> 和 <span class="number">3</span> 。因此，该用户的用户活跃分钟数为 <span class="number">2</span></span><br><span class="line"><span class="number">2</span> 个用户的用户活跃分钟数都是 <span class="number">2</span> ，answer[<span class="number">2</span>] 为 <span class="number">2</span> ，其余 answer[j] 的值都是 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]], k = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">ID=<span class="number">1</span> 的用户仅在分钟 <span class="number">1</span> 执行单个操作。因此，该用户的用户活跃分钟数为 <span class="number">1</span></span><br><span class="line">ID=<span class="number">2</span> 的用户执行操作的分钟分别是：<span class="number">2</span> 和 <span class="number">3</span> 。因此，该用户的用户活跃分钟数为 <span class="number">2</span></span><br><span class="line"><span class="number">1</span> 个用户的用户活跃分钟数是 <span class="number">1</span> ，<span class="number">1</span> 个用户的用户活跃分钟数是 <span class="number">2</span> </span><br><span class="line">因此，answer[<span class="number">1</span>] = <span class="number">1</span> ，answer[<span class="number">2</span>] = <span class="number">1</span> ，其余的值都是 <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= logs.length &lt;= 104</code></li><li><code>0 &lt;= IDi &lt;= 109</code></li><li><code>1 &lt;= timei &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[用户的最大用户活跃分钟数, 105]</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-the-users-active-minutes</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash统计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>利用<code>hash</code>统计每个用户活跃的分钟的计数，然后将每个用户的活跃分钟的次数返回到最终的统计结果中即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findingUsersActiveMinutes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; logs, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = logs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(k);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : logs)&#123;</span><br><span class="line">            cnt[v[<span class="number">0</span>]].insert(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: cnt)&#123;</span><br><span class="line">            ans[v.second.size()<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5724-绝对差值和"><a href="#5724-绝对差值和" class="headerlink" title="5724. 绝对差值和"></a>5724. 绝对差值和</h2><p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code>。</p><p>数组 <code>nums1</code> 和 <code>nums2</code> 的 绝对差值和 定义为所有 <code>|nums1[i] - nums2[i]|（0 &lt;= i &lt; n）</code>的 总和（下标从 0 开始）。</p><p>你可以选用 <code>nums1</code> 中的 任意一个 元素来替换 <code>nums1</code> 中的 至多 一个元素，以 最小化 绝对差值和。</p><p>在替换数组 <code>nums1</code> 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>109 + 7</code>取余 后返回。</p><p><code>|x|</code>定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，值为 <code>x</code> ，或者</li><li>如果 <code>x &lt;= 0</code> ，值为 <code>-x</code></li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：有两种可能的最优方案：</span><br><span class="line">- 将第二个元素替换为第一个元素：[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>] =&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>] ，或者</span><br><span class="line">- 将第二个元素替换为第三个元素：[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>] =&gt; [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">两种方案的绝对差值和都是 |<span class="number">1</span><span class="number">-2</span>| + (|<span class="number">1</span><span class="number">-3</span>| 或者 |<span class="number">5</span><span class="number">-3</span>|) + |<span class="number">5</span><span class="number">-5</span>| = <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>], nums2 = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：将第一个元素替换为第二个元素：[<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>] =&gt; [<span class="number">10</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">绝对差值和为 |<span class="number">10</span><span class="number">-9</span>| + |<span class="number">10</span><span class="number">-3</span>| + |<span class="number">4</span><span class="number">-5</span>| + |<span class="number">4</span><span class="number">-1</span>| + |<span class="number">2</span><span class="number">-7</span>| + |<span class="number">7</span><span class="number">-4</span>| = <span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-absolute-sum-difference</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>根据题目中的意思，我们只能进行一次替换，根据贪心原则则我们肯定将$|nums1[i]-nums2[i]|$最大的数对进行替换，才能使得返回值最小。因此首先我们找到所有的值$|nums1[i]-nums2[i]|$最大的所有数对，然后分别对其中的每一个数对尝试进行替换，是否能否取得最小值。</li><li>对于数对$nums1[i],nums2[i]$,如果要使的$|nums1[i]-nums2[i]|$的值，最小则我们应当尽量将$nums1[i]$替换为最接近$nums2[i]$的值，则此时我们可以利用二分查找，在数组<code>nums1</code>找到最小的大于等于$nums2[i]$的数和最大的小于等于$nums2[i]$的数，最接近的数肯定在这两个数中选一个即可，此时我们非常常见的可以利用二分查找即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsoluteSumDiff</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = nums1;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(nums1[i]-nums2[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums1[i]-nums2[i]) &gt; <span class="built_in">abs</span>(nums1[diff]-nums2[diff]))&#123;</span><br><span class="line">                diff = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums1[i]-nums2[i]) == <span class="built_in">abs</span>(nums1[diff]-nums2[diff]))&#123;</span><br><span class="line">                a.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr.begin(),arr.end(),nums2[a[i]]);</span><br><span class="line">            <span class="keyword">if</span>(it == arr.end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == arr.begin())&#123;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5725-序列中不同最大公约数的数目"><a href="#5725-序列中不同最大公约数的数目" class="headerlink" title="5725. 序列中不同最大公约数的数目"></a>5725. 序列中不同最大公约数的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个由正整数组成的数组 <code>nums</code>。</p><p>数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。<br>例如，序列 <code>[4,6,16]</code> 的最大公约数是 2 。<br>数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。<br>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,2,4,1,5,10]</code> 的一个子序列。<br>计算并返回 <code>nums</code> 的所有 非空 子序列中 不同 最大公约数的 数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">10</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：上图显示了所有的非空子序列与各自的最大公约数。</span><br><span class="line">不同的最大公约数为 <span class="number">6</span> 、<span class="number">10</span> 、<span class="number">3</span> 、<span class="number">2</span> 和 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">15</span>,<span class="number">40</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 105</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题，素数筛选法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先对于素数筛选法还是非常熟悉的，如果一个数<code>x</code>为素数，则<code>x</code>的倍数一定不是素数。我们知道可以在$O(n)$的时间复杂度内筛选出所有的从$[1,n]$的素数。</li><li>我们知道如果<code>x</code>为某个数组的最大公约数，则我们可以知道如下结论:</li></ol><ul><li>数组中的每个元素都能被$x$整除；</li><li>数组中的所有元素除以<code>x</code>以后组成的数组的最大公约数为<code>1</code>。</li><li>数组中所有元素都是$x$的倍数；</li></ul><ol><li>此时我们就可以参考素数筛选法，尝试从$[1,200000]$中所有的可能的最大公约数，则此时我们假设<code>x</code>为公约数，则我们测试所有的$x$的倍数是否存在于原数组中，如果存在我们则求最大公约数，最终我们测试所有可能的元素的最大公约数是否为$x$。</li><li>题目的算法时间复杂度计算公式为：<script type="math/tex; mode=display">O(n) = \frac{n}{1} + \frac{n}{2} + \frac{n}{3} + ... + \frac{n}{n} \\\approx n*lg(n)</script>非常喜欢这种思考类型的题目，但是感觉就是刷题而已。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) valid[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= <span class="number">200000</span>; j = j + i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="number">0</span>) curr = j;</span><br><span class="line">                    <span class="keyword">else</span> curr = __gcd(curr,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == i) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) valid[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= <span class="number">200000</span>; j = j + i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">                        curr = j/i;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        curr = __gcd(curr,j/i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="number">1</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-weekly-contest-235&quot;&gt;&lt;a href=&quot;#leetcode-weekly-contest-235&quot; class=&quot;headerlink&quot; title=&quot;leetcode weekly contest 235&quot;&gt;&lt;/a&gt;leetcode weekly contest 235&lt;/h1&gt;&lt;p&gt;还是依旧三道题，最后一题的思考确实比较难。&lt;/p&gt;&lt;h2 id=&quot;5722-截断句子&quot;&gt;&lt;a href=&quot;#5722-截断句子&quot; class=&quot;headerlink&quot; title=&quot;5722. 截断句子&quot;&gt;&lt;/a&gt;5722. 截断句子&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。&lt;/p&gt;&lt;p&gt;例如，&lt;code&gt;&amp;quot;Hello World&amp;quot;、&amp;quot;HELLO&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;hello world hello world&amp;quot;&lt;/code&gt;都是句子。&lt;br&gt;给你一个句子 &lt;code&gt;s​​​​​​&lt;/code&gt; 和一个整数&lt;code&gt;k​​​​​​&lt;/code&gt; ，请你将 &lt;code&gt;s​​&lt;/code&gt; 截断 ​，​​​使截断后的句子仅含 前 &lt;code&gt;k​​​​​​&lt;/code&gt; 个单词。返回 截断 &lt;code&gt;s​​​​​​&lt;/code&gt; 后得到的句子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Atcoder】</title>
    <link href="http://yoursite.com/2021/03/29/267/"/>
    <id>http://yoursite.com/2021/03/29/267/</id>
    <published>2021-03-29T14:16:04.543Z</published>
    <updated>2021-03-31T11:43:29.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="atcoder-197"><a href="#atcoder-197" class="headerlink" title="atcoder 197"></a>atcoder 197</h1><p>atcoder的题目难度还是非常高的，非常适合ACM的比赛，难度还是不小的，仔细做了一下，发现自己也就3到4题的水平，<code>e</code>和<code>f</code>的难度还是非常大。</p><h2 id="e"><a href="#e" class="headerlink" title="e"></a>e</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/31/7ZVcTIYC9uWfrma.png" alt><br>给编号从<code>1</code>到<code>n</code>的球的坐标和颜色，要求按照颜色的升序进行进行遍历。其中球的颜色可以重复，从<code>0</code>点开始起遍历所有的球，并返回到<code>0</code>点的最短路径。</p><a id="more"></a><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc197/tasks/abc197_e" target="_blank" rel="noopener">https://atcoder.jp/contests/abc197/tasks/abc197_e</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  dp</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本题的<code>dp</code>还是非常值得思考的一个<code>dp</code>，我们假设不考虑球的颜色，我们按照球的坐标的大小进行排序<script type="math/tex; mode=display">x_{1} < x_{2} < x_{3} < x_{4} ... < x_{n}</script>按照所有球的坐标从小到大进行访问即可。但在实际的过程中因为要求必须按照球的颜色大小进行访问，此时我们首先必须按照球的颜色编号大小对所有的球进行排序。我们仔细观察一下，假设对于第<code>i</code>种颜色的球总共有<code>m</code>个，它的所有的坐标按照从小到大分布如下：<script type="math/tex; mode=display">x^{i}_{1} < x^{i}_{2} < x^{i}_{3} < x^{i}_{4}< x^{i}_{5}...< x^{i}_{m}</script>我们仔细思索一下，假设我们从坐标$x^{i}_{k}$开始访问第<code>i</code>种颜色的球，无论访问顺序如何，最小的访问路径的终点一定是要么是$x^{i}_{1}$,要么是$x^{i}_{m}$,相当于要么是第<code>i</code>种颜色的球中坐标最小的球，要么是第<code>i</code>种颜色的球中坐标最大的球。<br>2.基于此种情况下，我们可以推到出<code>dp</code>的递推公式，我们设：</li></ol><ul><li><code>dp[i][0]</code>表示已经遍历了前<code>i</code>种颜色的球，且最后访问的球位于第<code>i</code>种颜色的球的坐标的首位。</li><li><code>dp[i][1]</code>表示已经遍历了前<code>i</code>种颜色的球，且最后访问的球位于第<code>i</code>种颜色的球的坐标的末位。</li></ul><ol><li>基于上述的推断，我们设<code>arr[i][0]</code>表示第<code>i</code>种球的坐标的首位，<code>arr[i][1]</code>表示第<code>i</code>种球的坐标的末位,我们可以得到递推公式如下：<script type="math/tex; mode=display">dp[i][0] = min(dp[i][0],dp[i-1][0] + abs(arr[i-1][0] - arr[i][1]) + arr[i][1] - arr[i][0); \\dp[i][0] = min(dp[i][0],dp[i-1][1] + abs(arr[i-1][1] - arr[i][1]) + arr[i][1] - arr[i][0); \\dp[i][1] = min(dp[i][1],dp[i-1][0] + abs(arr[i-1][0] - arr[i][0]) + arr[i][1] - arr[i][0); \\dp[i][1] = min(dp[i][1],dp[i-1][1] + abs(arr[i-1][1] - arr[i][0]) + arr[i][1] - arr[i][0); \\</script></li><li>此题的重点在于如何理解跨越时最小的移动轨迹，从某一点到某一点的最小的移动轨迹一般都是确定的。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;sz[find(x)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; y1) swap(x1,y1);</span><br><span class="line">        parent[y1] = x1;</span><br><span class="line">        sz[x1] += sz[y1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x,c;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        cnt[c].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        sort(cnt[v.first].begin(),cnt[v.first].end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        arr.push_back(&#123;v.second[<span class="number">0</span>],v.second.back()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push_back(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> m = arr.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>,LONG_MAX));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = arr[i][<span class="number">1</span>] - arr[i][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">0</span>] = min(dp[i][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">0</span>] - arr[i][<span class="number">1</span>]) + l);</span><br><span class="line">        dp[i][<span class="number">0</span>] = min(dp[i][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">1</span>] - arr[i][<span class="number">1</span>]) + l);</span><br><span class="line">        dp[i][<span class="number">1</span>] = min(dp[i][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">0</span>] - arr[i][<span class="number">0</span>]) + l);</span><br><span class="line">        dp[i][<span class="number">1</span>] = min(dp[i][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">1</span>] - arr[i][<span class="number">0</span>]) + l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(dp[m<span class="number">-1</span>][<span class="number">0</span>],dp[m<span class="number">-1</span>][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;atcoder-197&quot;&gt;&lt;a href=&quot;#atcoder-197&quot; class=&quot;headerlink&quot; title=&quot;atcoder 197&quot;&gt;&lt;/a&gt;atcoder 197&lt;/h1&gt;&lt;p&gt;atcoder的题目难度还是非常高的，非常适合ACM的比赛，难度还是不小的，仔细做了一下，发现自己也就3到4题的水平，&lt;code&gt;e&lt;/code&gt;和&lt;code&gt;f&lt;/code&gt;的难度还是非常大。&lt;/p&gt;&lt;h2 id=&quot;e&quot;&gt;&lt;a href=&quot;#e&quot; class=&quot;headerlink&quot; title=&quot;e&quot;&gt;&lt;/a&gt;e&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/7ZVcTIYC9uWfrma.png&quot; alt&gt;&lt;br&gt;给编号从&lt;code&gt;1&lt;/code&gt;到&lt;code&gt;n&lt;/code&gt;的球的坐标和颜色，要求按照颜色的升序进行进行遍历。其中球的颜色可以重复，从&lt;code&gt;0&lt;/code&gt;点开始起遍历所有的球，并返回到&lt;code&gt;0&lt;/code&gt;点的最短路径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="atcoder" scheme="http://yoursite.com/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 234</title>
    <link href="http://yoursite.com/2021/03/28/266/"/>
    <id>http://yoursite.com/2021/03/28/266/</id>
    <published>2021-03-28T05:22:16.985Z</published>
    <updated>2021-03-31T02:57:22.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-234"><a href="#leetcode-contest-234" class="headerlink" title="leetcode contest 234"></a>leetcode contest 234</h1><p>本周的题目质量太差了，没有特别需要思考的地方，除了第二题是个数学题以外，本周的题目感觉基本上都是数学问题，最有意思和思考的题目竟然是第二题。</p><h2 id="5713-字符串中不同整数的数目"><a href="#5713-字符串中不同整数的数目" class="headerlink" title="5713. 字符串中不同整数的数目"></a>5713. 字符串中不同整数的数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p><p>请你用空格替换每个不是数字的字符。例如，<code>&quot;a123bc34d8ef34&quot;</code> 将会变成 <code>&quot; 123  34 8  34&quot;</code> 。注意，剩下的这些整数间至少要用一个空格隔开：<code>&quot;123&quot;、&quot;34&quot;、&quot;8&quot; 和 &quot;34&quot;</code>。</p><a id="more"></a><p>返回对 <code>word</code> 完成替换后形成的 不同 整数的数目。</p><p>如果两个整数的 不含前导零 的十进制表示不同，则认为这两个整数也不同。</p><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"a123bc34d8ef34"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：不同的整数有 <span class="string">"123"</span>、<span class="string">"34"</span> 和 <span class="string">"8"</span> 。注意，<span class="string">"34"</span> 只计数一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"leet1234code234"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"a1b01c001"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="string">"1"</span>、<span class="string">"01"</span> 和 <span class="string">"001"</span> 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 1000</code></li><li><code>word</code> 由数字和小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-different-integers-in-a-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>取出字符串中连续的数字的字符串放入到集合中。对于字符串需要处理去掉前导<code>0</code>，然后将剩余的数字作为一个完整的字符串放入到集合中。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDifferentIntegers</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'a'</span> &amp;&amp; s[i] &lt;= <span class="string">'z'</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> curr;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] == <span class="string">'0'</span>) i++;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                    curr.push_back(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.size() == <span class="number">0</span>) curr.push_back(<span class="string">'0'</span>);</span><br><span class="line">                cnt.insert(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5715-还原排列的最少操作步数"><a href="#5715-还原排列的最少操作步数" class="headerlink" title="5715. 还原排列的最少操作步数"></a>5715. 还原排列的最少操作步数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个偶数 <code>n</code>​​​​​​ ，已知存在一个长度为 <code>n</code> 的排列 <code>perm</code>，其中 <code>perm[i] == i​</code>（下标 从 0 开始 计数）。</p><p>一步操作中，你将创建一个新数组 <code>arr</code>，对于每个 <code>i</code> ：</p><ul><li>如果 <code>i % 2 == 0</code>，那么 <code>arr[i] = perm[i / 2]</code></li><li>如果 <code>i % 2 == 1</code>，那么 <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code><br>然后将 <code>arr</code>​​ 赋值​​给<code>perm</code> 。</li></ul><p>要想使 <code>perm</code> 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">所以，仅需执行 <span class="number">1</span> 步操作</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">2</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">所以，仅需执行 <span class="number">2</span> 步操作</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>n</code>​​​​​​ 是一个偶数</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题，暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>如果不知道如何解决，我们可以建设最终变换的次数肯定不会多于<code>n</code>，则此时我们直接用暴力变换，知道变换出来的数组的每个元素满足<code>arr[i] == i</code>即回到初始值。<br>2.首先我们可以尝试进行变换一下题目中的变换规则：</li></ol><ul><li>如果 <code>i &lt; n/2</code>，那么 <code>arr[2*i] = perm[i]</code></li><li>如果 <code>i &gt;= n/2</code>，那么 <code>arr[2*i-n] = perm[i]</code><br>如果用数学问题来分析，我们可以看到第一次变换的情况如下，最开始的数组为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...,n<span class="number">-1</span></span><br></pre></td></tr></table></figure>经过第一次变换后，假设<code>n=10</code>，我们可以仔细观察它的变化规则，我们可以知道变换后的数组元素为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span>：<span class="number">0</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> </span><br><span class="line"><span class="number">2</span>：<span class="number">0</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">9</span> </span><br><span class="line"><span class="number">3</span>: <span class="number">0</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">9</span> </span><br><span class="line"><span class="number">4</span>: <span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">1</span> <span class="number">5</span> <span class="number">9</span> </span><br><span class="line"><span class="number">5</span>: <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> </span><br><span class="line"><span class="number">6</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>我们假设试着开始进行逆变换，即从上述的状态<code>6</code>向状态<code>5</code>开始变换，一直到变换出来状态<code>0</code>为止，如果为逆变换则我们应当遵循如下变换：</li><li>如果 <code>i &lt; n/2</code>，那么 <code>arr[i] = perm[2*i]</code></li><li>如果 <code>i &gt;= n/2</code>，那么 <code>arr[i] = perm[2*i-n]</code><br>则此时我们可以知道如下第一次变换时:</li><li>当$i &lt; \frac{n}{2}$时，此时我们可以知道$f(i) = 2*i$;</li><li>当$i \ge \frac{n}{2}$时，此时我们可以知道$f(i) = 2*i - (n-1)$;</li><li>$perm[0],perm[n-1]$这两个元素始终保持不变；<br>仔细观察其规律，我们可以得到结论得到结论，$f(i) = 2<em>i\quad mod (n-1)$，因为当$i &lt; \frac{n}{2}$时，此时我们可以知道$f(i) = 2</em>i$，此时$2*i &lt; (n-1)$.<br>根据上述得到的结论后，我们可以知道：<br>第<code>k</code>的结果与第<code>k-1</code>次的变换结果如下：<script type="math/tex; mode=display">f_{k}(i) = 2*f_{k-1}(i) \quad mod \quad (n-1)</script>则此时我们将$f_{1}(i)$代入到上述的公式中，可以得到：<script type="math/tex; mode=display">f_{k}(i) = 2^{k}*i \quad mod \quad(n-1)</script>因此我们只需要满足如下时，即表示我们当前的变换到了最终的结果：<script type="math/tex; mode=display">f_{k}(1) = 2^{k}*1 \quad mod \quad(n-1) = 1 \\ f_{k}(2) = 2^{k}*2 \quad mod \quad(n-1) = 2 \\f_{k}(3) = 2^{k}*3 \quad mod \quad(n-1) = 3 \\... \\f_{k}(n-1) = 2^{k}*(n-2) \quad mod \quad(n-1) = n-2</script>仔细观察一下，我们是需要满足$2^{k}<em>1 \quad mod \quad(n-1) = 1$这个等式，其余的等式都可以满足，所以我们求出最小的<code>k</code>满足$2^{k}</em>1 \quad mod \quad(n-1) = 1$即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reinitializePermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; perm(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) perm[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) arr[i] = perm[i/<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) arr[i] = perm[n/<span class="number">2</span> + (i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        perm = arr;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(perm[i] != i)&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) arr[i] = perm[i/<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) arr[i] = perm[n/<span class="number">2</span> + (i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            perm = arr;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reinitializePermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pow2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (pow2 != <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            pow2 = pow2 * <span class="number">2</span> % (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5714-替换字符串中的括号内容"><a href="#5714-替换字符串中的括号内容" class="headerlink" title="5714. 替换字符串中的括号内容"></a>5714. 替换字符串中的括号内容</h2><p>给你一个字符串 <code>s</code>，它包含一些括号对，每个括号中包含一个 非空 的键。</p><p>比方说，字符串 <code>&quot;(name)is(age)yearsold&quot;</code> 中，有 两个 括号对，分别包含键 <code>&quot;name&quot;</code> 和 <code>&quot;age&quot;</code> 。<br>你知道许多键对应的值，这些关系由二维字符串数组<code>knowledge</code> 表示，其中 <code>knowledge[i] = [keyi, valuei]</code> ，表示键 <code>keyi</code>对应的值为 <code>valuei</code>。</p><p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p><ul><li>将<code>keyi</code>和括号用对应的值 <code>valuei</code> 替换。</li><li>如果从 <code>knowledge</code>中无法得知某个键对应的值，你需要将 <code>keyi</code>和括号用问号 “?” 替换（不需要引号）。</li><li><code>knowledge</code>中每个键最多只会出现一次。<code>s</code> 中不会有嵌套的括号。</li></ul><p>请你返回替换 所有 括号对后的结果字符串。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(name)is(age)yearsold"</span>, knowledge = [[<span class="string">"name"</span>,<span class="string">"bob"</span>],[<span class="string">"age"</span>,<span class="string">"two"</span>]]</span><br><span class="line">输出：<span class="string">"bobistwoyearsold"</span></span><br><span class="line">解释：</span><br><span class="line">键 <span class="string">"name"</span> 对应的值为 <span class="string">"bob"</span> ，所以将 <span class="string">"(name)"</span> 替换为 <span class="string">"bob"</span> 。</span><br><span class="line">键 <span class="string">"age"</span> 对应的值为 <span class="string">"two"</span> ，所以将 <span class="string">"(age)"</span> 替换为 <span class="string">"two"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"hi(name)"</span>, knowledge = <span class="string">[["a","b"]]</span></span><br><span class="line">输出：<span class="string">"hi?"</span></span><br><span class="line">解释：由于不知道键 <span class="string">"name"</span> 对应的值，所以用 <span class="string">"?"</span> 替换 <span class="string">"(name)"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"(a)(a)(a)aaa"</span>, knowledge = [[<span class="comment">"a"</span>,<span class="comment">"yes"</span>]]</span><br><span class="line">输出：<span class="comment">"yesyesyesaaa"</span></span><br><span class="line">解释：相同的键在 s 中可能会出现多次。</span><br><span class="line">键 <span class="comment">"a"</span> 对应的值为 <span class="comment">"yes"</span> ，所以将所有的 <span class="comment">"(a)"</span> 替换为 <span class="comment">"yes"</span> 。</span><br><span class="line">注意，不在括号里的 <span class="comment">"a"</span> 不需要被替换。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(a)(b)"</span>, knowledge = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"a"</span>]]</span><br><span class="line">输出：<span class="string">"ba"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>0 &lt;= knowledge.length &lt;= 105</code></li><li><code>knowledge[i].length == 2</code></li><li><code>1 &lt;= keyi.length, valuei.length &lt;= 10</code></li><li>s 只包含小写英文字母和圆括号 ‘(‘ 和 ‘)’ 。</li><li>s 中每一个左圆括号 ‘(‘ 都有对应的右圆括号 ‘)’ 。</li><li>s 中每对括号内的键都不会为空。</li><li>s 中不会有嵌套括号对。</li><li><code>keyi</code>和 <code>valuei</code> 只包含小写英文字母。</li><li><code>knowledge</code> 中的 <code>keyi</code> 不会重复。<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>这个题目可以算是简单题目，只需要用<code>hashtable</code>保存<code>key</code>对应的<code>value</code>即可，取出括号中的<code>key</code>，然后用对应的<code>value</code>替换即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">evaluate</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; knowledge)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; dict;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : knowledge) dict[v[<span class="number">0</span>]] = v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); )&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">'('</span>)&#123;</span><br><span class="line">                ans.push_back(s[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) i++;</span><br><span class="line">                <span class="built_in">string</span> key;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] != <span class="string">')'</span>)&#123;</span><br><span class="line">                    key.push_back(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) i++;</span><br><span class="line">                <span class="keyword">if</span>(dict.count(key))&#123;</span><br><span class="line">                    ans += dict[key];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans.push_back(<span class="string">'?'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5716-好因子的最大数目"><a href="#5716-好因子的最大数目" class="headerlink" title="5716. 好因子的最大数目"></a>5716. 好因子的最大数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数 <code>primeFactors</code> 。你需要构造一个正整数 n ，它满足以下条件：</p><p>n 质因数（质因数需要考虑重复的情况）的数目 不超过 <code>primeFactors</code> 个。<br>n 好因子的数目最大化。如果 <code>n</code> 的一个因子可以被<code>n</code>的每一个质因数整除，我们称这个因子是 好因子 。比方说，如果 n = 12 ，那么它的质因数为 [2,2,3] ，那么 6 和 12 是好因子，但 3 和 4 不是。<br>请你返回 n 的好因子的数目。由于答案可能会很大，请返回答案对 <code>109 + 7</code>取余 的结果。</p><p>请注意，一个质数的定义是大于 1 ，且不能被分解为两个小于该数的自然数相乘。一个数 <code>n</code> 的质因子是将 <code>n</code> 分解为若干个质因子，且它们的乘积为 n 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：primeFactors = <span class="number">5</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="number">200</span> 是一个可行的 n 。</span><br><span class="line">它有 <span class="number">5</span> 个质因子：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>] ，且有 <span class="number">6</span> 个好因子：[<span class="number">10</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>] 。</span><br><span class="line">不存在别的 n 有至多 <span class="number">5</span> 个质因子，且同时有更多的好因子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：primeFactors = <span class="number">8</span></span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= primeFactors &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-233/problems/count-pairs-with-xor-in-a-range/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-233/problems/count-pairs-with-xor-in-a-range/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目弄得太啰嗦了，本质就是正整数分解使得乘积最大问题，如果转化为这个问题得话，本题就十分简单了，本质就变成了一个数学问题。<br><a href="https://blog.csdn.net/xiaoquantouer/article/details/70142739" target="_blank" rel="noopener">正整数分解使得乘积最大问题</a></li><li>按照题目中给定得意思，假设我们设<code>n</code>有<code>k</code>个不同的质因子，每个不同的质因子的数目分别为$p_{0},p_{1}，…,p_{k-1}$则我们可以知道如下：<script type="math/tex; mode=display">primeFactors = \sum_{i = 0}^{k-1}p_{i}</script>按照题目中要求好因子必须能够被所有的质因子整除，这就表示好因子必须包含每一个不同的质因子，根据组合定理可以知道，这样的好因子的数目即为:<script type="math/tex; mode=display">good = \prod_{i=0}^{k-1}p_{i}</script>题目中要求使得<code>good</code>的值最大，因此这就转为了正整数分解使得乘积最大问题。最大的分解的原则如下：</li></ol><ul><li>能被<code>3</code>除断，那么就分解为<code>3+3+...+3</code>的情况即可。例如<code>9=3+3+3</code>。</li><li>被<code>3</code>除余<code>1</code>，分解为<code>3+3+...+3+2+2</code>或者<code>3+3+...+3+4</code>的情况，例如<code>10=3+3+2+2</code></li><li>被<code>3</code>除余<code>2</code>，分解为<code>3+3+...+3+2</code>的情况，例如<code>11=3+3+3+2</code>。</li></ul><ol><li>我们根据<code>primeFactors</code>的大小按照上述规则进行分解即可，稍微麻烦点的我们可以利用二分法进行快速的求幂。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = fastpow(x,y/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(y%<span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (curr*curr)%mod;</span><br><span class="line">        <span class="keyword">return</span> (curr*curr*x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNiceDivisors</span><span class="params">(<span class="keyword">int</span> primeFactors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(primeFactors%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> fastpow(<span class="number">3</span>,primeFactors/<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primeFactors%<span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(primeFactors == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>*fastpow(<span class="number">3</span>,(primeFactors<span class="number">-4</span>)/<span class="number">3</span>)%mod; </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primeFactors%<span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*fastpow(<span class="number">3</span>,(primeFactors<span class="number">-2</span>)/<span class="number">3</span>)%mod;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-234&quot;&gt;&lt;a href=&quot;#leetcode-contest-234&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 234&quot;&gt;&lt;/a&gt;leetcode contest 234&lt;/h1&gt;&lt;p&gt;本周的题目质量太差了，没有特别需要思考的地方，除了第二题是个数学题以外，本周的题目感觉基本上都是数学问题，最有意思和思考的题目竟然是第二题。&lt;/p&gt;&lt;h2 id=&quot;5713-字符串中不同整数的数目&quot;&gt;&lt;a href=&quot;#5713-字符串中不同整数的数目&quot; class=&quot;headerlink&quot; title=&quot;5713. 字符串中不同整数的数目&quot;&gt;&lt;/a&gt;5713. 字符串中不同整数的数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;word&lt;/code&gt; ，该字符串由数字和小写英文字母组成。&lt;/p&gt;&lt;p&gt;请你用空格替换每个不是数字的字符。例如，&lt;code&gt;&amp;quot;a123bc34d8ef34&amp;quot;&lt;/code&gt; 将会变成 &lt;code&gt;&amp;quot; 123  34 8  34&amp;quot;&lt;/code&gt; 。注意，剩下的这些整数间至少要用一个空格隔开：&lt;code&gt;&amp;quot;123&amp;quot;、&amp;quot;34&amp;quot;、&amp;quot;8&amp;quot; 和 &amp;quot;34&amp;quot;&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 2021 Google Kick Start roundA</title>
    <link href="http://yoursite.com/2021/03/26/265/"/>
    <id>http://yoursite.com/2021/03/26/265/</id>
    <published>2021-03-26T05:54:42.650Z</published>
    <updated>2021-03-27T09:37:40.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2021-google-kick-start-roundA"><a href="#2021-google-kick-start-roundA" class="headerlink" title="2021 google kick start roundA"></a>2021 google kick start roundA</h1><p><code>kick start</code>的题目果真质量非常高，非常值得学习和练习的题目，非常喜欢这类的题目，前三题都可以做出来，不过题目<code>D</code>确实很难，我感觉自己肯定想不到解答的答案的。前三题就是<code>leetcode</code>的难度，最后一题确实很难。</p><h2 id="K-Goodness-String-5pts-7pts"><a href="#K-Goodness-String-5pts-7pts" class="headerlink" title="K-Goodness String (5pts, 7pts)"></a>K-Goodness String (5pts, 7pts)</h2><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/26/ERxJvVkZF1rYitD.png" alt><br>给定字符串，求出给定分值得最小变换次数</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cca3" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cca3</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单题目</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们只需要求出$s[i] != s[n-1-i]$得字符对个数，最小的变换次数等于不同的字符对的个数与<code>k</code>的绝对值之差。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> good = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bad = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n&gt;&gt;<span class="number">1</span>); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str[n<span class="number">-1</span>-i]) good++;</span><br><span class="line">        <span class="keyword">else</span> bad++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="built_in">abs</span>(k-bad)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="L-Shaped-Plots-8pts-12pts"><a href="#L-Shaped-Plots-8pts-12pts" class="headerlink" title="L Shaped Plots (8pts, 12pts)"></a>L Shaped Plots (8pts, 12pts)</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/26/3TnVvd1utlzsgqR.png" alt><br>求出给定的矩阵中<code>L</code>的个数，<code>L</code>形要求：</p><ul><li><code>L</code>的两个线段必须分别在一行和一列，两个线段必须必须与行、列平行；</li><li><code>L</code>的两个线段有且只有一个点相交，且一条线段的长度为另一条线段的长度的两倍；</li><li><code>L</code>的两个线段的长度必须大于等于<code>2</code>;<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c509" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c509</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口 + 前缀和</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>我们分别求出以点<code>(x,y)</code>为起点，分别往上下左右四个方向的最长的连续的<code>1</code>的长度。</li><li>分别求出以点<code>(x,y)</code>为起点相交顶点的<code>L</code>的个数，分别在上下左右四个方向求一边，我们设<code>L</code>的两个线段的长度分别为$m,n$,则以<code>m,n</code>为长度的两个线段可能组成的<code>L</code>的形状个数为：<script type="math/tex; mode=display">cnt = max(0,min(m/2,n)-1) + max(0,min(m,n/2)-1)</script></li><li>时间复杂度$O(m<em>n)$,空间复杂度$O(m</em>n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;row&gt;&gt;col;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; left(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; right(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; down(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; up(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            left[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            right[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">         <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            up[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            down[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            ans += max(min(left[i][j],up[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(left[i][j]/<span class="number">2</span>,up[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(right[i][j],up[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(right[i][j]/<span class="number">2</span>,up[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(left[i][j],down[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(left[i][j]/<span class="number">2</span>,down[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(right[i][j],down[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(right[i][j]/<span class="number">2</span>,down[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Rabbit-House-9pts-15pts"><a href="#Rabbit-House-9pts-15pts" class="headerlink" title="Rabbit House (9pts, 15pts)"></a>Rabbit House (9pts, 15pts)</h2><p><img src="https://i.loli.net/2021/03/26/o8TjBu3RcAtbyVp.png" alt><br>这个题目跟<code>leetcode</code>上的那个容器的题目很像，所以是中规中矩的题目，不算很难，靠自己还能思考出来。</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cb14" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cb14</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们将矩阵中所有单元的高度按照从高到底依次排列，每次从队列中取除当前高度最高的单元$(x,y)$,高度为$h$,则此时必须满足$(x,y)$周围的四个格子$(x-1,y),(x+1,y),(x,y+1),(x,y-1)$必须要大于等于$h-1$,如果当前格子的高度发生改变则将其从新放入队列中。</li><li>非常简单的优先级对即可解决，时间复杂度为$O(m<em>nlg(m</em>n))$,空间复杂度为$O(m*n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a,Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;row&gt;&gt;col;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;matrix[i][j];</span><br><span class="line">            pq.push(&#123;i,j,matrix[i][j]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">        Node curr = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        visit[curr.x][curr.y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr.val != matrix[curr.x][curr.y]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = curr.x + d[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = curr.y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visit[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &lt; curr.val - <span class="number">1</span>)&#123;</span><br><span class="line">                ans += curr.val - <span class="number">1</span> - matrix[x][y];</span><br><span class="line">                matrix[x][y] = curr.val - <span class="number">1</span>;</span><br><span class="line">                pq.push(&#123;x,y,matrix[x][y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Checksum-10pts-17pts-17pts"><a href="#Checksum-10pts-17pts-17pts" class="headerlink" title="Checksum (10pts, 17pts, 17pts)"></a>Checksum (10pts, 17pts, 17pts)</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/26/L8D2wuAkR5f6B3p.png" alt><br>给定矩阵和每行每列的异或校验和，求恢复矩阵所需要的最小代价。</p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c2c3" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c2c3</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>最小生成树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目还是非常难的，根本不容易想到，我们首先将已经恢复的单元视作代价为$0$的未恢复的单元。</li><li>首先我们需要想到一个问题，思考一下我们至少需要恢复多少个单元，才能将所有的单元全部恢复，这个就是一个非常值得思考得问题，我们仔细想一下，因为已知每一行所有元素得异或校验和，则我们如果已经知道每一行的$n-1$个值，则我们就能通过校验和计算最后一个未知的数，对于每一列同样也是如此，所以我们可以猜测一下，我们至少需要恢复$(n-1)^{2}$个数据，才能完成所有的$n^{2}$数据恢复。</li></ol><ul><li>我们可以计算一下，如果恢复的元素超过$(n-1)^{2}$个，则我们可以计算出肯定存在某一行或者某一列恢复的数据为$n$个，这个对于我们来说是不必要的。</li><li>如果恢复的数据少于$(n-1)^{2}$,则此时我们还至少需要恢复$2*N$个数据，而我们实际上根据异或的校验和，至多能够推导出$2N-1$个数据。</li></ul><ol><li>根据以上推论，我们可以知道可以知道选择出最大的未解的$2n-1$个数据，剩余的$(n-1)^{2}$的数据恢复则花费的代价可能最小。如何选择$2n-1$个数据呢？假设我们按照以下顺序通过校验和来恢复最后剩余的$(2n-1)$个数据，顺序为：<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">9</span> <span class="number">0</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">0</span> <span class="number">0</span> <span class="number">10</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>$1 \rightarrow 2 \rightarrow 3 \rightarrow 4\rightarrow 5\rightarrow 6\rightarrow 7\rightarrow 8\rightarrow 9\rightarrow 10 \rightarrow 11$<br>我们实际可以知道将行与列分别看成生成树中的两个顶点，我们实际可以看出由行与列组成成的图不能有环，如果存在环的话，则一定存在某一行或者某一列中有两个未知数，则此时就不可能恢复该行或者该列的元素。</li><li>根据以上得出我们只需要选出边与行的顶点组成的最大生成树，可以用<code>prim</code>或者<code>Kruskal</code>算法即可。因为在此图中一个顶点连接的边很多，此时明显我们用<code>prim</code>算法的时间复杂度更好。</li><li>代码直接<code>copy lucifer</code>的。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> c = getchar();</span><br><span class="line">  T sig = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar())</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">      sig = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar())</span><br><span class="line">    x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">  x *= sig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    size = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      parent[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[idx] == idx)</span><br><span class="line">      <span class="keyword">return</span> idx;</span><br><span class="line">    <span class="keyword">return</span> parent[idx] = find(parent[idx]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a), fb = find(b);</span><br><span class="line">    <span class="keyword">if</span> (fa != fb) &#123;</span><br><span class="line">      <span class="keyword">if</span> (size[fa] &gt; size[fb]) &#123;</span><br><span class="line">        parent[fb] = fa;</span><br><span class="line">        size[fa] += size[fb];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[fa] = fb;</span><br><span class="line">        size[fb] += size[fa];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> case_num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, case_num);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; b(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        read(a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        read(b[i][j]);</span><br><span class="line">        tot += b[i][j];</span><br><span class="line">        edges.emplace_back(b[i][j], i, n + j);</span><br><span class="line">      &#125;</span><br><span class="line">    sort(edges.rbegin(), edges.rend());</span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      read(r[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      read(c[i]);</span><br><span class="line"></span><br><span class="line">    ll remove = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [weight, u, v] : edges) &#123;</span><br><span class="line">      <span class="keyword">if</span> (uf.find(u) == uf.find(v))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      remove += weight;</span><br><span class="line">      uf.connect(u, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tot - remove);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  read(t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    Solution solution = Solution();</span><br><span class="line">    solution.solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2021-google-kick-start-roundA&quot;&gt;&lt;a href=&quot;#2021-google-kick-start-roundA&quot; class=&quot;headerlink&quot; title=&quot;2021 google kick start roundA&quot;&gt;&lt;/a&gt;2021 google kick start roundA&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kick start&lt;/code&gt;的题目果真质量非常高，非常值得学习和练习的题目，非常喜欢这类的题目，前三题都可以做出来，不过题目&lt;code&gt;D&lt;/code&gt;确实很难，我感觉自己肯定想不到解答的答案的。前三题就是&lt;code&gt;leetcode&lt;/code&gt;的难度，最后一题确实很难。&lt;/p&gt;&lt;h2 id=&quot;K-Goodness-String-5pts-7pts&quot;&gt;&lt;a href=&quot;#K-Goodness-String-5pts-7pts&quot; class=&quot;headerlink&quot; title=&quot;K-Goodness String (5pts, 7pts)&quot;&gt;&lt;/a&gt;K-Goodness String (5pts, 7pts)&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 233</title>
    <link href="http://yoursite.com/2021/03/20/264/"/>
    <id>http://yoursite.com/2021/03/20/264/</id>
    <published>2021-03-20T15:47:39.102Z</published>
    <updated>2021-03-21T15:45:16.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-233"><a href="#leetcode-contest-233" class="headerlink" title="leetcode contest 233"></a>leetcode contest 233</h1><p>周赛还算三道题的节奏，最后一题太难了，不会做，没有想到会用<code>trie</code>的解法，确实非常巧妙的解法。</p><h2 id="5709-最大升序子数组和"><a href="#5709-最大升序子数组和" class="headerlink" title="5709. 最大升序子数组和"></a>5709. 最大升序子数组和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数组成的数组 <code>nums</code> ，返回 nums 中一个 升序 子数组的最大可能元素和。</p><p>子数组是数组中的一个连续数字序列。</p><p>已知子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，若对所有 <code>i（l &lt;= i &lt; r）</code>，<code>numsi &lt; numsi+1</code>都成立，则称这一子数组为 升序 子数组。注意，大小为 <code>1</code> 的子数组也视作 升序 子数组。</p><a id="more"></a><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-233/problems/maximum-ascending-subarray-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-233/problems/maximum-ascending-subarray-sum/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力滑动窗口即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>求出每个连续升序的子数组，然后求和即可。时间复杂度$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAscendingSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curr = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                curr += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5711-有界数组中指定下标处的最大值"><a href="#5711-有界数组中指定下标处的最大值" class="headerlink" title="5711. 有界数组中指定下标处的最大值"></a>5711. 有界数组中指定下标处的最大值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你三个正整数 <code>n</code>、<code>index</code> 和 <code>maxSum</code> 。你需要构造一个同时满足下述所有条件的数组 <code>nums</code>（下标 从 <code>0</code> 开始 计数）：</p><ul><li><code>nums.length == n</code></li><li><code>nums[i]</code> 是 正整数 ，其中 <code>0 &lt;= i &lt; n</code></li><li><code>abs(nums[i] - nums[i+1]) &lt;= 1</code> ，其中 <code>0 &lt;= i &lt; n-1</code></li><li><code>nums</code>中所有元素之和不超过 <code>maxSum</code></li><li><code>nums[index]</code> 的值被 最大化<br>返回你所构造的数组中的 <code>nums[index]</code> 。</li></ul><p>注意：<code>abs(x)</code> 等于 <code>x</code> 的前提是 <code>x &gt;= 0</code> ；否则，<code>abs(x)</code>等于 <code>-x</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, index = <span class="number">2</span>,  maxSum = <span class="number">6</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：数组 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 和 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, index = <span class="number">1</span>,  maxSum = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= maxSum &lt;= 109</code></li><li><code>0 &lt;= index &lt; n</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找+贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目写的太长，感觉写的太奇怪。首先我们可以按照题目要求，如果给定<code>index</code>处的值为<code>val</code>,则此时我们既可以构造出最小能够满足题意要求的序列可能为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,..,<span class="number">1</span>,<span class="number">2</span>,...,val<span class="number">-1</span>,val,val<span class="number">-1</span>,val<span class="number">-2</span>,...,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>即以<code>index</code>为中心，左右两边分别为差为为<code>1</code>的等差数列，我们可以很容易利用等差数列的求和公式求出左右两边的和，此时:<script type="math/tex; mode=display">minSum = calc(val,index) + val + calc(val,n-1-index)</script>函数$calc(val,index)$表示计算出的最大值为<code>val-1</code>且长度为<code>index</code>的数列的和。<br>如果此时计算的$minSum \le maxSum$我们则认为其符合条件。</li><li>二分查找即为非常简单的操作，时间复杂度为$O(lg(maxV))$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= val)&#123;</span><br><span class="line">            <span class="keyword">return</span> (val + val - n + <span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (val + <span class="number">1</span>)*val/<span class="number">2</span> + n - val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> maxSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> sum = mid + calc(mid<span class="number">-1</span>,index) + calc(mid<span class="number">-1</span>,n<span class="number">-1</span>-index);</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= maxSum)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5710-积压订单中的订单总数"><a href="#5710-积压订单中的订单总数" class="headerlink" title="5710. 积压订单中的订单总数"></a>5710. 积压订单中的订单总数</h2><p>给你一个二维整数数组 <code>orders</code> ，其中每个 <code>orders[i] = [pricei, amounti, orderTypei]</code>表示有 <code>amounti</code> 笔类型为 <code>orderTypei</code> 、价格为 <code>pricei</code> 的订单。</p><p>订单类型 <code>orderTypei</code> 可以分为两种：</p><ul><li><code>0</code> 表示这是一批采购订单 <code>buy</code></li><li><code>1</code> 表示这是一批销售订单 <code>sell</code><br>注意，<code>orders[i]</code>表示一批共计 <code>amounti</code> 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 <code>i</code>，由 <code>orders[i]</code>表示的所有订单提交时间均早于 <code>orders[i+1]</code>表示的所有订单。</li></ul><p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p><ul><li>如果该订单是一笔采购订单 <code>buy</code> ，则可以查看积压订单中价格 最低 的销售订单 <code>sell</code> 。如果该销售订单 <code>sell</code> 的价格 低于或等于 当前采购订单 <code>buy</code>的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 <code>buy</code> 将会添加到积压订单中。</li><li>反之亦然，如果该订单是一笔销售订单 <code>sell</code> ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单<code>buy</code>的价格 高于或等于 当前销售订单 <code>sell</code>的价格，则匹配并执行这两笔订单，并将采购订单<code>buy</code>从积压订单中删除。否则，销售订单 <code>sell</code> 将会添加到积压订单中。<br>输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 <code>109 + 7</code> 取余的结果。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">15</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">25</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">30</span>,<span class="number">4</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：输入订单后会发生下述情况：</span><br><span class="line">- 提交 <span class="number">5</span> 笔采购订单，价格为 <span class="number">10</span> 。没有销售订单，所以这 <span class="number">5</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">2</span> 笔销售订单，价格为 <span class="number">15</span> 。没有采购订单的价格大于或等于 <span class="number">15</span> ，所以这 <span class="number">2</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">1</span> 笔销售订单，价格为 <span class="number">25</span> 。没有采购订单的价格大于或等于 <span class="number">25</span> ，所以这 <span class="number">1</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">4</span> 笔采购订单，价格为 <span class="number">30</span> 。前 <span class="number">2</span> 笔采购订单与价格最低（价格为 <span class="number">15</span>）的 <span class="number">2</span> 笔销售订单匹配，从积压订单中删除这 <span class="number">2</span> 笔销售订单。第 <span class="number">3</span> 笔采购订单与价格最低的 <span class="number">1</span> 笔销售订单匹配，销售订单价格为 <span class="number">25</span> ，从积压订单中删除这 <span class="number">1</span> 笔销售订单。积压订单中不存在更多销售订单，所以第 <span class="number">4</span> 笔采购订单需要添加到积压订单中。</span><br><span class="line">最终，积压订单中有 <span class="number">5</span> 笔价格为 <span class="number">10</span> 的采购订单，和 <span class="number">1</span> 笔价格为 <span class="number">30</span> 的采购订单。所以积压订单中的订单总数为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="number">7</span>,<span class="number">1000000000</span>,<span class="number">1</span>],[<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">999999995</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">999999984</span></span><br><span class="line">解释：输入订单后会发生下述情况：</span><br><span class="line">- 提交 <span class="number">109</span> 笔销售订单，价格为 <span class="number">7</span> 。没有采购订单，所以这 <span class="number">109</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">3</span> 笔采购订单，价格为 <span class="number">15</span> 。这些采购订单与价格最低（价格为 <span class="number">7</span> ）的 <span class="number">3</span> 笔销售订单匹配，从积压订单中删除这 <span class="number">3</span> 笔销售订单。</span><br><span class="line">- 提交 <span class="number">999999995</span> 笔采购订单，价格为 <span class="number">5</span> 。销售订单的最低价为 <span class="number">7</span> ，所以这 <span class="number">999999995</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">1</span> 笔销售订单，价格为 <span class="number">5</span> 。这笔销售订单与价格最高（价格为 <span class="number">5</span> ）的 <span class="number">1</span> 笔采购订单匹配，从积压订单中删除这 <span class="number">1</span> 笔采购订单。</span><br><span class="line">最终，积压订单中有 (<span class="number">1000000000</span><span class="number">-3</span>) 笔价格为 <span class="number">7</span> 的销售订单，和 (<span class="number">999999995</span><span class="number">-1</span>) 笔价格为 <span class="number">5</span> 的采购订单。所以积压订单中的订单总数为 <span class="number">1999999991</span> ，等于 <span class="number">999999984</span> % (<span class="number">109</span> + <span class="number">7</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= orders.length &lt;= 105</li><li>orders[i].length == 3</li><li>1 &lt;= pricei, amounti &lt;= 109</li><li>orderTypei 为 0 或 1</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-orders-in-the-backlog</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目很简单，就是容易出错。题目太长了，感觉应该短点。</li><li>设置积压订单中的<code>buy</code>积压的订单，按照购买价格从高到低进行排列。设置积压订单中的<code>sell</code>积压的订单，按照出售价格从低到高排列。每次当前订单如果为<code>buy</code>定时，则从<code>sell</code>的积压队列中找到出售价格小于等于<code>buy</code>的价格，并同时将积压订单数量进行核减掉。每次当前订单如果为<code>sell</code>定单时，则从<code>buy</code>的积压队列中找到购买价格大于等于<code>sell</code>的价格，并同时将积压订单数量进行核减掉。</li><li>时间复杂度$O(nlgn)$,空间复杂度$O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a, pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp2</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a, pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfBacklogOrders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; orders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = orders.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp1&gt; sell;</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp2&gt; buy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : orders)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">2</span>] == <span class="number">0</span>)&#123;<span class="comment">//buy</span></span><br><span class="line">                <span class="keyword">if</span>(sell.empty())&#123;</span><br><span class="line">                    buy.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!sell.empty() &amp;&amp; sell.top().first &lt;= v[<span class="number">0</span>])&#123;</span><br><span class="line">                        pii curr = sell.top();</span><br><span class="line">                        sell.pop();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(curr.second &lt;= v[<span class="number">1</span>])&#123;</span><br><span class="line">                            v[<span class="number">1</span>] -= curr.second;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            curr.second -= v[<span class="number">1</span>];</span><br><span class="line">                            v[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                            sell.push(curr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(v[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        buy.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//sell</span></span><br><span class="line">                <span class="keyword">if</span>(buy.empty())&#123;</span><br><span class="line">                    sell.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!buy.empty() &amp;&amp; buy.top().first &gt;= v[<span class="number">0</span>])&#123;</span><br><span class="line">                        pii curr = buy.top();</span><br><span class="line">                        buy.pop();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(curr.second &lt;= v[<span class="number">1</span>])&#123;</span><br><span class="line">                            v[<span class="number">1</span>] -= curr.second;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            curr.second -= v[<span class="number">1</span>];</span><br><span class="line">                            v[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                            buy.push(curr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(v[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        sell.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!buy.empty())&#123;</span><br><span class="line">            ans = (ans + buy.top().second)%mod;</span><br><span class="line">            buy.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">while</span>(!sell.empty())&#123;</span><br><span class="line">            ans = (ans + sell.top().second)%mod;</span><br><span class="line">            sell.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5696-统计异或值在范围内的数对有多少"><a href="#5696-统计异或值在范围内的数对有多少" class="headerlink" title="5696. 统计异或值在范围内的数对有多少"></a>5696. 统计异或值在范围内的数对有多少</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> （下标 从 <code>0</code> 开始 计数）以及两个整数：<code>low</code> 和 <code>high</code>，请返回 漂亮数对 的数目。</p><p>漂亮数对 是一个形如 <code>(i, j)</code> 的数对，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code>且 <code>low &lt;= (nums[i] XOR nums[j]) &lt;= high</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>], low = <span class="number">2</span>, high = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：所有漂亮数对 (i, j) 列出如下：</span><br><span class="line">    - (<span class="number">0</span>, <span class="number">1</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">1</span>] = <span class="number">5</span> </span><br><span class="line">    - (<span class="number">0</span>, <span class="number">2</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">    - (<span class="number">0</span>, <span class="number">3</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">2</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">3</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    - (<span class="number">2</span>, <span class="number">3</span>): nums[<span class="number">2</span>] XOR nums[<span class="number">3</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>], low = <span class="number">5</span>, high = <span class="number">14</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：所有漂亮数对 (i, j) 列出如下：</span><br><span class="line">​​​​​    - (<span class="number">0</span>, <span class="number">2</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">2</span>] = <span class="number">13</span></span><br><span class="line">    - (<span class="number">0</span>, <span class="number">3</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">3</span>] = <span class="number">11</span></span><br><span class="line">    - (<span class="number">0</span>, <span class="number">4</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">2</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">2</span>] = <span class="number">12</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">3</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">3</span>] = <span class="number">10</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">4</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">    - (<span class="number">2</span>, <span class="number">3</span>): nums[<span class="number">2</span>] XOR nums[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    - (<span class="number">2</span>, <span class="number">4</span>): nums[<span class="number">2</span>] XOR nums[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">2</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">2</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= low &lt;= high &lt;= <span class="number">2</span> * <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-233/problems/count-pairs-with-xor-in-a-range/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt; 异或</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 核心问题记住异或的时候需要用到`trie`的结构，感觉类似的题目确实非常少碰到，所以不会做。与下列两个题目类似，又一次碰到类似的题目了，我还以为需要用到数位`dp`，实际不需要。</span><br><span class="line">+ [LC421](https:<span class="comment">//leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/) 数组中两个数的最大异或值。</span></span><br><span class="line">+ [LC1707](https:<span class="comment">//leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/) 与数组中元素的最大异或值。</span></span><br><span class="line"><span class="number">2.</span> 我们建立`trie`记录下第`i`为`<span class="number">0</span>`或者`<span class="number">1</span>`的数的个数，我们可以深刻的理解题意，如果满足异或的值小于某个数`key`的话，只需要某一位比`key`的值不同，且为`<span class="number">0</span>`即可。</span><br><span class="line"><span class="number">3.</span> 根据容斥定理，我们只需要找到当前小于`target`的数组元素的个数即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line">struct TrieNode&#123;</span><br><span class="line">    TrieNode *next[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">int</span> cnt;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next[<span class="number">0</span>] = NULL;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next[<span class="number">1</span>] = NULL;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> insertTrie(TrieNode * root,<span class="built_in">int</span> val)&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">int</span> x = (val&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;next[x])&#123;</span><br><span class="line">            node-&gt;next[x] = new TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next[x];</span><br><span class="line">        node-&gt;cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> search(TrieNode * root,<span class="built_in">int</span> num,<span class="built_in">int</span> low)&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">int</span> x = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> y = (low&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">1</span>)&#123; <span class="comment">//当前位不同，则我们找到当前位异或结果为`0`的数目统计。</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[x])&#123;</span><br><span class="line">                ans += node-&gt;next[x]-&gt;cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[<span class="number">1</span>-x];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//当前位相同，我们直接按照相同的位进行查找。</span></span><br><span class="line">            node = node-&gt;next[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> countPairs(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> low, <span class="built_in">int</span> high) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        TrieNode * root = new TrieNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            ans += search(root,nums[i],high+<span class="number">1</span>) - search(root,nums[i],low);</span><br><span class="line">            insertTrie(root,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-233&quot;&gt;&lt;a href=&quot;#leetcode-contest-233&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 233&quot;&gt;&lt;/a&gt;leetcode contest 233&lt;/h1&gt;&lt;p&gt;周赛还算三道题的节奏，最后一题太难了，不会做，没有想到会用&lt;code&gt;trie&lt;/code&gt;的解法，确实非常巧妙的解法。&lt;/p&gt;&lt;h2 id=&quot;5709-最大升序子数组和&quot;&gt;&lt;a href=&quot;#5709-最大升序子数组和&quot; class=&quot;headerlink&quot; title=&quot;5709. 最大升序子数组和&quot;&gt;&lt;/a&gt;5709. 最大升序子数组和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个正整数组成的数组 &lt;code&gt;nums&lt;/code&gt; ，返回 nums 中一个 升序 子数组的最大可能元素和。&lt;/p&gt;&lt;p&gt;子数组是数组中的一个连续数字序列。&lt;/p&gt;&lt;p&gt;已知子数组 &lt;code&gt;[numsl, numsl+1, ..., numsr-1, numsr]&lt;/code&gt;，若对所有 &lt;code&gt;i（l &amp;lt;= i &amp;lt; r）&lt;/code&gt;，&lt;code&gt;numsi &amp;lt; numsi+1&lt;/code&gt;都成立，则称这一子数组为 升序 子数组。注意，大小为 &lt;code&gt;1&lt;/code&gt; 的子数组也视作 升序 子数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 48</title>
    <link href="http://yoursite.com/2021/03/20/263/"/>
    <id>http://yoursite.com/2021/03/20/263/</id>
    <published>2021-03-20T14:27:10.130Z</published>
    <updated>2021-03-21T10:07:04.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-48"><a href="#leetcode-contest-48" class="headerlink" title="leetcode contest 48"></a>leetcode contest 48</h1><p><img src="https://i.loli.net/2021/03/21/mPKJugl2FU1aBon.png" alt><br>又是三道题的节奏，很多题目还是想不出来，只能说太菜了。最后一题简直是模板题目，状态压缩dp，一点意思也没有，竟然卡在第三题上。</p><h2 id="5693-字符串中第二大的数字"><a href="#5693-字符串中第二大的数字" class="headerlink" title="5693. 字符串中第二大的数字"></a>5693. 字符串中第二大的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。</p><a id="more"></a><p>混合字符串 由小写英文字母和数字组成。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"dfa12321afd"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：出现在 s 中的数字包括 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] 。第二大的数字是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc1111"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：出现在 s 中的数字只包含 [<span class="number">1</span>] 。没有第二大的数字。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母和（或）数字。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/second-largest-digit-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/second-largest-digit-in-a-string/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力统计<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                cnt.insert(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = cnt.end();</span><br><span class="line">        it--;</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">return</span> *it - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5694-设计一个验证系统"><a href="#5694-设计一个验证系统" class="headerlink" title="5694. 设计一个验证系统"></a>5694. 设计一个验证系统</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code>时刻之后 <code>timeToLive</code>秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code>（可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p><p>请你实现 <code>AuthenticationManager</code>类：</p><ul><li><code>AuthenticationManager(int timeToLive)</code>构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code>参数。</li><li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code>，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li><li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 未过期 的验证码在 <code>currentTime</code>时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li><li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，未过期 的验证码数目。<br>如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生<code>（renew</code>或者 <code>countUnexpiredTokens</code>操作），过期事件 优先于 其他操作。</li></ul><p>示例 1：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"AuthenticationManager"</span>, <span class="string">"renew"</span>, <span class="string">"generate"</span>, <span class="string">"countUnexpiredTokens"</span>, <span class="string">"generate"</span>, <span class="string">"renew"</span>, <span class="string">"renew"</span>, <span class="string">"countUnexpiredTokens"</span>]</span><br><span class="line">[[<span class="number">5</span>], [<span class="string">"aaa"</span>, <span class="number">1</span>], [<span class="string">"aaa"</span>, <span class="number">2</span>], [<span class="number">6</span>], [<span class="string">"bbb"</span>, <span class="number">7</span>], [<span class="string">"aaa"</span>, <span class="number">8</span>], [<span class="string">"bbb"</span>, <span class="number">10</span>], [<span class="number">15</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">1</span>, null, null, null, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">AuthenticationManager authenticationManager = new AuthenticationManager(<span class="number">5</span>); <span class="comment">// 构造 AuthenticationManager ，设置 timeToLive = 5 秒。</span></span><br><span class="line">authenticationManager.renew(<span class="string">"aaa"</span>, <span class="number">1</span>); <span class="comment">// 时刻 1 时，没有验证码的 tokenId 为 "aaa" ，没有验证码被更新。</span></span><br><span class="line">authenticationManager.generate(<span class="string">"aaa"</span>, <span class="number">2</span>); <span class="comment">// 时刻 2 时，生成一个 tokenId 为 "aaa" 的新验证码。</span></span><br><span class="line">authenticationManager.countUnexpiredTokens(<span class="number">6</span>); <span class="comment">// 时刻 6 时，只有 tokenId 为 "aaa" 的验证码未过期，所以返回 1 。</span></span><br><span class="line">authenticationManager.generate(<span class="string">"bbb"</span>, <span class="number">7</span>); <span class="comment">// 时刻 7 时，生成一个 tokenId 为 "bbb" 的新验证码。</span></span><br><span class="line">authenticationManager.renew(<span class="string">"aaa"</span>, <span class="number">8</span>); <span class="comment">// tokenId 为 "aaa" 的验证码在时刻 7 过期，且 8 &gt;= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。</span></span><br><span class="line">authenticationManager.renew(<span class="string">"bbb"</span>, <span class="number">10</span>); <span class="comment">// tokenId 为 "bbb" 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。</span></span><br><span class="line">authenticationManager.countUnexpiredTokens(<span class="number">15</span>); <span class="comment">// tokenId 为 "bbb" 的验证码在时刻 15 过期，tokenId 为 "aaa" 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= timeToLive &lt;= 108</code></li><li><code>1 &lt;= currentTime &lt;= 108</code></li><li><code>1 &lt;= tokenId.length &lt;= 5</code></li><li><code>tokenId</code> 只包含小写英文字母。</li><li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li><li>所有函数调用中，<code>currentTime</code>的值 严格递增 。</li><li>所有函数的调用次数总共不超过 2000 次。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/design-authentication-manager/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/design-authentication-manager/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力统计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的非常不好，给定的数据量又很小，全部用暴力都可以实现。</li><li>每次<code>generate</code>时记录下生成<code>token</code>的时间，<code>renew</code>时检查是否超时，如果超时则删除，<code>countUnexpiredTokens</code>则直接暴力查找统计，感觉就是送分题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManager</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AuthenticationManager(<span class="keyword">int</span> timeToLive) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;live = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="built_in">string</span> tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        token[tokenId] = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renew</span><span class="params">(<span class="built_in">string</span> tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!token.count(tokenId)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>((currentTime - token[tokenId])&gt;= live)&#123;</span><br><span class="line">            token.erase(tokenId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        token[tokenId] = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countUnexpiredTokens</span><span class="params">(<span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = token.begin(); it != token.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentTime - it-&gt;second &lt; live)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; token;</span><br><span class="line">    <span class="keyword">int</span> live;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5712-你能构造出连续值的最大数目"><a href="#5712-你能构造出连续值的最大数目" class="headerlink" title="5712. 你能构造出连续值的最大数目"></a>5712. 你能构造出连续值的最大数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3>给你一个长度为<code>n</code>的整数数组 <code>coins</code> ，它代表你拥有的 n 个硬币。第 <code>i</code>个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为<code>x</code>，那么称，你可以 构造 出<code>x</code> 。</li></ol></blockquote><p>请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">2</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">- <span class="number">2</span>：取 [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">3</span>：取 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">4</span>：取 [<span class="number">4</span>]</span><br><span class="line">- <span class="number">5</span>：取 [<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">6</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">7</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">8</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>coins.length == n</code></li><li><code>1 &lt;= n &lt;= 4 * 104</code></li><li><code>1 &lt;= coins[i] &lt;= 4 * 104</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>假设数组中的部分元素能否构成$[0,x]$中的所有整数，此时我们再加入整数$y$,则此时我们知道肯定可以构成的整数范围为$[y,y+x]$,假设满足$y \le x+1$,则我们可以将$[0,x]$与$[y,y+x]$进行合并跟新为新的连续区间为$[0,y+x]$,此时我们即扩大了连续整数的范围。否则如果$y &gt; x+1$则不会对最终的结果产生任何影响。</li><li>我们首先将数组按照升序进行排列，我们每次选取最小的<code>nums[i]</code>看是否能增加当前的选择范围，如果可以增加，则我们将对数据的范围进行扩展长度为$nums[i]$。</li><li>非常喜欢这类思考性质的数学题目，虽然比较难，但是思考的深度非常不错。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(coins.begin(),coins.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coins[i] &lt;= ans + <span class="number">1</span>)&#123;</span><br><span class="line">                ans += coins[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5712-你能构造出连续值的最大数目-1"><a href="#5712-你能构造出连续值的最大数目-1" class="headerlink" title="5712. 你能构造出连续值的最大数目"></a>5712. 你能构造出连续值的最大数目</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>coins</code> ，它代表你拥有的<code>n</code>个硬币。第 <code>i</code>个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。</p><p>请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">2</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">- <span class="number">2</span>：取 [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">3</span>：取 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">4</span>：取 [<span class="number">4</span>]</span><br><span class="line">- <span class="number">5</span>：取 [<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">6</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">7</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">8</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>coins.length == n</code></li><li><code>1 &lt;= n &lt;= 4 * 104</code></li><li><code>1 &lt;= coins[i] &lt;= 4 * 104</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>标准的模板题，状态压缩<code>dp</code>加上子空间遍历。</li><li>设<code>dp[state]</code>表示当前已经选择的元素的掩码为<code>state</code>时，所能获取到的最大分数。首先我们需要确定的是<code>state</code>中一定包含偶数个元素，我们设然<code>state</code>包含的元素个数为<code>x</code>，我们遍历<code>state</code>的状态子空间<code>prevstate</code>，当且仅当<code>prevstate</code>包含<code>x-2</code>个元素时，此时我们就可以得到<code>dp</code>的递推公式:<script type="math/tex; mode=display">dp[state] = max(dp[state],dp[prevstate] + \frac{x}{2}*dp[prevstate\bigoplus state])</script></li><li>非常典型的状态压缩和子空间遍历。稍微用点技巧的时可以用快速的<code>n&amp;(n-1)</code>的方法来得到数中<code>1</code>的个数。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp[(<span class="number">1</span>&lt;&lt;i)|(<span class="number">1</span>&lt;&lt;j)] = __gcd(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count(i)%<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">0</span>; j = (j<span class="number">-1</span>)&amp;i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count(i) - count(j) == <span class="number">2</span>)&#123;</span><br><span class="line">                    dp[i] = max(dp[i],dp[j] + (count(i)/<span class="number">2</span>)*dp[i^j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>贪心算法：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                arr.push_back(Node(i,j,__gcd(nums[i],nums[j])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](Node &amp; a,Node &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.v &gt; b.v;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[arr[i].x] == <span class="literal">false</span> &amp;&amp; visit[arr[i].y] == <span class="literal">false</span>)&#123;</span><br><span class="line">                res.push_back(arr[i].v);</span><br><span class="line">                visit[arr[i].x] = <span class="literal">true</span>;</span><br><span class="line">                visit[arr[i].y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); ++i)&#123;</span><br><span class="line">            ans += (i+<span class="number">1</span>)*res[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-48&quot;&gt;&lt;a href=&quot;#leetcode-contest-48&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 48&quot;&gt;&lt;/a&gt;leetcode contest 48&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/21/mPKJugl2FU1aBon.png&quot; alt&gt;&lt;br&gt;又是三道题的节奏，很多题目还是想不出来，只能说太菜了。最后一题简直是模板题目，状态压缩dp，一点意思也没有，竟然卡在第三题上。&lt;/p&gt;&lt;h2 id=&quot;5693-字符串中第二大的数字&quot;&gt;&lt;a href=&quot;#5693-字符串中第二大的数字&quot; class=&quot;headerlink&quot; title=&quot;5693. 字符串中第二大的数字&quot;&gt;&lt;/a&gt;5693. 字符串中第二大的数字&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT】 2021 MIT6.824 Lab1</title>
    <link href="http://yoursite.com/2021/03/16/262/"/>
    <id>http://yoursite.com/2021/03/16/262/</id>
    <published>2021-03-16T01:51:21.636Z</published>
    <updated>2021-03-16T03:39:10.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MIT6-824-2021-lab1"><a href="#MIT6-824-2021-lab1" class="headerlink" title="MIT6.824 2021 lab1"></a>MIT6.824 2021 lab1</h1><p>终于在跌跌撞撞中完成了<code>MIT lab1 map-reduce</code>的<code>lab</code>，仔细对比了一下，<code>2021</code>年的<code>lab</code>要比之前的<code>lab</code>要复杂一些，以前的<code>map-reduce lab</code>基本上只是<code>Coordinator</code>对任务进行主动调度，<code>2021</code>的<code>lab</code>会涉及到<code>Coordinator</code>被动接受<code>worker</code>的任务请求，然后进行被动的调度，同时加入了防止任务意外中止的校验，使得系统更加完善和健壮。所有的测试结果如下所示：<br><img src="https://i.loli.net/2021/03/16/2TsRwIzVidc8apv.png" alt><br>所有的代码都放在github上.</p><a id="more"></a><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>按照题目要求实现<code>map-reduce</code>系统，按照<code>lab</code>的要求实现调度器<code>Coordinator</code>和<code>worker</code>的基本功能，<code>lab</code>要求由<code>woker</code>主动向调度器发起任务请求，<code>Coordinator</code>按照当前的任务分配进度为每个<code>worker</code>分配<code>map</code>或者<code>reduce</code>任务，<code>reduce</code>任务必须在所有的<code>map</code>任务都完成后才能开始启动。其中的核心的难点并不是在于<code>map</code>和<code>reduce</code>的实现，难点在于如何做好<code>worker</code>和<code>Coordinator</code>之间的任务分配和调度。</p><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><ul><li><code>Coordinator</code>作为一个<code>rpc server</code>,处理所有从<code>worker</code>发送过来的<code>rpc</code>请求，当然在此也顺便学习了一下<code>go</code>的<code>rpc</code>框架，其实还是挺有意思的，非常方便的消息处理框架，首先我们需要设置好双方进行消息交互的<code>rpc</code>消息格式定义，目前定义如下：<br><code>option</code>请求定义:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OpType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">TaskReq OpType = <span class="literal">iota</span> <span class="comment">//请求分配任务</span></span><br><span class="line">TaskMap               <span class="comment">//分配一个map类型的任务</span></span><br><span class="line">TaskReduce            <span class="comment">//分配一个reduce类型的任务</span></span><br><span class="line">TaskMapDone           <span class="comment">//完成一个map任务</span></span><br><span class="line">TaskReduceDone        <span class="comment">//完成一个reduce任务</span></span><br><span class="line">TaskDone              <span class="comment">//所有任务均已完成</span></span><br><span class="line">TaskWait              <span class="comment">//等待当前任务完成</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><code>rpc</code>请求消息定义:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReqArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">ReqId <span class="keyword">int64</span>    <span class="comment">// timestamp，作为本次请求分配的唯一标识。</span></span><br><span class="line">ReqOp OpType   <span class="comment">// 消息类型</span></span><br><span class="line">ReqTaskId <span class="keyword">int</span>  <span class="comment">// 任务的ID编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>rpc</code>回应消息定义：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplyArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">RepId <span class="keyword">int64</span>   <span class="comment">// timestamp，作为某次请求的唯一标识。</span></span><br><span class="line">RepOp OpType  <span class="comment">//消息类型</span></span><br><span class="line">RepTaskId <span class="keyword">int</span> <span class="comment">//分配的任务ID</span></span><br><span class="line">RepnMap <span class="keyword">int</span>   <span class="comment">//map任务的总数</span></span><br><span class="line">RepnReduce <span class="keyword">int</span> <span class="comment">//reduce任务的总数</span></span><br><span class="line">RepContent <span class="keyword">string</span> <span class="comment">//map任务的文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>Coordinator</code>定义：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">mapTasks <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//待分配的map任务列表</span></span><br><span class="line">reduceTasks <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//待分配的reduce任务列表</span></span><br><span class="line">nReduce <span class="keyword">int</span> <span class="comment">//reduce任务的数量</span></span><br><span class="line">nMap <span class="keyword">int</span>    <span class="comment">//map的任务数量</span></span><br><span class="line">mapRuning []<span class="keyword">int64</span> <span class="comment">//map任务状态</span></span><br><span class="line">reduceRuning []<span class="keyword">int64</span> <span class="comment">//reduce任务状态</span></span><br><span class="line">tasks []<span class="keyword">string</span> <span class="comment">//待处理的文件名称</span></span><br><span class="line">mapCnt <span class="keyword">int</span>   <span class="comment">//当前未完成的map数量</span></span><br><span class="line">reduceCnt <span class="keyword">int</span> <span class="comment">//当前未完成的reduce任务数量</span></span><br><span class="line">taskDone <span class="keyword">bool</span>  <span class="comment">//任务是否全部完成</span></span><br><span class="line">lock *sync.Cond  <span class="comment">//互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Coordinator</code>接受到<code>worker</code>的请求后，根据请求的消息类型进行回应，如果当前的任务已经完成，则直接回应；如果请求的消息为任务请求，则查看是否存在待处理的<code>map</code>任务，如果存在则分发一个<code>map</code>类型的任务，如果<code>map</code>任务都已经下发但是还未全部完成，则通知<code>worker</code>进行等待；如果所有的<code>map</code>任务都已经下发且已经完成，则分配一个<code>reduce</code>类型的任务交给<code>worker</code>进行处理；如果接受的消息为<code>worker</code>通知任务完成，我们会校验该任务的标识，如果校验通过，我们将相应的任务状态设置为已经完成。</li><li>最关键的一点处理，每当<code>Coordinator</code>分配一个任务后，就会启动一个定时器任务，该定时器任务会在<code>10s</code>后检查该任务的状态是否已经完成，如果未完成，则将该任务再次进入到待分配列表中。</li><li>关键的临界区处理，这点我处理的不太好，为了图简单，直接在所有的存在竞争的数据访问处都用的互斥锁锁，其实也可以试试用<code>go</code>的<code>atmoic</code>来定义某些关键数据类型，后面如果需要改进的话重点放在临界区访问的控制上。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">c.lock.L.Lock()</span><br><span class="line">allDone := c.taskDone </span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">if</span> allDone &#123; <span class="comment">//检验当前所有任务的状态，如果已经全部完成则直接返回</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskDone</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> args.ReqOp&#123;</span><br><span class="line"><span class="keyword">case</span> TaskReq: <span class="comment">//任务请求</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.mapTasks) &gt; <span class="number">0</span> &#123; <span class="comment">//如果存在待分配的map任务，则分配一个任务给当前的worker</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskMap</span><br><span class="line">reply.RepTaskId = &lt;-c.mapTasks</span><br><span class="line">reply.RepnMap = c.nMap</span><br><span class="line">reply.RepContent = c.tasks[reply.RepTaskId]</span><br><span class="line">reply.RepnReduce = c.nReduce</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line">c.mapRuning[reply.RepTaskId] = args.ReqId <span class="comment">//记录当前任务请求的标识</span></span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="keyword">int</span>)</span></span>&#123; <span class="comment">// 10s后检查该任务是否完成，如果未完成则将该任务再次进入待分配列表</span></span><br><span class="line">time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.mapRuning[taskId] != <span class="number">1</span>&#123;</span><br><span class="line">c.mapTasks&lt;-taskId</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c.mapCnt--</span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line">&#125;(reply.RepTaskId)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(c.mapTasks) == <span class="number">0</span> &#123;</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line">mapCurr := c.mapCnt</span><br><span class="line">reduceCurr := c.reduceCnt</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  mapCurr &gt; <span class="number">0</span> &#123; <span class="comment">// map任务全部分配，但是并未全部完成，此时需要通知worker进行等待</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskWait</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.reduceTasks) &gt; <span class="number">0</span> &#123;<span class="comment">// 如果存在待分配的reduce任务，则分配一个任务给当前的worker</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskReduce</span><br><span class="line">reply.RepTaskId = &lt;-c.reduceTasks</span><br><span class="line">reply.RepnMap = c.nMap</span><br><span class="line">reply.RepnReduce = c.nReduce</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line">c.reduceRuning[reply.RepTaskId] = args.ReqId</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">time.Sleep(<span class="number">10</span>*time.Second) <span class="comment">//  10s后检查该任务是否完成，如果未完成则将该任务再次进入待分配列表</span></span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.reduceRuning[taskId] != <span class="number">1</span>&#123;</span><br><span class="line">c.reduceTasks&lt;-taskId</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c.reduceCnt--</span><br><span class="line"><span class="keyword">if</span> c.reduceCnt == <span class="number">0</span>&#123;</span><br><span class="line">c.taskDone = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line">&#125;(reply.RepTaskId)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> reduceCurr &gt; <span class="number">0</span> &#123; <span class="comment">// reduce任务全部分配，但是并未全部完成，此时需要通知worker进行等待</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskWait</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> TaskMapDone: <span class="comment">// map任务完成，将该任务的状态置为完成</span></span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.mapRuning[args.ReqTaskId] == args.ReqId &#123;</span><br><span class="line">c.mapRuning[args.ReqTaskId] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">case</span> TaskReduceDone: <span class="comment">// reduce任务完成，将该任务的状态置为完成</span></span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.reduceRuning[args.ReqTaskId] == args.ReqId&#123;</span><br><span class="line">c.reduceRuning[args.ReqTaskId] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><code>worker</code>的处理就简单许多，主要是<code>map</code>处理和<code>reduce</code>处理，这个基本上可以参考<code>lab</code>给定的<code>mrsequential</code>代码即可，此时我们主要对<code>map</code>进行处理产生中间文件交给<code>reduce</code>处理即可。</li><li><code>map</code>:从文件种读取所有的<code>key-value</code>数据，然后根据<code>hash</code>值写入不同的文件即可，当然这里的优化完全可以按照hash值进行排序，这样可以一次性将hash值相同的元素写入同一个文件，避免每次写入时写入不同的文件，从而可以加快处理速度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// process a map task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startMapTask</span><span class="params">(timestamp <span class="keyword">int64</span>,reply * ReplyArgs,mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">ifile, err := os.Open(reply.RepContent)</span><br><span class="line"><span class="keyword">defer</span> ifile.Close()</span><br><span class="line"><span class="comment">// read content from the file</span></span><br><span class="line">content, err := ioutil.ReadAll(ifile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"can not read %v"</span>, reply.RepContent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intermediate := mapf(reply.RepContent, <span class="keyword">string</span>(content)) <span class="comment">// map任务处理</span></span><br><span class="line">ofile := <span class="built_in">make</span>([]*os.File,reply.RepnReduce)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.RepnReduce; i++ &#123;</span><br><span class="line">ofname := <span class="string">"mr-"</span> + strconv.Itoa(reply.RepTaskId) + <span class="string">"-"</span> + strconv.Itoa(i)</span><br><span class="line">ofile[i], _ = os.Create(ofname)</span><br><span class="line"><span class="keyword">defer</span> ofile[i].Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,kv := <span class="keyword">range</span> intermediate&#123; <span class="comment">// 根据key的hash值写入相应的中间文件</span></span><br><span class="line">reduceId := ihash(kv.Key)%reply.RepnReduce</span><br><span class="line">enc := json.NewEncoder(ofile[reduceId])</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span>(err != <span class="literal">nil</span>)&#123;</span><br><span class="line">log.Fatalf(<span class="string">"can not read %v"</span>, ofile[reduceId])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//notice the server task finished</span></span><br><span class="line">args := ReqArgs&#123;&#125; <span class="comment">// 向Coordinator回应本次任务处理完成</span></span><br><span class="line">args.ReqId = timestamp</span><br><span class="line">args.ReqOp = TaskMapDone</span><br><span class="line">args.ReqTaskId = reply.RepTaskId</span><br><span class="line">nextreply := ReplyArgs&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> call(<span class="string">"Coordinator.Request"</span>, &amp;args, &amp;nextreply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>reduce</code>:从文件种读取所有的<code>key hash</code>值相同的数据，然后根据<code>key</code>进行排序，将相同的<code>key</code>的元素进行<code>reduce</code>处理，处理完成后结果写入到目标文件种，全部完成后通知<code>Coordinator</code>本次任务完成。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/ process a reduce task</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startReduceTask</span><span class="params">(timestamp <span class="keyword">int64</span>,reply * ReplyArgs,reducef <span class="keyword">func</span>(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// we check every intermediate map task file</span></span><br><span class="line">kva := []KeyValue&#123;&#125; </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.RepnMap; i++ &#123; <span class="comment">//读取所有的中间文件</span></span><br><span class="line">ifilename := <span class="string">"mr-"</span> + strconv.Itoa(i) + <span class="string">"-"</span> + strconv.Itoa(reply.RepTaskId)</span><br><span class="line">ifile, err := os.Open(ifilename)</span><br><span class="line"><span class="keyword">defer</span> ifile.Close()</span><br><span class="line"><span class="comment">// open file error</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">"Open File Error."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read all intermediate data from the file</span></span><br><span class="line">dec := json.NewDecoder(ifile)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; </span><br><span class="line">kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//store intermediate data to the out file</span></span><br><span class="line">sort.Sort(ByKey(kva)) <span class="comment">//排序</span></span><br><span class="line"><span class="comment">// write to the target file</span></span><br><span class="line">ofilename := <span class="string">"mr-out-"</span> + strconv.Itoa(reply.RepTaskId)</span><br><span class="line"><span class="comment">//fmt.Println("out file %v",ofilename)</span></span><br><span class="line">ofile,err := os.Create(ofilename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">"Creat Open File Error."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ofile.Close()</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(kva) &#123; <span class="comment">//按照相同的key进行分配，并进行reduce处理</span></span><br><span class="line">j := i + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="built_in">len</span>(kva) &amp;&amp; kva[j].Key == kva[i].Key &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">values := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">values = <span class="built_in">append</span>(values, kva[k].Value)</span><br><span class="line">&#125;</span><br><span class="line">output := reducef(kva[i].Key, values)</span><br><span class="line"><span class="comment">// this is the correct format for each line of Reduce output.</span></span><br><span class="line">fmt.Fprintf(ofile, <span class="string">"%v %v\n"</span>, kva[i].Key, output)</span><br><span class="line">i = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//notice the server task finished</span></span><br><span class="line">args := ReqArgs&#123;&#125; <span class="comment">// 向Coordinator回应本次任务处理完成</span></span><br><span class="line">args.ReqId = timestamp</span><br><span class="line">args.ReqOp = TaskReduceDone</span><br><span class="line">args.ReqTaskId = reply.RepTaskId</span><br><span class="line">nextreply := ReplyArgs&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> call(<span class="string">"Coordinator.Request"</span>, &amp;args, &amp;nextreply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h3>根据<code>paper</code>中的描述如下：<br><img src="https://i.loli.net/2021/03/16/GQntKroZga4NE6j.png" alt></li></ul><ol><li>假设有 <code>M</code> 个 <code>map</code>   操作， <code>n</code> 个 <code>reduce</code>  操作， 那么<code>master</code>一共要安排<code>M +N</code> 个<code>worker</code>任务 。</li><li>每个 <code>map</code> 操作将生成  <code>n</code>个文件，<code>map</code>过程一共产生  <code>m*n</code> 个文件.</li><li><code>map</code> 操作完成后的数据是以文件的形式存储的.<br>实际处理过程：首先将 文档分成  <code>m</code>份，每一份调用一个 <code>map</code> 函数操作并生成 <code>n</code>个文件  。所有 <code>map</code>操作完成后进行 <code>reduce</code>操作，对于 每个 <code>reduce</code> 操作，从上一步生成 的<code>m*n</code> 个文件中选取对应的<code>m</code>个文件 进行<code>reduce</code> 操作，完成后将结果写入$n_{i}$ 中。 所有 <code>reduce</code> 操作完成后将 <code>n</code>个临时文件合并成最终的 <code>output</code> 文件<br><img src="https://i.loli.net/2021/03/16/W2GvcPOLAkXbtMH.png" alt><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MIT6-824-2021-lab1&quot;&gt;&lt;a href=&quot;#MIT6-824-2021-lab1&quot; class=&quot;headerlink&quot; title=&quot;MIT6.824 2021 lab1&quot;&gt;&lt;/a&gt;MIT6.824 2021 lab1&lt;/h1&gt;&lt;p&gt;终于在跌跌撞撞中完成了&lt;code&gt;MIT lab1 map-reduce&lt;/code&gt;的&lt;code&gt;lab&lt;/code&gt;，仔细对比了一下，&lt;code&gt;2021&lt;/code&gt;年的&lt;code&gt;lab&lt;/code&gt;要比之前的&lt;code&gt;lab&lt;/code&gt;要复杂一些，以前的&lt;code&gt;map-reduce lab&lt;/code&gt;基本上只是&lt;code&gt;Coordinator&lt;/code&gt;对任务进行主动调度，&lt;code&gt;2021&lt;/code&gt;的&lt;code&gt;lab&lt;/code&gt;会涉及到&lt;code&gt;Coordinator&lt;/code&gt;被动接受&lt;code&gt;worker&lt;/code&gt;的任务请求，然后进行被动的调度，同时加入了防止任务意外中止的校验，使得系统更加完善和健壮。所有的测试结果如下所示：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/03/16/2TsRwIzVidc8apv.png&quot; alt&gt;&lt;br&gt;所有的代码都放在github上.&lt;/p&gt;
    
    </summary>
    
    
      <category term="公开课" scheme="http://yoursite.com/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
      <category term="MIT" scheme="http://yoursite.com/tags/MIT/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 232</title>
    <link href="http://yoursite.com/2021/03/14/261/"/>
    <id>http://yoursite.com/2021/03/14/261/</id>
    <published>2021-03-14T08:17:04.714Z</published>
    <updated>2021-03-14T09:18:34.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-232"><a href="#leetcode-contest-232" class="headerlink" title="leetcode contest 232"></a>leetcode contest 232</h1><p>本周的周赛题目还是质量非常高的，最后两道题目的解法还是非常有意思的题目，虽然解法很简单，但是非常值得深入思考的题目，特别是第三题，给人印象深刻。</p><h2 id="5701-仅执行一次字符串交换能否使两个字符串相等"><a href="#5701-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="5701. 仅执行一次字符串交换能否使两个字符串相等"></a>5701. 仅执行一次字符串交换能否使两个字符串相等</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。</p><a id="more"></a><p>如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"bank"</span>, <span class="built_in">s2</span> = <span class="string">"kanb"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：例如，交换 <span class="built_in">s2</span> 中的第一个和最后一个字符可以得到 <span class="string">"bank"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"attack"</span>, <span class="attr">s2</span> = <span class="string">"defend"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：一次字符串交换无法使两个字符串相等</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"kelb"</span>, <span class="attr">s2</span> = <span class="string">"kelb"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：两个字符串已经相等，所以不需要进行字符串交换</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"abcd"</span>, <span class="attr">s2</span> = <span class="string">"dcba"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= s1.length, s2.length &lt;= 100</li><li>s1.length == s2.length</li><li>s1 和 s2 仅由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>如果仅要求交换一次就可完成两个字符串的相等排列，我们即判断字符串是否只有两个字符不同，然后判断是否相等。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areAlmostEqual</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[i])&#123;</span><br><span class="line">                diff.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(diff.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(diff.size() != <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1[diff[<span class="number">0</span>]] == s2[diff[<span class="number">1</span>]] &amp;&amp; s1[diff[<span class="number">1</span>]] == s2[diff[<span class="number">0</span>]])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5702-找出星型图的中心节点"><a href="#5702-找出星型图的中心节点" class="headerlink" title="5702. 找出星型图的中心节点"></a>5702. 找出星型图的中心节点</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有一个无向的 星型 图，由 <code>n</code>个编号从 <code>1</code>到 <code>n</code>的节点组成。星型图有一个 中心 节点，并且恰有 <code>n - 1</code>条边将中心节点与其他每个节点连接起来。</p><p>给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示在节点 <code>ui</code> 和 <code>vi</code> 之间存在一条边。请你找出并返回 <code>edges</code> 所表示星型图的中心节点。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如上图所示，节点 <span class="number">2</span> 与其他每个节点都相连，所以节点 <span class="number">2</span> 是中心节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>3 &lt;= n &lt;= 105</li><li>edges.length == n - 1</li><li>edges[i].length == 2</li><li>1 &lt;= ui, vi &lt;= n</li><li>ui != vi</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-center-of-star-graph" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-center-of-star-graph</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 图论</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>此题非常简单，我们只需要判断是否存在度为<code>n-1</code>的顶点即可，非常简单的实现即可，简单的有点离谱。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCenter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            degree[v[<span class="number">0</span>]<span class="number">-1</span>]++;</span><br><span class="line">            degree[v[<span class="number">1</span>]<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i] == n<span class="number">-1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5703-最大平均通过率"><a href="#5703-最大平均通过率" class="headerlink" title="5703. 最大平均通过率"></a>5703. 最大平均通过率</h2><p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 <code>classes</code> ，其中 <code>classes[i] = [passi, totali]</code> ，表示你提前知道了第 <code>i</code> 个班级总共有 <code>totali</code>个学生，其中只有 <code>passi</code>个学生可以通过考试。</p><p>给你一个整数 <code>extraStudents</code> ，表示额外有 <code>extraStudents</code>个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 <code>extraStudents</code>个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。</p><p>一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。</p><p>请你返回在安排这 <code>extraStudents</code>个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 <code>10-5</code>以内的结果都会视为正确结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：classes = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>]], extraStudents = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0.78333</span></span><br><span class="line">解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (<span class="number">3</span>/<span class="number">4</span> + <span class="number">3</span>/<span class="number">5</span> + <span class="number">2</span>/<span class="number">2</span>) / <span class="number">3</span> = <span class="number">0.78333</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：classes = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">9</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">10</span>]], extraStudents = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0.53485</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= classes.length &lt;= 105</code></li><li><code>classes[i].length == 2</code></li><li><code>1 &lt;= passi &lt;= totali &lt;= 105</code></li><li><code>1 &lt;= extraStudents &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-average-pass-ratio</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始这个题目，自己想的太复杂了，后来相明白了，就是非常简单的贪心算法。</li><li>我们设总通过班级通过率之和为$tot$,如果我们想增加最大平均通过率，本质就是如何使得总的班级通过率之和最大。此时我们就需要思考如何分配增加人数，我们根据贪心策略则优先将通过的学生分配给增加的通过率最大的班级即可，这样即保证最终得到的通过率之和最大。</li><li>我们可以通过数学计算得出每增加一个学生，该班级的通过率增加的多少，我们设该班级原有的总人数为$n$,通过考试的人数为$m$,如果增加$1$人后，则增加的通过率为：<script type="math/tex; mode=display">\frac{m+1}{n+1} - \frac{m}{n}</script>我们按照贪心策略，每次为增加的通过率最大的班级分配一个学生即可,我们用优先级队列，每次弹出最优策略的班级，然后给其增加$1$个学生，然后再将其放入队列。时间复杂度为$O(mlgn)$,其中$m$为增加的学生人数，$n$为班级的数目。空间复杂度为$O(n)$.</li><li>我们同时也可以得到策略可以知道，不断给某个班级增加人数，那么它增加的通过率实际上是递减的。<script type="math/tex; mode=display">\frac{m+1}{n+1} - \frac{m}{n} > \frac{m+2}{n+2} - \frac{m+1}{n+1}</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">double</span> p;</span><br><span class="line">    Node(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">double</span> p)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Node &amp; a,Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.p &lt; b.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = classes.size();</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">auto</span> diff = [&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>(x+<span class="number">1</span>)/(y+<span class="number">1</span>) - <span class="keyword">double</span>(x)/y;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : classes)&#123;</span><br><span class="line">            pq.push(Node(v[<span class="number">0</span>],v[<span class="number">1</span>],diff(v[<span class="number">0</span>],v[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; extraStudents; ++i)&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            curr.m++;</span><br><span class="line">            curr.n++;</span><br><span class="line">            curr.p = diff(curr.m,curr.n);</span><br><span class="line">            pq.push(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> tot = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            tot += <span class="keyword">double</span>(curr.m)/curr.n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tot/n;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;tuple&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> diff = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(x + <span class="number">1</span>) / (y + <span class="number">1</span>) - (<span class="keyword">double</span>)x / y;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: classes) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[<span class="number">0</span>], y = c[<span class="number">1</span>];</span><br><span class="line">            ans += (<span class="keyword">double</span>)x / y;</span><br><span class="line">            q.emplace(diff(x, y), x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> _ = <span class="number">0</span>; _ &lt; extraStudents; ++_) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [d, x, y] = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans += d;</span><br><span class="line">            q.emplace(diff(x + <span class="number">1</span>, y + <span class="number">1</span>), x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / classes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5704-好子数组的最大分数"><a href="#5704-好子数组的最大分数" class="headerlink" title="5704. 好子数组的最大分数"></a>5704. 好子数组的最大分数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> （下标从 0 开始）和一个整数 <code>k</code>。<br>一个子数组 <code>(i, j)</code> 的 分数 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code>。一个 好 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。<br>请你返回 好 子数组的最大可能 分数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：最优子数组的左右端点下标是 (<span class="number">1</span>, <span class="number">5</span>) ，分数为 min(<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>) * (<span class="number">5</span><span class="number">-1</span>+<span class="number">1</span>) = <span class="number">3</span> * <span class="number">5</span> = <span class="number">15</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：最优子数组的左右端点下标是 (<span class="number">0</span>, <span class="number">4</span>) ，分数为 min(<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>) * (<span class="number">4</span><span class="number">-0</span>+<span class="number">1</span>) = <span class="number">4</span> * <span class="number">5</span> = <span class="number">20</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 104</code></li><li><code>0 &lt;= k &lt; nums.length</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>双指针或者二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目还是非常不错的，但是总体来说本题比起之前的题目都偏简单。</li><li>我们可以求出有的以索引$k$为结尾的连续子字符串的最小数的前缀$left$，我们同时也可以求出所有以索引$k$为结尾的连续子字符串的最小数的后缀$right$。我们设$left[i]$表示子数组$[i,k]$的最小值，$right[j]$表示子数组$[k,j]$的最小值,我们可以很明显的看出$left$数组为递减，而$right$数组为递减.</li><li>我们可以固定目标子数组的起始索引为$i$,子数组的结束索引为$k$,满足$0 \le i \le k$，此时很容易求出数组索引$[i,k]$之间的最小元素为$left[i]$,而此时我们则去查找满足以$k$为起始索引的连续子数组，且子数组的最小值大于等于$left[i]$的最大长度,我们依次遍历用双指针所有可能的$i$即可;</li><li>此时我们可以固定目标子数组起始索引为$k$,结束索引为$j$,满足$k \le j \le n-1$，此时很容易求出数组索引$[k,j]$之间的最小元素为$right[j]$,而此时我们则去查找满足以$k$为结尾索引的连续子数组，且子数组的最小值大于等于$right[j]$的最大长度,我们依次遍历用双指针所有可能的$j$即可;</li><li>时间复杂度为$O(n)$,空间复杂度为$O(n)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = nums[k];</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        curr = nums[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            curr = min(curr,nums[i]);</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(arr.begin(),arr.end());</span><br><span class="line">        curr = nums[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k+<span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr = min(curr,nums[i]);</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &gt; arr[r]) r--;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">                ans = max(ans,arr[l]*(r-l+<span class="number">1</span>));</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt; arr[r]) l++;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">                ans = max(ans,arr[r]*(r-l+<span class="number">1</span>));</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-232&quot;&gt;&lt;a href=&quot;#leetcode-contest-232&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 232&quot;&gt;&lt;/a&gt;leetcode contest 232&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，最后两道题目的解法还是非常有意思的题目，虽然解法很简单，但是非常值得深入思考的题目，特别是第三题，给人印象深刻。&lt;/p&gt;&lt;h2 id=&quot;5701-仅执行一次字符串交换能否使两个字符串相等&quot;&gt;&lt;a href=&quot;#5701-仅执行一次字符串交换能否使两个字符串相等&quot; class=&quot;headerlink&quot; title=&quot;5701. 仅执行一次字符串交换能否使两个字符串相等&quot;&gt;&lt;/a&gt;5701. 仅执行一次字符串交换能否使两个字符串相等&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你长度相等的两个字符串 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 231</title>
    <link href="http://yoursite.com/2021/03/07/260/"/>
    <id>http://yoursite.com/2021/03/07/260/</id>
    <published>2021-03-07T13:17:33.864Z</published>
    <updated>2021-03-08T03:19:29.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-231"><a href="#leetcode-contest-231" class="headerlink" title="leetcode contest 231"></a>leetcode contest 231</h1><p>本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。周赛的题目质量就是非常高，非常喜欢这种有思考的题目。</p><h2 id="5697-检查二进制字符串字段"><a href="#5697-检查二进制字符串字段" class="headerlink" title="5697. 检查二进制字符串字段"></a>5697. 检查二进制字符串字段</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 <code>s</code> ，该字符串 不含前导零 。</p><a id="more"></a><p>如果 s 最多包含 一个由连续的 <code>&#39;1&#39;</code> 组成的字段 ，返回 <code>true​​​</code> 。否则，返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1001"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：字符串中的 <span class="number">1</span> 没有形成一个连续字段。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"110"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]​​​​</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li><li><code>s[0]</code> 为 <code>&#39;1&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力搜索即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOnesSegment</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'1'</span>) i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'0'</span>) i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5698-构成特定和需要添加的最少元素"><a href="#5698-构成特定和需要添加的最少元素" class="headerlink" title="5698. 构成特定和需要添加的最少元素"></a>5698. 构成特定和需要添加的最少元素</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，和两个整数 <code>limit</code> 与<code>goal</code>。数组 <code>nums</code> 有一条重要属性：<code>abs(nums[i]) &lt;= limit</code> 。</p><p>返回使数组元素总和等于 <code>goal</code> 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 <code>abs(nums[i]) &lt;= limit</code> 这一属性。</p><p>注意，如果 <code>x &gt;= 0</code> ，那么 <code>abs(x)</code> 等于 <code>x</code> ；否则，等于 <code>-x</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>], limit = <span class="number">3</span>, goal = <span class="number">-4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：可以将 <span class="number">-2</span> 和 <span class="number">-3</span> 添加到数组中，数组的元素总和变为 <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> - <span class="number">2</span> - <span class="number">3</span> = <span class="number">-4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-10</span>,<span class="number">9</span>,<span class="number">1</span>], limit = <span class="number">100</span>, goal = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= limit &lt;= 106</code></li><li><code>-limit &lt;= nums[i] &lt;= limit</code></li><li><code>-109 &lt;= goal &lt;= 109</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质为贪心算法，首先我们求出目标数组的和$sum$与$goal$之间的差距，题目中要求增加绝对值不大于等于<code>limit</code>的元素，我们则利用贪心法，每次增加绝对值最大的元素即可，这样即可使得增加的元素最少。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) sum += v;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">abs</span>(goal - sum) + limit - <span class="number">1</span>)/limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5699-从第一个节点出发到最后一个节点的受限路径数"><a href="#5699-从第一个节点出发到最后一个节点的受限路径数" class="headerlink" title="5699. 从第一个节点出发到最后一个节点的受限路径数"></a>5699. 从第一个节点出发到最后一个节点的受限路径数</h2><p>现有一个加权无向连通图。给你一个正整数 <code>n</code>，表示图中有 <code>n</code> 个节点，并按从 <code>1</code> 到 <code>n</code> 给节点编号；另给你一个数组 <code>edges</code> ，其中每个 <code>edges[i] = [ui, vi, weighti]</code> 表示存在一条位于节点 <code>ui</code>和 <code>vi</code> 之间的边，这条边的权重为 <code>weighti</code> 。</p><p>从节点 <code>start</code> 出发到节点 end 的路径是一个形如 <code>[z0, z1, z2, ..., zk]</code> 的节点序列，满足<code>z0 = start 、zk = end</code> 且在所有符合<code>0 &lt;= i &lt;= k-1</code> 的节点 <code>zi</code> 和 <code>zi+1</code>之间存在一条边。</p><p>路径的距离定义为这条路径上所有边的权重总和。用 <code>distanceToLastNode(x)</code>表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 <code>distanceToLastNode(zi) &gt; distanceToLastNode(zi+1)</code> 的一条路径，其中 <code>0 &lt;= i &lt;= k-1</code>。</p><p>返回从节点 1 出发到节点 <code>n</code> 的 受限路径数 。由于数字可能很大，请返回对 <code>109 + 7</code> 取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">5</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">3</span> --&gt; <span class="number">5</span></span><br><span class="line"><span class="number">3</span>) <span class="number">1</span> --&gt; <span class="number">3</span> --&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：<span class="number">1</span> --&gt; <span class="number">3</span> --&gt; <span class="number">7</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>n - 1 &lt;= edges.length &lt;= 4 * 104</code></li><li><code>edges[i].length == 3</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li><code>1 &lt;= weighti &lt;= 105</code></li><li>任意两个节点之间至多存在一条边</li><li>任意两个节点之间至少存在一条路径</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 迪杰斯特拉算法 + dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们需要求出所有点到节点<code>end</code>的最小距离，这个解法很多，经典的<code>dijistra</code>算法即可解决。</li><li>我们则需要求出所有的受限路径，按照题目的要求，首先路径中满足<code>distanceToLastNode(zi) &gt; distanceToLastNode(zi+1)</code>，则此时我们很容易联想到将所有的路径按照<code>distanceToLastNode</code>的大小进行排序，此时我们即可利用<code>dp</code>的特性，因为前面的数一定比后面的数小。此时我们可以设$dp[n] = 1$,按照所有排序的顺序依次对该顶点的邻接节点进行依次遍历。</li><li>时间复杂度为$O(nlgn + n + 2n)$，空间复杂度为$O(n)$.</li><li>另一种解法则为<code>dfs</code>我们也可以很快求出，但是还是感觉太复杂，只贴代码不讲原理了。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>dp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRestrictedPaths</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,INT_MAX);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">1</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">0</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        qu.push(make_pair(n<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">        dist[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.first])&#123;</span><br><span class="line">                <span class="keyword">int</span> x = v.first;</span><br><span class="line">                <span class="keyword">int</span> d = v.second;</span><br><span class="line">                <span class="keyword">if</span>(curr.second + d &lt; dist[x])&#123;</span><br><span class="line">                    dist[x] = curr.second + d;</span><br><span class="line">                    qu.push(make_pair(x,dist[x]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) arr[i] = i;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> dist[a] &lt; dist[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        dp[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[arr[i]])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[v.first] &gt; <span class="number">0</span> &amp;&amp; dist[arr[i]] &gt; dist[v.first])&#123;</span><br><span class="line">                    dp[arr[i]] = (dp[arr[i]] + dp[v.first])%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>dfs<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; dist,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; graph,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp; count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == dist.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count[curr] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v.first;</span><br><span class="line">            <span class="keyword">if</span>(dist[curr] &lt;= dist[x] || count[x] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(count[x] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                count[curr] = (count[x] + count[curr])%MOD;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count[x] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(x,dist,graph,count);</span><br><span class="line">                <span class="keyword">if</span>(count[x] &gt; <span class="number">0</span>) count[curr] = (count[curr] + count[x])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRestrictedPaths</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,INT_MAX);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">1</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">0</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        qu.push(make_pair(n<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">        dist[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.first])&#123;</span><br><span class="line">                <span class="keyword">int</span> x = v.first;</span><br><span class="line">                <span class="keyword">int</span> d = v.second;</span><br><span class="line">                <span class="keyword">if</span>(curr.second + d &lt; dist[x])&#123;</span><br><span class="line">                    dist[x] = curr.second + d;</span><br><span class="line">                    qu.push(make_pair(x,dist[x]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; count(n,<span class="number">0</span>);</span><br><span class="line">        count[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">0</span>,dist,graph,count);</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>]%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5700-使所有区间的异或结果为零"><a href="#5700-使所有区间的异或结果为零" class="headerlink" title="5700. 使所有区间的异或结果为零"></a>5700. 使所有区间的异或结果为零</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k​​​​​</code> 。区间 <code>[left, right]（left &lt;= right）</code>的 异或结果 是对下标位于 <code>left</code>和 <code>right</code>（包括 <code>left</code> 和 <code>right</code> ）之间所有元素进行 <code>XOR</code> 运算的结果：<br><code>nums[left] XOR nums[left+1] XOR ... XOR nums[right]</code>。</p><p>返回数组中 要更改的最小元素数 ，以使所有长度为 <code>k</code> 的区间异或结果等于零。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将数组 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>] 修改为 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将数组 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>] 修改为 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将数组[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>] 修改为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 2000</code><br>​+ ​​​​​<code>0 &lt;= nums[i] &lt; 210</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学 + dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们我们可以得出以下推论<script type="math/tex; mode=display">nums[i] \bigoplus nums[i+1] \bigoplus ... \bigoplus nums[i+k-1] = 0 \\nums[i+1] \bigoplus nums[i+1] \bigoplus ... \bigoplus nums[i+k] = 0</script>通过上述我们可以发现$nums[i]  = nums[i+k]$.因此我们可以优先筛选$nums[i],nums[i+k],nums[i+2k]…$中频次最高的数。</li><li>仔细思考以下，我们如何让前$k$个元素异或的结果为<code>0</code>,我们可以设<code>dp</code>递推公式，例如<code>dp[i][val]</code>,表示前前<code>i</code>个元素异或的结果为$val$的最小替换数次数。则我们遇到第<code>i+1</code>个元素时，如果要使的前<code>i+1</code>个元素为<code>x</code>时，此时第<code>i+1</code>个元素有两种选择：</li></ol><ul><li>从选择一个全新的并且未在当前待选元素中出现过的，我们设前<code>i</code>个元素变为某个特定的值的最小替换次数为<code>dp[y]</code>, 此时我们需要将前<code>i+1</code>个元素的最小变化次数则为$dp[i+1][x] = sz[i+1] + dp[i][y]$,而此时需满足第<code>i+1</code>个元素的选择为$nums[i+1] = x\bigoplus y$.</li><li>从待选元素中选择一个值为$s$,则此时需要增加的替换最小次数为$dp[i][x\bigoplus s] + sz[i+1] - freq[i+1][s]$，此时我们将计算待选元素第<code>i+1</code>个分组中的$s$的统计统计次数，并计算第<code>i+1</code>个不等于$s$的次数。</li></ul><ol><li>总的来说感觉还是非常需要想像的一个<code>dp</code>，题目还是非常难的。自己都想了一个小时，才想明白这个题目。非常难思考的动态规划题目。题目太难了，确实不太会。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minChanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; cnt(k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sz[i%k]++;</span><br><span class="line">            cnt[i%k][nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1025</span>,<span class="number">-2000</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = *max_element(dp.begin(),dp.end());</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextdp(<span class="number">1025</span>,hi);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;<span class="number">10</span>); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y] : cnt[i])&#123;</span><br><span class="line">                    nextdp[j^x] = max(nextdp[j^x],dp[j] + y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = nextdp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n - dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-231&quot;&gt;&lt;a href=&quot;#leetcode-contest-231&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 231&quot;&gt;&lt;/a&gt;leetcode contest 231&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。周赛的题目质量就是非常高，非常喜欢这种有思考的题目。&lt;/p&gt;&lt;h2 id=&quot;5697-检查二进制字符串字段&quot;&gt;&lt;a href=&quot;#5697-检查二进制字符串字段&quot; class=&quot;headerlink&quot; title=&quot;5697. 检查二进制字符串字段&quot;&gt;&lt;/a&gt;5697. 检查二进制字符串字段&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个二进制字符串 &lt;code&gt;s&lt;/code&gt; ，该字符串 不含前导零 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 47</title>
    <link href="http://yoursite.com/2021/03/07/259/"/>
    <id>http://yoursite.com/2021/03/07/259/</id>
    <published>2021-03-07T13:17:21.442Z</published>
    <updated>2021-03-07T14:25:25.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-47"><a href="#leetcode-biweekly-contest-47" class="headerlink" title="leetcode biweekly contest 47"></a>leetcode biweekly contest 47</h1><p>本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。本周的状态真差，每次都是3题，<code>hard</code>难度没能做出来。</p><h2 id="5680-找到最近的有相同-X-或-Y-坐标的点"><a href="#5680-找到最近的有相同-X-或-Y-坐标的点" class="headerlink" title="5680. 找到最近的有相同 X 或 Y 坐标的点"></a>5680. 找到最近的有相同 X 或 Y 坐标的点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数 <code>x</code> 和 <code>y</code> ，表示你在一个笛卡尔坐标系下的 <code>(x, y)</code>处。同时，在同一个坐标系下给你一个数组 <code>points</code> ，其中 <code>points[i] = [ai, bi]</code>表示在 <code>(ai, bi)</code> 处有一个点。当一个点与你所在的位置有相同的 <code>x</code> 坐标或者相同的 <code>y</code> 坐标时，我们称这个点是 有效的 。</p><a id="more"></a><p>请返回距离你当前位置 曼哈顿距离 最近的 有效 点的下标（下标从 0 开始）。如果有多个最近的有效点，请返回下标 最小 的一个。如果没有有效点，请返回 -1 。</p><p>两个点 <code>(x1, y1)</code> 和<code>(x2, y2)</code> 之间的 曼哈顿距离 为 <code>abs(x1 - x2) + abs(y1 - y2)</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">3</span>, y = <span class="number">4</span>, points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：所有点中，[<span class="number">3</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">4</span>] 是有效点。有效点中，[<span class="number">2</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">4</span>] 距离你当前位置的曼哈顿距离最小，都为 <span class="number">1</span> 。[<span class="number">2</span>,<span class="number">4</span>] 的下标最小，所以返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">3</span>, y = <span class="number">4</span>, points = [[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">提示：答案可以与你当前所在位置坐标相同。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">3</span>, y = <span class="number">4</span>, points = [[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：没有有效点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= points.length &lt;= 104</code></li><li><code>points[i].length == 2</code></li><li><code>1 &lt;= x, y, ai, bi &lt;= 104</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力搜索即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nearestValidPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> dist = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] == x || points[i][<span class="number">1</span>] == y)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-x) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-y) &lt; dist)&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    dist = <span class="built_in">abs</span>(points[i][<span class="number">0</span>]-x) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5681-判断一个数字是否可以表示成三的幂的和"><a href="#5681-判断一个数字是否可以表示成三的幂的和" class="headerlink" title="5681. 判断一个数字是否可以表示成三的幂的和"></a>5681. 判断一个数字是否可以表示成三的幂的和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> ，如果你可以将 <code>n</code>表示成若干个不同的三的幂之和，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p><p>对于一个整数 <code>y</code> ，如果存在整数 <code>x</code> 满足 <code>y == 3x</code> ，我们称这个整数 <code>y</code> 是三的幂。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">12</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">12</span> = <span class="number">31</span> + <span class="number">32</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">91</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">91</span> = <span class="number">30</span> + <span class="number">32</span> + <span class="number">34</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">21</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>`1 &lt;= n &lt;= 107<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/check-if-number-is-a-sum-of-powers-of-three" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-number-is-a-sum-of-powers-of-three</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 位图暴力搜索或者<code>dfs</code></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>由于题目中给定的目标<code>n</code>的最大值为$10^{7}$,我们可以通过计算得知，最大的数可能为$3^{16} = 43,046,721$，因次我们很容易计算出所有的$3$的幂，通过暴力穷举所有的组合数即可。</li><li>我们用$32$位整数的图表示即可，通过暴力遍历出所有的组合数，整体的时间复杂度为$O(17*3^{16})$,可以计算出在允许的时间复杂度范围内。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>暴力<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPowersOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)&#123;</span><br><span class="line">            arr[i] = <span class="built_in">pow</span>(<span class="number">3</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>&lt;&lt;<span class="number">17</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">17</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr += arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>找规律<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPowersOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">3</span> == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5682-所有子字符串美丽值之和"><a href="#5682-所有子字符串美丽值之和" class="headerlink" title="5682. 所有子字符串美丽值之和"></a>5682. 所有子字符串美丽值之和</h2><p>一个字符串的 美丽值 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。</p><p>比方说，<code>&quot;abaacc&quot;</code>的美丽值为 <code>3 - 1 = 2</code>。<br>给你一个字符串 <code>s</code> ，请你返回它所有子字符串的 美丽值 之和。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabcb"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：美丽值不为零的字符串包括 [<span class="string">"aab"</span>,<span class="string">"aabc"</span>,<span class="string">"aabcb"</span>,<span class="string">"abcb"</span>,<span class="string">"bcb"</span>] ，每一个字符串的美丽值都为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabcbaa"</span></span><br><span class="line">输出：<span class="number">17</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-beauty-of-all-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-beauty-of-all-substrings</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash统计或者暴力统计</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>枚举所有的子串，然后统计所有子串的字符的频数，然后计算出最多的和最少的字符的个数，即求出美丽值，感觉不需要什么技巧。时间复杂度为$O(26*n^{2})$,空间复杂度为$O(26)$.</li><li>另一种方法是只快速统计频次，可以用有序<code>hash</code>保存当前所有字符的频次，每次取出最大的频次和最小的频次即可。时间复杂度为$O(lg26 * n^{2})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beautySum</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; freq;</span><br><span class="line">            cnt[s[i]-<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">            freq[cnt[s[i]-<span class="string">'a'</span>]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[s[j]-<span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> prev = cnt[s[j]-<span class="string">'a'</span>];</span><br><span class="line">                    freq[prev]--;</span><br><span class="line">                    <span class="keyword">if</span>(freq[prev] == <span class="number">0</span>) freq.erase(prev);</span><br><span class="line">                    cnt[s[j]-<span class="string">'a'</span>]++;</span><br><span class="line">                    freq[cnt[s[j]-<span class="string">'a'</span>]]++;</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt[s[j]-<span class="string">'a'</span>]++;</span><br><span class="line">                    freq[cnt[s[j]-<span class="string">'a'</span>]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += (freq.rbegin()-&gt;first - freq.begin()-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>暴力统统计<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 出现最大次数 - 最小最小次数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calcDiff</span><span class="params">(<span class="keyword">int</span> *cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = fmax(max, cnt[i]);</span><br><span class="line">            min = fmin(min, cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beautySum</span><span class="params">(<span class="keyword">char</span> * s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 枚举所有子串, 计算其字母出现次数, 计算美丽值 */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; len; j++) &#123;</span><br><span class="line">                cnt[s[j] - <span class="string">'a'</span>]++;</span><br><span class="line">                res += calcDiff(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5683-统计点对的数目"><a href="#5683-统计点对的数目" class="headerlink" title="5683. 统计点对的数目"></a>5683. 统计点对的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个无向图，无向图由整数 n  ，表示图中节点的数目，和 edges 组成，其中 edges[i] = [ui, vi] 表示 ui 和 vi 之间有一条无向边。同时给你一个代表查询的整数数组 queries 。</p><p>第 j 个查询的答案是满足如下条件的点对 (a, b) 的数目：</p><p>a &lt; b<br>cnt 是与 a 或者 b 相连的边的数目，且 cnt 严格大于 queries[j] 。<br>请你返回一个数组 answers ，其中 answers.length == queries.length 且 answers[j] 是第 j 个查询的答案。</p><p>请注意，图中可能会有 重复边 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">1</span>]], queries = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">解释：每个点对中，与至少一个点相连的边的数目如上图所示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>]], queries = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">10</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 2 * 104</code></li><li><code>1 &lt;= edges.length &lt;= 105</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li><code>1 &lt;= queries.length &lt;= 20</code></li><li><code>0 &lt;= queries[j] &lt; edges.length</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-pairs-of-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-pairs-of-nodes</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 容斥问题，经典的双指针</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目拿到以后我们首先看到不太好做，既然题目要求求出所有符合要求的点对的组合数目，很明显的我们首先需要求出所有顶点的度数，后面我们再分情况讨论。</li><li>我们可以知道如果有一个$query = x$,此时要求我们求出组合点的非重合的度数大于$x$的组合数目，这里就对组合$(ea,eb)$需要分为两种情况来讨论。</li></ol><ul><li>$(ea,eb)$不相邻，则此时我们很容易求出与点对$(ea,eb)$相邻的边数为$degree[a] + degree[b]$, 则此时我们已经知道所有顶点的度数，如何求出数组中其两个元素的值大于等于$x$的组合数目有多少，这是个经典的双指针问题，或者我们也可以用二分查找的方法解决。<script type="math/tex; mode=display">f(ea,eb) = degree[a] + degree[b]</script></li><li>$(ea,eb)$相邻，则此时我们就需要把相邻的边重复计算的次数减掉。此时的判断条件则为<script type="math/tex; mode=display">degree[a] + degree[b] > x \\f(ea,eb) = degree[a] + degree[b] - edges[a][b] > x</script></li></ul><ol><li>根据容斥原理，则首先我们找到所有可能的组合，然后我们再减去可能重复计算的组合数，即可得到最终的结果。题目整体还是非常好的题目，非常值得思考。双指针的时间复杂度为$O(n<em>m)$,二分查找的时间复杂度为$O(m</em>n*lgn)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countPairs(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(n,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;pii,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            v[<span class="number">0</span>]--;</span><br><span class="line">            v[<span class="number">1</span>]--;</span><br><span class="line">            degree[v[<span class="number">0</span>]]++;</span><br><span class="line">            degree[v[<span class="number">1</span>]]++;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] &gt; v[<span class="number">1</span>]) swap(v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">            cnt[make_pair(v[<span class="number">0</span>],v[<span class="number">1</span>])]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = degree;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : queries)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = n<span class="number">-1</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; i &amp;&amp; arr[i] + arr[j] &gt; x) j--;</span><br><span class="line">                curr += n - <span class="number">1</span> - max(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*remove the repeat edges*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = v.first.first;</span><br><span class="line">                <span class="keyword">int</span> b = v.first.second;</span><br><span class="line">                <span class="keyword">if</span>(degree[a] + degree[b] &gt; x &amp;&amp; (degree[a] + degree[b] - v.second) &lt;= x) curr--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>二分查找</li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-47&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-47&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 47&quot;&gt;&lt;/a&gt;leetcode biweekly contest 47&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。本周的状态真差，每次都是3题，&lt;code&gt;hard&lt;/code&gt;难度没能做出来。&lt;/p&gt;&lt;h2 id=&quot;5680-找到最近的有相同-X-或-Y-坐标的点&quot;&gt;&lt;a href=&quot;#5680-找到最近的有相同-X-或-Y-坐标的点&quot; class=&quot;headerlink&quot; title=&quot;5680. 找到最近的有相同 X 或 Y 坐标的点&quot;&gt;&lt;/a&gt;5680. 找到最近的有相同 X 或 Y 坐标的点&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个整数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ，表示你在一个笛卡尔坐标系下的 &lt;code&gt;(x, y)&lt;/code&gt;处。同时，在同一个坐标系下给你一个数组 &lt;code&gt;points&lt;/code&gt; ，其中 &lt;code&gt;points[i] = [ai, bi]&lt;/code&gt;表示在 &lt;code&gt;(ai, bi)&lt;/code&gt; 处有一个点。当一个点与你所在的位置有相同的 &lt;code&gt;x&lt;/code&gt; 坐标或者相同的 &lt;code&gt;y&lt;/code&gt; 坐标时，我们称这个点是 有效的 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 230</title>
    <link href="http://yoursite.com/2021/03/01/257/"/>
    <id>http://yoursite.com/2021/03/01/257/</id>
    <published>2021-03-01T04:28:34.667Z</published>
    <updated>2021-03-02T02:19:54.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-230"><a href="#leetcode-contest-230" class="headerlink" title="leetcode contest 230"></a>leetcode contest 230</h1><p>本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。</p><h2 id="1773-统计匹配检索规则的物品数量"><a href="#1773-统计匹配检索规则的物品数量" class="headerlink" title="1773. 统计匹配检索规则的物品数量"></a>1773. 统计匹配检索规则的物品数量</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>items</code> ，其中<code>items[i] = [typei, colori, namei]</code>，描述第 i 件物品的类型、颜色以及名称。</p><a id="more"></a><p>另给你一条由两个字符串 <code>ruleKey</code> 和 <code>ruleValue</code> 表示的检索规则。</p><p>如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：</p><ul><li><code>ruleKey == &quot;type&quot;</code> 且 <code>ruleValue == typei</code> 。</li><li><code>ruleKey == &quot;color&quot;</code> 且 <code>ruleValue == colori</code>。</li><li><code>ruleKey == &quot;name&quot;</code> 且 <code>ruleValue == namei</code> 。<br>统计并返回 匹配检索规则的物品数量 。</li></ul><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="string">"phone"</span>,<span class="string">"blue"</span>,<span class="string">"pixel"</span>],[<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"lenovo"</span>],[<span class="string">"phone"</span>,<span class="string">"gold"</span>,<span class="string">"iphone"</span>]], ruleKey = <span class="string">"color"</span>, ruleValue = <span class="string">"silver"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只有一件物品匹配检索规则，这件物品是 [<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"lenovo"</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="string">"phone"</span>,<span class="string">"blue"</span>,<span class="string">"pixel"</span>],[<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"phone"</span>],[<span class="string">"phone"</span>,<span class="string">"gold"</span>,<span class="string">"iphone"</span>]], ruleKey = <span class="string">"type"</span>, ruleValue = <span class="string">"phone"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：只有两件物品匹配检索规则，这两件物品分别是 [<span class="string">"phone"</span>,<span class="string">"blue"</span>,<span class="string">"pixel"</span>] 和 [<span class="string">"phone"</span>,<span class="string">"gold"</span>,<span class="string">"iphone"</span>] 。注意，[<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"phone"</span>] 未匹配检索规则。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= items.length &lt;= 104</code></li><li><code>1 &lt;= typei.length, colori.length, namei.length, ruleValue.length &lt;= 10</code></li><li><code>ruleKey 等于 &quot;type&quot;、&quot;color&quot; 或 &quot;name&quot;</code></li><li>所有字符串仅由小写字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-items-matching-a-rule/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-items-matching-a-rule/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力搜索即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; items, <span class="built_in">string</span> ruleKey, <span class="built_in">string</span> ruleValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : items)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ruleKey == <span class="string">"type"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[<span class="number">0</span>] == ruleValue) ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ruleKey == <span class="string">"color"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[<span class="number">1</span>] == ruleValue) ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ruleKey == <span class="string">"name"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[<span class="number">2</span>] == ruleValue) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1774-最接近目标价格的甜点成本"><a href="#1774-最接近目标价格的甜点成本" class="headerlink" title="1774. 最接近目标价格的甜点成本"></a>1774. 最接近目标价格的甜点成本</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你打算做甜点，现在需要购买配料。目前共有 <code>n</code>种冰激凌基料和 <code>m</code> 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><ul><li>必须选择 一种 冰激凌基料。</li><li>可以添加 一种或多种 配料，也可以不添加任何配料。</li><li>每种类型的配料 最多两份 。<br>给你以下三个输入：<br><code>baseCosts</code> ，一个长度为 <code>n</code> 的整数数组，其中每个 <code>baseCosts[i]</code>表示第 <code>i</code> 种冰激凌基料的价格。<br><code>toppingCosts</code>，一个长度为 <code>m</code>的整数数组，其中每个 <code>toppingCosts[i]</code> 表示 一份 第 <code>i</code> 种冰激凌配料的价格。<br><code>target</code> ，一个整数，表示你制作甜点的目标价格。<br>你希望自己做的甜点总成本尽可能接近目标价格 <code>target</code>。</li></ul><p>返回最接近 <code>target</code> 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">1</span>,<span class="number">7</span>], toppingCosts = [<span class="number">3</span>,<span class="number">4</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：考虑下面的方案组合（所有下标均从 <span class="number">0</span> 开始）：</span><br><span class="line">- 选择 <span class="number">1</span> 号基料：成本 <span class="number">7</span></span><br><span class="line">- 选择 <span class="number">1</span> 份 <span class="number">0</span> 号配料：成本 <span class="number">1</span> x <span class="number">3</span> = <span class="number">3</span></span><br><span class="line">- 选择 <span class="number">0</span> 份 <span class="number">1</span> 号配料：成本 <span class="number">0</span> x <span class="number">4</span> = <span class="number">0</span></span><br><span class="line">总成本：<span class="number">7</span> + <span class="number">3</span> + <span class="number">0</span> = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">2</span>,<span class="number">3</span>], toppingCosts = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">100</span>], target = <span class="number">18</span></span><br><span class="line">输出：<span class="number">17</span></span><br><span class="line">解释：考虑下面的方案组合（所有下标均从 <span class="number">0</span> 开始）：</span><br><span class="line">- 选择 <span class="number">1</span> 号基料：成本 <span class="number">3</span></span><br><span class="line">- 选择 <span class="number">1</span> 份 <span class="number">0</span> 号配料：成本 <span class="number">1</span> x <span class="number">4</span> = <span class="number">4</span></span><br><span class="line">- 选择 <span class="number">2</span> 份 <span class="number">1</span> 号配料：成本 <span class="number">2</span> x <span class="number">5</span> = <span class="number">10</span></span><br><span class="line">- 选择 <span class="number">0</span> 份 <span class="number">2</span> 号配料：成本 <span class="number">0</span> x <span class="number">100</span> = <span class="number">0</span></span><br><span class="line">总成本：<span class="number">3</span> + <span class="number">4</span> + <span class="number">10</span> + <span class="number">0</span> = <span class="number">17</span> 。不存在总成本为 <span class="number">18</span> 的甜点制作方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">3</span>,<span class="number">10</span>], toppingCosts = [<span class="number">2</span>,<span class="number">5</span>], target = <span class="number">9</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：可以制作总成本为 <span class="number">8</span> 和 <span class="number">10</span> 的甜点。返回 <span class="number">8</span> ，因为这是成本更低的方案。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">10</span>], toppingCosts = [<span class="number">1</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == baseCosts.length</code></li><li><code>m == toppingCosts.length</code></li><li><code>1 &lt;= n, m &lt;= 10</code></li><li><code>1 &lt;= baseCosts[i], toppingCosts[i] &lt;= 104</code></li><li><code>1 &lt;= target &lt;= 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/closest-dessert-cost" target="_blank" rel="noopener">https://leetcode-cn.com/problems/closest-dessert-cost</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力搜索</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>由于题目中给定的数据量很小，我们则可以用3进制的状态掩码来表示配料的组合，因为每种配料只有三种状态，分别为<code>0,1,2</code>.</li><li>然后分别遍历每种基料和配料的所有组合即可求出接近的值。时间复杂度为$O(n*3^{n})$,空间复杂度为$O(3^{n})$.</li><li>另一种解法，将其转化为背包问题，限定每种配料的数量为<code>2</code>,也可以转化为<code>0,1</code>背包问题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; baseCosts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; toppingCosts, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = baseCosts.size();</span><br><span class="line">        <span class="keyword">int</span> m = toppingCosts.size();</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(mask,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = i/<span class="built_in">pow</span>(<span class="number">3</span>,j);</span><br><span class="line">                cost += (x%<span class="number">3</span>)*toppingCosts[j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(baseCosts[j] + dp[i] - target) &lt; <span class="built_in">abs</span>(ans-target))&#123;</span><br><span class="line">                    ans = baseCosts[j] + dp[i];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(baseCosts[j] + dp[i] - target) == <span class="built_in">abs</span>(ans-target) &amp;&amp; (baseCosts[j] + dp[i]) &lt; ans)&#123;</span><br><span class="line">                    ans = baseCosts[j] + dp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1775-通过最少操作次数使数组的和相等"><a href="#1775-通过最少操作次数使数组的和相等" class="headerlink" title="1775. 通过最少操作次数使数组的和相等"></a>1775. 通过最少操作次数使数组的和相等</h2><p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 1 和 6）。</p><p>每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。</p><p>请你返回使 <code>nums1</code>中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], nums2 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以通过 <span class="number">3</span> 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 <span class="number">0</span> 开始。</span><br><span class="line">- 将 nums2[<span class="number">0</span>] 变为 <span class="number">6</span> 。 nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], nums2 = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将 nums1[<span class="number">5</span>] 变为 <span class="number">1</span> 。 nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>], nums2 = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将 nums1[<span class="number">2</span>] 变为 <span class="number">2</span> 。 nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>], nums2 = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], nums2 = [<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">6</span>,<span class="number">6</span>], nums2 = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以通过 <span class="number">3</span> 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 <span class="number">0</span> 开始。</span><br><span class="line">- 将 nums1[<span class="number">0</span>] 变为 <span class="number">2</span> 。 nums1 = [<span class="number">2</span>,<span class="number">6</span>], nums2 = [<span class="number">1</span>] 。</span><br><span class="line">- 将 nums1[<span class="number">1</span>] 变为 <span class="number">2</span> 。 nums1 = [<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>] 。</span><br><span class="line">- 将 nums2[<span class="number">0</span>] 变为 <span class="number">4</span> 。 nums1 = [<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">4</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们设数组<code>nums1</code>的和为$s_{1}$,数组<code>nums2</code>的和为$s_{2}$,假设有$s_{1} &lt; s_{2}$,则此时我们如果想要使得变换步数最小，则此时我们需要尽可能的将$num1$中的元素变大，将数组$nums2$中的元素变小。可以实际参考<a href="https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations/solution/tong-guo-zui-shao-cao-zuo-ci-shu-shi-shu-o8no/" target="_blank" rel="noopener">zerotrac</a>的解法，写的非常详细。我们知道：</li></ol><ul><li>可以将数组$nums1$中的每个元素变大，每个元素$x$变大的变化量为$6-x$,$x\in[1,6]$;</li><li>可以将数组$nums2$中的每个元素变小，每个元素$x$变小的变化量为$x-1$,$x\in[1,6]$;</li></ul><ol><li>我们设$diff = abs(s_{1} -s_{2})$,则此时我们可以应当尽可能的使得元素变大或者变小的变化量之和大于等于$diff$,且尽可能的使用最少的元素的变化量，此时我们可以利用贪心法，每次从最大的变化量中选择，直到选择的变化量之和满足$sum_{c} \ge diff$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1) s1 += v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2) s2 += v;</span><br><span class="line">        <span class="keyword">if</span>(s1 &gt; s2) <span class="keyword">return</span> minOperations(nums2,nums1);</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="built_in">abs</span>(s1 - s2);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1) cnt[<span class="number">6</span>-v]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2) cnt[v<span class="number">-1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(diff &gt; <span class="number">0</span> &amp;&amp; cnt[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                diff -= i;</span><br><span class="line">                cnt[i]--;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(diff &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5692-车队-II"><a href="#5692-车队-II" class="headerlink" title="5692. 车队 II"></a>5692. 车队 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在一条单车道上有 <code>n</code>辆车，它们朝着同样的方向行驶。给你一个长度为 <code>n</code> 的数组 <code>cars</code> ，其中 <code>cars[i] = [positioni, speedi]</code> ，它表示：</p><p><code>positioni</code> 是第 <code>i</code>辆车和道路起点之间的距离（单位：米）。题目保证 <code>positioni &lt; positioni+1</code> 。<br><code>speedi</code> 是第 <code>i</code> 辆车的初始速度（单位：米/秒）。<br>简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 最慢 一辆车的速度。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 i 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 <code>answer[i]</code> 为 -1 。答案精度误差需在 <code>10-5</code>以内。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cars = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">7</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">1.00000</span>,<span class="number">-1.00000</span>,<span class="number">3.00000</span>,<span class="number">-1.00000</span>]</span><br><span class="line">解释：经过恰好 <span class="number">1</span> 秒以后，第一辆车会与第二辆车相遇，并形成一个 <span class="number">1</span> m/s 的车队。经过恰好 <span class="number">3</span> 秒以后，第三辆车会与第四辆车相遇，并形成一个 <span class="number">2</span> m/s 的车队。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cars = [[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">3</span>],[<span class="number">9</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="number">2.00000</span>,<span class="number">1.00000</span>,<span class="number">1.50000</span>,<span class="number">-1.00000</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= cars.length &lt;= 105</code></li><li><code>1 &lt;= positioni, speedi &lt;= 106</code></li><li><code>positioni &lt; positioni+1</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/car-fleet-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/car-fleet-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>优先级队列或者栈</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目的思路还是非常好的，对于算法的思考方面来说还算是一个非常好的题目，对于具体的解法有两种解法，首先需要我们重点思考以下几个重要的结论，对于第<code>i</code>辆车来说，它左边的$i-1$辆车的最终合并后的最大时速肯定不会超过第<code>i</code>辆车，所以我们可以看到最终的车辆的运行速度肯定有以下结论:<script type="math/tex; mode=display">speed[j] \le speed[i] \qquad if (j  < i)</script>我们依次排列车辆的$a,b,c$,假设$b$车与$c$车相遇的时间比$a$车与$c$车相遇的时间要早，则我们可以知道$a$车与$b$车相遇的时候，这是与$a$相遇的车应该是$b,c$合并的车队，此时$a$车与$b$车相遇的时间即等于$a$车与$c$车相遇的时间。我们计算第<code>i</code>辆车与第<code>j</code>辆车的相遇时间一般为:<script type="math/tex; mode=display">\frac{p_{j}-p_{i}}{speed_{i}-speed_{j}}</script></li><li>单调栈的解法：因为我们知道$1$的结论，对于第<code>i</code>辆车来说，它左边的$i-1$辆车的最终合并后的最大时速肯定不会超过第<code>i</code>辆车，所以无论前<code>i-1</code>辆车的如何合并与否并不影响第<code>i</code>辆车与第<code>i+1</code>辆车相遇的时间。因此我们知道第<code>i</code>辆车的与合并的时间只与其后$[i+1,n]$的车辆相关，则我们可以利用栈的特性，每次第<code>i</code>车时，它会查看后面$[i+1,n]$车的状态，因此我们利用栈的功能。</li><li>优先级队列模拟：</li></ol><ul><li>我们将所有的车辆全部编为车队，$left[i]$表示以第<code>i</code>辆车为结尾的车队的最左侧的车辆的编号，因此$(left[i],i)$代表从$left[i]$到$i$的车队。</li><li>我们设$x &lt; y$,以我们每次将可能会相遇的车队$(left[x],x),(x+1,y)$，计算前后车队相遇的时间并进入优先级队列，每次从队列中取出最早相遇的车队，并将两个车队合并，则我们可以知道车队$(left[x],x),(x+1,y)$合并后的车队则为$(left[x],y)$,并同时将$(left[x],x)$从所有的车队中移除，因为我们知道以$y$为结尾的车队与后车相遇的时间不会受到前$y$辆车的合并的影响。</li><li>同时我们需要计算车队$(left[left[x]-1],left[x]-1)$与后车$left[x]$相遇的时间，并更新队列。如此就可以不断模拟，想法还是非常有意思的。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>优先级队列模拟<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    Node(<span class="keyword">double</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a, Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.t &gt; b.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; getCollisionTimes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cars) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = cars.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans(n,<span class="number">-1.0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; remove(n,<span class="literal">false</span>);</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[i] = i;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; cars[i][<span class="number">1</span>] &lt; cars[i<span class="number">-1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                pq.push(Node(<span class="number">1.0</span>*(cars[i][<span class="number">0</span>] - cars[i<span class="number">-1</span>][<span class="number">0</span>])/(cars[i<span class="number">-1</span>][<span class="number">1</span>]-cars[i][<span class="number">1</span>]),i<span class="number">-1</span>,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(remove[curr.x] || remove[curr.y]) <span class="keyword">continue</span>;</span><br><span class="line">            left[curr.y] = left[curr.x];</span><br><span class="line">            remove[curr.x] = <span class="literal">true</span>;</span><br><span class="line">            ans[curr.x] = curr.t;</span><br><span class="line">            <span class="keyword">if</span>(left[curr.x] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> prev = left[curr.x] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cars[prev][<span class="number">1</span>] &gt; cars[curr.y][<span class="number">1</span>])&#123;</span><br><span class="line">                    pq.push(Node(<span class="number">1.0</span>*(cars[curr.y][<span class="number">0</span>]-cars[prev][<span class="number">0</span>])/(cars[prev][<span class="number">1</span>]-cars[curr.y][<span class="number">1</span>]),prev,curr.y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>栈<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; getCollisionTimes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cars) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = cars.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans(n,<span class="number">-1.0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = cars[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> s = cars[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = cars[st.top()][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> s1 = cars[st.top()][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> j = st.top();</span><br><span class="line">                <span class="keyword">if</span>(s &lt;= s1 || (ans[j] &gt; <span class="number">0</span> &amp;&amp; <span class="number">1.0</span>*(p1-p)/(s-s1) &gt; ans[j]))&#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">                ans[i] = <span class="number">1.0</span>*(cars[st.top()][<span class="number">0</span>]-p)/(s-cars[st.top()][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-230&quot;&gt;&lt;a href=&quot;#leetcode-contest-230&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 230&quot;&gt;&lt;/a&gt;leetcode contest 230&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。&lt;/p&gt;&lt;h2 id=&quot;1773-统计匹配检索规则的物品数量&quot;&gt;&lt;a href=&quot;#1773-统计匹配检索规则的物品数量&quot; class=&quot;headerlink&quot; title=&quot;1773. 统计匹配检索规则的物品数量&quot;&gt;&lt;/a&gt;1773. 统计匹配检索规则的物品数量&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;items&lt;/code&gt; ，其中&lt;code&gt;items[i] = [typei, colori, namei]&lt;/code&gt;，描述第 i 件物品的类型、颜色以及名称。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言编程范式</title>
    <link href="http://yoursite.com/2021/02/23/258/"/>
    <id>http://yoursite.com/2021/02/23/258/</id>
    <published>2021-02-23T01:39:54.829Z</published>
    <updated>2021-04-02T03:32:02.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-语言学习"><a href="#go-语言学习" class="headerlink" title="go 语言学习"></a>go 语言学习</h1><p>最近因为学习MIT 6.824的课程，顺便把<code>go</code>语言的相关语法知识也学习了一遍，总共花了约<code>1</code>个星期，总的来说还是非常新颖的一门语言，非常喜欢学习新的知识和技巧。</p><h2 id="go-语言简介"><a href="#go-语言简介" class="headerlink" title="go 语言简介"></a>go 语言简介</h2><p><code>go</code>语言作为<code>google</code>推广的语言，实际写了几次程序，感觉写起来很爽，最爽的还是其中涉及到的多核编程，支持轻量级的携程，真心是非常大的创新。作为现代的语言确实有非常多的优点值得学习。非常多的新技术值得学习。</p><a id="more"></a><h2 id="go-语言的部分特性"><a href="#go-语言的部分特性" class="headerlink" title="go 语言的部分特性"></a>go 语言的部分特性</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p><code>go</code>的<code>struct</code>非常灵活，对比<code>c/c++</code>来说，<code>go</code>的结构体定义用<code>type</code>，这点与<code>c/c++</code>不同，另外最重要的是结构体的函数的定义非常灵活，可以随意对结构体的定义进行扩展。比如定义结构体：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x</span><br><span class="line">    <span class="keyword">int</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结构体指针定义，同时访问结构体的变量也可以用<code>-&gt;</code>来访问相关变量。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 point</span><br><span class="line"><span class="keyword">var</span> *p2 *point</span><br><span class="line">p2 = &amp;p1</span><br><span class="line">fmt.Printf(<span class="string">"location ： %d\n"</span>,p1.x)</span><br><span class="line">fmt.Printf(<span class="string">"location :  %d\n"</span>,p1.y)</span><br></pre></td></tr></table></figure></p><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><h3 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h3><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><h3 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h3><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><h3 id="fucntional-options"><a href="#fucntional-options" class="headerlink" title="fucntional options"></a>fucntional options</h3><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><h3 id="pipe-line"><a href="#pipe-line" class="headerlink" title="pipe line"></a>pipe line</h3><h3 id="relect"><a href="#relect" class="headerlink" title="relect"></a>relect</h3><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h3><h3 id="go-rpc"><a href="#go-rpc" class="headerlink" title="go rpc"></a>go rpc</h3><h3 id><a href="#" class="headerlink" title=" "></a> </h3><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;go-语言学习&quot;&gt;&lt;a href=&quot;#go-语言学习&quot; class=&quot;headerlink&quot; title=&quot;go 语言学习&quot;&gt;&lt;/a&gt;go 语言学习&lt;/h1&gt;&lt;p&gt;最近因为学习MIT 6.824的课程，顺便把&lt;code&gt;go&lt;/code&gt;语言的相关语法知识也学习了一遍，总共花了约&lt;code&gt;1&lt;/code&gt;个星期，总的来说还是非常新颖的一门语言，非常喜欢学习新的知识和技巧。&lt;/p&gt;&lt;h2 id=&quot;go-语言简介&quot;&gt;&lt;a href=&quot;#go-语言简介&quot; class=&quot;headerlink&quot; title=&quot;go 语言简介&quot;&gt;&lt;/a&gt;go 语言简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;go&lt;/code&gt;语言作为&lt;code&gt;google&lt;/code&gt;推广的语言，实际写了几次程序，感觉写起来很爽，最爽的还是其中涉及到的多核编程，支持轻量级的携程，真心是非常大的创新。作为现代的语言确实有非常多的优点值得学习。非常多的新技术值得学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术学习" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="go 语言" scheme="http://yoursite.com/tags/go-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 229</title>
    <link href="http://yoursite.com/2021/02/22/256/"/>
    <id>http://yoursite.com/2021/02/22/256/</id>
    <published>2021-02-22T00:38:27.241Z</published>
    <updated>2021-03-01T04:31:37.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-229"><a href="#leetcode-contest-229" class="headerlink" title="leetcode contest 229"></a>leetcode contest 229</h1><p>本周的周赛的题目确实出乎意外的简单，竟然全部都<code>AK</code>了，排名还可以，竟然排名<code>52</code>名.<br><img src="https://i.loli.net/2021/02/22/YPfB63l2RzmX7rE.png" alt></p><h2 id="5685-交替合并字符串"><a href="#5685-交替合并字符串" class="headerlink" title="5685. 交替合并字符串"></a>5685. 交替合并字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。<br>返回 合并后的字符串 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"abc"</span>, word2 = <span class="string">"pqr"</span></span><br><span class="line">输出：<span class="string">"apbqcr"</span></span><br><span class="line">解释：字符串合并情况如下所示：</span><br><span class="line">word1：  <span class="selector-tag">a</span>   <span class="selector-tag">b</span>   c</span><br><span class="line">word2：    <span class="selector-tag">p</span>   <span class="selector-tag">q</span>   r</span><br><span class="line">合并后：  <span class="selector-tag">a</span> <span class="selector-tag">p</span> <span class="selector-tag">b</span> <span class="selector-tag">q</span> c r</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"ab"</span>, word2 = <span class="string">"pqrs"</span></span><br><span class="line">输出：<span class="string">"apbqrs"</span></span><br><span class="line">解释：注意，word2 比 word1 长，<span class="string">"rs"</span> 需要追加到合并后字符串的末尾。</span><br><span class="line">word1：  <span class="selector-tag">a</span>   <span class="selector-tag">b</span> </span><br><span class="line">word2：    <span class="selector-tag">p</span>   <span class="selector-tag">q</span>   r   s</span><br><span class="line">合并后：  <span class="selector-tag">a</span> <span class="selector-tag">p</span> <span class="selector-tag">b</span> <span class="selector-tag">q</span>   r   s</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"abcd"</span>, word2 = <span class="string">"pq"</span></span><br><span class="line">输出：<span class="string">"apbqcd"</span></span><br><span class="line">解释：注意，word1 比 word2 长，<span class="string">"cd"</span> 需要追加到合并后字符串的末尾。</span><br><span class="line">word1：  a   b   c   d</span><br><span class="line">word2：    p   q </span><br><span class="line">合并后：  a p b q c   d</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= word1.length, word2.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `word1` 和 `word2` 由小写英文字母组成</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址</span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/merge-strings-alternately</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;   简单问题,直接暴力或者前缀和什么的</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 双指针交替将字符加入到目标字符串中即可。</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> mergeAlternately(<span class="keyword">string</span> word1, <span class="keyword">string</span> word2) &#123;</span><br><span class="line">        <span class="keyword">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; word1.size() &amp;&amp; l2 &lt; word2.size())&#123;</span><br><span class="line">            ans.push_back(word1[l1++]);</span><br><span class="line">            ans.push_back(word2[l2++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 &lt; word1.size())&#123;</span><br><span class="line">            ans = ans + word1.substr(l1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 &lt; word2.size())&#123;</span><br><span class="line">            ans = ans + word2.substr(l2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5686-移动所有球到每个盒子所需的最小操作数"><a href="#5686-移动所有球到每个盒子所需的最小操作数" class="headerlink" title="5686. 移动所有球到每个盒子所需的最小操作数"></a>5686. 移动所有球到每个盒子所需的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有 n 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code>，其中 <code>boxes[i]</code> 的值为 ‘0’ 表示第 i 个盒子是 空 的，而 <code>boxes[i]</code>的值为 ‘1’ 表示盒子里有 一个 小球。</p><p>在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p><p>返回一个长度为<code>n</code> 的数组 <code>answer</code>，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 最小 操作数。</p><p>每个 <code>answer[i]</code> 都需要根据盒子的 初始状态 进行计算。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：boxes = <span class="string">"110"</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：每个盒子对应的最小操作数如下：</span><br><span class="line"><span class="number">1</span>) 第 <span class="number">1</span> 个盒子：将一个小球从第 <span class="number">2</span> 个盒子移动到第 <span class="number">1</span> 个盒子，需要 <span class="number">1</span> 步操作。</span><br><span class="line"><span class="number">2</span>) 第 <span class="number">2</span> 个盒子：将一个小球从第 <span class="number">1</span> 个盒子移动到第 <span class="number">2</span> 个盒子，需要 <span class="number">1</span> 步操作。</span><br><span class="line"><span class="number">3</span>) 第 <span class="number">3</span> 个盒子：将一个小球从第 <span class="number">1</span> 个盒子移动到第 <span class="number">3</span> 个盒子，需要 <span class="number">2</span> 步操作。将一个小球从第 <span class="number">2</span> 个盒子移动到第 <span class="number">3</span> 个盒子，需要 <span class="number">1</span> 步操作。共计 <span class="number">3</span> 步操作。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：boxes = <span class="string">"001011"</span></span><br><span class="line">输出：[<span class="number">11</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == boxes.length</code></li><li><code>1 &lt;= n &lt;= 2000</code></li><li><code>boxes[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力或者前缀和</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>双层循环暴力解法很简单，只需要判断所有的小球与当前的位置<code>i</code>之间的距离之和求出即可，时间复杂度为$O(N^{2})$，如果题目中给定的数量级过大时，则$O(N^{2})$肯定会超时.</li><li>前缀和后缀和的求法，我们设<code>left[i]</code>表示将前 <code>i</code>个盒子的球移动到第<code>i</code>个盒子所需要的操作步数，我们设<code>sumleft[i]</code>表示前<code>i</code>个盒子的球的总数目；<code>right[i]</code>代表将位置<code>i</code>以后的球全部移动到第<code>i</code>个盒子的最小移动步数，我们设<code>sumright[i]</code>代表所有大于等于<code>i</code>位置的盒子的球的总数目，则我们可以知道：<script type="math/tex; mode=display">left[i] = left[i-1] + sumleft[i-1] \\right[i] = right[i-1] + sumright[i-1] \\answer[i] = left[i] + right[i] \\</script></li><li>时间复杂度为$O(N)$,空间复杂度为$O(N)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minOperations(<span class="built_in">string</span> boxes) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = boxes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                left[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left[i] = left[i<span class="number">-1</span>] + sum;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += boxes[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n<span class="number">-1</span>)&#123;</span><br><span class="line">                right[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right[i] = right[i+<span class="number">1</span>] + sum;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += boxes[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                ans[i]  = right[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n<span class="number">-1</span>)&#123;</span><br><span class="line">                ans[i]  = left[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i] = left[i] + right[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5687-执行乘法运算的最大分数"><a href="#5687-执行乘法运算的最大分数" class="headerlink" title="5687. 执行乘法运算的最大分数"></a>5687. 执行乘法运算的最大分数</h2><p>给你两个长度分别 <code>n</code> 和 <code>m</code>的整数数组 <code>nums</code> 和 <code>multipliers</code> ，其中 <code>n &gt;= m</code>，数组下标 从<code>1</code>开始 计数。</p><p>初始时，你的分数为 0 。你需要执行恰好 m 步操作。在第 i 步操作（从 1 开始 计数）中，需要：</p><p>选择数组 <code>nums</code>开头处或者末尾处 的整数 x 。<br>你获得 <code>multipliers[i] * x</code>分，并累加到你的分数中。<br>将 x 从数组 nums 中移除。<br>在执行 m 步操作后，返回 最大 分数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], multipliers = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">解释：一种最优解决方案如下：</span><br><span class="line">- 选择末尾处的整数 <span class="number">3</span> ，[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，得 <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span> 分，累加到分数中。</span><br><span class="line">- 选择末尾处的整数 <span class="number">2</span> ，[<span class="number">1</span>,<span class="number">2</span>] ，得 <span class="number">2</span> * <span class="number">2</span> = <span class="number">4</span> 分，累加到分数中。</span><br><span class="line">- 选择末尾处的整数 <span class="number">1</span> ，[<span class="number">1</span>] ，得 <span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span> 分，累加到分数中。</span><br><span class="line">总分数为 <span class="number">9</span> + <span class="number">4</span> + <span class="number">1</span> = <span class="number">14</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-5</span>,<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>], multipliers = [<span class="number">-10</span>,<span class="number">-5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">102</span></span><br><span class="line">解释：一种最优解决方案如下：</span><br><span class="line">- 选择开头处的整数 <span class="number">-5</span> ，[<span class="number">-5</span>,<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>] ，得 <span class="number">-5</span> * <span class="number">-10</span> = <span class="number">50</span> 分，累加到分数中。</span><br><span class="line">- 选择开头处的整数 <span class="number">-3</span> ，[<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>] ，得 <span class="number">-3</span> * <span class="number">-5</span> = <span class="number">15</span> 分，累加到分数中。</span><br><span class="line">- 选择开头处的整数 <span class="number">-3</span> ，[<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>] ，得 <span class="number">-3</span> * <span class="number">3</span> = <span class="number">-9</span> 分，累加到分数中。</span><br><span class="line">- 选择末尾处的整数 <span class="number">1</span> ，[<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>] ，得 <span class="number">1</span> * <span class="number">4</span> = <span class="number">4</span> 分，累加到分数中。</span><br><span class="line">- 选择末尾处的整数 <span class="number">7</span> ，[<span class="number">-2</span>,<span class="number">7</span>] ，得 <span class="number">7</span> * <span class="number">6</span> = <span class="number">42</span> 分，累加到分数中。</span><br><span class="line">总分数为 <span class="number">50</span> + <span class="number">15</span> - <span class="number">9</span> + <span class="number">4</span> + <span class="number">42</span> = <span class="number">102</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>m == multipliers.length</code></li><li><code>1 &lt;= m &lt;= 103</code></li><li><code>m &lt;= n &lt;= 105</code></li><li><code>-1000 &lt;= nums[i], multipliers[i] &lt;= 1000</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-from-performing-multiplication-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-from-performing-multiplication-operations</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的<code>dp</code>解法，我们设<code>dp[i][j]</code>表示前<code>i</code>个数中有<code>j</code>个数是从<code>nums</code>数组中左边进行选取，有<code>i-j</code>个数是从<code>nums</code>数组中右边进行选取的所得到的最大结果，则我们可以知道递推公式如下：<script type="math/tex; mode=display">dp[i][j] = max(dp[i-1][j] + nums[n-(i-j)]*multipliers[i-1],dp[i-1][j-1] + nums[j-1]*multipliers[i-1]);</script>要么第<code>i</code>个数从左边取，要么第<code>i</code>个数从右边取，</li></ol><ul><li>假设第<code>i</code>个数从数组左边取的话，则表示当前肯定已经从左边去了<code>j-1</code>个数，则此时我们需要从数组左边选取第<code>j</code>个数即为<code>nums[j-1]</code>与<code>multipliers[i-1]</code>进行相乘，我们可以知道此时递推关系如下：<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1] + nums[j-1]*multipliers[i-1]</script></li><li>假设第<code>i</code>个数从数组右边取的话，则表示当前肯定已经从左边去了<code>j</code>个数，则此时我们需要从数组的右边选取，我们知道当前右边已经选取了<code>i-1-j</code>个数，则此时我们需要选取右边第<code>i-j</code>个数即为<code>nums[n-(i-j)]</code>，则我们可以知道此时递推关系如下：<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1] + nums[n-(i-j)]*multipliers[i-1]</script></li></ul><ol><li>时间复杂度为$O(N^{2})$,空间复杂度为$O(N^{2})$,当然我们可以继续优化空间复杂度为$O(N)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; multipliers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = multipliers.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[n-i]*multipliers[i<span class="number">-1</span>];</span><br><span class="line">            dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>] + nums[i<span class="number">-1</span>]*multipliers[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j] + nums[n-(i-j)]*multipliers[i<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + nums[j<span class="number">-1</span>]*multipliers[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[m][i]);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5688-由子序列构造的最长回文串的长度"><a href="#5688-由子序列构造的最长回文串的长度" class="headerlink" title="5688. 由子序列构造的最长回文串的长度"></a>5688. 由子序列构造的最长回文串的长度</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> ，请你按下述方法构造一个字符串：</p><ul><li>从 <code>word1</code> 中选出某个 非空 子序列 <code>subsequence1</code> 。</li><li>从 <code>word2</code> 中选出某个 非空 子序列 <code>subsequence2</code> 。<br>连接两个子序列 <code>subsequence1 + subsequence2</code>，得到字符串。<br>返回可按上述方法构造的最长 回文串 的 长度 。如果无法构造回文串，返回 0 。</li></ul><p>字符串 <code>s</code> 的一个 子序列 是通过从 s 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。</p><p>回文串 是正着读和反着读结果一致的字符串。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">"cacb"</span>, <span class="attr">word2</span> = <span class="string">"cbba"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：从 word1 中选出 <span class="string">"ab"</span> ，从 word2 中选出 <span class="string">"cba"</span> ，得到回文串 <span class="string">"abcba"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">"ab"</span>, <span class="attr">word2</span> = <span class="string">"ab"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：从 word1 中选出 <span class="string">"ab"</span> ，从 word2 中选出 <span class="string">"a"</span> ，得到回文串 <span class="string">"aba"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"aa"</span>, word2 = <span class="string">"bb"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无法按题面所述方法构造回文串，所以返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 1000</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximize-palindrome-length-from-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximize-palindrome-length-from-subsequences</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p><code>dp</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>拿到题目的时候首先想到的就是求字符串的最长的回文子串，这个解法非常经典的<code>dp</code>，一般都能先到出来，本题的重点在于如何选择的字串都为非空。</li><li>首先我们想到的是将字符串<code>1</code>和字符串<code>2</code>进行合并，然后求出最大的回文子串，但是如何确定目标回文串的两端横跨两个字符串，其实原理很简单，我们只需要判断目标回文字符串的两端的字符位置即可.我们设字符串<code>1</code>的长度为<code>l1</code>，字符串<code>2</code>的长度为<code>l2</code>，则此时我们只需要判断最左边的字符的位置是否在<code>[0,l1)</code>之间，最右边的字符是否在<code>[l1,l1+l2)</code>之间，即满足如下条件:<script type="math/tex; mode=display">0 \le C_{l} < l1 \\l1 \le C_{r} < l1+l2</script></li><li>求字符串的最大回文子串的长度很简单，用<code>dp</code>实现即可：<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j-1],dp[i+1][j]) \\dp[i][j] = dp[i+1][j-1] + 2 \qquad if(s[i] == s[j])</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = word1 + word2;</span><br><span class="line">        <span class="keyword">int</span> l1 = word1.size();</span><br><span class="line">        <span class="keyword">int</span> l2 = word2.size();</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">1</span>));            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j+i &lt; n; ++j)&#123;</span><br><span class="line">                dp[j][j+i] = max(dp[j][j+i<span class="number">-1</span>],dp[j+<span class="number">1</span>][j+i]);</span><br><span class="line">                <span class="keyword">if</span>(s[j] == s[j+i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                        dp[j][j+i] = <span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[j][j+i] = max(dp[j][j+i],dp[j+<span class="number">1</span>][j+i<span class="number">-1</span>] + <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; l1 &amp;&amp; (j+i) &gt;= l1)&#123;</span><br><span class="line">                        ans = max(ans,dp[j][j+i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-229&quot;&gt;&lt;a href=&quot;#leetcode-contest-229&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 229&quot;&gt;&lt;/a&gt;leetcode contest 229&lt;/h1&gt;&lt;p&gt;本周的周赛的题目确实出乎意外的简单，竟然全部都&lt;code&gt;AK&lt;/code&gt;了，排名还可以，竟然排名&lt;code&gt;52&lt;/code&gt;名.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/22/YPfB63l2RzmX7rE.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5685-交替合并字符串&quot;&gt;&lt;a href=&quot;#5685-交替合并字符串&quot; class=&quot;headerlink&quot; title=&quot;5685. 交替合并字符串&quot;&gt;&lt;/a&gt;5685. 交替合并字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt; 。请你从 &lt;code&gt;word1&lt;/code&gt; 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。&lt;br&gt;返回 合并后的字符串 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 46</title>
    <link href="http://yoursite.com/2021/02/18/255/"/>
    <id>http://yoursite.com/2021/02/18/255/</id>
    <published>2021-02-18T03:50:37.013Z</published>
    <updated>2021-02-20T16:28:52.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-46"><a href="#leetcode-biweekly-contest-46" class="headerlink" title="leetcode biweekly contest 46"></a>leetcode biweekly contest 46</h1><p>本周双周赛的题目确实出乎意外的简单，最后一题<code>hard</code>难度竟然暴力<code>dfs</code>搞定，意外的进入了前<code>100</code>.<br><img src="https://i.loli.net/2021/02/21/4qkwW1O5ChIxrb9.png" alt></p><h2 id="5668-最长的美好子字符串"><a href="#5668-最长的美好子字符串" class="headerlink" title="5668. 最长的美好子字符串"></a>5668. 最长的美好子字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>当一个字符串 <code>s</code> 包含的每一种字母的大写和小写形式 同时 出现在 <code>s</code> 中，就称这个字符串 s 是 美好 字符串。比方说，<code>&quot;abABB&quot;</code>是美好字符串，因为 <code>&#39;A&#39;</code>和<code>&#39;a&#39;</code>同时出现了，且 <code>&#39;B&#39;</code> 和 <code>&#39;b&#39;</code>也同时出现了。然而，<code>&quot;abA&quot;</code>不是美好字符串因为 <code>&#39;b&#39;</code>出现了，而 <code>&#39;B&#39;</code>没有出现。</p><a id="more"></a><p>给你一个字符串 s ，请你返回 <code>s</code> 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"YazaAay"</span></span><br><span class="line">输出：<span class="string">"aAa"</span></span><br><span class="line">解释：<span class="string">"aAa"</span> 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。</span><br><span class="line"><span class="string">"aAa"</span> 是最长的美好子字符串。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"Bb"</span></span><br><span class="line">输出：<span class="string">"Bb"</span></span><br><span class="line">解释：<span class="string">"Bb"</span> 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"c"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：没有美好子字符串。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"dDzeE"</span></span><br><span class="line">输出：<span class="string">"dD"</span></span><br><span class="line">解释：<span class="string">"dD"</span> 和 <span class="string">"eE"</span> 都是最长美好子字符串。</span><br><span class="line">由于有多个美好子字符串，返回 <span class="string">"dD"</span> ，因为它出现得最早。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code>只包含大写和小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题,直接暴力或者前缀和什么的</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力求出每个连续的子字符串是否符合美好字符串即可，分别记录所有的大写字母和小写字符的统计次数。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestNiceSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> maxN = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum[<span class="number">101</span>][<span class="number">26</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; arr1(<span class="number">26</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; arr2(<span class="number">26</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] &gt;= <span class="string">'a'</span> &amp;&amp; s[j] &lt;= <span class="string">'z'</span>) arr1[s[j]-<span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[j] &gt;= <span class="string">'A'</span> &amp;&amp; s[j] &lt;= <span class="string">'Z'</span>) arr2[s[j]-<span class="string">'A'</span>] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!arr1[k] &amp;&amp; !arr2[k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!arr1[k])&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!arr2[k])&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; maxN)&#123;</span><br><span class="line">                        ans = s.substr(i,j-i+<span class="number">1</span>);</span><br><span class="line">                        maxN = j - i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5669-通过连接另一个数组的子数组得到一个数组"><a href="#5669-通过连接另一个数组的子数组得到一个数组" class="headerlink" title="5669. 通过连接另一个数组的子数组得到一个数组"></a>5669. 通过连接另一个数组的子数组得到一个数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的二维整数数组<code>groups</code>，同时给你一个整数数组 <code>nums</code> 。</p><p>你是否可以从 <code>nums</code> 中选出 <code>n</code> 个 不相交 的子数组，使得第 <code>i</code> 个子数组与 <code>groups[i]</code> （下标从 0 开始）完全相同，且如果<code>i &gt; 0</code>，那么第 <code>(i-1)</code>个子数组在 <code>nums</code>中出现的位置在第 i 个子数组前面。（也就是说，这些子数组在 <code>nums</code> 中出现的顺序需要与 groups 顺序相同）</p><p>如果你可以找出这样的 <code>n</code>个子数组，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>如果不存在下标为 <code>k</code>的元素 <code>nums[k]</code>属于不止一个子数组，就称这些子数组是 不相交 的。子数组指的是原数组中连续元素组成的一个序列。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：groups = [[<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>],[<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>]], nums = [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：你可以分别在 nums 中选出第 <span class="number">0</span> 个子数组 [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>] 和第 <span class="number">1</span> 个子数组 [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>] 。</span><br><span class="line">这两个子数组是不相交的，因为它们没有任何共同的元素。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：groups = [[<span class="number">10</span>,<span class="number">-2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]], nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">-2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：选择子数组 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">-2</span>] 和 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">-2</span>] 是不正确的，因为它们出现的顺序与 groups 中顺序不同。</span><br><span class="line">[<span class="number">10</span>,<span class="number">-2</span>] 必须出现在 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 之前。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：groups = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]], nums = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：选择子数组 [<span class="number">7</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">7</span>] 和 [<span class="number">7</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">7</span>] 是不正确的，因为它们不是不相交子数组。</span><br><span class="line">它们有一个共同的元素 nums[<span class="number">4</span>] （下标从 <span class="number">0</span> 开始）。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>groups.length == n</code></li><li><code>1 &lt;= n &lt;= 103</code></li><li><code>1 &lt;= groups[i].length, sum(groups[i].length) &lt;= 103</code></li><li><code>1 &lt;= nums.length &lt;= 103</code></li><li><code>-107 &lt;= groups[i][j], nums[k] &lt;= 107</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-46/problems/form-array-by-concatenating-subarrays-of-another-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-46/problems/form-array-by-concatenating-subarrays-of-another-array/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力双指针即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>一个指针<code>l1</code>指向<code>group</code>,另一个指针<code>l2</code>指向<code>nums</code>,我们判断当前l2指向的<code>group</code>数组是否满足当前<code>l2</code>指针指向的与<code>group[l1]</code>数组长度相等的连续子数组，如果相等我们将两个指针变换为：<code>l2 = l2 + len(group[l1])</code>,<code>l1 = l1 + 1</code>;如果不相等我们则将指针<code>l2</code>变换为<code>l2 = l2 + 1</code>.</li><li>最终判定指针<code>l1</code>是否等于<code>n</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canChoose</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; groups, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = groups.size();</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; n &amp;&amp; l2 &lt; m)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; groups[l1].size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>((l2 + i) &gt;= m || groups[l1][i] != nums[l2+i])&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                l2 = l2 + groups[l1].size();</span><br><span class="line">                l1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5671-地图中的最高点"><a href="#5671-地图中的最高点" class="headerlink" title="5671. 地图中的最高点"></a>5671. 地图中的最高点</h2><p>给你一个大小为 <code>m x n</code>的整数矩阵 <code>isWater</code> ，它代表了一个由 陆地 和 水域 单元格组成的地图。</p><ul><li>如果 <code>isWater[i][j] == 0</code>，格子 <code>(i, j)</code>是一个 陆地 格子。</li><li>如果 <code>isWater[i][j] == 1</code> ，格子 <code>(i, j)</code> 是一个 水域 格子。<br>你需要按照如下规则给每个单元格安排高度：</li></ul><p>每个格子的高度都必须是非负的。<br>如果一个格子是是 水域 ，那么它的高度必须为 0 。<br>任意相邻的格子高度差 至多 为 <code>1</code> 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）<br>找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。<br>请你返回一个大小为 <code>m x n</code>的整数矩阵 <code>height</code> ，其中<code>height[i][j]</code>是格子<code>(i, j)</code> 的高度。如果有多种解法，请返回 任意一个 。</p><p>示例 1：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：isWater = <span class="string">[[0,1],[0,0]]</span></span><br><span class="line">输出：<span class="string">[[1,0],[2,1]]</span></span><br><span class="line">解释：上图展示了给各个格子安排的高度。</span><br><span class="line">蓝色格子是水域格，绿色格子是陆地格。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：isWater = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">解释：所有安排方案中，最高可行高度为 <span class="number">2</span> 。</span><br><span class="line">任意安排方案中，只要最高高度为 <span class="number">2</span> 且符合上述规则的，都为可行方案。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == isWater.length</code></li><li><code>n == isWater[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>isWater[i][j]</code> 要么是 <code>0</code> ，要么是 <code>1</code>。</li><li>至少有 <code>1</code>个水域格子。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的<code>bfs</code>我们知道水域的高度肯定为<code>0</code>,那么紧挨着水域的格子最大为<code>1</code>,则紧紧挨着<code>1</code>的陆地最大也只能为<code>2</code>，依次下去，我们可以推出紧挨着高度为<code>n</code>的陆地的最大高度也只能为<code>n+1</code>。所以典型的层次的<code>bfs</code>。</li><li>我们将水域的高度初始化为<code>0</code>，同时将其进入队列，每次出队列时将周边为进行紧挨着的四个陆地设置为当前格子的高度加<code>1</code>。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; highestPeak(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isWater) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = isWater.size();</span><br><span class="line">        <span class="keyword">int</span> col = isWater[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isWater[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    qu.push(i*col+j);</span><br><span class="line">                    ans[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = (curr/col) + d[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = (curr%col) + d[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans[x][y] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    ans[x][y] = ans[curr/col][curr%col] + <span class="number">1</span>;</span><br><span class="line">                    qu.push(x*col+y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5670-互质树"><a href="#5670-互质树" class="headerlink" title="5670. 互质树"></a>5670. 互质树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 n 个节点的树（也就是一个无环连通无向图），节点编号从 0 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条边，每个节点有一个值。树的 根节点 为 0 号点。</p><p>给你一个整数数组 nums 和一个二维数组 edges 来表示这棵树。<code>nums[i]</code>表示第 i 个点的值，<code>edges[j] = [uj, vj]</code>表示节点 uj 和节点 vj 在树中有一条边。</p><p>当 <code>gcd(x, y) == 1</code> ，我们称两个数 x 和 y 是 互质的 ，其中 <code>gcd(x, y)</code> 是 x 和 y 的 最大公约数 。</p><p>从节点 i 到 根 最短路径上的点都是节点 i 的祖先节点。一个节点 不是 它自己的祖先节点。</p><p>请你返回一个大小为 n 的数组 <code>ans</code>，其中 <code>ans[i]</code>是离节点 i 最近的祖先节点且满足 <code>nums[i]</code>和 <code>nums[ans[i]]</code> 是 互质的 ，如果不存在这样的祖先节点，<code>ans[i]</code> 为 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：上图中，每个节点的值在括号中表示。</span><br><span class="line">- 节点 <span class="number">0</span> 没有互质祖先。</span><br><span class="line">- 节点 <span class="number">1</span> 只有一个祖先节点 <span class="number">0</span> 。它们的值是互质的（gcd(<span class="number">2</span>,<span class="number">3</span>) == <span class="number">1</span>）。</span><br><span class="line">- 节点 <span class="number">2</span> 有两个祖先节点，分别是节点 <span class="number">1</span> 和节点 <span class="number">0</span> 。节点 <span class="number">1</span> 的值与它的值不是互质的（gcd(<span class="number">3</span>,<span class="number">3</span>) == <span class="number">3</span>）但节点 <span class="number">0</span> 的值是互质的(gcd(<span class="number">2</span>,<span class="number">3</span>) == <span class="number">1</span>)，所以节点 <span class="number">0</span> 是最近的符合要求的祖先节点。</span><br><span class="line">- 节点 <span class="number">3</span> 有两个祖先节点，分别是节点 <span class="number">1</span> 和节点 <span class="number">0</span> 。它与节点 <span class="number">1</span> 互质（gcd(<span class="number">3</span>,<span class="number">2</span>) == <span class="number">1</span>），所以节点 <span class="number">1</span> 是离它最近的符合要求的祖先节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">15</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>nums.length == n</code></li><li><code>1 &lt;= nums[i] &lt;= 50</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[j].length == 2</code></li><li><code>0 &lt;= uj, vj &lt; n</code></li><li><code>uj != vj</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-46/problems/tree-of-coprimes/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-46/problems/tree-of-coprimes/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p><code>DFS</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目感觉很怪异，不过最关键的在于<code>1 &lt;= nums[i] &lt;= 50</code>，存在这一条我们就可以使用暴力<code>dfs</code>了。</li><li><code>dfs</code>时保存当前节点的所有祖先节点的值，并存放该值的最大深度和节点编号，遍历到当前节点时，我们通过遍历其所有的祖先节点的值，并找到最大的深度且与当前节点的值为互质的即可，本质上没有多少难度，可以用<code>map</code>或者数组保存祖先节点的值均可。唯一需要注意的是，我们每次在更新节点祖先的值时，如果当前节点的值已经与祖先节点重复时，我们在遍历完成<code>dfs</code>遍历当前节点的所有的孩子节点后，要进行恢复。</li><li>时间复杂度为$O(max(nums)<em>N)$,空间复杂度为$O(2</em>N)$,感觉没有多少技巧和难度可言。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> curr,<span class="keyword">int</span> depth,<span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; graph,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,pii&gt; &amp; fa,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; ret)</span></span>&#123;</span><br><span class="line">        ret[curr] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : fa)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second.first &gt; dis &amp;&amp; __gcd(v.first,arr[curr]) == <span class="number">1</span>)&#123;</span><br><span class="line">                ret[curr] = v.second.second;</span><br><span class="line">                dis = v.second.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pii last;</span><br><span class="line">        <span class="keyword">bool</span> repeat = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(fa.count(arr[curr]))&#123;</span><br><span class="line">            repeat = <span class="literal">true</span>;</span><br><span class="line">            last = fa[arr[curr]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fa[arr[curr]] = make_pair(depth,curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == root) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(curr,v,depth+<span class="number">1</span>,graph,fa,ret);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(repeat)&#123;</span><br><span class="line">            fa[arr[curr]] = last;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fa.erase(arr[curr]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getCoprimes(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,pii&gt; fa;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        arr = nums;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].insert(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].insert(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,graph,fa,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-46&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-46&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 46&quot;&gt;&lt;/a&gt;leetcode biweekly contest 46&lt;/h1&gt;&lt;p&gt;本周双周赛的题目确实出乎意外的简单，最后一题&lt;code&gt;hard&lt;/code&gt;难度竟然暴力&lt;code&gt;dfs&lt;/code&gt;搞定，意外的进入了前&lt;code&gt;100&lt;/code&gt;.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/21/4qkwW1O5ChIxrb9.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5668-最长的美好子字符串&quot;&gt;&lt;a href=&quot;#5668-最长的美好子字符串&quot; class=&quot;headerlink&quot; title=&quot;5668. 最长的美好子字符串&quot;&gt;&lt;/a&gt;5668. 最长的美好子字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;当一个字符串 &lt;code&gt;s&lt;/code&gt; 包含的每一种字母的大写和小写形式 同时 出现在 &lt;code&gt;s&lt;/code&gt; 中，就称这个字符串 s 是 美好 字符串。比方说，&lt;code&gt;&amp;quot;abABB&amp;quot;&lt;/code&gt;是美好字符串，因为 &lt;code&gt;&amp;#39;A&amp;#39;&lt;/code&gt;和&lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt;同时出现了，且 &lt;code&gt;&amp;#39;B&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt;也同时出现了。然而，&lt;code&gt;&amp;quot;abA&amp;quot;&lt;/code&gt;不是美好字符串因为 &lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt;出现了，而 &lt;code&gt;&amp;#39;B&amp;#39;&lt;/code&gt;没有出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 228</title>
    <link href="http://yoursite.com/2021/02/14/254/"/>
    <id>http://yoursite.com/2021/02/14/254/</id>
    <published>2021-02-14T05:59:22.942Z</published>
    <updated>2021-02-14T07:18:04.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-228"><a href="#leetcode-contest-228" class="headerlink" title="leetcode  contest 228"></a>leetcode  contest 228</h1><p>本周的周赛题目确实都非常简单，第四题竟然暴力就能过了，完全只能算是<code>mid</code>难度的题目，不过竟然第三题没有想出用二分查找的方法来解题。<br><img src="https://i.loli.net/2021/02/14/IyFxT79gj8OYsRG.png" alt></p><h2 id="5676-生成交替二进制字符串的最少操作数"><a href="#5676-生成交替二进制字符串的最少操作数" class="headerlink" title="5676. 生成交替二进制字符串的最少操作数"></a>5676. 生成交替二进制字符串的最少操作数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个仅由字符<code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串<code>s</code>。一步操作中，你可以将任一 ‘0’ 变成 ‘1’ ，或者将 ‘1’ 变成 ‘0’ 。</p><a id="more"></a><p>交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>&quot;010&quot;</code>是交替字符串，而字符串 <code>&quot;0100&quot;</code>不是。</p><p>返回使 <code>s</code> 变成 交替字符串 所需的 最少 操作数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"0100"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：如果将最后一个字符变为 '<span class="number">1</span>' ，s 就变成 <span class="string">"0101"</span> ，即符合交替字符串定义。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"10"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：s 已经是交替字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1111"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：需要 <span class="number">2</span> 步操作得到 <span class="string">"0101"</span> 或 <span class="string">"1010"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s[i]</code> 是 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>两种<code>0</code>,<code>1</code>交替的方式分别计算替换次数，返回最小的替换次数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]-<span class="string">'0'</span>)%<span class="number">2</span> != (i%<span class="number">2</span>))&#123;</span><br><span class="line">                l1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> min(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5677-统计同构子字符串的数目"><a href="#5677-统计同构子字符串的数目" class="headerlink" title="5677. 统计同构子字符串的数目"></a>5677. 统计同构子字符串的数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，返回 <code>s</code>中 同构子字符串 的数目。由于答案可能很大，只需返回对 <code>109 + 7</code>取余 后的结果。<br>同构字符串 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。<br>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abbcccaa"</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：同构子字符串如下所列：</span><br><span class="line"><span class="string">"a"</span>   出现 <span class="number">3</span> 次。</span><br><span class="line"><span class="string">"aa"</span>  出现 <span class="number">1</span> 次。</span><br><span class="line"><span class="string">"b"</span>   出现 <span class="number">2</span> 次。</span><br><span class="line"><span class="string">"bb"</span>  出现 <span class="number">1</span> 次。</span><br><span class="line"><span class="string">"c"</span>   出现 <span class="number">3</span> 次。</span><br><span class="line"><span class="string">"cc"</span>  出现 <span class="number">2</span> 次。</span><br><span class="line"><span class="string">"ccc"</span> 出现 <span class="number">1</span> 次。</span><br><span class="line"><span class="number">3</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">13</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"xy"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：同构子字符串是 <span class="string">"x"</span> 和 <span class="string">"y"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"zzzzz"</span></span><br><span class="line">输出：<span class="number">15</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 由小写字符串组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-homogenous-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-number-of-homogenous-substrings</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>求出连续相同字符子串的长度<code>n</code>,次数可能的异构子字符串的数目为$\frac{n*(n+1)}{2}$.</li><li>求出所有连续相同字符串的所有异构子字符串即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countHomogenous</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == s[curr]) i++;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> m = i - curr;</span><br><span class="line">            ans = (ans + m*(m+<span class="number">1</span>)/<span class="number">2</span>)%mod;</span><br><span class="line">            curr = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5678-袋子里最少数目的球"><a href="#5678-袋子里最少数目的球" class="headerlink" title="5678. 袋子里最少数目的球"></a>5678. 袋子里最少数目的球</h2><p>给你一个整数数组 <code>nums</code> ，其中 <code>nums[i]</code>表示第 i 个袋子里球的数目。同时给你一个整数 <code>maxOperations</code> 。</p><p>你可以进行如下操作至多 <code>maxOperations</code> 次：</p><ul><li>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。</li><li><ul><li>比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。<br>你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。<br>请你返回进行上述操作后的最小开销。</li></ul></li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>], maxOperations = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">- 将装有 <span class="number">9</span> 个球的袋子分成装有 <span class="number">6</span> 个和 <span class="number">3</span> 个球的袋子。[<span class="number">9</span>] -&gt; [<span class="number">6</span>,<span class="number">3</span>] 。</span><br><span class="line">- 将装有 <span class="number">6</span> 个球的袋子分成装有 <span class="number">3</span> 个和 <span class="number">3</span> 个球的袋子。[<span class="number">6</span>,<span class="number">3</span>] -&gt; [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>] 。</span><br><span class="line">装有最多球的袋子里装有 <span class="number">3</span> 个球，所以开销为 <span class="number">3</span> 并返回 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>], maxOperations = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 将装有 <span class="number">8</span> 个球的袋子分成装有 <span class="number">4</span> 个和 <span class="number">4</span> 个球的袋子。[<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将装有 <span class="number">4</span> 个球的袋子分成装有 <span class="number">2</span> 个和 <span class="number">2</span> 个球的袋子。[<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将装有 <span class="number">4</span> 个球的袋子分成装有 <span class="number">2</span> 个和 <span class="number">2</span> 个球的袋子。[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将装有 <span class="number">4</span> 个球的袋子分成装有 <span class="number">2</span> 个和 <span class="number">2</span> 个球的袋子。[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line">装有最多球的袋子里装有 <span class="number">2</span> 个球，所以开销为 <span class="number">2</span> 并返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">17</span>], maxOperations = <span class="number">2</span></span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= maxOperations, nums[i] &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>直接计算的话，感觉这个算法很难写。我们反而利用二分查找的办法很容易实现。</li><li>直接确定测试最终的目表数为<code>x</code>，则次数若要将数<code>n</code>分为划分为全部小于<code>x</code>的整数，则最少需要$\frac{n-1}{x}$次操作，则此时我们每次测试当前可能的最少操作数是否能够满足<code>maxOperations</code>，如果所有需要的操作数小于等于<code>maxOperations</code>，则表示一定可以变换成功，否则则不可能切分成功。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v: nums) curr += (v<span class="number">-1</span>)/mid;</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; maxOperations)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5679-一个图中连通三元组的最小度数"><a href="#5679-一个图中连通三元组的最小度数" class="headerlink" title="5679. 一个图中连通三元组的最小度数"></a>5679. 一个图中连通三元组的最小度数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个无向图，整数 <code>n</code> 表示图中节点的数目，<code>edges</code> 数组表示图中的边，其中 <code>edges[i] = [ui, vi]</code>，表示 <code>ui</code> 和 <code>vi</code>之间有一条无向边。<br>一个 连通三元组 指的是 三个 节点组成的集合且这三个点之间 两两 有边。<br>连通三元组的度数 是所有满足此条件的边的数目：一个顶点在三元组内，而另一个顶点不在三元组内。<br>请你返回所有连通三元组中度数的 最小值 ，如果图中没有连通三元组，那么返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：只有一个三元组 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 。构成度数的边在上图中已被加粗。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">7</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：有 <span class="number">3</span> 个三元组：</span><br><span class="line"><span class="number">1</span>) [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]，度数为 <span class="number">0</span> 。</span><br><span class="line"><span class="number">2</span>) [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]，度数为 <span class="number">2</span> 。</span><br><span class="line"><span class="number">3</span>) [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]，度数为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 400</code></li><li><code>edges[i].length == 2</code></li><li><code>1 &lt;= edges.length &lt;= n * (n-1) / 2</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li>图中没有重复的边。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>刚开始想了半天没有特别好的办法来判别是否为三元组，后来只能硬着头皮试了下暴力,时间复杂度为$O(n^{3})$,竟然过了，感觉太出乎意料了，这种时间复杂度的情况下竟然通过了，不过可以试试计算最大的数据量大概如下：<script type="math/tex; mode=display">T(n) = \sum_{i=1}^{n}\frac{(n-1)*(n-2)}{2} \\= \sum_{i=1}^{n}(\frac{n^{2}}{2} - \frac{3n}{2} + 1) \\= \frac{n*(n+1)*(2n+1)}{12} - \frac{3n*(n+1)}{4} + n</script>如果当<code>n</code>取最大值<code>400</code>时，上述的时间复杂度约为:<script type="math/tex; mode=display">T(400) = 10706700 - 120300 + 400 = 10,586,800</script>感觉时间复杂度应该是卡在边缘地带，但是<code>lc</code>时间判别竟然过了，没有超时。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTrioDegree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; graph(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            edges[i][<span class="number">0</span>]--;</span><br><span class="line">            edges[i][<span class="number">1</span>]--;</span><br><span class="line">            degree[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">            degree[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]][edges[i][<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]][edges[i][<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* three */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!graph[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(graph[i][j] &amp;&amp; graph[j][k]&amp;&amp;graph[i][k])&#123;</span><br><span class="line">                        ans = min(ans,degree[i] + degree[j] + degree[k] - <span class="number">6</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ans == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-228&quot;&gt;&lt;a href=&quot;#leetcode-contest-228&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 228&quot;&gt;&lt;/a&gt;leetcode  contest 228&lt;/h1&gt;&lt;p&gt;本周的周赛题目确实都非常简单，第四题竟然暴力就能过了，完全只能算是&lt;code&gt;mid&lt;/code&gt;难度的题目，不过竟然第三题没有想出用二分查找的方法来解题。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/14/IyFxT79gj8OYsRG.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5676-生成交替二进制字符串的最少操作数&quot;&gt;&lt;a href=&quot;#5676-生成交替二进制字符串的最少操作数&quot; class=&quot;headerlink&quot; title=&quot;5676. 生成交替二进制字符串的最少操作数&quot;&gt;&lt;/a&gt;5676. 生成交替二进制字符串的最少操作数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个仅由字符&lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;1&amp;#39;&lt;/code&gt; 组成的字符串&lt;code&gt;s&lt;/code&gt;。一步操作中，你可以将任一 ‘0’ 变成 ‘1’ ，或者将 ‘1’ 变成 ‘0’ 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 227</title>
    <link href="http://yoursite.com/2021/02/07/253/"/>
    <id>http://yoursite.com/2021/02/07/253/</id>
    <published>2021-02-07T09:16:17.932Z</published>
    <updated>2021-02-14T15:18:42.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-227"><a href="#leetcode-contest-227" class="headerlink" title="leetcode  contest 227"></a>leetcode  contest 227</h1><p>周赛的题目还是挺难的，竟然只做出来了三道题目，最后一题还是没有能够做出来。</p><h2 id="5672-检查数组是否经排序和轮转得到"><a href="#5672-检查数组是否经排序和轮转得到" class="headerlink" title="5672. 检查数组是否经排序和轮转得到"></a>5672. 检查数组是否经排序和轮转得到</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code> 。<code>nums</code> 的源数组中，所有元素与 <code>nums</code>相同，但按非递减顺序排列。</p><p>如果 <code>nums</code> 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 <code>true</code>；否则，返回 <code>false</code> 。</p><a id="more"></a><p>源数组中可能存在 重复项 。</p><p>注意：我们称数组 <code>A</code> 在轮转 <code>x</code> 个位置后得到长度相同的数组 B ，当它们满足<code>A[i] == B[(i+x) % A.length]</code>，其中 % 为取余运算。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 为有序的源数组。</span><br><span class="line">可以轮转 x = <span class="number">3</span> 个位置，使新数组从值为 <span class="number">3</span> 的元素开始：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：源数组无法经轮转得到 nums 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 为有序的源数组。</span><br><span class="line">可以轮转 x = <span class="number">0</span> 个位置（即不轮转）得到 nums 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 为有序的源数组。</span><br><span class="line">轮转任意个位置都可以得到 nums 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>] 为有序的源数组。</span><br><span class="line">可以轮转 x = <span class="number">5</span> 个位置，使新数组从值为 <span class="number">2</span> 的元素开始：[<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-array-is-sorted-and-rotated" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-array-is-sorted-and-rotated</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>判断数字的连续大小问题，如果数组的前半部分连续升序和后半部分连续升序，即可判断该数组可以通过旋转得到目标数组。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            mid = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &lt; n <span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5673-移除石子的最大得分"><a href="#5673-移除石子的最大得分" class="headerlink" title="5673. 移除石子的最大得分"></a>5673. 移除石子的最大得分</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你正在玩一个单人游戏，面前放置着大小分别为 <code>a</code>​​​​​​、<code>b</code> 和 <code>c</code>​​​​​​ 的 三堆 石子。</p><p>每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。</p><p>给你三个整数 <code>a</code> 、<code>b</code> 和 <code>c</code> ，返回可以得到的 最大分数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">2</span>, b = <span class="number">4</span>, c = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：石子起始状态是 (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>) ，最优的一组操作是：</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">总分：<span class="number">6</span> 分 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">4</span>, b = <span class="number">4</span>, c = <span class="number">6</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：石子起始状态是 (<span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>) ，最优的一组操作是：</span><br><span class="line">- 从第一和第二堆取，石子状态现在是 (<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">总分：<span class="number">7</span> 分 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">1</span>, b = <span class="number">8</span>, c = <span class="number">8</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：最优的一组操作是连续从第二和第三堆取 <span class="number">8</span> 回合，直到将它们取空。</span><br><span class="line">注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= a, b, c &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-from-removing-stones/solution/tan-xin-you-xian-dui-lie-by-sheeeeeeep-t-awzc/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-from-removing-stones/solution/tan-xin-you-xian-dui-lie-by-sheeeeeeep-t-awzc/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质为数学问题，首先我们将<code>a</code>,<code>b</code>,<code>c</code>按照大小进行排序，我们来分为两种情况看待：</li></ol><ul><li><code>a+b &lt;= c</code>: 则此时我们可以知道最多的得分肯定为$min(a+b,c)$;</li><li><code>a+b &gt; c</code>: 此时我们需要思考一下，我们可以将<code>a,b，c</code>总的组合种进行每次减<code>2</code>操作，总的结果肯定应该等于$\frac{a+b+c}{2}$;<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = a + b + c;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        arr.push_back(a);</span><br><span class="line">        arr.push_back(b);</span><br><span class="line">        arr.push_back(c);</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>] + arr[<span class="number">1</span>] &lt;= arr[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>] + arr[<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sum/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5674-构造字典序最大的合并字符串"><a href="#5674-构造字典序最大的合并字符串" class="headerlink" title="5674. 构造字典序最大的合并字符串"></a>5674. 构造字典序最大的合并字符串</h2><p>给你两个字符串 <code>word1</code> 和 <code>word2</code>。你需要按下述方式构造一个新字符串 <code>merge</code> ：如果 <code>word1</code> 或 <code>word2</code> 非空，选择 下面选项之一 继续操作：</p><ul><li>如果 <code>word1</code> 非空，将 <code>word1</code>中的第一个字符附加到 <code>merge</code> 的末尾，并将其从<code>word1</code>中移除。<br>例如，<code>word1 = &quot;abc&quot;</code> 且 <code>merge = &quot;dv&quot;</code> ，在执行此选项操作之后，<code>word1 = &quot;bc&quot;</code> ，同时 <code>merge = &quot;dva&quot;</code>。<br>如果 <code>word2</code> 非空，将 <code>word2</code>中的第一个字符附加到<code>merge</code>的末尾，并将其从 <code>word2</code>中移除。</li><li>例如，<code>word2 = &quot;abc&quot;</code>且 <code>merge = &quot;&quot;</code>，在执行此选项操作之后，<code>word2 = &quot;bc&quot;</code> ，同时 <code>merge = &quot;a&quot;</code>。<br>返回你可以构造的字典序 最大 的合并字符串 <code>merge</code>。</li></ul><p>长度相同的两个字符串 a 和 b 比较字典序大小，如果在 a 和 b 出现不同的第一个位置，a 中字符在字母表中的出现顺序位于 b 中相应字符之后，就认为字符串 a 按字典序比字符串 b 更大。例如，<code>&quot;abcd&quot;</code>按字典序比 <code>&quot;abcc&quot;</code> 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 d 在字母表中的出现顺序位于 c 之后。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">"cabaa"</span>, <span class="attr">word2</span> = <span class="string">"bcaaa"</span></span><br><span class="line">输出：<span class="string">"cbcabaaaaa"</span></span><br><span class="line">解释：构造字典序最大的合并字符串，可行的一种方法如下所示：</span><br><span class="line">- 从 word1 中取第一个字符：<span class="attr">merge</span> = <span class="string">"c"</span>，<span class="attr">word1</span> = <span class="string">"abaa"</span>，<span class="attr">word2</span> = <span class="string">"bcaaa"</span></span><br><span class="line">- 从 word2 中取第一个字符：<span class="attr">merge</span> = <span class="string">"cb"</span>，<span class="attr">word1</span> = <span class="string">"abaa"</span>，<span class="attr">word2</span> = <span class="string">"caaa"</span></span><br><span class="line">- 从 word2 中取第一个字符：<span class="attr">merge</span> = <span class="string">"cbc"</span>，<span class="attr">word1</span> = <span class="string">"abaa"</span>，<span class="attr">word2</span> = <span class="string">"aaa"</span></span><br><span class="line">- 从 word1 中取第一个字符：<span class="attr">merge</span> = <span class="string">"cbca"</span>，<span class="attr">word1</span> = <span class="string">"baa"</span>，<span class="attr">word2</span> = <span class="string">"aaa"</span></span><br><span class="line">- 从 word1 中取第一个字符：<span class="attr">merge</span> = <span class="string">"cbcab"</span>，<span class="attr">word1</span> = <span class="string">"aa"</span>，<span class="attr">word2</span> = <span class="string">"aaa"</span></span><br><span class="line">- 将 word1 和 word2 中剩下的 <span class="number">5</span> 个 a 附加到 merge 的末尾。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">"abcabc"</span>, <span class="attr">word2</span> = <span class="string">"abdcaba"</span></span><br><span class="line">输出：<span class="string">"abdcabcabcaba"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 3000</code></li><li><code>word1</code> 和 <code>word2</code>仅由小写英文组成</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-merge-of-two-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-merge-of-two-strings/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目刚开始写错了，首先我们分析一下，采用双指针<code>l1,l2</code>分别指向字符串<code>word1</code>和字符串<code>word2</code>，如果当前字符满足$word1[l1] &gt; word2[l2]$,则我们将<code>l1 + 1</code>；如果当前满足$word1[l1] &lt; word2[l2]$,则此时我们将<code>l2 + 1</code>；如果满足$word1[l1] = word2[l2]$时，此时我们到底是选择<code>l1 + 1</code>还是<code>l2+1</code>,这个是值得思考的问题。</li><li>此时我们根据贪心算法，选择剩余的字符串的字典序最大的优先选择，解法很简单，但是感觉证明还是挺难的，不过后来还是仔细思考了一下，想通了这个题目如何证明通过此贪心法得到的结果即为最优解，可以通过反证法即可。</li><li>时间复杂度为$O(n^{2})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestMerge</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; word1.size() &amp;&amp; l2 &lt; word2.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.substr(l1) &gt; word2.substr(l2))&#123;</span><br><span class="line">                ans.push_back(word1[l1]);</span><br><span class="line">                l1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(word2[l2]);</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; word1.size())&#123;</span><br><span class="line">            ans.push_back(word1[l1]);</span><br><span class="line">            l1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 &lt; word2.size())&#123;</span><br><span class="line">            ans.push_back(word2[l2]);</span><br><span class="line">            l2++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1755-最接近目标值的子序列和"><a href="#1755-最接近目标值的子序列和" class="headerlink" title="1755. 最接近目标值的子序列和"></a>1755. 最接近目标值的子序列和</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 和一个目标值<code>goal</code> 。<br>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 sum ，你需要 最小化绝对差 <code>abs(sum - goal)</code> 。<br>返回 <code>abs(sum - goal)</code> 可能的 最小值 。<br>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">-7</span>,<span class="number">3</span>,<span class="number">5</span>], goal = <span class="number">6</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：选择整个数组作为选出的子序列，元素和为 <span class="number">6</span> 。</span><br><span class="line">子序列和与目标值相等，所以绝对差为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">-9</span>,<span class="number">15</span>,<span class="number">-2</span>], goal = <span class="number">-5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：选出子序列 [<span class="number">7</span>,<span class="number">-9</span>,<span class="number">-2</span>] ，元素和为 <span class="number">-4</span> 。</span><br><span class="line">绝对差为 abs(<span class="number">-4</span> - (<span class="number">-5</span>)) = abs(<span class="number">1</span>) = <span class="number">1</span> ，是可能的最小值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], goal = <span class="number">-7</span></span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 40</code></li><li><code>-107 &lt;= nums[i] &lt;= 107</code></li><li><code>-109 &lt;= goal &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/closest-subsequence-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/closest-subsequence-sum</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们假如直接通过暴力求解的话，则可以知道算法的时间复杂度为$O(2^{n})$,此时根据题目中的数据量来看必然会超时，此时我们就需要另辟蹊径去降低时间复杂度。</li><li>我们可以将数据分为长度相等的前后两部分，则此时我们首先可以根据位图来求出前半部分数组的所有的可能的和的组合，我们将前半部分的所有子序列的和按照大小进行排序，则此时我们可以进行遍历后半部分的所有子序列的组合$rsum[i]$时，则我们在前半部分的和中搜索最接近$goal - rsum[i]$的两个数$lowerx,upperx$,则此时我们通过筛选则能够筛选出所有的最可能接近的组合。</li><li>空间复杂度为$O(2^{\frac{n}{2}})$,时间复杂度为$O((\frac{n}{2})^{2}*2^{\frac{n}{2}}$，在此数据量的前提下，时间限制基本可以接受。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">abs</span>(goal);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*left half*/</span></span><br><span class="line">        left.insert(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) sum += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            left.insert(sum);</span><br><span class="line">            ans = min(ans,<span class="built_in">abs</span>(sum-goal));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*right half*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;(n-m)); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) sum += nums[j+m];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> x = goal - sum;</span><br><span class="line">            <span class="keyword">auto</span> it = left.lower_bound(x);</span><br><span class="line">            <span class="keyword">if</span>(it == left.end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(*it + sum - goal));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == left.begin())&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(*it + sum - goal));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(*it + sum - goal));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(*it + sum - goal));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-227&quot;&gt;&lt;a href=&quot;#leetcode-contest-227&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 227&quot;&gt;&lt;/a&gt;leetcode  contest 227&lt;/h1&gt;&lt;p&gt;周赛的题目还是挺难的，竟然只做出来了三道题目，最后一题还是没有能够做出来。&lt;/p&gt;&lt;h2 id=&quot;5672-检查数组是否经排序和轮转得到&quot;&gt;&lt;a href=&quot;#5672-检查数组是否经排序和轮转得到&quot; class=&quot;headerlink&quot; title=&quot;5672. 检查数组是否经排序和轮转得到&quot;&gt;&lt;/a&gt;5672. 检查数组是否经排序和轮转得到&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;code&gt;nums&lt;/code&gt; 的源数组中，所有元素与 &lt;code&gt;nums&lt;/code&gt;相同，但按非递减顺序排列。&lt;/p&gt;&lt;p&gt;如果 &lt;code&gt;nums&lt;/code&gt; 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 45</title>
    <link href="http://yoursite.com/2021/02/06/252/"/>
    <id>http://yoursite.com/2021/02/06/252/</id>
    <published>2021-02-06T15:27:41.693Z</published>
    <updated>2021-02-07T05:04:46.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-45"><a href="#leetcode-biweekly-contest-45" class="headerlink" title="leetcode  biweekly contest 45"></a>leetcode  biweekly contest 45</h1><p>双周赛的题目质量还是非常不错的，终于又能<code>ak</code>一次，还是不错的，不过题目整体来说还是偏简单，不是特别有区分度，前三题全部都是水题，最后一题也是常规的<code>dp</code>题目。<br><img src="https://i.loli.net/2021/02/07/5E18o69BkrIameK.png" alt></p><h2 id="5657-唯一元素的和"><a href="#5657-唯一元素的和" class="headerlink" title="5657. 唯一元素的和"></a>5657. 唯一元素的和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。数组中唯一元素是那些只出现 恰好一次 的元素。</p><a id="more"></a><p>请你返回 <code>nums</code>中唯一元素的 和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：唯一元素为 [<span class="number">1</span>,<span class="number">3</span>] ，和为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有唯一元素，和为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：唯一元素为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，和为 <span class="number">15</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/sum-of-unique-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-45/problems/sum-of-unique-elements/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力遍历，签到题目<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">101</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            count[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] == <span class="number">1</span>) ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5658-任意子数组和的绝对值的最大值"><a href="#5658-任意子数组和的绝对值的最大值" class="headerlink" title="5658. 任意子数组和的绝对值的最大值"></a>5658. 任意子数组和的绝对值的最大值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。一个子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code>的 和的绝对值 为 <code>abs(numsl + numsl+1 + ... + numsr-1 + numsr)</code> 。</p><p>请你找出 <code>nums</code>中 和的绝对值 最大的任意子数组（可能为空），并返回该 最大值 。</p><p><code>abs(x)</code> 定义如下：</p><ul><li>如果 x 是负整数，那么 <code>abs(x) = -x</code> 。</li><li>如果 x 是非负整数，那么<code>abs(x) = x</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：子数组 [<span class="number">2</span>,<span class="number">3</span>] 和的绝对值最大，为 abs(<span class="number">2</span>+<span class="number">3</span>) = abs(<span class="number">5</span>) = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">-5</span>,<span class="number">1</span>,<span class="number">-4</span>,<span class="number">3</span>,<span class="number">-2</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：子数组 [<span class="number">-5</span>,<span class="number">1</span>,<span class="number">-4</span>] 和的绝对值最大，为 abs(<span class="number">-5</span>+<span class="number">1</span><span class="number">-4</span>) = abs(<span class="number">-8</span>) = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/maximum-absolute-sum-of-any-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-45/problems/maximum-absolute-sum-of-any-subarray/</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 前缀和的变形</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>我们记录下前<code>i</code>项的所有前缀和的最小值和最大值为<code>maxpresum[i]</code>,<code>minpresum[i]</code>,则我们对数组进行遍历，遍历到第<code>i+1</code>时我们测试<script type="math/tex; mode=display">ans = max(ans,max(abs(presum[i+1]-maxpresum[i]),abs(presum[i+1]-minpresum[i])))</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAbsoluteSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">        pre.insert(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += nums[i];</span><br><span class="line">            ans = max(ans,<span class="built_in">abs</span>(curr - *pre.begin()));</span><br><span class="line">            ans = max(ans,<span class="built_in">abs</span>(curr - *pre.rbegin()));</span><br><span class="line">            pre.insert(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5659-删除字符串两端相同字符后的最短长度"><a href="#5659-删除字符串两端相同字符后的最短长度" class="headerlink" title="5659. 删除字符串两端相同字符后的最短长度"></a>5659. 删除字符串两端相同字符后的最短长度</h2><p>给你一个只包含字符 ‘a’，’b’ 和 ‘c’ 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次：</p><ul><li>选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。</li><li>选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。</li><li>前缀和后缀在字符串中任意位置都不能有交集。</li><li>前缀和后缀包含的所有字符都要相同。</li><li>同时删除前缀和后缀。<br>请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"ca"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你没法删除任何一个字符，所以字符串长度仍然保持不变。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"cabaabac"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最优操作序列为：</span><br><span class="line">- 选择前缀 <span class="string">"c"</span> 和后缀 <span class="string">"c"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"abaaba"</span> 。</span><br><span class="line">- 选择前缀 <span class="string">"a"</span> 和后缀 <span class="string">"a"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"baab"</span> 。</span><br><span class="line">- 选择前缀 <span class="string">"b"</span> 和后缀 <span class="string">"b"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"aa"</span> 。</span><br><span class="line">- 选择前缀 <span class="string">"a"</span> 和后缀 <span class="string">"a"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">""</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"aabccabba"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最优操作序列为：</span><br><span class="line">- 选择前缀 <span class="string">"aa"</span> 和后缀 <span class="string">"a"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"bccabb"</span> 。</span><br><span class="line">- 选择前缀 <span class="string">"b"</span> 和后缀 <span class="string">"bb"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"cca"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li>s 只包含字符 ‘a’，’b’ 和 ‘c’ </li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/minimum-length-of-string-after-deleting-similar-ends/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-45/problems/minimum-length-of-string-after-deleting-similar-ends/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 双指针</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>记录下所有连续相同的字符和相同字符的长度，采用双指针，判断首尾的字符是否相等，如果相等则分别减去其长度，否则则终止。</li><li>需要特殊处理的是如果只剩下一个字符，则此时只能返回<code>1</code>。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLength</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = i;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == s[curr]) i++;</span><br><span class="line">            arr.push_back(make_pair(s[curr],i-curr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = arr.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l].first == arr[r].first)&#123;</span><br><span class="line">                ans -= arr[l].second;</span><br><span class="line">                ans -= arr[r].second;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l].second == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5660-最多可以参加的会议数目"><a href="#5660-最多可以参加的会议数目" class="headerlink" title="5660. 最多可以参加的会议数目"></a>5660. 最多可以参加的会议数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>events</code> 数组，其中 <code>events[i] = [startDayi, endDayi, valuei]</code> ，表示第 i 个会议在 <code>startDayi</code> 天开始，第 endDayi 天结束，如果你参加这个会议，你能得到价值 <code>valuei</code> 。同时给你一个整数 k 表示你能参加的最多会议数目。</p><p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 完整 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p><p>请你返回能得到的会议价值 最大和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：选择绿色的活动会议 <span class="number">0</span> 和 <span class="number">1</span>，得到总价值和为 <span class="number">4</span> + <span class="number">3</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>]], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：参加会议 <span class="number">2</span> ，得到价值和为 <span class="number">10</span> 。</span><br><span class="line">你没法再参加别的会议了，因为跟会议 <span class="number">2</span> 有重叠。你 不 需要参加满 k 个会议。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：尽管会议互不重叠，你只能参加 <span class="number">3</span> 个会议，所以选择价值最大的 <span class="number">3</span> 个会议。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= events.length</code></li><li><code>1 &lt;= k * events.length &lt;= 106</code></li><li><code>1 &lt;= startDayi &lt;= endDayi &lt;= 109</code></li><li><code>1 &lt;= valuei &lt;= 106</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/maximum-number-of-events-that-can-be-attended-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-45/problems/maximum-number-of-events-that-can-be-attended-ii/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>依然为经典的<code>dp</code>,不过要稍微复杂点，我们首先要按照会议结束的时间的先后进行排序，我们设<code>dp[i][j]</code>表示从前<code>i</code>个会议中选取<code>j</code>个会议召开的最大价值。首先我们知道如果不选则第<code>i</code>个会议时，则加递推公式为:<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j],dp[i-1][min(i-1,j)])</script></li><li>假如选择第<code>i</code>个会议时，则我们知道已经选择的前<code>j-1</code>个会议的结束时间都必须小于第<code>i</code>个会议的起始时间才可以，则此时我们可以利用二分查找很快的找到小于第<code>i</code>个会议起始时间$start_{i}$的最大索引<code>x</code>，则此时的递推公式为:<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j],dp[x][min(x,j-1)] + events[i][2])</script></li><li>我们最终返回<code>dp[n][k]</code>即为所需的最大值，空间复杂度为$O(nk)$,时间复杂度为$O(nklgn)$<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>结束时间排序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = events.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        sort(events.begin(),events.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr.push_back(events[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*initial*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][min(i<span class="number">-1</span>,j)];</span><br><span class="line">                <span class="keyword">int</span> idx = upper_bound(arr.begin(),arr.end(),events[i<span class="number">-1</span>][<span class="number">0</span>]<span class="number">-1</span>) - arr.begin() - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[idx+<span class="number">1</span>][min(idx+<span class="number">1</span>,j<span class="number">-1</span>)] + events[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>开始时间排序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 依然为经典的`dp`,不过要稍微复杂点，我们首先要按照会议结束的时间的先后进行排序，我们设`dp[i][j]`表示从前`i`个会议中选取`j`个会议召开的最大价值。首先我们知道如果不选则第`i`个会议时，则加递推公式为:</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][min(i<span class="number">-1</span>,j)])</span><br><span class="line">$$</span><br><span class="line"><span class="number">2.</span> 假如选择第`i`个会议时，则我们知道已经选择的前`j<span class="number">-1</span>`个会议的结束时间都必须小于第`i`个会议的起始时间才可以，则此时我们可以利用二分查找很快的找到小于第`i`个会议起始时间$start_&#123;i&#125;$的最大索引`x`，则此时的递推公式为:</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = max(dp[i][j],dp[x][min(x,j<span class="number">-1</span>)] + events[i][<span class="number">2</span>])</span><br><span class="line">$$</span><br><span class="line"><span class="number">3.</span> 按照会议开始时间排序的解法类似第`<span class="number">2</span>`种。</span><br><span class="line"><span class="number">4.</span> 我们最终返回`dp[n][k]`即为所需的最大值，空间复杂度为$O(nk)$,时间复杂度为$O(nklgn)$</span><br><span class="line">+ 结束时间排序:</span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxValue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = events.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        sort(events.begin(),events.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr.push_back(events[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*initial*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][min(i<span class="number">-1</span>,j)];</span><br><span class="line">                <span class="keyword">int</span> idx = upper_bound(arr.begin(),arr.end(),events[i<span class="number">-1</span>][<span class="number">0</span>]<span class="number">-1</span>) - arr.begin() - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[idx+<span class="number">1</span>][min(idx+<span class="number">1</span>,j<span class="number">-1</span>)] + events[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>开始时间排序:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = events.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        sort(events.begin(),events.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) arr.push_back(events[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j &lt;= (n-i); ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][min(j,n-i<span class="number">-1</span>)];</span><br><span class="line">                <span class="keyword">int</span> idx = upper_bound(arr.begin(),arr.end(),events[i][<span class="number">1</span>]) - arr.begin();</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[idx][min(n-idx,j<span class="number">-1</span>)] + events[i][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-45&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-45&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 45&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 45&lt;/h1&gt;&lt;p&gt;双周赛的题目质量还是非常不错的，终于又能&lt;code&gt;ak&lt;/code&gt;一次，还是不错的，不过题目整体来说还是偏简单，不是特别有区分度，前三题全部都是水题，最后一题也是常规的&lt;code&gt;dp&lt;/code&gt;题目。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/07/5E18o69BkrIameK.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5657-唯一元素的和&quot;&gt;&lt;a href=&quot;#5657-唯一元素的和&quot; class=&quot;headerlink&quot; title=&quot;5657. 唯一元素的和&quot;&gt;&lt;/a&gt;5657. 唯一元素的和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。数组中唯一元素是那些只出现 恰好一次 的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
