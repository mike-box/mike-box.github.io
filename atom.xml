<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-25T11:52:22.849Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 238</title>
    <link href="http://yoursite.com/2021/04/25/277/"/>
    <id>http://yoursite.com/2021/04/25/277/</id>
    <published>2021-04-25T04:37:23.010Z</published>
    <updated>2021-04-25T11:52:22.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-238"><a href="#leetcode-contest-238" class="headerlink" title="leetcode  contest 238"></a>leetcode  contest 238</h1><p>本周周赛的题目质量非常高，非常喜欢第<code>2</code>题与第<code>4</code>题，还是三道题的节奏。</p><h2 id="5738-K-进制表示下的各位数字总和"><a href="#5738-K-进制表示下的各位数字总和" class="headerlink" title="5738. K 进制表示下的各位数字总和"></a>5738. K 进制表示下的各位数字总和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>（<code>10</code> 进制）和一个基数 <code>k</code> ，请你将 <code>n</code> 从 <code>10</code> 进制表示转换为 <code>k</code> 进制表示，计算并返回转换后各位数字的 总和 。</p><p>转换后，各位数字应当视作是 <code>10</code> 进制数字，且它们的总和也应当按 <code>10</code>进制表示返回。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">34</span>, k = <span class="number">6</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：<span class="number">34</span> (<span class="number">10</span> 进制) 在 <span class="number">6</span> 进制下表示为 <span class="number">54</span> 。<span class="number">5</span> + <span class="number">4</span> = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：n 本身就是 <span class="number">10</span> 进制。 <span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>2 &lt;= k &lt;= 10</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-digits-in-base-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-digits-in-base-k</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单暴力即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumBase</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            ans += (n%k);</span><br><span class="line">            n = n/k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5739-最高频元素的频数"><a href="#5739-最高频元素的频数" class="headerlink" title="5739. 最高频元素的频数"></a>5739. 最高频元素的频数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>元素的 频数 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。在一步操作中，你可以选择<code>nums</code>的一个下标，并将该下标对应元素的值增加 <code>1</code>。</p><p>执行最多 <code>k</code> 次操作后，返回数组中最高频元素的 最大可能频数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：对第一个元素执行 <span class="number">3</span> 次递增操作，对第二个元素执 <span class="number">2</span> 次递增操作，此时 nums = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>] 。</span><br><span class="line"><span class="number">4</span> 是数组中最高频元素，频数是 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">13</span>], k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：存在多种最优解决方案：</span><br><span class="line">- 对第一个元素执行 <span class="number">3</span> 次递增操作，此时 nums = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">13</span>] 。<span class="number">4</span> 是数组中最高频元素，频数是 <span class="number">2</span> 。</span><br><span class="line">- 对第二个元素执行 <span class="number">4</span> 次递增操作，此时 nums = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">13</span>] 。<span class="number">8</span> 是数组中最高频元素，频数是 <span class="number">2</span> 。</span><br><span class="line">- 对第三个元素执行 <span class="number">5</span> 次递增操作，此时 nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">13</span>] 。<span class="number">13</span> 是数组中最高频元素，频数是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">6</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找或者双指针</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>首先需要按照元素的大小进行排序，我们每次遍历到第<code>i</code>个元素时，我们需要计算将<code>i-1</code>个元素中在<code>k</code>的限制条件下，最多可以变换多少元素变换为<code>nums[i]</code>，此时我们可以利用前缀和即可，假设我们可以将第<code>i</code>个元素之前的<code>m</code>个元素变换为<code>nums[i]</code>，则约束条件为:<script type="math/tex; mode=display">\sum_{i=1}^{m} (nums[i] - nums[i-k]) \le k \\f(m) = m*nums[i] - \sum_{i=1}^{m}(nums[i-k]) \le k</script>满足上述条件即可，我们可以看到上述函数<code>f</code>是根据<code>m</code>的大小是递增的，由此我们即可利用二分查找，每次测试合适的<code>m</code>的值满足<code>k</code>的限制条件即可。</li><li>第二种解法则是利用双指针滑动窗口，由于利用递增的特性每次对当前的窗口的值进行尝试即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; presum(n,<span class="number">0</span>);</span><br><span class="line">        presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(mid == <span class="number">0</span>)&#123;</span><br><span class="line">                    curr = presum[i<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    curr = presum[i<span class="number">-1</span>] - presum[mid<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(((<span class="keyword">long</span> <span class="keyword">long</span>)(i-mid)*nums[i] - curr) &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>)k)&#123;</span><br><span class="line">                    cnt = i - mid;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,cnt+<span class="number">1</span>);</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>滑动窗口<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            tot += nums[i];</span><br><span class="line">            <span class="keyword">while</span>((tot + k) &lt; (<span class="keyword">long</span> <span class="keyword">long</span>)nums[i]*(i-j+<span class="number">1</span>))&#123;</span><br><span class="line">                tot -= nums[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5740-所有元音按顺序排布的最长子字符串"><a href="#5740-所有元音按顺序排布的最长子字符串" class="headerlink" title="5740. 所有元音按顺序排布的最长子字符串"></a>5740. 所有元音按顺序排布的最长子字符串</h2><p>当一个字符串满足如下条件时，我们称它是 美丽的 ：</p><p>所有 5 个英文元音字母<code>（&#39;a&#39; ，&#39;e&#39; ，&#39;i&#39; ，&#39;o&#39; ，&#39;u&#39;）</code>都必须 至少 出现一次。<br>这些元音字母的顺序都必须按照 字典序 升序排布（也就是说所有的 ‘a’ 都在 ‘e’ 前面，所有的 ‘e’ 都在 ‘i’ 前面，以此类推）<br>比方说，字符串 <code>&quot;aeiou&quot;</code>和 <code>&quot;aaaaaaeiiiioou&quot;</code> 都是 美丽的 ，但是<code>&quot;uaeio&quot;</code> ，<code>&quot;aeoiu&quot;</code> 和 <code>&quot;aaaeeeooo&quot;</code> 不是美丽的 。</p><p>给你一个只包含英文元音字母的字符串<code>word</code>，请你返回<code>word</code> 中 最长美丽子字符串的长度 。如果不存在这样的子字符串，请返回 0 。</p><p>子字符串 是字符串中一个连续的字符序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"aeiaaioaaaaeiiiiouuuooaauuaeiu"</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：最长子字符串是 <span class="string">"aaaaeiiiiouuu"</span> ，长度为 <span class="number">13</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"aeeeiiiioooauuuaeiou"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：最长子字符串是 <span class="string">"aeiou"</span> ，长度为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"a"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有美丽子字符串，所以返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-xor-for-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-xor-for-each-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划，我们设<code>dp[i]</code>代表以<code>i</code>的元音字母为结尾且满足从<code>a</code>开始且递增<code>1</code>的连续字符串的长度。</li><li>我们每次需要判断两个条件：</li></ol><ul><li>当前字符串是否严格连续递增<code>1</code>或者与前一个字符相等；</li><li>当前子字符串的起始字符是否为<code>a</code>；<br>本质来说还算是非常简单的<code>dp</code>实现，感觉比第二题简单多了。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestBeautifulSubstring</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; order;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; arr = &#123;<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) order[arr[i]] = i;</span><br><span class="line">        <span class="keyword">if</span>(word[<span class="number">0</span>] == <span class="string">'a'</span>) dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>] == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>(word[i] == <span class="string">'a'</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(order[word[i]] == order[word[i<span class="number">-1</span>]] || (order[word[i]] - order[word[i<span class="number">-1</span>]]) == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(word[i] == <span class="string">'a'</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; <span class="number">0</span> &amp;&amp; word[i] == <span class="string">'u'</span>)&#123;</span><br><span class="line">                ans = max(ans,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5741-最高建筑高度"><a href="#5741-最高建筑高度" class="headerlink" title="5741. 最高建筑高度"></a>5741. 最高建筑高度</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在一座城市里，你需要建 <code>n</code>栋新的建筑。这些新的建筑会从 <code>1</code>到 <code>n</code>编号排成一列。</p><p>这座城市对这些新建筑有一些规定：</p><p>每栋建筑的高度必须是一个非负整数。<br>第一栋建筑的高度 必须 是 <code>0</code>。<br>任意两栋相邻建筑的高度差 不能超过  <code>1</code>。<br>除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组 <code>restrictions</code> 的形式给出，其中 <code>restrictions[i] = [idi, maxHeighti]</code> ，表示建筑 <code>idi</code>的高度 不能超过 <code>maxHeighti</code> 。</p><p>题目保证每栋建筑在 <code>restrictions</code>中 至多出现一次 ，同时建筑 1 不会 出现在 <code>restrictions</code> 中。</p><p>请你返回 最高 建筑能达到的 最高高度 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, restrictions = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>] ，最高建筑的高度为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, restrictions = []</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，最高建筑的高度为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, restrictions = [[<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>] ，最高建筑的高度为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 109</code></li><li><code>0 &lt;= restrictions.length &lt;= min(n - 1, 105)</code></li><li><code>2 &lt;= idi &lt;= n</code></li><li><code>idi</code> 是 唯一的 。</li><li><code>0 &lt;= maxHeighti &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-building-height" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-building-height</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>奥数</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目确实出的很好，根据题目中的要求，由于相邻的楼层的高度差为<code>1</code>，则我们可以知道位于位置<code>i</code>处的楼层为$h[i]$,则我们可以知道位于位置<code>j</code>处的楼层的高度最高一定不能高于$h[i] + abs(i-j)$，我们按照位置的先后来排序，然后利用传递性，对楼层的高度进行限制，刚好能够符合要求。</li><li>对于$(i,h[i])$与$(j,h[j])$两点坐标所能构成的楼层的最大高度有公式为$\frac{abs(i-j)+h[i] + h[j]}{2}$.</li><li>参考官方题解，确实是个非常不错的面试题目。<a href="https://leetcode-cn.com/problems/maximum-building-height/solution/zui-gao-jian-zhu-gao-du-by-leetcode-solu-axbb/" target="_blank" rel="noopener">题解</a>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxBuilding</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        arr.push_back(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        arr.push_back(&#123;n,n<span class="number">-1</span>&#125;);</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">int</span> m = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            arr[i][<span class="number">1</span>] = min(arr[i][<span class="number">1</span>],arr[i<span class="number">-1</span>][<span class="number">1</span>] + arr[i][<span class="number">0</span>] - arr[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            arr[i][<span class="number">1</span>] = min(arr[i][<span class="number">1</span>],arr[i+<span class="number">1</span>][<span class="number">1</span>] + arr[i+<span class="number">1</span>][<span class="number">0</span>] - arr[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            ans = max(ans,(arr[i+<span class="number">1</span>][<span class="number">0</span>] - arr[i][<span class="number">0</span>] + arr[i][<span class="number">1</span>] + arr[i+<span class="number">1</span>][<span class="number">1</span>])/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-238&quot;&gt;&lt;a href=&quot;#leetcode-contest-238&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 238&quot;&gt;&lt;/a&gt;leetcode  contest 238&lt;/h1&gt;&lt;p&gt;本周周赛的题目质量非常高，非常喜欢第&lt;code&gt;2&lt;/code&gt;题与第&lt;code&gt;4&lt;/code&gt;题，还是三道题的节奏。&lt;/p&gt;&lt;h2 id=&quot;5738-K-进制表示下的各位数字总和&quot;&gt;&lt;a href=&quot;#5738-K-进制表示下的各位数字总和&quot; class=&quot;headerlink&quot; title=&quot;5738. K 进制表示下的各位数字总和&quot;&gt;&lt;/a&gt;5738. K 进制表示下的各位数字总和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;（&lt;code&gt;10&lt;/code&gt; 进制）和一个基数 &lt;code&gt;k&lt;/code&gt; ，请你将 &lt;code&gt;n&lt;/code&gt; 从 &lt;code&gt;10&lt;/code&gt; 进制表示转换为 &lt;code&gt;k&lt;/code&gt; 进制表示，计算并返回转换后各位数字的 总和 。&lt;/p&gt;&lt;p&gt;转换后，各位数字应当视作是 &lt;code&gt;10&lt;/code&gt; 进制数字，且它们的总和也应当按 &lt;code&gt;10&lt;/code&gt;进制表示返回。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Google Kickstart】 Google Kick Start 2021 roundB</title>
    <link href="http://yoursite.com/2021/04/19/276/"/>
    <id>http://yoursite.com/2021/04/19/276/</id>
    <published>2021-04-19T09:09:34.045Z</published>
    <updated>2021-04-21T13:41:34.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-kick-start-2021-roundB"><a href="#google-kick-start-2021-roundB" class="headerlink" title="google kick start 2021 roundB"></a>google kick start 2021 roundB</h1><p><code>google kickstart</code>的题目质量很高，虽然比不上竞赛的难度，但是都是非常有思考的题目。<br>还是把题解仔细的写一遍，非常喜欢这类型的题目。</p><h2 id="Increasing-Substring"><a href="#Increasing-Substring" class="headerlink" title="Increasing Substring"></a>Increasing Substring</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/04/21/2z4NiBxDXLouK5W.png" alt></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882</a></p><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>判断当前字符为结尾的最长递增连续字符串的长度。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt; s[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans[i] = ans[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Longest-Progression"><a href="#Longest-Progression" class="headerlink" title="Longest Progression"></a>Longest Progression</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/04/21/r1f43nB5j2SHFYo.png" alt></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a3a5" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a3a5</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>在最多只能改变一个元素的情况下，求连续最长的等差序列的长度。典型的滑动窗口，跟力扣的某个题目非常像。我们设<code>left[i]</code>为以第<code>i</code>个元素为结尾的最长连续等差序列的长度，<code>right[i]</code>为以第<code>i</code>个元素为开始的最长连续等差序列的长度，所以我们每次尝试改变第<code>i</code>个元素，然后进行前后可能的元素进行相连即可尝试得到最长的长度。</li><li>时间复杂度为$O(n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*left*/</span></span><br><span class="line">    left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    left[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] - arr[i<span class="number">-1</span>] == arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>])&#123;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    right[n<span class="number">-2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-3</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] - arr[i+<span class="number">1</span>] == arr[i+<span class="number">1</span>] - arr[i+<span class="number">2</span>])&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = max(ans, <span class="number">1</span> + right[<span class="number">1</span>]);</span><br><span class="line">    ans = max(ans,<span class="number">1</span> + left[n<span class="number">-2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        ans = n;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i+<span class="number">2</span>] - arr[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                    ans = max(ans,right[i+<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = max(ans,right[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n<span class="number">-2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i+<span class="number">2</span>] - arr[i+<span class="number">1</span>]) &amp;&amp; \</span><br><span class="line">                   arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + right[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i+<span class="number">2</span>] - arr[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                    ans = max(ans,right[i+<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = max(ans,right[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Consecutive-Primes"><a href="#Consecutive-Primes" class="headerlink" title="Consecutive Primes"></a>Consecutive Primes</h2><p>给定数字<code>num</code>,求小等于<code>num</code>且刚好能够被分解为两个连续的质数的乘积的最大元素。</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a8e6" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a8e6</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先因为题目中限定了元素的大小，我们仔细推算一下，肯定只能由这三个连续的质数的组合，$p_{1} &lt; p_{2} &lt; \sqrt{num} &lt; p_{3}$,最终的结果要么为$p_{1}<em>p_{2}$,要么为$p_{2}</em>p_{3}$.</li><li>如果数据量非常小的话，我们直接用素数筛查法，即可求出所有的素数，但是因为本题中的数据量非常大，所以我们需要另辟蹊径。仔细查看一下数学知识，<a href="https://en.wikipedia.org/wiki/Prime_gap" target="_blank" rel="noopener">素数最大间隔</a>，根据题目中的判断，我们可以猜测两个素数之间的最大间隔也就在几百，所以我们此时就可以用暴力求解，然后同时可以利用素因子快速检测一个数是否为素数因为我们只需要检测$lg(lg(num))$范围的素因子即可。</li><li>时间复杂度计算还是太麻烦了，大概在$O(k*lg(lg(num)))$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">100006</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> h = <span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.size() &amp;&amp; prime[i] &lt;= h; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%prime[i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="comment">/*upper*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x+<span class="number">1</span>; i &lt; num ;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(i))&#123;</span><br><span class="line">            arr.push_back(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*lower*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt;= <span class="number">2</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(i))&#123;</span><br><span class="line">            arr.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(arr.size() &gt;= <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">0</span>]*arr[<span class="number">1</span>] &lt;= num)&#123;</span><br><span class="line">        ans = max(ans,arr[<span class="number">0</span>]*arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">1</span>]*arr[<span class="number">2</span>] &lt;= num)&#123;</span><br><span class="line">        ans = max(ans,arr[<span class="number">1</span>]*arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*find all prime*/</span></span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100005</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">        prime.push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= <span class="number">100005</span>; j = j + i)&#123;</span><br><span class="line">            visit[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Truck-Delivery"><a href="#Truck-Delivery" class="headerlink" title="Truck Delivery"></a>Truck Delivery</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/04/21/TbHgtyqCvL2SI7M.png" alt></p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a885#problem" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a885#problem</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>线段树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>对于<code>test1</code>的数据集感觉一般人都能拿到分，无非是每次遇到查询，进行暴力检测路劲即可，即可得到所有可能的$GCD$的值，这个13分感觉很好难，时间复杂度为$O(N*Q)$.</li><li>对于第二个测试集则需要进行深入思考的深度，仔细发现一下，如果我们采用<code>dfs</code>遍历每一条路径时，如果所经历的路径已经按照<code>limit</code>进行排序好了，则我们可以很容易的利用二分查找即可在$O(lg(MAX(L)))$的时间复杂度内完成一次查询，如果需要这样进行查询的话则我们需要构造一种数据结构在$O(lg(MAX(L)))$的时间复杂度内完成这个查询。仔细思索一下我们可以构造线段树，线段树的长度为$(1,MAX(L))$,线段树的<code>key</code>为$L_{i}$,值为$V_{i}$,初始时设置$V_{i} = 0$.每次遇到查询$(C_{i},W_{i})$时，我们只需要查询$(1,W_{i})$范围的$gcd$即可。我们在遍历到某个节点时，则我们需要对线段树进行更新，每次更新$(L_{i},gcd(V_{i},C_{i}))$，每当我们从第$i$个节点退出时，则我们需要更新线段树的节点，需要将其节点的值从$gcd(V_{i},C_{i})$恢复到$V_{i}$.</li><li>时间复杂度为$O((2<em>N+Q)</em>lg(MAX(L)))$,空间复杂度为$O(MAX(L))$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>暴力解法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; graph(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; edgs(n,<span class="built_in">vector</span>&lt;pii&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x,y,l,a;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;l&gt;&gt;a;</span><br><span class="line">        x--;</span><br><span class="line">        y--;</span><br><span class="line">        graph[x].push_back(y);</span><br><span class="line">        graph[y].push_back(x);</span><br><span class="line">        edgs[x][y] = &#123;l,a&#125;;</span><br><span class="line">        edgs[y][x] = &#123;l,a&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; fa = <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bfs*/</span></span><br><span class="line">    qu.push(<span class="number">0</span>);</span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*neg*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">            visit[v] = <span class="literal">true</span>;</span><br><span class="line">            fa[v] = curr;</span><br><span class="line">            qu.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> c,w;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        c--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(c != <span class="number">0</span>)&#123;</span><br><span class="line">            pii curr = edgs[c][fa[c]];</span><br><span class="line">            <span class="keyword">if</span>(w &gt;= curr.first)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">0</span>) num = curr.second;</span><br><span class="line">                <span class="keyword">else</span> num = __gcd(num,curr.second);</span><br><span class="line">            &#125;</span><br><span class="line">            c = fa[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>线段树解法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> int32;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; gcd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> city;</span><br><span class="line">    <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> charge;</span><br><span class="line">    Edge(<span class="keyword">int</span> city,<span class="keyword">int</span> limit,<span class="keyword">long</span> <span class="keyword">long</span> charge)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;city = city;</span><br><span class="line">        <span class="keyword">this</span>-&gt;limit = limit;</span><br><span class="line">        <span class="keyword">this</span>-&gt;charge = charge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">200005</span>;</span><br><span class="line">SegTreeNode tree[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2 + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left = tree[CHL(idx)].gcd.back();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> right = tree[CHR(idx)].gcd.back();</span><br><span class="line">    tree[idx].gcd[<span class="number">0</span>] = __gcd(left,right);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].gcd.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(l,mid,CHL(idx));</span><br><span class="line">    buildTree(mid+<span class="number">1</span>,r,CHR(idx));</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">long</span> <span class="keyword">long</span> charge,<span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; tree[idx].l || x &gt; tree[idx].r ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == tree[idx].r &amp;&amp; tree[idx].l == x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(add == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//向当前节点加入一个新值</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val = tree[idx].gcd.back();</span><br><span class="line">            tree[idx].gcd.push_back(__gcd(val,charge));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(add == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//弹出最后一个值</span></span><br><span class="line">            tree[idx].gcd.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        updateTree(CHL(idx),x,charge,add);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        updateTree(CHR(idx),x,charge,add);</span><br><span class="line">    &#125;</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w &lt; tree[idx].l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == tree[idx].r &amp;&amp; tree[idx].r &lt;= w)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].gcd.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w &gt;= tree[idx].r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].gcd.back();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(w &lt;= mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> queryTree(CHL(idx),w);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(w &gt; mid)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> left = queryTree(CHL(idx),w);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> right = queryTree(CHR(idx),w);</span><br><span class="line">            <span class="keyword">return</span> __gcd(left,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp; res,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; &amp; graph,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; query)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[curr].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = graph[curr][i].city;</span><br><span class="line">        <span class="keyword">int</span> limit = graph[curr][i].limit;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> charge = graph[curr][i].charge;</span><br><span class="line">        <span class="keyword">if</span>(visit[nx]) <span class="keyword">continue</span>;</span><br><span class="line">        visit[nx] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新当前的（L,C）</span></span><br><span class="line">        updateTree(<span class="number">1</span>,limit,charge,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : query[nx])&#123;</span><br><span class="line">            <span class="keyword">int</span> weight = v.first;</span><br><span class="line">            <span class="keyword">int</span> idx = v.second;</span><br><span class="line">            res[idx] = queryTree(<span class="number">1</span>,weight);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nx,visit,res,graph,query);</span><br><span class="line">        <span class="comment">//删除当前的边</span></span><br><span class="line">        updateTree(<span class="number">1</span>,limit,charge,<span class="number">-1</span>);</span><br><span class="line">        visit[nx] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;    </span><br><span class="line">    <span class="comment">/*input the value*/</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; graph(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; query(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        int64 x,y,l,a;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;l&gt;&gt;a;</span><br><span class="line">        x--;</span><br><span class="line">        y--;</span><br><span class="line">        graph[x].push_back(Edge(y,l,a));</span><br><span class="line">        graph[y].push_back(Edge(x,l,a));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> c,w;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        c--;</span><br><span class="line">        <span class="comment">//按照城市将所有的查询进行分类</span></span><br><span class="line">        query[c].push_back(&#123;w,i&#125;);     </span><br><span class="line">    &#125;</span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*dfs every node*/</span></span><br><span class="line">    dfs(<span class="number">0</span>,visit,ans,graph,query);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    buildTree(<span class="number">0</span>,<span class="number">200001</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;google-kick-start-2021-roundB&quot;&gt;&lt;a href=&quot;#google-kick-start-2021-roundB&quot; class=&quot;headerlink&quot; title=&quot;google kick start 2021 roundB&quot;&gt;&lt;/a&gt;google kick start 2021 roundB&lt;/h1&gt;&lt;p&gt;&lt;code&gt;google kickstart&lt;/code&gt;的题目质量很高，虽然比不上竞赛的难度，但是都是非常有思考的题目。&lt;br&gt;还是把题解仔细的写一遍，非常喜欢这类型的题目。&lt;/p&gt;&lt;h2 id=&quot;Increasing-Substring&quot;&gt;&lt;a href=&quot;#Increasing-Substring&quot; class=&quot;headerlink&quot; title=&quot;Increasing Substring&quot;&gt;&lt;/a&gt;Increasing Substring&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/21/2z4NiBxDXLouK5W.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="kickstart" scheme="http://yoursite.com/tags/kickstart/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly  Contest 50</title>
    <link href="http://yoursite.com/2021/04/18/274/"/>
    <id>http://yoursite.com/2021/04/18/274/</id>
    <published>2021-04-18T03:36:35.107Z</published>
    <updated>2021-04-18T04:56:44.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-50"><a href="#leetcode-biweekly-contest-50" class="headerlink" title="leetcode  biweekly  contest 50"></a>leetcode  biweekly  contest 50</h1><p>还是三道题的节奏，前三题基本上都是简单题，不到15分钟搞定前三题，最后一题又难度特别高，感觉就是比手速。<br><img src="https://i.loli.net/2021/04/18/zubn7aMx1DEXHos.png" alt></p><h2 id="5717-最少操作使数组递增"><a href="#5717-最少操作使数组递增" class="headerlink" title="5717. 最少操作使数组递增"></a>5717. 最少操作使数组递增</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>（下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。</p><a id="more"></a><p>比方说，如果 <code>nums = [1,2,3]</code> ，你可以选择增加 <code>nums[1]</code> 得到 <code>nums = [1,3,3]</code>。<br>请你返回使 <code>nums</code> 严格递增 的 最少 操作次数。</p><p>我们称数组 <code>nums</code> 是 严格递增的 ，当它满足对于所有的 <code>0 &lt;= i &lt; nums.length - 1</code> 都有 <code>nums[i] &lt; nums[i+1]</code> 。一个长度为 1 的数组是严格递增的一种特殊情况。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以进行如下操作：</span><br><span class="line"><span class="number">1</span>) 增加 nums[<span class="number">2</span>] ，数组变为 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] 。</span><br><span class="line"><span class="number">2</span>) 增加 nums[<span class="number">1</span>] ，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line"><span class="number">3</span>) 增加 nums[<span class="number">2</span>] ，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-increasing" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-increasing</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  贪心算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>每次最多递增到前一个数字加1即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = max(nums[i],nums[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">            ans += x - nums[i];</span><br><span class="line">            nums[i] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5718-统计一个圆中点的数目"><a href="#5718-统计一个圆中点的数目" class="headerlink" title="5718. 统计一个圆中点的数目"></a>5718. 统计一个圆中点的数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> ，表示第 i 个点在二维平面上的坐标。多个点可能会有 相同 的坐标。</p><p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [xj, yj, rj]</code> ，表示一个圆心在<code>(xj, yj)</code>且半径为 rj 的圆。</p><p>对于每一个查询 <code>queries[j]</code> ，计算在第 j 个圆 内 点的数目。如果一个点在圆的 边界上 ，我们同样认为它在圆 内 。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[j]</code>是第 j 个查询的答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">2</span>]], queries = [[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：所有的点和圆如上图所示。</span><br><span class="line">queries[<span class="number">0</span>] 是绿色的圆，queries[<span class="number">1</span>] 是红色的圆，queries[<span class="number">2</span>] 是蓝色的圆。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>]], queries = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：所有的点和圆如上图所示。</span><br><span class="line">queries[<span class="number">0</span>] 是绿色的圆，queries[<span class="number">1</span>] 是红色的圆，queries[<span class="number">2</span>] 是蓝色的圆，queries[<span class="number">3</span>] 是紫色的圆。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= points.length &lt;= 500</code></li><li><code>points[i].length == 2</code></li><li><code>0 &lt;= x​​​​​​i, y​​​​​​i &lt;= 500</code></li><li><code>1 &lt;= queries.length &lt;= 500</code></li><li><code>queries[j].length == 3</code></li><li><code>0 &lt;= xj, yj &lt;= 500</code></li><li><code>1 &lt;= rj &lt;= 500</code></li><li>所有的坐标都是整数。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/queries-on-number-of-points-inside-a-circle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queries-on-number-of-points-inside-a-circle</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力解决即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>检查每一个点是否都在园内即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countPoints(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="built_in">abs</span>(points[j][<span class="number">0</span>] - queries[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> y = <span class="built_in">abs</span>(points[j][<span class="number">1</span>] - queries[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> r = queries[i][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>((x*x + y*y) &lt;= (r*r))&#123;</span><br><span class="line">                    ans[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5719-每个查询的最大异或值"><a href="#5719-每个查询的最大异或值" class="headerlink" title="5719. 每个查询的最大异或值"></a>5719. 每个查询的最大异或值</h2><p>给你一个 有序 数组 <code>nums</code> ，它由 n 个非负整数组成，同时给你一个整数 <code>maximumBit</code> 。你需要执行以下查询 n 次：</p><p>找到一个非负整数<code>k &lt; 2maximumBit</code> ，使得<code>nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k</code> 的结果 最大化 。k 是第 i 个查询的答案。<br>从当前数组 <code>nums</code> 删除 最后 一个元素。<br>请你返回一个数组 <code>answer</code>，其中 <code>answer[i]</code>是第 i 个查询的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>], maximumBit = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：查询的答案如下：</span><br><span class="line">第一个查询：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]，k = <span class="number">0</span>，因为 <span class="number">0</span> XOR <span class="number">1</span> XOR <span class="number">1</span> XOR <span class="number">3</span> XOR <span class="number">0</span> = <span class="number">3</span> 。</span><br><span class="line">第二个查询：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]，k = <span class="number">3</span>，因为 <span class="number">0</span> XOR <span class="number">1</span> XOR <span class="number">1</span> XOR <span class="number">3</span> = <span class="number">3</span> 。</span><br><span class="line">第三个查询：nums = [<span class="number">0</span>,<span class="number">1</span>]，k = <span class="number">2</span>，因为 <span class="number">0</span> XOR <span class="number">1</span> XOR <span class="number">2</span> = <span class="number">3</span> 。</span><br><span class="line">第四个查询：nums = [<span class="number">0</span>]，k = <span class="number">3</span>，因为 <span class="number">0</span> XOR <span class="number">3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], maximumBit = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">解释：查询的答案如下：</span><br><span class="line">第一个查询：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]，k = <span class="number">5</span>，因为 <span class="number">2</span> XOR <span class="number">3</span> XOR <span class="number">4</span> XOR <span class="number">7</span> XOR <span class="number">5</span> = <span class="number">7</span>。</span><br><span class="line">第二个查询：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，k = <span class="number">2</span>，因为 <span class="number">2</span> XOR <span class="number">3</span> XOR <span class="number">4</span> XOR <span class="number">2</span> = <span class="number">7</span> 。</span><br><span class="line">第三个查询：nums = [<span class="number">2</span>,<span class="number">3</span>]，k = <span class="number">6</span>，因为 <span class="number">2</span> XOR <span class="number">3</span> XOR <span class="number">6</span> = <span class="number">7</span> 。</span><br><span class="line">第四个查询：nums = [<span class="number">2</span>]，k = <span class="number">5</span>，因为 <span class="number">2</span> XOR <span class="number">5</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>], maximumBit = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>nums.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= maximumBit &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt; 2maximumBit</code></li><li><code>nums​​​</code> 中的数字已经按 升序 排好序。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-xor-for-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-xor-for-each-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们计算出当前数组异或的结果<code>x</code>，然后根据贪心法，如果<code>x</code>的第<code>i</code>位为<code>0</code>，我们则在符合<code>maximumBit</code>的范围内将第<code>i</code>位的值取为<code>1</code>即可，贪心原则取即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getMaximumXor(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> maximumBit) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) curr = curr^nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = maximumBit<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr&amp;(<span class="number">1</span>&lt;&lt;j)) <span class="keyword">continue</span>;</span><br><span class="line">                x += (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(x);</span><br><span class="line">            curr = curr^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5720-使字符串有序的最少操作次数"><a href="#5720-使字符串有序的最少操作次数" class="headerlink" title="5720. 使字符串有序的最少操作次数"></a>5720. 使字符串有序的最少操作次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>s</code>（下标从<code>0</code>开始）。你需要对 <code>s</code>执行以下操作直到它变为一个有序字符串：</p><ul><li>找到 最大下标 <code>i</code> ，使得 <code>1 &lt;= i &lt; s.length</code> 且 <code>s[i] &lt; s[i - 1]</code> 。</li><li>找到 最大下标 <code>j</code> ，使得 <code>i &lt;= j &lt; s.length</code> 且对于所有在闭区间 <code>[i, j]</code> 之间的 <code>k</code> 都有 <code>s[k] &lt; s[i - 1]</code> 。<br>交换下标为 <code>i - 1</code>​​​​ 和 <code>j</code>​​​​ 处的两个字符。<br>将下标 i 开始的字符串后缀反转。<br>请你返回将字符串变成有序的最少操作次数。由于答案可能会很大，请返回它对 <code>109 + 7</code> 取余 的结果。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"cba"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：模拟过程如下所示：</span><br><span class="line">操作 <span class="number">1</span>：i=<span class="number">2</span>，j=<span class="number">2</span>。交换 s[<span class="number">1</span>] 和 s[<span class="number">2</span>] 得到 s=<span class="string">"cab"</span> ，然后反转下标从 <span class="number">2</span> 开始的后缀字符串，得到 s=<span class="string">"cab"</span> 。</span><br><span class="line">操作 <span class="number">2</span>：i=<span class="number">1</span>，j=<span class="number">2</span>。交换 s[<span class="number">0</span>] 和 s[<span class="number">2</span>] 得到 s=<span class="string">"bac"</span> ，然后反转下标从 <span class="number">1</span> 开始的后缀字符串，得到 s=<span class="string">"bca"</span> 。</span><br><span class="line">操作 <span class="number">3</span>：i=<span class="number">2</span>，j=<span class="number">2</span>。交换 s[<span class="number">1</span>] 和 s[<span class="number">2</span>] 得到 s=<span class="string">"bac"</span> ，然后反转下标从 <span class="number">2</span> 开始的后缀字符串，得到 s=<span class="string">"bac"</span> 。</span><br><span class="line">操作 <span class="number">4</span>：i=<span class="number">1</span>，j=<span class="number">1</span>。交换 s[<span class="number">0</span>] 和 s[<span class="number">1</span>] 得到 s=<span class="string">"abc"</span> ，然后反转下标从 <span class="number">1</span> 开始的后缀字符串，得到 s=<span class="string">"acb"</span> 。</span><br><span class="line">操作 <span class="number">5</span>：i=<span class="number">2</span>，j=<span class="number">2</span>。交换 s[<span class="number">1</span>] 和 s[<span class="number">2</span>] 得到 s=<span class="string">"abc"</span> ，然后反转下标从 <span class="number">2</span> 开始的后缀字符串，得到 s=<span class="string">"abc"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabaa"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：模拟过程如下所示：</span><br><span class="line">操作 <span class="number">1</span>：i=<span class="number">3</span>，j=<span class="number">4</span>。交换 s[<span class="number">2</span>] 和 s[<span class="number">4</span>] 得到 s=<span class="string">"aaaab"</span> ，然后反转下标从 <span class="number">3</span> 开始的后缀字符串，得到 s=<span class="string">"aaaba"</span> 。</span><br><span class="line">操作 <span class="number">2</span>：i=<span class="number">4</span>，j=<span class="number">4</span>。交换 s[<span class="number">3</span>] 和 s[<span class="number">4</span>] 得到 s=<span class="string">"aaaab"</span> ，然后反转下标从 <span class="number">4</span> 开始的后缀字符串，得到 s=<span class="string">"aaaab"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"cdbea"</span></span><br><span class="line">输出：<span class="number">63</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcodeleetcodeleetcode"</span></span><br><span class="line">输出：<span class="number">982157772</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 3000</code></li><li><code>s</code>​ 只包含小写英文字母。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-string-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-string-sorted</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目非常考验思考的深度，仔细思考如果满足在某处最大值使得$s[i-1] &gt; s[i]….s[j]$，则我们肯定可以得到以下推论：</li></ol><ul><li>首先字符是从<code>i</code>后满足递增：<script type="math/tex; mode=display">s[i] \le s[i+1] \le s[i+2] ...s[j-1] \le s[j] \le s[j+1] ... s[n-2] \le s[n-1]</script></li><li>我们将$s[i]$与$s[j]$进行交换后，从<code>i</code>以后的序列仍然满足递增：<script type="math/tex; mode=display">s[i] \le s[i+1] \le s[i+2] ...s[j-1] \le s[i-1] \le s[j+1] ... s[n-2] \le s[n-1]</script></li></ul><ol><li>我们需要仔细分析一下，反转后的序列，<script type="math/tex; mode=display">s[n-1] \ge s[n-2] ... \ge s[j+1] \ge s[i-1] \ge s[j-1] ... s[i+2] \ge s[i+1] \ge s[i]</script>仔细思考一下，序列:<script type="math/tex; mode=display">t = (s[i-1],s[i],s[i+1] ,s[i+2] ...s[j-1],s[i-1],s[j+1] ... s[n-2],s[n-1]) \\s = (s[j],s[i+1],s[i+2],s[j-1],s[j],s[j+1],s[n-2],s[n-1]) \\</script>经过一变换后的序列$s$刚好是原字符串序列$t$按照字典序从大到小排列的下一个更小的序列，我们最终需要将整个字符串变换为字典序最小的序列。此时我们只需要计算从最小的序列递增到当前的序列需要经过多少步即可。但是实际这个变换还是非常难计算的，中间如果不涉及到重复的字符串，则非常容易计算，但是涉及到重复的字符串则稍微复杂许多，我们需要经过去重的操作。<br>题目的解答参考官方的解答，题目还是非常难的题目<a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-string-sorted/solution/shi-zi-fu-chuan-you-xu-de-zui-shao-cao-z-qgra/" target="_blank" rel="noopener">官方解答</a></li><li>乘法逆元的基本知识，证明过程还是非常复杂，但是记住两个重要的结论：</li></ol><ul><li>$a$在质数$m$的乘法逆元为：<script type="math/tex; mode=display">a \quad mod \quad m \neq 0 \\(a*a^{-1}) \quad mod \quad m = 1 \\a^{-1} = a^{m-2}</script></li><li>$(\frac{a}{b})\quad mod \quad m$可以利用乘法逆元进行等价变换为：<script type="math/tex; mode=display">(\frac{a}{b})\quad mod \quad m = (a*b^{-1})\quad mod \quad m \\= (a*b^{m-2})\quad mod \quad m \\\frac{a}{\prod_{i=1}^{n}b_{i}}\quad mod \quad m = (a*\prod_{i=1}^{n}b_{i}^{-1}) \quad mod \quad m\\= (a*\prod_{i=1}^{n}b_{i}^{m-2})\quad mod \quad m</script></li></ul></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快速幂，用来计算 x^y mod m</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickmul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>, mul = x;</span><br><span class="line">        <span class="keyword">while</span> (y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ret = (LL)ret * mul % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            mul = (LL)mul * mul % mod;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeStringSorted</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fac[i] 表示 i! mod m</span></span><br><span class="line">        <span class="comment">// facinv[i] 表示 i! 在 mod m 意义下的乘法逆元</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fac(n + <span class="number">1</span>), facinv(n + <span class="number">1</span>);</span><br><span class="line">        fac[<span class="number">0</span>] = facinv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fac[i] = (LL)fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">            <span class="comment">// 使用费马小定理 + 快速幂计算乘法逆元</span></span><br><span class="line">            facinv[i] = quickmul(fac[i], mod - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// freq 存储每个字符出现的次数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; freq(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">            ++freq[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// rank 求出比 s[i] 小的字符数量</span></span><br><span class="line">            <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i] - <span class="string">'a'</span>; ++j) &#123;</span><br><span class="line">                rank += freq[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 排列个数的分子</span></span><br><span class="line">            <span class="keyword">int</span> cur = (LL)rank * fac[n - i - <span class="number">1</span>] % mod;</span><br><span class="line">            <span class="comment">// 依次乘分母每一项阶乘的乘法逆元</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                cur = (LL)cur * facinv[freq[j]] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + cur) % mod;</span><br><span class="line">            --freq[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-50&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-50&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly  contest 50&quot;&gt;&lt;/a&gt;leetcode  biweekly  contest 50&lt;/h1&gt;&lt;p&gt;还是三道题的节奏，前三题基本上都是简单题，不到15分钟搞定前三题，最后一题又难度特别高，感觉就是比手速。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/04/18/zubn7aMx1DEXHos.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5717-最少操作使数组递增&quot;&gt;&lt;a href=&quot;#5717-最少操作使数组递增&quot; class=&quot;headerlink&quot; title=&quot;5717. 最少操作使数组递增&quot;&gt;&lt;/a&gt;5717. 最少操作使数组递增&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;（下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 237</title>
    <link href="http://yoursite.com/2021/04/18/275/"/>
    <id>http://yoursite.com/2021/04/18/275/</id>
    <published>2021-04-18T02:20:45.849Z</published>
    <updated>2021-04-18T11:45:12.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-237"><a href="#leetcode-contest-237" class="headerlink" title="leetcode  contest 237"></a>leetcode  contest 237</h1><p>本周周赛的题目都是考验手速，最后一道<code>hard</code>题目可以算是中等难度,感觉就是拼手速。<br><img src="https://i.loli.net/2021/04/18/n9wsAmVWiE6TNKr.png" alt></p><h2 id="5734-判断句子是否为全字母句"><a href="#5734-判断句子是否为全字母句" class="headerlink" title="5734. 判断句子是否为全字母句"></a>5734. 判断句子是否为全字母句</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>全字母句 指包含英语字母表中每个字母至少一次的句子。</p><p>给你一个仅由小写英文字母组成的字符串 <code>sentence</code> ，请你判断 <code>sentence</code> 是否为 全字母句 。</p><a id="more"></a><p>如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"thequickbrownfoxjumpsoverthelazydog"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="keyword">sentence</span> 包含英语字母表中每个字母至少一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 1000</code></li><li><code>sentence</code> 由小写英语字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-237/problems/check-if-the-sentence-is-pangram/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-237/problems/check-if-the-sentence-is-pangram/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>统计<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfPangram</span><span class="params">(<span class="built_in">string</span> A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : A) cnt.insert(c);</span><br><span class="line">        <span class="keyword">return</span> cnt.size() == <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5735-雪糕的最大数量"><a href="#5735-雪糕的最大数量" class="headerlink" title="5735. 雪糕的最大数量"></a>5735. 雪糕的最大数量</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>夏日炎炎，小男孩 <code>Tony</code> 想买一些雪糕消消暑。</p><p>商店中新到 <code>n</code> 支雪糕，用长度为 n 的数组 <code>costs</code> 表示雪糕的定价，其中 <code>costs[i]</code> 表示第 i 支雪糕的现金价格。<code>Tony</code> 一共有 <code>coins</code> 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 <code>costs</code> 和现金量 <code>coins</code> ，请你计算并返回 <code>Tony</code> 用 <code>coins</code> 现金能够买到的雪糕的 最大数量 。</p><p>注意：<code>Tony</code> 可以按任意顺序购买雪糕。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：costs = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>], coins = <span class="number">7</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：Tony 可以买下标为 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">4</span> 的雪糕，总价为 <span class="number">1</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：costs = [<span class="number">10</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>], coins = <span class="number">5</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：Tony 没有足够的钱买任何一支雪糕。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：costs = [<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>], coins = <span class="number">20</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：Tony 可以买下所有的雪糕，总价为 <span class="number">1</span> + <span class="number">6</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">5</span> = <span class="number">18</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>costs.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= costs[i] &lt;= 105</code></li><li><code>1 &lt;= coins &lt;= 108</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-237/problems/maximum-ice-cream-bars/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-237/problems/maximum-ice-cream-bars/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>按照价格从高到底排列即可，依次购买所能达到的最大数量。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = costs.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(costs.begin(),costs.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coins &gt;= costs[i])&#123;</span><br><span class="line">                coins -= costs[i];</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5736-单线程-CPU"><a href="#5736-单线程-CPU" class="headerlink" title="5736. 单线程 CPU"></a>5736. 单线程 CPU</h2><p>给你一个二维数组 <code>tasks</code> ，用于表示 n​​​​​​ 项从 0 到 n - 1 编号的任务。其中 <code>tasks[i] = [enqueueTimei, processingTimei]</code>意味着第 i​​​​​​​​​​ 项任务将会于 <code>enqueueTimei</code> 时进入任务队列，需要 <code>processingTimei</code> 的时长完成执行。</p><p>现有一个单线程 <code>CPU</code>，同一时间只能执行 最多一项 任务，该 <code>CPU</code>将会按照下述方式运行：</p><ul><li>如果 <code>CPU</code> 空闲，且任务队列中没有需要执行的任务，则 <code>CPU</code> 保持空闲状态。</li><li>如果 <code>CPU</code> 空闲，但任务队列中有需要执行的任务，则 <code>CPU</code> 将会选择 执行时间最短 的任务开始执行。</li><li>如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li><li>一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。</li><li><code>CPU</code> 可以在完成一项任务后，立即开始执行一项新任务。<br>返回 CPU 处理任务的顺序。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：事件按下述流程运行： </span><br><span class="line">- time = <span class="number">1</span> ，任务 <span class="number">0</span> 进入任务队列，可执行任务项 = &#123;<span class="number">0</span>&#125;</span><br><span class="line">- 同样在 time = <span class="number">1</span> ，空闲状态的 CPU 开始执行任务 <span class="number">0</span> ，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = <span class="number">2</span> ，任务 <span class="number">1</span> 进入任务队列，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">3</span> ，任务 <span class="number">2</span> 进入任务队列，可执行任务项 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">- 同样在 time = <span class="number">3</span> ，CPU 完成任务 <span class="number">0</span> 并开始执行队列中用时最短的任务 <span class="number">2</span> ，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">4</span> ，任务 <span class="number">3</span> 进入任务队列，可执行任务项 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">- time = <span class="number">5</span> ，CPU 完成任务 <span class="number">2</span> 并开始执行队列中用时最短的任务 <span class="number">3</span> ，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">6</span> ，CPU 完成任务 <span class="number">3</span> 并开始执行任务 <span class="number">1</span> ，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = <span class="number">10</span> ，CPU 完成任务 <span class="number">1</span> 并进入空闲状态</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">7</span>,<span class="number">10</span>],[<span class="number">7</span>,<span class="number">12</span>],[<span class="number">7</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：事件按下述流程运行： </span><br><span class="line">- time = <span class="number">7</span> ，所有任务同时进入任务队列，可执行任务项  = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">- 同样在 time = <span class="number">7</span> ，空闲状态的 CPU 开始执行任务 <span class="number">4</span> ，可执行任务项 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">- time = <span class="number">9</span> ，CPU 完成任务 <span class="number">4</span> 并开始执行任务 <span class="number">3</span> ，可执行任务项 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">- time = <span class="number">13</span> ，CPU 完成任务 <span class="number">3</span> 并开始执行任务 <span class="number">2</span> ，可执行任务项 = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">18</span> ，CPU 完成任务 <span class="number">2</span> 并开始执行任务 <span class="number">0</span> ，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">28</span> ，CPU 完成任务 <span class="number">0</span> 并开始执行任务 <span class="number">1</span> ，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = <span class="number">40</span> ，CPU 完成任务 <span class="number">1</span> 并进入空闲状态</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>tasks.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= enqueueTimei, processingTimei &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-xor-for-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-xor-for-each-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的优先级队列解法；</li><li>首先我们将队列按照入队时间进行排列。我们设置一个时间轴<code>enter</code>表示当前任务处理的起始时间，当前如果队列为空，或者当前任务的入队时间小于等于<code>CPU</code>的处理起始时间，我们则将任务进行入队等待操作；如果当前的任务的起始时间大于<code>CPU</code>的处理任务时间，则我们必须将任务从已有队列中移出，直到<code>CPU</code>的处理任务的起始时间大于等于当前任务的入队时间。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> start,<span class="keyword">int</span> cost)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;idx = idx;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a,Node &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.cost == b.cost)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.idx &gt; b.idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = tasks.size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; arr;</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); ++i)&#123;</span><br><span class="line">            arr.push_back(Node(i,tasks[i][<span class="number">0</span>],tasks[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](Node &amp; a,Node &amp; b)&#123;</span><br><span class="line">           <span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> enter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(enter &lt; arr[i].start &amp;&amp; !pq.empty())&#123;</span><br><span class="line">                Node curr = pq.top();</span><br><span class="line">                pq.pop();</span><br><span class="line">                ans.push_back(curr.idx);</span><br><span class="line">                enter += curr.cost;</span><br><span class="line">            &#125;</span><br><span class="line">            enter = max(enter,arr[i].start);</span><br><span class="line">            pq.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            ans.push_back(curr.idx);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5737-所有数对按位与结果的异或和"><a href="#5737-所有数对按位与结果的异或和" class="headerlink" title="5737. 所有数对按位与结果的异或和"></a>5737. 所有数对按位与结果的异或和</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>列表的 异或和<code>（XOR sum）</code>指对所有元素进行按位 <code>XOR</code> 运算的结果。如果列表中仅有一个元素，那么其 异或和 就等于该元素。</p><p>例如，<code>[1,2,3,4]</code> 的 异或和 等于<code>1 XOR 2 XOR 3 XOR 4 = 4</code>，而 <code>[3]</code> 的 异或和 等于 3 。<br>给你两个下标 从 0 开始 计数的数组 arr1 和 arr2 ，两数组均由非负整数组成。</p><p>根据每个 <code>(i, j)</code>数对，构造一个由 <code>arr1[i] AND arr2[j]</code>（按位 AND 运算）结果组成的列表。其中 <code>0 &lt;= i &lt; arr1.length</code> 且 <code>0 &lt;= j &lt; arr2.length</code> 。</p><p>返回上述列表的 异或和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], arr2 = [<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：列表 = [<span class="number">1</span> AND <span class="number">6</span>, <span class="number">1</span> AND <span class="number">5</span>, <span class="number">2</span> AND <span class="number">6</span>, <span class="number">2</span> AND <span class="number">5</span>, <span class="number">3</span> AND <span class="number">6</span>, <span class="number">3</span> AND <span class="number">5</span>] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>] ，</span><br><span class="line">异或和 = <span class="number">0</span> XOR <span class="number">1</span> XOR <span class="number">2</span> XOR <span class="number">0</span> XOR <span class="number">2</span> XOR <span class="number">1</span> = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 = [<span class="number">12</span>], arr2 = [<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：列表 = [<span class="number">12</span> AND <span class="number">4</span>] = [<span class="number">4</span>] ，异或和 = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr1.length, arr2.length &lt;= 105</code></li><li><code>0 &lt;= arr1[i], arr2[j] &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-237/problems/find-xor-sum-of-all-pairs-bitwise-and/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-237/problems/find-xor-sum-of-all-pairs-bitwise-and/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目可以算是中等难度，我们仔细的需要思考如下某个数<code>num</code>：</li></ol><ul><li>如果$num$的第$i$位为<code>0</code>,则第<code>i</code>位<code>and</code>任何数的结果则都为<code>0</code>;</li><li>如果$num$的第$i$位为<code>1</code>,则第<code>i</code>位<code>and 1</code>的结果则都为<code>1</code>;</li><li>奇数个<code>1</code>的异或的结果为<code>1</code>，偶数个<code>1</code>异或的结果则为<code>0</code>;</li><li>我们可以求所出数组<code>arr1</code>的某个数$arr1[i]$的每一位与<code>arr2</code>的每一位进行<code>AND</code>之后再进行异或后的结果。</li></ul><ol><li>实际可以更简单的利用公式：<script type="math/tex; mode=display">(a\&b)\oplus (a\&c) = a\&(b\oplus c)</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = arr1.size();</span><br><span class="line">        <span class="keyword">int</span> l2 = arr2.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; ++i) x = x^arr1[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l2; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr2[i]&amp;(<span class="number">1</span>&lt;&lt;j)&amp;(x)) ans ^=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-237&quot;&gt;&lt;a href=&quot;#leetcode-contest-237&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 237&quot;&gt;&lt;/a&gt;leetcode  contest 237&lt;/h1&gt;&lt;p&gt;本周周赛的题目都是考验手速，最后一道&lt;code&gt;hard&lt;/code&gt;题目可以算是中等难度,感觉就是拼手速。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/04/18/n9wsAmVWiE6TNKr.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5734-判断句子是否为全字母句&quot;&gt;&lt;a href=&quot;#5734-判断句子是否为全字母句&quot; class=&quot;headerlink&quot; title=&quot;5734. 判断句子是否为全字母句&quot;&gt;&lt;/a&gt;5734. 判断句子是否为全字母句&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;全字母句 指包含英语字母表中每个字母至少一次的句子。&lt;/p&gt;&lt;p&gt;给你一个仅由小写英文字母组成的字符串 &lt;code&gt;sentence&lt;/code&gt; ，请你判断 &lt;code&gt;sentence&lt;/code&gt; 是否为 全字母句 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly  Contest 236</title>
    <link href="http://yoursite.com/2021/04/11/273/"/>
    <id>http://yoursite.com/2021/04/11/273/</id>
    <published>2021-04-11T05:38:01.505Z</published>
    <updated>2021-04-18T04:15:17.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-weekly-contest-236"><a href="#leetcode-weekly-contest-236" class="headerlink" title="leetcode weekly contest 236"></a>leetcode weekly contest 236</h1><p>还是三道题的节奏，周赛题目比季度赛的题目简单多了，最后一题实际可以用<code>bst</code>或者<code>set</code>均可。</p><h2 id="5726-数组元素积的符号"><a href="#5726-数组元素积的符号" class="headerlink" title="5726. 数组元素积的符号"></a>5726. 数组元素积的符号</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>已知函数 <code>signFunc(x)</code> 将会根据 x 的正负返回特定值：</p><ul><li>如果 <code>x</code> 是正数，返回 <code>1</code>。</li><li>如果 <code>x</code> 是负数，返回 <code>-1</code> 。</li><li>如果 <code>x</code> 是等于 <code>0</code> ，返回 <code>0</code> 。<br>给你一个整数数组 <code>nums</code> 。令 <code>product</code> 为数组 <code>nums</code> 中所有元素值的乘积。</li></ul><a id="more"></a><p>返回 <code>signFunc(product)</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：数组中所有值的乘积是 <span class="number">144</span> ，且 signFunc(<span class="number">144</span>) = <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：数组中所有值的乘积是 <span class="number">0</span> ，且 signFunc(<span class="number">0</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：数组中所有值的乘积是 <span class="number">-1</span> ，且 signFunc(<span class="number">-1</span>) = <span class="number">-1</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">-100</span> &lt;= nums[i] &lt;= <span class="number">100</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/sign-of-the-product-of-an-array</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   计算符号的个数即可</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 遇到第`k`个空格则推出即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">array</span>Sign(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        long long curr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; <span class="number">0</span>) curr = curr*(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">0</span>) curr = curr*<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5727-找出游戏的获胜者"><a href="#5727-找出游戏的获胜者" class="headerlink" title="5727. 找出游戏的获胜者"></a>5727. 找出游戏的获胜者</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第<code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code>，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。</p><p>游戏遵循如下规则：</p><ul><li>从第 1 名小伙伴所在位置 开始 。</li><li>沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。</li><li>否则，圈子中最后一名小伙伴赢得游戏。<br>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</li></ul><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：游戏运行步骤如下：</span><br><span class="line"><span class="number">1</span>) 从小伙伴 <span class="number">1</span> 开始。</span><br><span class="line"><span class="number">2</span>) 顺时针数 <span class="number">2</span> 名小伙伴，也就是小伙伴 <span class="number">1</span> 和 <span class="number">2</span> 。</span><br><span class="line"><span class="number">3</span>) 小伙伴 <span class="number">2</span> 离开圈子。下一次从小伙伴 <span class="number">3</span> 开始。</span><br><span class="line"><span class="number">4</span>) 顺时针数 <span class="number">2</span> 名小伙伴，也就是小伙伴 <span class="number">3</span> 和 <span class="number">4</span> 。</span><br><span class="line"><span class="number">5</span>) 小伙伴 <span class="number">4</span> 离开圈子。下一次从小伙伴 <span class="number">5</span> 开始。</span><br><span class="line"><span class="number">6</span>) 顺时针数 <span class="number">2</span> 名小伙伴，也就是小伙伴 <span class="number">5</span> 和 <span class="number">1</span> 。</span><br><span class="line"><span class="number">7</span>) 小伙伴 <span class="number">1</span> 离开圈子。下一次从小伙伴 <span class="number">3</span> 开始。</span><br><span class="line"><span class="number">8</span>) 顺时针数 <span class="number">2</span> 名小伙伴，也就是小伙伴 <span class="number">3</span> 和 <span class="number">5</span> 。</span><br><span class="line"><span class="number">9</span>) 小伙伴 <span class="number">5</span> 离开圈子。只剩下小伙伴 <span class="number">3</span> 。所以小伙伴 <span class="number">3</span> 是游戏的获胜者。</span><br></pre></td></tr></table></figure><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：小伙伴离开圈子的顺序：<span class="number">5</span>、<span class="number">4</span>、<span class="number">6</span>、<span class="number">2</span>、<span class="number">3</span> 。小伙伴 <span class="number">1</span> 是游戏的获胜者。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= n &lt;= 500</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 经典的约瑟夫环问题，可以利用公式或者直接模拟即可，因为本题数据量非常小，直接模拟即可，时间复杂度$O(n^{2})$即可解决。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheWinner</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p=(p+k)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5728-最少侧跳次数"><a href="#5728-最少侧跳次数" class="headerlink" title="5728. 最少侧跳次数"></a>5728. 最少侧跳次数</h2><p>给你一个长度为 <code>n</code> 的 <code>3</code>跑道道路 ，它总共包含<code>n + 1</code>个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。</p><p>给你一个长度为 <code>n + 1</code> 的数组 <code>obstacles</code>，其中 <code>obstacles[i]</code> （取值范围从 0 到 3）表示在点 i 处的 <code>obstacles[i]</code>跑道上有一个障碍。如果 <code>obstacles[i] == 0</code>，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。</p><p>比方说，如果 <code>obstacles[2] == 1</code> ，那么说明在点 2 处跑道 1 有障碍。<br>这只青蛙从点 i 跳到点 <code>i + 1</code>且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p><p>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。<br>这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。</p><p>注意：点 0 处和点 n 处的任一跑道都不会有障碍。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：最优方案如上图箭头所示。总共有 <span class="number">2</span> 次侧跳（红色箭头）。</span><br><span class="line">注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 <span class="number">2</span> 处所示）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：跑道 <span class="number">2</span> 没有任何障碍，所以不需要任何侧跳。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最优方案如上图所示。总共有 <span class="number">2</span> 次侧跳。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>obstacles.length == n + 1</code></li><li><code>1 &lt;= n &lt;= 5 * 105</code></li><li><code>0 &lt;= obstacles[i] &lt;= 3</code></li><li><code>obstacles[0] == obstacles[n] == 0</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-sideway-jumps" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-sideway-jumps</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的<code>dp</code>即可解决该问题，<code>dp[i][j]</code>表示到达第<code>i</code>跳第<code>j</code>个赛道时花费的最少跳数。<script type="math/tex; mode=display">dp[i][j] = min(dp[i-1][j],dp[i][j+1] + 1,dp[i][j+2] + 1)</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSideJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = obstacles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>,n+<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*initial*/</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(obstacles[i] != j) dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j)&#123;</span><br><span class="line">               <span class="keyword">if</span>(obstacles[i] != j)&#123;</span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">3</span>; ++k)&#123;</span><br><span class="line">                       dp[i][j] = min(dp[i][j],dp[i][k] + <span class="number">1</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *min_element(dp[n<span class="number">-1</span>].begin(),dp[n<span class="number">-1</span>].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5729-求出-MK-平均值"><a href="#5729-求出-MK-平均值" class="headerlink" title="5729. 求出 MK 平均值"></a>5729. 求出 MK 平均值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数 <code>m</code> 和 <code>k</code> ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 <code>MK</code> 平均值 。</p><p>MK 平均值 按照如下步骤计算：</p><p>如果数据流中的整数少于 <code>m</code> 个，<code>MK</code> 平均值 为 <code>-1</code> ，否则将数据流中最后 <code>m</code>个元素拷贝到一个独立的容器中。<br>从这个容器中删除最小的 k 个数和最大的 k 个数。<br>计算剩余元素的平均值，并 向下取整到最近的整数 。<br>请你实现 <code>MKAverage</code> 类：</p><ul><li><code>MKAverage(int m, int k)</code> 用一个空的数据流和两个整数 m 和 k 初始化 MKAverage 对象。</li><li><code>void addElement(int num)</code> 往数据流中插入一个新的元素 num 。</li><li><code>int calculateMKAverage()</code> 对当前的数据流计算并返回 MK 平均数 ，结果需 向下取整到最近的整数 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MKAverage"</span>, <span class="string">"addElement"</span>, <span class="string">"addElement"</span>, <span class="string">"calculateMKAverage"</span>, <span class="string">"addElement"</span>, <span class="string">"calculateMKAverage"</span>, <span class="string">"addElement"</span>, <span class="string">"addElement"</span>, <span class="string">"addElement"</span>, <span class="string">"calculateMKAverage"</span>]</span><br><span class="line">[[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>], [<span class="number">1</span>], [], [<span class="number">10</span>], [], [<span class="number">5</span>], [<span class="number">5</span>], [<span class="number">5</span>], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">-1</span>, null, <span class="number">3</span>, null, null, null, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MKAverage obj = new MKAverage(<span class="number">3</span>, <span class="number">1</span>); </span><br><span class="line">obj.addElement(<span class="number">3</span>);        <span class="comment">// 当前元素为 [3]</span></span><br><span class="line">obj.addElement(<span class="number">1</span>);        <span class="comment">// 当前元素为 [3,1]</span></span><br><span class="line">obj.calculateMKAverage(); <span class="comment">// 返回 -1 ，因为 m = 3 ，但数据流中只有 2 个元素</span></span><br><span class="line">obj.addElement(<span class="number">10</span>);       <span class="comment">// 当前元素为 [3,1,10]</span></span><br><span class="line">obj.calculateMKAverage(); <span class="comment">// 最后 3 个元素为 [3,1,10]</span></span><br><span class="line">                          <span class="comment">// 删除最小以及最大的 1 个元素后，容器为 [3]</span></span><br><span class="line">                          <span class="comment">// [3] 的平均值等于 3/1 = 3 ，故返回 3</span></span><br><span class="line">obj.addElement(<span class="number">5</span>);        <span class="comment">// 当前元素为 [3,1,10,5]</span></span><br><span class="line">obj.addElement(<span class="number">5</span>);        <span class="comment">// 当前元素为 [3,1,10,5,5]</span></span><br><span class="line">obj.addElement(<span class="number">5</span>);        <span class="comment">// 当前元素为 [3,1,10,5,5,5]</span></span><br><span class="line">obj.calculateMKAverage(); <span class="comment">// 最后 3 个元素为 [5,5,5]</span></span><br><span class="line">                          <span class="comment">// 删除最小以及最大的 1 个元素后，容器为 [5]</span></span><br><span class="line">                          <span class="comment">// [5] 的平均值等于 5/1 = 5 ，故返回 5</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>3 &lt;= m &lt;= 105</code></li><li><code>1 &lt;= k*2 &lt; m</code></li><li><code>1 &lt;= num &lt;= 105</code></li><li><code>addElement</code> 与 <code>calculateMKAverage</code> 总操作次数不超过 105 次。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-mk-average" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-mk-average</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p><code>BST</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>最简单直接的方法就是利用三个有序的<code>set</code>，分别存储最小的<code>k</code>个数，中间的<code>m-2*k</code>个数，最大的<code>k</code>个数，比赛时想到了用这种方法，但是没有写对。</li><li>每次更新时将最后一个元素删除，并同时加入新的元素，然后分别调整三个<code>set</code>使得其数量和大小关系达成符合条件要求即可。最大的收获时关于<code>multiset</code>的几种基本操作。</li></ol><ul><li><code>erase</code>的几种基本操作:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>但是关键一点<code>erase</code>不支持<code>reverse_iterator</code>,这个是我第一次知道。<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position</span><br><span class="line">Iterator pointing <span class="built_in">to</span> <span class="keyword">a</span> single <span class="keyword">element</span> <span class="built_in">to</span> be removed <span class="built_in">from</span> <span class="keyword">the</span> multiset.</span><br><span class="line">Member types iterator <span class="keyword">and</span> const_iterator are bidirectional iterator types that point <span class="built_in">to</span> elements.</span><br><span class="line">erase postion支持对multiset中单个元素的删除</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val</span><br><span class="line">Value <span class="keyword">to</span> be removed <span class="keyword">from</span> the multiset. All elements with a value equivalent <span class="keyword">to</span> this are removed <span class="keyword">from</span> the container.</span><br><span class="line">Member<span class="built_in"> type </span>value_type is the<span class="built_in"> type </span>of the elements <span class="keyword">in</span> the container, defined <span class="keyword">in</span> multiset as an alias of its first template parameter (T).</span><br><span class="line">erase val则会将集合中所有等于val的元素全部删除</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">first</span>, <span class="keyword">last</span></span><br><span class="line">Iterators specifying <span class="keyword">a</span> range <span class="keyword">within</span> <span class="keyword">the</span> multiset container <span class="built_in">to</span> be removed: [<span class="keyword">first</span>,<span class="keyword">last</span>). i.e., <span class="keyword">the</span> range includes all <span class="keyword">the</span> elements between <span class="keyword">first</span> <span class="keyword">and</span> <span class="keyword">last</span>, including <span class="keyword">the</span> <span class="keyword">element</span> pointed <span class="keyword">by</span> <span class="keyword">first</span> but <span class="keyword">not</span> <span class="keyword">the</span> <span class="literal">one</span> pointed <span class="keyword">by</span> <span class="keyword">last</span>.</span><br><span class="line">Member types iterator <span class="keyword">and</span> const_iterator are bidirectional iterator types that point <span class="built_in">to</span> elements.</span><br><span class="line">erase val则会将集合中[<span class="keyword">first</span>, <span class="keyword">last</span>]的元素全部删除，支持范围删除</span><br></pre></td></tr></table></figure></li></ul><ol><li>线段树的版本最后花了点时间参考树状数组的解法写了出来，收获不少，可以将数组中的元素离散化，全部转换成对元素的统计，通过二分查找，我们找到从小到大排序中第<code>k</code>个元素$num_{k}$和第<code>m-k</code>个元素$num_{m-k}$，然后利用线段树求所有小于等于$num_{k}$的元素的和与所有小于等于$num_{m-k}$的元素和，然后求差即可得到第<code>k+1</code>个元素到第<code>m-k</code>个元素的和。解法非常巧妙，但是非常值得学习的解法。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MKAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m, k, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; lower, middle, upper;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    </span><br><span class="line">    MKAverage(<span class="keyword">int</span> m, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftLeft</span><span class="params">(<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&amp; l, <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        l.insert(*r.begin());</span><br><span class="line">        r.erase(r.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftRight</span><span class="params">(<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&amp; l, <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        r.insert(*l.rbegin());</span><br><span class="line">        l.erase(--l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        nums.push(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lower.size() &amp;&amp; *lower.rbegin() &gt;= num) lower.insert(num);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(upper.size() &amp;&amp; *upper.begin() &lt;= num) upper.insert(num);</span><br><span class="line">        <span class="keyword">else</span> middle.insert(num), sum += num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(lower.size() &gt; k)&#123;</span><br><span class="line">            sum += *lower.rbegin();</span><br><span class="line">            shiftRight(lower, middle);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span>(upper.size() &gt; k)&#123;</span><br><span class="line">            sum += *upper.begin();</span><br><span class="line">            shiftLeft(middle, upper);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*erase the first element*/</span></span><br><span class="line">        <span class="keyword">if</span>(nums.size() &gt; m) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = nums.front(); </span><br><span class="line">            nums.pop();</span><br><span class="line">            <span class="keyword">if</span>(lower.find(d) != lower.end()) lower.erase(lower.find(d));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(middle.find(d) != middle.end()) middle.erase(middle.find(d)), sum -= d;</span><br><span class="line">            <span class="keyword">else</span> upper.erase(upper.find(d));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">while</span>(lower.size() &lt; k)&#123;</span><br><span class="line">                sum -= *middle.begin();</span><br><span class="line">                shiftLeft(lower, middle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(upper.size() &lt; k)&#123;</span><br><span class="line">                sum -= *middle.rbegin();</span><br><span class="line">                shiftRight(middle, upper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMKAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> sum / (m - <span class="number">2</span>*k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2 + 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line">segTreeNode tree[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    tree[idx].count = tree[CHL(idx)].count + tree[CHR(idx)].count;</span><br><span class="line">    tree[idx].sum = tree[CHL(idx)].sum + tree[CHR(idx)].sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[idx].count = arr[l];</span><br><span class="line">        tree[idx].sum = l*arr[l];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(l,mid,arr,CHL(idx));</span><br><span class="line">    buildTree(mid+<span class="number">1</span>,r,arr,CHR(idx));</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryCount</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt;= x) <span class="keyword">return</span> tree[idx].count;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryCount(l,mid,CHL(idx),x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryCount(l,mid,CHL(idx),x) + queryCount(mid+<span class="number">1</span>,r,CHR(idx),x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryKth</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> kth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].count &lt; kth) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == tree[idx].r) <span class="keyword">return</span> tree[idx].l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = tree[CHL(idx)].count;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= kth)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryKth(CHL(idx),kth);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryKth(CHR(idx),kth -left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt;= x) <span class="keyword">return</span> tree[idx].sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> querySum(l,mid,CHL(idx),x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> querySum(l,mid,CHL(idx),x) + querySum(mid+<span class="number">1</span>,r,CHR(idx),x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">addTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt; x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == x &amp;&amp; tree[idx].r == x)&#123;</span><br><span class="line">        tree[idx].count += val;</span><br><span class="line">        tree[idx].sum += val*x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        addTree(CHL(idx),x,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        addTree(CHR(idx),x,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MKAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MKAverage(<span class="keyword">int</span> m, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">100001</span>);</span><br><span class="line">        buildTree(<span class="number">0</span>,<span class="number">100000</span>,arr,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        qu.push(num);</span><br><span class="line">        addTree(<span class="number">1</span>,num,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(qu.size() &gt; m)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            addTree(<span class="number">1</span>,x,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMKAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(qu.size() &lt; m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> lower = queryKth(<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">int</span> upper = queryKth(<span class="number">1</span>,m-k);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lsum = querySum(<span class="number">0</span>,<span class="number">100000</span>,<span class="number">1</span>,lower);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rsum = querySum(<span class="number">0</span>,<span class="number">100000</span>,<span class="number">1</span>,upper);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lcnt = queryCount(<span class="number">0</span>,<span class="number">100000</span>,<span class="number">1</span>,lower);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rcnt = queryCount(<span class="number">0</span>,<span class="number">100000</span>,<span class="number">1</span>,upper);</span><br><span class="line">        <span class="keyword">if</span>(lcnt &gt; k) lsum -= (lcnt-k)*lower;</span><br><span class="line">        <span class="keyword">if</span>(rcnt &gt; m-k) rsum -= (rcnt - (m-k))*upper;</span><br><span class="line">        <span class="keyword">return</span> (rsum-lsum)/(m<span class="number">-2</span>*k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MKAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MKAverage* obj = new MKAverage(m, k);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addElement(num);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;calculateMKAverage();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-weekly-contest-236&quot;&gt;&lt;a href=&quot;#leetcode-weekly-contest-236&quot; class=&quot;headerlink&quot; title=&quot;leetcode weekly contest 236&quot;&gt;&lt;/a&gt;leetcode weekly contest 236&lt;/h1&gt;&lt;p&gt;还是三道题的节奏，周赛题目比季度赛的题目简单多了，最后一题实际可以用&lt;code&gt;bst&lt;/code&gt;或者&lt;code&gt;set&lt;/code&gt;均可。&lt;/p&gt;&lt;h2 id=&quot;5726-数组元素积的符号&quot;&gt;&lt;a href=&quot;#5726-数组元素积的符号&quot; class=&quot;headerlink&quot; title=&quot;5726. 数组元素积的符号&quot;&gt;&lt;/a&gt;5726. 数组元素积的符号&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;已知函数 &lt;code&gt;signFunc(x)&lt;/code&gt; 将会根据 x 的正负返回特定值：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 是正数，返回 &lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 是负数，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 是等于 &lt;code&gt;0&lt;/code&gt; ，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;br&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。令 &lt;code&gt;product&lt;/code&gt; 为数组 &lt;code&gt;nums&lt;/code&gt; 中所有元素值的乘积。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  LCCUP 2021 团队赛</title>
    <link href="http://yoursite.com/2021/04/08/272/"/>
    <id>http://yoursite.com/2021/04/08/272/</id>
    <published>2021-04-08T14:22:38.256Z</published>
    <updated>2021-04-13T01:42:47.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-LCCUP-2021-团队赛"><a href="#leetcode-LCCUP-2021-团队赛" class="headerlink" title="leetcode  LCCUP 2021 团队赛"></a>leetcode  LCCUP 2021 团队赛</h1><h2 id="LCP-33-蓄水"><a href="#LCP-33-蓄水" class="headerlink" title="LCP 33. 蓄水"></a>LCP 33. 蓄水</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 <code>N</code>个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 <code>bucket[i]</code>。小扣有以下两种操作：</p><ul><li>升级水桶：选择任意一个水桶，使其容量增加为 <code>bucket[i]+1</code></li><li>蓄水：将全部水桶接满水，倒入各自对应的水缸<br>每个水缸对应最低蓄水量记作 <code>vat[i]</code>，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。</li></ul><a id="more"></a><p>注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bucket = [<span class="number">1</span>,<span class="number">3</span>], vat = [<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 次操作升级 bucket[<span class="number">0</span>]；</span><br><span class="line">第 <span class="number">2</span> ~ <span class="number">4</span> 次操作均选择蓄水，即可完成蓄水要求。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：bucket = [<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>], vat = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>输出：3<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 次操作均选择升级 bucket[<span class="number">1</span>]</span><br><span class="line">第 <span class="number">2</span>~<span class="number">3</span> 次操作选择蓄水，即可完成蓄水要求。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= bucket.length == vat.length &lt;= 100</code></li><li><code>0 &lt;= bucket[i], vat[i] &lt;= 10^4</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/o8SXZn" target="_blank" rel="noopener">https://leetcode-cn.com/problems/o8SXZn</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  贪心算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>最优策略肯定是我们将每个水桶升级到一定的重量，然后一起进行蓄水<code>n</code>次即可。</li><li>难点在于如何求得最终蓄水的次数，好在我们可以进行暴力，遍历所有可能的蓄水次数，在蓄水之前同时要升级水桶，如何求得升级的水桶：设总容量为$v$,蓄水次数为$n$,则我们知道桶的重量肯定最少需要为<script type="math/tex; mode=display">b \ge ⌈\frac{v}{n}⌉</script>依次我们需要升级桶的次数为$⌈\frac{v}{n}⌉ - b$，求出所有的升级次数即可再加上升级次数。</li><li>唯一需要注意的一点，需要剔除到容量为$0$的水池。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">storeWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bucket, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = vat.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxn = *max_element(vat.begin(),vat.end());</span><br><span class="line">        <span class="keyword">if</span>(maxn == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                curr += max(<span class="number">0</span>,(vat[j] + i <span class="number">-1</span>)/i - bucket[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans,curr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-34-二叉树染色"><a href="#LCP-34-二叉树染色" class="headerlink" title="LCP 34. 二叉树染色"></a>LCP 34. 二叉树染色</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>小扣有一个根结点为 <code>root</code> 的二叉树模型，初始所有结点均为白色，可以用蓝色染料给模型结点染色，模型的每个结点有一个 <code>val</code>价值。小扣出于美观考虑，希望最后二叉树上每个蓝色相连部分的结点个数不能超过<code>k</code>个，求所有染成蓝色的结点价值总和最大是多少？</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line"></span><br><span class="line">解释：结点 <span class="number">5</span>、<span class="number">3</span>、<span class="number">4</span> 染成蓝色，获得最大的价值 <span class="number">5</span>+<span class="number">3</span>+<span class="number">4</span>=<span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line"></span><br><span class="line">解释：结点 <span class="number">4</span>、<span class="number">3</span>、<span class="number">9</span> 染成蓝色，获得最大的价值 <span class="number">4</span>+<span class="number">3</span>+<span class="number">9</span>=<span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= k &lt;= 10</li><li>1 &lt;= val &lt;= 10000</li><li>1 &lt;= 结点数量 &lt;= 10000</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/er-cha-shu-ran-se-UGC" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-ran-se-UGC</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dfs</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的非常好，非常适合于面试题目，难度刚好始终，非常适合思考，写代码的难度不是很难。</li><li>设<code>dp(root,i)</code>表示以当前<code>root</code>为根节点，且包含根节点在内被染色的节点的个数为<code>i</code>的最大价值，我们即可传递下去：<script type="math/tex; mode=display">dp[root][i] = max(dp[root][i],dp[left][j] + 1 + dp[right][i-j])</script></li><li>还是非常有深度思考的<code>dfs</code>方案。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfs(TreeNode * root,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vl = dfs(root-&gt;left,k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vr = dfs(root-&gt;right,k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; k; ++j)&#123;</span><br><span class="line">                ans[i+j+<span class="number">1</span>] = max(ans[i+j+<span class="number">1</span>],root-&gt;val + vl[i] + vr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = max(ans[<span class="number">0</span>],vl[i] + vr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret = dfs(root,k);</span><br><span class="line">        <span class="keyword">return</span> *max_element(ret.begin(),ret.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-35-电动车游城市"><a href="#LCP-35-电动车游城市" class="headerlink" title="LCP 35. 电动车游城市"></a>LCP 35. 电动车游城市</h2><p>小明的电动车电量充满时可行驶距离为 <code>cnt</code>，每行驶 <code>1</code> 单位距离消耗 <code>1</code> 单位电量，且花费 <code>1</code> 单位时间。小明想选择电动车作为代步工具。地图上共有 <code>N</code> 个景点，景点编号为<code>0 ~ N-1</code>。他将地图信息以 [城市 <code>A</code>编号,城市 <code>B</code> 编号,两城市间距离] 格式整理在在二维数组<code>paths</code>，表示城市<code>A、B</code>间存在双向通路。初始状态，电动车电量为 <code>0</code>。每个城市都设有充电桩，<code>charge[i]</code> 表示第 <code>i</code>个城市每充 <code>1</code> 单位电量需要花费的单位时间。请返回小明最少需要花费多少单位时间从起点城市 <code>start</code> 抵达终点城市 <code>end</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>]], cnt = <span class="number">6</span>, start = <span class="number">1</span>, end = <span class="number">0</span>, charge = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">43</span></span><br><span class="line"></span><br><span class="line">解释：最佳路线为：<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">0</span>。</span><br><span class="line">在城市 <span class="number">1</span> 仅充 <span class="number">3</span> 单位电至城市 <span class="number">3</span>，然后在城市 <span class="number">3</span> 充 <span class="number">5</span> 单位电，行驶至城市 <span class="number">5</span>。</span><br><span class="line">充电用时共 <span class="number">3</span>*<span class="number">10</span> + <span class="number">5</span>*<span class="number">1</span>= <span class="number">35</span></span><br><span class="line">行驶用时 <span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span>，此时总用时最短 <span class="number">43</span>。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>]], cnt = <span class="number">8</span>, start = <span class="number">0</span>, end = <span class="number">2</span>, charge = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">38</span></span><br><span class="line"></span><br><span class="line">解释：最佳路线为：<span class="number">0</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>。</span><br><span class="line">城市 <span class="number">0</span> 充电 <span class="number">2</span> 单位，行驶至城市 <span class="number">4</span> 充电 <span class="number">8</span> 单位，行驶至城市 <span class="number">3</span> 充电 <span class="number">1</span> 单位，最终行驶至城市 <span class="number">2</span>。</span><br><span class="line">充电用时 <span class="number">4</span>*<span class="number">2</span>+<span class="number">2</span>*<span class="number">8</span>+<span class="number">3</span>*<span class="number">1</span> = <span class="number">27</span></span><br><span class="line">行驶用时 <span class="number">2</span>+<span class="number">5</span>+<span class="number">4</span> = <span class="number">11</span>，总用时最短 <span class="number">38</span>。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= paths.length &lt;= 200</code></li><li><code>paths[i].length == 3</code></li><li><code>2 &lt;= charge.length == n &lt;= 100</code></li><li><code>0 &lt;= path[i][0],path[i][1],start,end &lt; n</code></li><li><code>1 &lt;= cnt &lt;= 100</code></li><li><code>1 &lt;= path[i][2] &lt;= cnt</code></li><li><code>1 &lt;= charge[i] &lt;= 100</code></li><li>题目保证所有城市相互可以到达</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/DFPeFJ" target="_blank" rel="noopener">https://leetcode-cn.com/problems/DFPeFJ</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>dijistra</code>算法，我们设置<code>dp[i][x]</code>表示我们到达第<code>i</code>个城市后，剩余的电量为<code>x</code>时所花费的最小时间。</li><li>状态转移：当我们达到一个城市<code>i</code>且当前剩余电量为<code>x</code>时，次时我们需要计算下一个的状态转移：</li></ol><ul><li>要么我们继续停留在当前城市进行充电,我们可以遍历所有的可能，每充电<code>1</code>单位则记录一个状态；</li><li>要么我们选择开到另一个城市<code>j</code>，则此时存有的电量值应该能够满足开到另一个城市，$x \ge cost[i][j]$；</li></ul><ol><li>根据计算本程序的时间复杂度为$O(n<em>(C+m))$,空间复杂度为$O(n</em>m)$<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> e,<span class="keyword">int</span> cost)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;e = e;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a,Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">electricCarPlan</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths, <span class="keyword">int</span> cnt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; charge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = charge.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INF;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cnt+<span class="number">1</span>,INF));</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : paths)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(&#123;v[<span class="number">0</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pq.push(Node(start,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        dp[start][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*we find it reach to the end*/</span></span><br><span class="line">            <span class="keyword">if</span>(curr.x == end) <span class="keyword">return</span> curr.cost;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.x])&#123;</span><br><span class="line">                <span class="keyword">int</span> nx = v.first;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = v.second; i &lt;= cnt; ++i)&#123;</span><br><span class="line">                    <span class="keyword">int</span> add = max(<span class="number">0</span>,i-curr.e);</span><br><span class="line">                    <span class="keyword">int</span> cost = curr.cost + v.second + add*charge[curr.x];</span><br><span class="line">                    <span class="keyword">if</span>(dp[nx][i-v.second] &gt; cost)&#123;</span><br><span class="line">                        pq.push(Node(nx,i-v.second,cost));</span><br><span class="line">                        dp[nx][i-v.second] = cost;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-36-最多牌组数"><a href="#LCP-36-最多牌组数" class="headerlink" title="LCP 36. 最多牌组数"></a>LCP 36. 最多牌组数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>麻将的游戏规则中，共有两种方式凑成「一组牌」：</p><ul><li>顺子：三张牌面数字连续的麻将，例如 [4,5,6]</li><li>刻子：三张牌面数字相同的麻将，例如 [10,10,10]<br>给定若干数字作为麻将牌的数值（记作一维数组 <code>tiles</code>），请返回所给 <code>tiles</code> 最多可组成的牌组数。<br>注意：凑成牌组时，每张牌仅能使用一次。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：tiles = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：最多可以组合出 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 或者 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 其中一组牌。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：tiles = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：最多可以组合出 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 与 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 两组牌。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= tiles.length &lt;= 10^5</code></li><li><code>1 &lt;= tiles[i] &lt;= 10^9</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/Up5XYM" target="_blank" rel="noopener">https://leetcode-cn.com/problems/Up5XYM</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LCP-37-最小矩形面积"><a href="#LCP-37-最小矩形面积" class="headerlink" title="LCP 37. 最小矩形面积"></a>LCP 37. 最小矩形面积</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>二维平面上有 NN 条直线，形式为 <code>y = kx + b</code>，其中 <code>k、b</code>为整数 且 <code>k &gt; 0</code>。所有直线以 <code>[k,b]</code> 的形式存于二维数组 <code>lines</code> 中，不存在重合的两条直线。两两直线之间可能存在一个交点，最多会有$C^{2}n$个交点。我们用一个平行于坐标轴的矩形覆盖所有的交点，请问这个矩形最小面积是多少。若直线之间无交点、仅有一个交点或所有交点均在同一条平行坐标轴的直线上，则返回0。</p><p>注意：返回结果是浮点数，与标准答案 绝对误差或相对误差 在 10^-4 以内的结果都被视为正确结果</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：lines = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">48.00000</span></span><br><span class="line"></span><br><span class="line">解释：三条直线的三个交点为 (<span class="number">3</span>, <span class="number">9</span>) (<span class="number">1</span>, <span class="number">5</span>) 和 (<span class="number">-1</span>, <span class="number">-3</span>)。最小覆盖矩形左下角为 (<span class="number">-1</span>, <span class="number">-3</span>) 右上角为 (<span class="number">3</span>,<span class="number">9</span>)，面积为 <span class="number">48</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：lines = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0.00000</span></span><br><span class="line"></span><br><span class="line">解释：仅有一个交点 (<span class="number">-2</span>，<span class="number">-1</span>）</span><br></pre></td></tr></table></figure></p><p>限制：</p><ul><li><code>1 &lt;= lines.length &lt;= 10^5 且 lines[i].length == 2</code></li><li><code>1 &lt;= lines[0] &lt;= 10000</code></li><li><code>-10000 &lt;= lines[1] &lt;= 10000</code></li><li>与标准答案绝对误差或相对误差在 <code>10^-4</code> 以内的结果都被视为正确结果</li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-ju-xing-mian-ji" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-ju-xing-mian-ji</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>二分查找</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LCP-38-守卫城堡"><a href="#LCP-38-守卫城堡" class="headerlink" title="LCP 38. 守卫城堡"></a>LCP 38. 守卫城堡</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>城堡守卫游戏的胜利条件为使恶魔无法从出生点到达城堡。游戏地图可视作 <code>2*N</code>的方格图，记作字符串数组 <code>grid</code>，其中：</p><ul><li>“.” 表示恶魔可随意通行的平地；</li><li>“#” 表示恶魔不可通过的障碍物，玩家可通过在 平地 上设置障碍物，即将 “.” 变为 “#” 以阻挡恶魔前进；</li><li>“S” 表示恶魔出生点，将有大量的恶魔该点生成，恶魔可向上/向下/向左/向右移动，且无法移动至地图外；</li><li>“P” 表示瞬移点，移动到 “P” 点的恶魔可被传送至任意一个 “P” 点，也可选择不传送；</li><li>“C” 表示城堡。<br>然而在游戏中用于建造障碍物的金钱是有限的，请返回玩家最少需要放置几个障碍物才能获得胜利。若无论怎样放置障碍物均无法获胜，请返回 -1。</li></ul><p>注意：</p><p>地图上可能有一个或多个出生点<br>地图上有且只有一个城堡<br>示例 1<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [<span class="string">"S.C.P<span class="subst">#P</span>."</span>, <span class="string">".....#.S"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：至少需要放置三个障碍物</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [<span class="string">"SP<span class="subst">#P</span>..P<span class="subst">#PC</span>#.S"</span>, <span class="string">"..<span class="subst">#P</span>..P####.#"</span>]</span><br><span class="line"></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：无论怎样修筑障碍物，均无法阻挡最左侧出生的恶魔到达城堡位置</span><br></pre></td></tr></table></figure></p><p>示例 3：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [<span class="string">"SP#.C.<span class="subst">#PS</span>"</span>, <span class="string">"P.#...#.P"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：无需放置障碍物即可获得胜利</span><br></pre></td></tr></table></figure></p><p>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [<span class="string">"CP.#.P."</span>, <span class="string">"...S..S"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：至少需要放置 <span class="number">4</span> 个障碍物，示意图为放置方法之一</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>grid.length == 2</code></li><li><code>2 &lt;= grid[0].length == grid[1].length &lt;= 10^4</code></li><li><code>grid[i][j]</code> 仅包含字符 <code>&quot;.&quot;、&quot;#&quot;、&quot;C&quot;、&quot;P&quot;、&quot;S&quot;</code></li></ul><h3 id="地址-5"><a href="#地址-5" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/7rLGCR" target="_blank" rel="noopener">https://leetcode-cn.com/problems/7rLGCR</a></p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp或者最大流</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-LCCUP-2021-团队赛&quot;&gt;&lt;a href=&quot;#leetcode-LCCUP-2021-团队赛&quot; class=&quot;headerlink&quot; title=&quot;leetcode  LCCUP 2021 团队赛&quot;&gt;&lt;/a&gt;leetcode  LCCUP 2021 团队赛&lt;/h1&gt;&lt;h2 id=&quot;LCP-33-蓄水&quot;&gt;&lt;a href=&quot;#LCP-33-蓄水&quot; class=&quot;headerlink&quot; title=&quot;LCP 33. 蓄水&quot;&gt;&lt;/a&gt;LCP 33. 蓄水&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定 &lt;code&gt;N&lt;/code&gt;个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 &lt;code&gt;bucket[i]&lt;/code&gt;。小扣有以下两种操作：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;升级水桶：选择任意一个水桶，使其容量增加为 &lt;code&gt;bucket[i]+1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;蓄水：将全部水桶接满水，倒入各自对应的水缸&lt;br&gt;每个水缸对应最低蓄水量记作 &lt;code&gt;vat[i]&lt;/code&gt;，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Google】 Google</title>
    <link href="http://yoursite.com/2021/04/06/271/"/>
    <id>http://yoursite.com/2021/04/06/271/</id>
    <published>2021-04-06T05:05:05.749Z</published>
    <updated>2021-04-08T14:22:41.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-mock-view"><a href="#Google-mock-view" class="headerlink" title="Google mock view"></a>Google mock view</h1><p>前段时间做了一下<code>google</code>的<code>mock interview</code>,其中有道题目印象深刻。</p><h2 id="1-区间查询"><a href="#1-区间查询" class="headerlink" title="1. 区间查询"></a>1. 区间查询</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定长度为<code>n</code>的数组<code>A</code>，给定组数$[i,j]$，求以下结果:</p><script type="math/tex; mode=display">query(i,j) = \prod_{k=1}^{j-i+1}(A_{i+k-1}^{k})</script><p>所求结果对$10^{9} + 7$取模, 其中满足以下：</p><a id="more"></a><ul><li>$i \le j$</li><li>$1 \le n \le 10^{5}$</li><li>$0 \le A[i] \le 10^{9}$ <h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/truncate-sentence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/truncate-sentence</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>线段树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote></li></ul><ol><li>首先看到类似的求区间的数列我们首先想到的就是用线段树。我们首先用数学分解的方法来将公式进行分解和变换：<script type="math/tex; mode=display">A[i,j] = \prod_{k=i}^{j}(A_{k}^{k-i+1}) \\= \prod_{m=i}^{s-1}(A_{m}^{m+1-i}) * \prod_{n=s}^{j}(A_{n}^{n+1-i}) \\= \prod_{m=i}^{s-1}(A_{m}^{m+1-i}) * \prod_{n=s}^{j}(A_{n}^{n+1-s})*(\prod_{n=s}^{j}A_{n})^{s-i} \\</script>由上述变换我们就可以知道如何通过线段树对其进行分解，我们设线段树的每个非叶子节点，包含的范围为$(i,j)$,且包含两个值：<script type="math/tex; mode=display">prod_{(i,j)} = \prod_{k=i}^{j}A_{k}\\val_{(i,j)} = \prod_{k=i}^{j}A_{k}^{k+1-i}\\</script>有了上述变换以后我们可以知道线段树的变化，假如本次我们需要查询的区间为$(i,j)$,假设线段从$mid$处断开分为两个子节点，则我们可以知道如下的求和公式：<script type="math/tex; mode=display">prod_{(i,j)} = \prod_{k=i}^{j}A_{k} = \prod_{k=i}^{mid}A_{k}*\prod_{k=mid+1}^{j}A_{k} \\= prod_{(i,mid)}*prod_{(mid+1,j)} \\</script>而$val$可以变换如下：<script type="math/tex; mode=display">val_{(i,j)} = \prod_{k=i}^{j}A_{k}^{k+1-i} =  \prod_{k=i}^{mid}(A_{k}^{k+1-i}) * \prod_{k=mid+1}^{j}(A_{k}^{k+1-i}) \\=  \prod_{k=i}^{mid}(A_{k}^{k+1-i}) * \prod_{k=mid+1}^{j}(A_{k}^{k+1-(mid+1)})*(\prod_{k=mid+1}^{j}A_{k})^{mid+1-i} \\= val_{(i,mid)}*val_{(mid+1,j)}*(prod_{(mid+1,j)})^{mid+1-i}</script>根据以上变换，我们则可以轻易的用线段树可以在$lg(n)$的时间复杂度内求出所有的查询。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">2000000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> prod;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2+1)</span></span><br><span class="line">segTreeNode tree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i != <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ret = (ret*x)%mod;</span><br><span class="line">        x = (x*x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> d = mid - tree[idx].l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pl = tree[CHL(idx)].prod;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pr = tree[CHR(idx)].prod;</span><br><span class="line">    tree[idx].prod = pl*pr%MOD;</span><br><span class="line">    tree[idx].val = tree[CHL(idx)].val*tree[CHR(idx)].val*fastpow(pr,d,MOD)%MOD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].val = <span class="number">1</span>;</span><br><span class="line">    tree[idx].prod = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[idx].val = arr[l];</span><br><span class="line">        tree[idx].prod = arr[l];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(l,mid,arr,CHL(idx));</span><br><span class="line">    buildTree(mid+<span class="number">1</span>,r,arr,CHR(idx));</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; l || tree[idx].l &gt; r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tree[idx].l &amp;&amp;  tree[idx].r &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d = tree[idx].l - l;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].val*fastpow(tree[idx].prod,d,MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(l,r,CHR(idx));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(l,r,CHL(idx));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lval = queryTree(l,r,CHL(idx));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rval = queryTree(l,r,CHR(idx));</span><br><span class="line">        <span class="keyword">return</span> lval*rval%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    buildTree(<span class="number">0</span>,n<span class="number">-1</span>,arr,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l--;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;queryTree(l,r,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Google-mock-view&quot;&gt;&lt;a href=&quot;#Google-mock-view&quot; class=&quot;headerlink&quot; title=&quot;Google mock view&quot;&gt;&lt;/a&gt;Google mock view&lt;/h1&gt;&lt;p&gt;前段时间做了一下&lt;code&gt;google&lt;/code&gt;的&lt;code&gt;mock interview&lt;/code&gt;,其中有道题目印象深刻。&lt;/p&gt;&lt;h2 id=&quot;1-区间查询&quot;&gt;&lt;a href=&quot;#1-区间查询&quot; class=&quot;headerlink&quot; title=&quot;1. 区间查询&quot;&gt;&lt;/a&gt;1. 区间查询&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定长度为&lt;code&gt;n&lt;/code&gt;的数组&lt;code&gt;A&lt;/code&gt;，给定组数$[i,j]$，求以下结果:&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
query(i,j) = \prod_{k=1}^{j-i+1}(A_{i+k-1}^{k})&lt;/script&gt;&lt;p&gt;所求结果对$10^{9} + 7$取模, 其中满足以下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  LCCUP 2021</title>
    <link href="http://yoursite.com/2021/04/06/270/"/>
    <id>http://yoursite.com/2021/04/06/270/</id>
    <published>2021-04-06T00:39:47.905Z</published>
    <updated>2021-04-08T09:58:12.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-LCCUP-2021"><a href="#leetcode-LCCUP-2021" class="headerlink" title="leetcode  LCCUP 2021"></a>leetcode  LCCUP 2021</h1><p>总共5道题目，还是依旧三道题，后面两道题思考量确实很大，前三题基本上都是<code>mid</code>难度的题目。</p><h2 id="1-采购方案"><a href="#1-采购方案" class="headerlink" title="1. 采购方案"></a>1. 采购方案</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小力将 N 个零件的报价存于数组 <code>nums</code>。小力预算为 <code>target</code>，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 <code>1e9 + 7 (1000000007)</code>为底取模，如：计算初始结果为：<code>1000000008</code>，请返回 <code>1</code></p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：预算内仅能购买 nums[<span class="number">0</span>] 与 nums[<span class="number">2</span>]。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：符合预算的采购方案如下：</span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">nums[<span class="number">1</span>] + nums[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">nums[<span class="number">2</span>] + nums[<span class="number">3</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i], target &lt;= 10^5</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/truncate-sentence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/truncate-sentence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  两数求和问题，双指针或者二分查找</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的两数求和问题，常见的就是用双指针或者二分查找，在这里比较简单的是用双指针问题，固定一个较大的数<code>x</code>，查找用多少个数满足$x+y &lt; target$.</li><li>算法时间复杂度$O(nlgn)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; i &amp;&amp; nums[i] + nums[l] &lt;= target) l++;</span><br><span class="line">            <span class="keyword">if</span>(l == i) l--;</span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; nums[i] + nums[l] &gt; target) l--;</span><br><span class="line">            <span class="keyword">if</span>(l &gt;= <span class="number">0</span>) ans = (ans + l + <span class="number">1</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="2-乐团站位"><a href="#2-乐团站位" class="headerlink" title="2. 乐团站位"></a>2. 乐团站位</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>某乐团的演出场地可视作 <code>num * num</code> 的二维矩阵 <code>grid</code>（左上角坐标为 <code>[0,0]</code>)，每个位置站有一位成员。乐团共有 <code>9</code> 种乐器，乐器编号为 <code>1~9</code>，每位成员持有 <code>1</code> 个乐器。</p><p>为保证声乐混合效果，成员站位规则为：自 <code>grid</code> 左上角开始顺时针螺旋形向内循环以 <code>1，2，...，9</code>循环重复排列。例如当 <code>num = 5</code>时，站位如图所示</p><p>请返回位于场地坐标<code>[Xpos,Ypos]</code>的成员所持乐器编号。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">3</span>, Xpos = <span class="number">0</span>, Ypos = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">4</span>, Xpos = <span class="number">1</span>, Ypos = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= num &lt;= 10^9</code></li><li><code>0 &lt;= Xpos, Ypos &lt; num</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-the-users-active-minutes</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>思路很简单，我们首先找到该坐标属于从外往里数第几个正方形，然后属于该正方形中的第几个元素即可。<br><img src="https://i.loli.net/2021/04/06/uoGFLZHMPvskAn7.jpg" alt></li><li>第几圈我们仔细观察一下可以知道$level = min(x,y,num-1-x,num-1-y)$,第$level$个正方形的边长为$ edge = num - 2<em>level$,此时我们知道<code>level</code>以外的所有正方形的周长的综合为$sum = num</em>num - edge<em>edge$,此时我们知道从第<code>level</code>层的正方形的起始点应该为$num</em>num - edge*edge + 1$,此时我们在分别判断$(x,y)$按照顺时针旋转属于该正方形的第几条边即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orchestraLayout</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> xPos, <span class="keyword">int</span> yPos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> level = min(min(xPos,yPos),min(num-xPos<span class="number">-1</span>,num<span class="number">-1</span>-yPos));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> edge  = num - <span class="number">2</span>*level;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = (<span class="keyword">long</span> <span class="keyword">long</span>)(num)*num - (<span class="keyword">long</span> <span class="keyword">long</span>)(edge)*edge;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*move to (0,0)*/</span></span><br><span class="line">        xPos -= level;</span><br><span class="line">        yPos -= level;</span><br><span class="line">        <span class="keyword">if</span>(xPos == <span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            curr += yPos + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(yPos == edge - <span class="number">1</span>)&#123; <span class="comment">// 2</span></span><br><span class="line">            curr += (edge <span class="number">-1</span>) + xPos + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xPos == edge - <span class="number">1</span>)&#123; <span class="comment">// 3</span></span><br><span class="line">            curr += (edge <span class="number">-1</span>)*<span class="number">2</span> + edge - yPos;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(yPos == <span class="number">0</span>)&#123; <span class="comment">// 4</span></span><br><span class="line">            curr += (edge <span class="number">-1</span>)*<span class="number">3</span> + edge - xPos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (curr%<span class="number">9</span>) == <span class="number">0</span> ? <span class="number">9</span> : (curr%<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-30-魔塔游戏"><a href="#LCP-30-魔塔游戏" class="headerlink" title="LCP 30. 魔塔游戏"></a>LCP 30. 魔塔游戏</h2><p>小扣当前位于魔塔游戏第一层，共有 <code>N</code> 个房间，编号为 <code>0 ~ N-1</code>。每个房间的补血道具/怪物对于血量影响记于数组<code>nums</code>，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；<code>0</code> 表示房间对血量无影响。</p><p>小扣初始血量为<code>1</code>，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 <code>-1</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">-250</span>,<span class="number">-60</span>,<span class="number">-140</span>,<span class="number">-50</span>,<span class="number">-50</span>,<span class="number">100</span>,<span class="number">150</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：初始血量为 <span class="number">1</span>。至少需要将 nums[<span class="number">3</span>] 调整至访问顺序末尾以满足要求。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-200</span>,<span class="number">-300</span>,<span class="number">400</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">解释：调整访问顺序也无法完成全部房间的访问。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/p0NxJO" target="_blank" rel="noopener">https://leetcode-cn.com/problems/p0NxJO</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>思考一下，如何才能满足能够通过这一层，我们将所有的伤害和血量增加加起来的和满足大于<code>0</code>则表示一定可以通过这一层，否则则表示我们不能通过这一层。</li><li>假如我们当前遇到血量不足时，我们最优策略应该即把伤害值最大的房间往后移，根据这个贪心策略，我们利用优先级的特性，每次将所有的伤害均进入优先级队列，穿越房间时，如果发现当前血量不足，则我们从队列弹出最大的伤害值，并将当前的血量进行恢复，一直回到当前的持有的血量大于<code>0</code>为止。</li><li>算法的时间复杂度为$O(nlgn)$.空间复杂度为$O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicTower</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            sum += v;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.push(-v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!pq.empty() &amp;&amp; sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    sum += pq.top();</span><br><span class="line">                    pq.pop();</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-31-变换的迷宫"><a href="#LCP-31-变换的迷宫" class="headerlink" title="LCP 31. 变换的迷宫"></a>LCP 31. 变换的迷宫</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>某解密游戏中，有一个 <code>N*M</code> 的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于 <code>(n-1,m-1)</code>位置。迷宫变化规律记录于 <code>maze</code>中，<code>maze[i]</code>表示 <code>i</code>时刻迷宫的地形状态，<code>&quot;.&quot;</code>表示可通行空地，<code>&quot;#&quot;</code> 表示陷阱。</p><p>地形图初始状态记作 <code>maze[0]</code>，此时小力位于起点 <code>(0,0)</code>。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。</p><p>小力背包有以下两个魔法卷轴（卷轴使用一次后消失）：</p><ul><li>临时消除术：将指定位置在下一个时刻变为空地；</li><li>永久消除术：将指定位置永久变为空地。<br>请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？</li></ul><p>注意： 输入数据保证起点和终点在所有时刻均为空地。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">".#."</span>,<span class="string">"#.."</span>],[<span class="string">"..."</span>,<span class="string">".#."</span>],[<span class="string">".##"</span>,<span class="string">".#."</span>],[<span class="string">"..#"</span>,<span class="string">".#."</span>]]</span><br><span class="line"></span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">解释：</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">".#."</span>,<span class="string">"..."</span>],[<span class="string">"..."</span>,<span class="string">"..."</span>]]</span><br><span class="line"></span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">解释：由于时间不够，小力无法到达终点逃出迷宫。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">"..."</span>,<span class="string">"..."</span>,<span class="string">"..."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>]]</span><br><span class="line"></span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">解释：由于道路不通，小力无法到达终点逃出迷宫。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= maze.length &lt;= 100</code></li><li><code>1 &lt;= maze[i].length, maze[i][j].length &lt;= 50</code></li><li><code>maze[i][j]</code> 仅包含 <code>&quot;.&quot;、&quot;#&quot;</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/Db3wC1" target="_blank" rel="noopener">https://leetcode-cn.com/problems/Db3wC1</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p><code>dfs</code>记忆式搜索。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本题的思考难度还是非常大的，难点在于如何处理永久将某一位置变为空地，假如我们直接设遍历所有的状态，则可能会超时。难点在于如何思考和优化，参考了一下第二名的代码，非常简洁。</li></ol><ul><li>对于临时消除的这个问题，非常好处理，设立一个标志位，表示当前是否可以进行临时消除即可。</li><li>对于永久消除的这个问题，我们最难思考的是，假设我们在某一个时刻$t_{0}$对坐标$(x,y)$进行了消除，则我们经历了$t_{1},t_{2},t_{3}…,t_{i}$跳跃了坐标$(x_{1},y_{1})，(x_{2},y_{2})，(x_{3},y_{3})…(x_{i},y_{i})，$后，我们又回到了坐标$(x,y)$,则此时我们如何判断$(x,y)$已经被永久消除，这个是最难的思考点。题解中给出的假设我们在$t_{0}$时候已经对坐标$(x,y)$进行了消除，我们在$t_{i}$时候刻后经历了其他不同的坐标后又回到原始坐标$(x,y)$,我们完全可以可以在一直$t_{1},t_{2},t_{3}…,t_{i}$一直呆在原始坐标$(x,y)$处，因此我们可以判断，假如它从永久消除的坐标$(x,y)$跳出后，就不会再跳回原始坐标$(x,y)$.</li><li>因此我们需要增设一个状态$usedStay$,如果$usedStay = 1$，表示我们已经用了永久消除当前可以一直停留在原地，如果$usedStay = 0$则表示为未用永久消除术或者用了永久消除但已经跳出释放永久消除的格子。</li></ul><ol><li>我们设$dp[t][x][y][tmpuse][alluse][usedstay]$表示在<code>t</code>时候到达坐标$(x,y)$,且手中持有的临时消除的次数为$tmpuse$,手中持有的永久消除的次数为$alluse$,当前的是否使用永久消除术且可以停留在原地的状态为$usedstay$.</li><li>时间复杂度为$O(n<em>row</em>col<em>2</em>2<em>2</em>4)$,在我们当前的数值的允许范围内可以完成全部搜索。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">51</span>][<span class="number">51</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> n,row,col;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; matrix;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> tmp_use,<span class="keyword">int</span> all_use,<span class="keyword">int</span> used_stay)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[t][x][y][tmp_use][all_use][used_stay]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        dp[t][x][y][tmp_use][all_use][used_stay] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t == n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*check if we can stay at the same positon (x,y) in the next time t+1*/</span></span><br><span class="line">        <span class="keyword">if</span>(used_stay || matrix[t+<span class="number">1</span>][x][y] == <span class="string">'.'</span>) </span><br><span class="line">            dfs(t+<span class="number">1</span>,x,y,tmp_use,all_use,used_stay);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*check if we can move to other position in the next time*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = x + d[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y1 = y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x1 &lt; <span class="number">0</span> || y1 &lt; <span class="number">0</span> || x1 &gt;= row || y1 &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[t+<span class="number">1</span>][x1][y1] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="comment">/*we just move to other postion (x1,y1)*/</span></span><br><span class="line">                dfs(t+<span class="number">1</span>,x1,y1,tmp_use,all_use,<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/*we use temple erase (x1,y1) at this time,the next time it can move to (x1,y1)*/</span></span><br><span class="line">                <span class="keyword">if</span>(tmp_use &gt; <span class="number">0</span>) dfs(t+<span class="number">1</span>,x1,y1,<span class="number">0</span>,all_use,<span class="number">0</span>);</span><br><span class="line">                <span class="comment">/*we use all erase (x1,y1) at this time, the next time it can move to (x1,y1) and it can stay at (x1,y1) all over the life*/</span></span><br><span class="line">                <span class="keyword">if</span>(all_use &gt; <span class="number">0</span>) dfs(t+<span class="number">1</span>,x1,y1,tmp_use,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">escapeMaze</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; maze)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = maze.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;row = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;col = maze[<span class="number">0</span>][<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;matrix = maze;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; ++l)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i][row<span class="number">-1</span>][col<span class="number">-1</span>][j][k][l]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-32-批量处理任务"><a href="#LCP-32-批量处理任务" class="headerlink" title="LCP 32. 批量处理任务"></a>LCP 32. 批量处理任务</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>某实验室计算机待处理任务以<code>[start,end,period]</code>格式记于二维数组 <code>tasks</code>，表示完成该任务的时间范围为起始时间 <code>start</code> 至结束时间 <code>end</code>之间，需要计算机投入 <code>period</code> 的时长，注意：</p><ul><li><code>period</code> 可为不连续时间</li><li>首尾时间均包含在内</li><li>处于开机状态的计算机可同时处理任意多个任务，请返回电脑最少开机多久，可处理完所有任务。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">tasks[<span class="number">0</span>] 选择时间点 <span class="number">2</span>、<span class="number">3</span>；</span><br><span class="line">tasks[<span class="number">1</span>] 选择时间点 <span class="number">2</span>、<span class="number">3</span>、<span class="number">5</span>；</span><br><span class="line">tasks[<span class="number">2</span>] 选择时间点 <span class="number">5</span>、<span class="number">6</span>；</span><br><span class="line">因此计算机仅需在时间点 <span class="number">2</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span> 四个时刻保持开机即可完成任务。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">tasks[<span class="number">0</span>] 选择时间点 <span class="number">2</span> 或 <span class="number">3</span>；</span><br><span class="line">tasks[<span class="number">1</span>] 选择时间点 <span class="number">5</span>；</span><br><span class="line">tasks[<span class="number">2</span>] 选择时间点 <span class="number">5</span>、<span class="number">6</span>；</span><br><span class="line">因此计算机仅需在时间点 <span class="number">2</span>、<span class="number">5</span>、<span class="number">6</span> 或 <span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span> 三个时刻保持开机即可完成任务。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= tasks.length &lt;= 10^5</code></li><li><code>tasks[i].length == 3</code></li><li><code>0 &lt;= tasks[i][0] &lt;= tasks[i][1] &lt;= 10^9</code></li><li><code>1 &lt;= tasks[i][2] &lt;= tasks[i][1]-tasks[i][0] + 1</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/t3fKg1" target="_blank" rel="noopener">https://leetcode-cn.com/problems/t3fKg1</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>贪心算法，线段树</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们可以知道每一个任务对应着一个线段，所有的运行时间点我们也可以看作为离散的线段，所谓的开机时间满足要求，只需要在线段范围$[l,r]$内运行的时间点组成的离散的小线段的总长度大于等于$period$即可，仔细分析一下，我们可以利用类似于差分数组的方法，我们按照任务的结束时间的先后顺序进行排序，每遇到一个任务结束的右端点$r_{i}$时，我们首先查询当前任务运行时间范围$[l_{i},r_{i}]$内已经运行的开机时间是否满足$period_{i}$,如果不满足，则我们从右端$r_{i}$向左开始在空闲的时间内依次添加开机时间直到$[l_{i},r_{i}]$范围的开机时间满足$period_{i}$即可。</li><li>我们可以用数组表示当前已经开机时间点离散小线段，比如$arr[i] = {l_{i},r_{i}}$表示当前在$[l_{i},r_{i}]$设备已经在开机运行，则此时该时间段内连续的运行时间即为$r_{i}-l_{i} + 1$，我们用前缀和$pre[i]$表示前<code>i</code>个开机运行线段的运行时间的总和.我们每次固定当前的右端点，然后利用二分查找和前缀和可以快速查找在$[l_{i},r_{i}]$范围内已经开机运行的时间的总和，然后即可求出当前任务中我们还需要再开机运行多长时间，依次进行叠加即可求出所满足要求，这个算法是参考@cuiaoxiang的，不过算法时间复杂度较高，时间复杂度感觉应该是$o(n^{2})$因为其中涉及到线段的合并的问题，但是实际上我们可以进行优化，最终结果是可以过测试用例的。</li><li>线段树，线段树的解法就复杂的多了，可以参考@restant的解法，写的实在太复杂，不过原理应该差不多。<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">processTasks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tasks.size();</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : tasks) v[<span class="number">0</span>]--;</span><br><span class="line">        sort(tasks.begin(),tasks.end(),[&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; used;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; n; i = j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*we find the most running time from task[i][1] which we need to add*/</span></span><br><span class="line">            <span class="keyword">for</span>(j = i; j &lt; n &amp;&amp; tasks[j][<span class="number">1</span>] == tasks[i][<span class="number">1</span>]; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> s = tasks[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> t = tasks[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> p = tasks[j][<span class="number">2</span>];</span><br><span class="line">                <span class="comment">/*search last segment greater than x*/</span></span><br><span class="line">                <span class="keyword">int</span> k = lower_bound(used.begin(),used.end(),pii&#123;s,<span class="number">0</span>&#125;) - used.begin();</span><br><span class="line">                <span class="keyword">int</span> m = used.size();</span><br><span class="line">                <span class="keyword">int</span> curr = pre[m] - pre[k];</span><br><span class="line">                <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; used[k<span class="number">-1</span>].second &gt;= s) curr += used[k<span class="number">-1</span>].second - s;</span><br><span class="line">                <span class="keyword">if</span>(p &gt; curr)  mx = max(mx,p-curr);</span><br><span class="line">            &#125;</span><br><span class="line">            ret += mx;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(mx &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = tasks[i][<span class="number">1</span>]-mx;</span><br><span class="line">                <span class="keyword">int</span> y = tasks[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span>(used.size() &amp;&amp; used.back().second &gt;= x)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> [u,v] = used.back();</span><br><span class="line">                    used.pop_back();</span><br><span class="line">                    pre.pop_back();</span><br><span class="line">                    x = u - (v-x);</span><br><span class="line">                &#125;</span><br><span class="line">                used.push_back(&#123;x,y&#125;);</span><br><span class="line">                pre.push_back(pre.back() + y - x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (t&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((t&lt;&lt;1)|1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, p;</span><br><span class="line">&#125;a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NMB</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> add ,sum, id;</span><br><span class="line">&#125;tree[<span class="number">100005</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[ls].add += tree[t].add;</span><br><span class="line">tree[ls].sum += tree[t].add;</span><br><span class="line">tree[rs].add += tree[t].add;</span><br><span class="line">tree[rs].sum += tree[t].add;</span><br><span class="line">tree[t].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[ls].sum &lt; tree[rs].sum)</span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = tree[ls].sum;</span><br><span class="line">tree[t].id = tree[ls].id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = tree[rs].sum;</span><br><span class="line">tree[t].id = tree[rs].id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[t].add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) </span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = a[l].r - a[l].p + <span class="number">1</span>;</span><br><span class="line">tree[t].id = l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build_tree(l,mid,ls);</span><br><span class="line">build_tree(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> tree[t].sum;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">down(t);</span><br><span class="line"><span class="keyword">if</span> (ll&lt;=mid) <span class="keyword">return</span> find(ll,l,mid,ls);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> find(ll,mid+<span class="number">1</span>,r,rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">down(t);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ll&lt;=mid) modify(ll,c,l,mid,ls);</span><br><span class="line"><span class="keyword">else</span> modify(ll,c,mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(t); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr)</span><br><span class="line">&#123;</span><br><span class="line">tree[t].add += c;</span><br><span class="line">tree[t].sum += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">down(t);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ll &lt;= mid) change(ll,rr,c,l,mid,ls);</span><br><span class="line"><span class="keyword">if</span> (rr&gt;mid)  change(ll,rr,c,mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = n + <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;</span><br><span class="line">ans += R - L + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> ((l + r) &gt;&gt; <span class="number">1</span> != mid)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid].l &gt;= L) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r; a[i].l &lt;= R &amp;&amp; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p = find(i, <span class="number">1</span>, n, <span class="number">1</span>) + (R - a[i].l + <span class="number">1</span>); </span><br><span class="line">modify(i, p, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">1</span>) change(<span class="number">1</span>, r - <span class="number">1</span>, R - L + <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">processTasks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">n = tasks.size();</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ;++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i].l = tasks[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">a[i].r = tasks[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">a[i].p = tasks[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">build_tree(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = tree[<span class="number">1</span>].id;</span><br><span class="line"><span class="keyword">int</span> L = find(x, <span class="number">1</span>, n ,<span class="number">1</span>), R = a[x].r;</span><br><span class="line">Work(L,R);</span><br><span class="line">modify(x,(<span class="keyword">int</span>)<span class="number">1e9</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-LCCUP-2021&quot;&gt;&lt;a href=&quot;#leetcode-LCCUP-2021&quot; class=&quot;headerlink&quot; title=&quot;leetcode  LCCUP 2021&quot;&gt;&lt;/a&gt;leetcode  LCCUP 2021&lt;/h1&gt;&lt;p&gt;总共5道题目，还是依旧三道题，后面两道题思考量确实很大，前三题基本上都是&lt;code&gt;mid&lt;/code&gt;难度的题目。&lt;/p&gt;&lt;h2 id=&quot;1-采购方案&quot;&gt;&lt;a href=&quot;#1-采购方案&quot; class=&quot;headerlink&quot; title=&quot;1. 采购方案&quot;&gt;&lt;/a&gt;1. 采购方案&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;小力将 N 个零件的报价存于数组 &lt;code&gt;nums&lt;/code&gt;。小力预算为 &lt;code&gt;target&lt;/code&gt;，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。&lt;/p&gt;&lt;p&gt;注意：答案需要以 &lt;code&gt;1e9 + 7 (1000000007)&lt;/code&gt;为底取模，如：计算初始结果为：&lt;code&gt;1000000008&lt;/code&gt;，请返回 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 49</title>
    <link href="http://yoursite.com/2021/04/04/268/"/>
    <id>http://yoursite.com/2021/04/04/268/</id>
    <published>2021-04-04T12:18:32.818Z</published>
    <updated>2021-04-05T15:17:52.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-49"><a href="#leetcode-biweekly-contest-49" class="headerlink" title="leetcode biweekly contest 49"></a>leetcode biweekly contest 49</h1><p>还是依旧三道题，最后一题的状态压缩<code>dp</code>确实非常难以想到。前三题非常简单，最后一题比较难。</p><h2 id="5705-判断国际象棋棋盘中一个格子的颜色"><a href="#5705-判断国际象棋棋盘中一个格子的颜色" class="headerlink" title="5705. 判断国际象棋棋盘中一个格子的颜色"></a>5705. 判断国际象棋棋盘中一个格子的颜色</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个坐标<code>coordinates</code>，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。<br>如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 <code>false</code>。<br>给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。</p><a id="more"></a><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coordinates</span> = <span class="string">"a1"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：如上图棋盘所示，<span class="string">"a1"</span> 坐标的格子是黑色的，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coordinates</span> = <span class="string">"h3"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：如上图棋盘所示，<span class="string">"h3"</span> 坐标的格子是白色的，所以返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coordinates</span> = <span class="string">"c7"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>coordinates.length == 2</code></li><li><code>&#39;a&#39; &lt;= coordinates[0] &lt;= &#39;h&#39;</code></li><li><code>&#39;1&#39; &lt;= coordinates[1] &lt;= &#39;8&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/determine-color-of-a-chessboard-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/determine-color-of-a-chessboard-square</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>行号与列号的奇偶性相同时，则为黑色，否则则为白色。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">squareIsWhite</span><span class="params">(<span class="built_in">string</span> coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = coordinates[<span class="number">0</span>] - <span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = coordinates[<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>((x&amp;<span class="number">1</span>)^(y&amp;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5706-句子相似性-III"><a href="#5706-句子相似性-III" class="headerlink" title="5706. 句子相似性 III"></a>5706. 句子相似性 III</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>&quot;Hello World&quot; ，&quot;HELLO&quot; ，&quot;hello world hello world&quot;</code> 都是句子。每个单词都 只 包含大写和小写英文字母。</p><p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 相似的 。比方说，<code>sentence1 = &quot;Hello my name is Jane&quot;</code>且 <code>sentence2 = &quot;Hello Jane&quot;</code> ，我们可以往 sentence2 中 “Hello” 和 “Jane” 之间插入 “my name is” 得到 sentence1 。<br><code>给你两个句子</code>sentence1 <code>和</code>sentence2<code>，如果</code>sentence1<code>和</code>sentence2` 是相似的，请你返回 true ，否则返回 false 。</p><p>示例 1：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：se<span class="symbol">ntence1</span> = <span class="string">"My name is Haley"</span>, se<span class="symbol">ntence2</span> = <span class="string">"My Haley"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：可以往 se<span class="symbol">ntence2</span> 中 <span class="string">"My"</span> 和 <span class="string">"Haley"</span> 之间插入 <span class="string">"name is"</span> ，得到 se<span class="symbol">ntence1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence1</span> = <span class="string">"of"</span>, <span class="attr">sentence2</span> = <span class="string">"A lot of words"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：se<span class="symbol">ntence1</span> = <span class="string">"Eating right now"</span>, se<span class="symbol">ntence2</span> = <span class="string">"Eating"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：可以往 se<span class="symbol">ntence2</span> 的结尾插入 <span class="string">"right now"</span> 得到 se<span class="symbol">ntence1</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence1</span> = <span class="string">"Luky"</span>, <span class="attr">sentence2</span> = <span class="string">"Lucccky"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li><li><code>sentence1</code> 和 <code>sentence2</code> 都只包含大小写英文字母和空格。</li><li><code>sentence1</code> 和 <code>sentence2</code> 中的单词都只由单个空格隔开。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sentence-similarity-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sentence-similarity-iii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的不好，没啥好说的，只需要判断两个句子的首尾相等的部分去掉即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areSentencesSimilar</span><span class="params">(<span class="built_in">string</span> sentence1, <span class="built_in">string</span> sentence2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = sentence1.size();</span><br><span class="line">        <span class="keyword">int</span> n = sentence2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sentence1.size();)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; sentence1[i] == <span class="string">' '</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; sentence1[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                curr.push_back(sentence1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt; <span class="number">0</span>) arr1.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sentence2.size();)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; sentence2[i] == <span class="string">' '</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; sentence2[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                curr.push_back(sentence2[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt; <span class="number">0</span>) arr2.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**/</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r1 = arr1.size();</span><br><span class="line">        <span class="keyword">int</span> r2 = arr2.size();</span><br><span class="line">        <span class="comment">/*left*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1 &amp;&amp; i &lt; r2; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] == arr2[i]) l = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*right*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr1.size()<span class="number">-1</span>,j = arr2.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] == arr2[j])&#123;</span><br><span class="line">                r1 = i;</span><br><span class="line">                r2 = j;</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == (arr1.size()<span class="number">-1</span>) || l == (arr2.size()<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="number">0</span> || r2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((r1 - l) == <span class="number">1</span> || (r2-l) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5708-统计一个数组中好对子的数目"><a href="#5708-统计一个数组中好对子的数目" class="headerlink" title="5708. 统计一个数组中好对子的数目"></a>5708. 统计一个数组中好对子的数目</h2><p>给你一个数组 nums ，数组中只包含非负整数。定义<code>rev(x)</code>的值为将整数 x 各个数字位反转得到的结果。比方说 <code>rev(123) = 321</code> ， <code>rev(120) = 21</code> 。我们称满足下面条件的下标对 <code>(i, j)</code>是 好的 ：</p><ul><li><code>0 &lt;= i &lt; j &lt; nums.length</code></li><li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code><br>请你返回好下标对的数目。由于结果可能会很大，请将结果对 <code>109 + 7</code>取余 后返回。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">42</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">97</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：两个坐标对为：</span><br><span class="line"> - (<span class="number">0</span>,<span class="number">3</span>)：<span class="number">42</span> + rev(<span class="number">97</span>) = <span class="number">42</span> + <span class="number">79</span> = <span class="number">121</span>, <span class="number">97</span> + rev(<span class="number">42</span>) = <span class="number">97</span> + <span class="number">24</span> = <span class="number">121</span> 。</span><br><span class="line"> - (<span class="number">1</span>,<span class="number">2</span>)：<span class="number">11</span> + rev(<span class="number">1</span>) = <span class="number">11</span> + <span class="number">1</span> = <span class="number">12</span>, <span class="number">1</span> + rev(<span class="number">11</span>) = <span class="number">1</span> + <span class="number">11</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">13</span>,<span class="number">10</span>,<span class="number">35</span>,<span class="number">24</span>,<span class="number">76</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-nice-pairs-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-nice-pairs-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简单，题目中要求给定的公式为：<script type="math/tex; mode=display">nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</script>我们只需要将上述公式变换一下：<script type="math/tex; mode=display">nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])</script>因此我们统计数组中所有等式$nums[i] - rev(nums[i])$的值的个数，利用数学组合定理即可求出所有可能的数目。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNicePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curr = curr*<span class="number">10</span> + (x%<span class="number">10</span>);</span><br><span class="line">                x = x/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cnt[nums[i]-arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            ans = (ans + v.second*(v.second<span class="number">-1</span>)/<span class="number">2</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5707-得到新鲜甜甜圈的最多组数"><a href="#5707-得到新鲜甜甜圈的最多组数" class="headerlink" title="5707. 得到新鲜甜甜圈的最多组数"></a>5707. 得到新鲜甜甜圈的最多组数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一个甜甜圈商店，每批次都烤<code>batchSize</code> 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 所有 甜甜圈都必须已经全部销售完毕。给你一个整数 <code>batchSize</code> 和一个整数数组 <code>groups</code> ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 <code>groups[i]</code>表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。<br>当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。<br>你可以随意安排每批顾客到来的顺序。请你返回在此前提下，最多 有多少组人会感到开心。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：batchSize = <span class="number">3</span>, groups = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你可以将这些批次的顾客顺序安排为 [<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>] 。那么第 <span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">6</span> 组都会感到开心。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：batchSize = <span class="number">4</span>, groups = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= batchSize &lt;= 9</code></li><li><code>1 &lt;= groups.length &lt;= 30</code></li><li><code>1 &lt;= groups[i] &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-groups-getting-fresh-donuts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-groups-getting-fresh-donuts</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>状态压缩<code>dp</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目说的还是太复杂了，本质就是求将数组划分为能被<code>k</code>整除的非连续子数组的最大数目，以前见到过连续的子数组划分，遇到类似的题目确实不好想到。</li><li>我们可以看到假设只有<code>20</code>个元素时，则此时非常好解决，我们只需要利用二进制掩码解决所有可能的分组即可或者常规的<code>dfs</code>即可。</li><li>我们如何优化状态，减少所有可能的状态，即可对算法时间复杂度进行优化：</li></ol><ul><li>首先进行剪枝，我们知道如果当前的<code>group</code>刚好能被<code>batchSize</code>整除，或者刚好两个数相加能被<code>batchSize</code>整除的，我们优先将这两类数目去除掉。</li><li>我们对于状态如何定义，因为题目中并没有要求数字有序，数字可以为乱序，此时我们则看到题目中给定的条件为$1 &lt;= batchSize &lt;= 9$,则我们可以将数组按照对<code>batchSize</code>取模的结果进行分类，对其分类作为状态<code>dp</code>，则此时所有可能的最大状态为$3^{10}$，这个数字实际在可以接受的范围内，因此采用这个即可，看了所有的解答，基本上都在用各种方法对状态进行编码压缩，也可以直接用字符串对状态进行编码，也可以用类似于<code>K-R</code>的字符串的搜索方法对其进行编码，然后遍历所有可能的状态，各式各样的状态编码和压缩，当然最直接和最简单的就是直接暴力将用<code>treeMap</code>将数组作为状态，同时求出当前状态下所能够得到的最大可能分组以及剩余的余数，刚刚时间卡住可以过时间复杂度。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; dp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cnt, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = dp.find(cnt);</span><br><span class="line">        <span class="keyword">if</span>(it != end(dp)) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cnt[i] -= <span class="number">1</span>;</span><br><span class="line">            res = max(res,(left == <span class="number">0</span>) + dfs(cnt,(left + i)%cnt.size()));</span><br><span class="line">            cnt[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[cnt] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxHappyGroups</span><span class="params">(<span class="keyword">int</span> batchSize, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; groups)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(batchSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> group : groups)&#123;</span><br><span class="line">            ++cnt[group % batchSize];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = cnt[<span class="number">0</span>];</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (batchSize<span class="number">-1</span>)/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = min(cnt[i],cnt[batchSize-i]);</span><br><span class="line">            ans += m;</span><br><span class="line">            cnt[i] -= m;</span><br><span class="line">            cnt[batchSize-i] -= m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + dfs(cnt, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-49&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-49&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 49&quot;&gt;&lt;/a&gt;leetcode biweekly contest 49&lt;/h1&gt;&lt;p&gt;还是依旧三道题，最后一题的状态压缩&lt;code&gt;dp&lt;/code&gt;确实非常难以想到。前三题非常简单，最后一题比较难。&lt;/p&gt;&lt;h2 id=&quot;5705-判断国际象棋棋盘中一个格子的颜色&quot;&gt;&lt;a href=&quot;#5705-判断国际象棋棋盘中一个格子的颜色&quot; class=&quot;headerlink&quot; title=&quot;5705. 判断国际象棋棋盘中一个格子的颜色&quot;&gt;&lt;/a&gt;5705. 判断国际象棋棋盘中一个格子的颜色&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个坐标&lt;code&gt;coordinates&lt;/code&gt;，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。&lt;br&gt;如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 &lt;code&gt;false&lt;/code&gt;。&lt;br&gt;给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly  Contest 235</title>
    <link href="http://yoursite.com/2021/04/04/269/"/>
    <id>http://yoursite.com/2021/04/04/269/</id>
    <published>2021-04-04T01:30:40.110Z</published>
    <updated>2021-04-04T13:59:32.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-weekly-contest-235"><a href="#leetcode-weekly-contest-235" class="headerlink" title="leetcode weekly contest 235"></a>leetcode weekly contest 235</h1><p>还是依旧三道题，最后一题的思考确实比较难。</p><h2 id="5722-截断句子"><a href="#5722-截断句子" class="headerlink" title="5722. 截断句子"></a>5722. 截断句子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p><p>例如，<code>&quot;Hello World&quot;、&quot;HELLO&quot;</code> 和 <code>&quot;hello world hello world&quot;</code>都是句子。<br>给你一个句子 <code>s​​​​​​</code> 和一个整数<code>k​​​​​​</code> ，请你将 <code>s​​</code> 截断 ​，​​​使截断后的句子仅含 前 <code>k​​​​​​</code> 个单词。返回 截断 <code>s​​​​​​</code> 后得到的句子。</p><a id="more"></a><p>示例 1：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"Hello how are you Contestant"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="comment">"Hello how are you"</span></span><br><span class="line">解释：</span><br><span class="line">s 中的单词为 [<span class="comment">"Hello"</span>, <span class="comment">"how"</span> <span class="comment">"are"</span>, <span class="comment">"you"</span>, <span class="comment">"Contestant"</span>]</span><br><span class="line">前 <span class="number">4</span> 个单词为 [<span class="comment">"Hello"</span>, <span class="comment">"how"</span>, <span class="comment">"are"</span>, <span class="comment">"you"</span>]</span><br><span class="line">因此，应当返回 <span class="comment">"Hello how are you"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"What is the solution to this problem"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="comment">"What is the solution"</span></span><br><span class="line">解释：</span><br><span class="line">s 中的单词为 [<span class="comment">"What"</span>, <span class="comment">"is"</span> <span class="comment">"the"</span>, <span class="comment">"solution"</span>, <span class="comment">"to"</span>, <span class="comment">"this"</span>, <span class="comment">"problem"</span>]</span><br><span class="line">前 <span class="number">4</span> 个单词为 [<span class="comment">"What"</span>, <span class="comment">"is"</span>, <span class="comment">"the"</span>, <span class="comment">"solution"</span>]</span><br><span class="line">因此，应当返回 <span class="comment">"What is the solution"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "chopper <span class="keyword">is</span> <span class="keyword">not</span> a tanuki", k = 5</span><br><span class="line">输出："chopper <span class="keyword">is</span> <span class="keyword">not</span> a tanuki"</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>k</code> 的取值范围是 <code>[1,  s 中单词的数目]</code></li><li><code>s</code> 仅由大小写英文字母和空格组成</li><li><code>s</code> 中的单词之间由单个空格隔开</li><li>不存在前导或尾随空格</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/truncate-sentence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/truncate-sentence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>遇到第<code>k</code>个空格则推出即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">truncateSentence</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>) k--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> s.substr(<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5723-查找用户活跃分钟数"><a href="#5723-查找用户活跃分钟数" class="headerlink" title="5723. 查找用户活跃分钟数"></a>5723. 查找用户活跃分钟数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你用户在 <code>LeetCode</code>的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 <code>logs[i] = [IDi, timei]</code> 表示 ID 为 IDi 的用户在 timei 分钟时执行了某个操作。</p><p>多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。</p><p>指定用户的 用户活跃分钟数<code>（user active minutes，UAM）</code> 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p><p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 <code>answer</code> ，对于每个 <code>j（1 &lt;= j &lt;= k）</code>，<code>answer[j]</code>表示 用户活跃分钟数 等于 <code>j</code> 的用户数。</p><p>返回上面描述的答案数组 <code>answer</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>]], k = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">ID=<span class="number">0</span> 的用户执行操作的分钟分别是：<span class="number">5</span> 、<span class="number">2</span> 和 <span class="number">5</span> 。因此，该用户的用户活跃分钟数为 <span class="number">2</span>（分钟 <span class="number">5</span> 只计数一次）</span><br><span class="line">ID=<span class="number">1</span> 的用户执行操作的分钟分别是：<span class="number">2</span> 和 <span class="number">3</span> 。因此，该用户的用户活跃分钟数为 <span class="number">2</span></span><br><span class="line"><span class="number">2</span> 个用户的用户活跃分钟数都是 <span class="number">2</span> ，answer[<span class="number">2</span>] 为 <span class="number">2</span> ，其余 answer[j] 的值都是 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]], k = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">ID=<span class="number">1</span> 的用户仅在分钟 <span class="number">1</span> 执行单个操作。因此，该用户的用户活跃分钟数为 <span class="number">1</span></span><br><span class="line">ID=<span class="number">2</span> 的用户执行操作的分钟分别是：<span class="number">2</span> 和 <span class="number">3</span> 。因此，该用户的用户活跃分钟数为 <span class="number">2</span></span><br><span class="line"><span class="number">1</span> 个用户的用户活跃分钟数是 <span class="number">1</span> ，<span class="number">1</span> 个用户的用户活跃分钟数是 <span class="number">2</span> </span><br><span class="line">因此，answer[<span class="number">1</span>] = <span class="number">1</span> ，answer[<span class="number">2</span>] = <span class="number">1</span> ，其余的值都是 <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= logs.length &lt;= 104</code></li><li><code>0 &lt;= IDi &lt;= 109</code></li><li><code>1 &lt;= timei &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[用户的最大用户活跃分钟数, 105]</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-the-users-active-minutes</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash统计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>利用<code>hash</code>统计每个用户活跃的分钟的计数，然后将每个用户的活跃分钟的次数返回到最终的统计结果中即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findingUsersActiveMinutes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; logs, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = logs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(k);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : logs)&#123;</span><br><span class="line">            cnt[v[<span class="number">0</span>]].insert(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: cnt)&#123;</span><br><span class="line">            ans[v.second.size()<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5724-绝对差值和"><a href="#5724-绝对差值和" class="headerlink" title="5724. 绝对差值和"></a>5724. 绝对差值和</h2><p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code>。</p><p>数组 <code>nums1</code> 和 <code>nums2</code> 的 绝对差值和 定义为所有 <code>|nums1[i] - nums2[i]|（0 &lt;= i &lt; n）</code>的 总和（下标从 0 开始）。</p><p>你可以选用 <code>nums1</code> 中的 任意一个 元素来替换 <code>nums1</code> 中的 至多 一个元素，以 最小化 绝对差值和。</p><p>在替换数组 <code>nums1</code> 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>109 + 7</code>取余 后返回。</p><p><code>|x|</code>定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，值为 <code>x</code> ，或者</li><li>如果 <code>x &lt;= 0</code> ，值为 <code>-x</code></li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：有两种可能的最优方案：</span><br><span class="line">- 将第二个元素替换为第一个元素：[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>] =&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>] ，或者</span><br><span class="line">- 将第二个元素替换为第三个元素：[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>] =&gt; [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">两种方案的绝对差值和都是 |<span class="number">1</span><span class="number">-2</span>| + (|<span class="number">1</span><span class="number">-3</span>| 或者 |<span class="number">5</span><span class="number">-3</span>|) + |<span class="number">5</span><span class="number">-5</span>| = <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>], nums2 = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：将第一个元素替换为第二个元素：[<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>] =&gt; [<span class="number">10</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">绝对差值和为 |<span class="number">10</span><span class="number">-9</span>| + |<span class="number">10</span><span class="number">-3</span>| + |<span class="number">4</span><span class="number">-5</span>| + |<span class="number">4</span><span class="number">-1</span>| + |<span class="number">2</span><span class="number">-7</span>| + |<span class="number">7</span><span class="number">-4</span>| = <span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-absolute-sum-difference</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>根据题目中的意思，我们只能进行一次替换，根据贪心原则则我们肯定将$|nums1[i]-nums2[i]|$最大的数对进行替换，才能使得返回值最小。因此首先我们找到所有的值$|nums1[i]-nums2[i]|$最大的所有数对，然后分别对其中的每一个数对尝试进行替换，是否能否取得最小值。</li><li>对于数对$nums1[i],nums2[i]$,如果要使的$|nums1[i]-nums2[i]|$的值，最小则我们应当尽量将$nums1[i]$替换为最接近$nums2[i]$的值，则此时我们可以利用二分查找，在数组<code>nums1</code>找到最小的大于等于$nums2[i]$的数和最大的小于等于$nums2[i]$的数，最接近的数肯定在这两个数中选一个即可，此时我们非常常见的可以利用二分查找即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsoluteSumDiff</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = nums1;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(nums1[i]-nums2[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums1[i]-nums2[i]) &gt; <span class="built_in">abs</span>(nums1[diff]-nums2[diff]))&#123;</span><br><span class="line">                diff = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums1[i]-nums2[i]) == <span class="built_in">abs</span>(nums1[diff]-nums2[diff]))&#123;</span><br><span class="line">                a.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr.begin(),arr.end(),nums2[a[i]]);</span><br><span class="line">            <span class="keyword">if</span>(it == arr.end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == arr.begin())&#123;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5725-序列中不同最大公约数的数目"><a href="#5725-序列中不同最大公约数的数目" class="headerlink" title="5725. 序列中不同最大公约数的数目"></a>5725. 序列中不同最大公约数的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个由正整数组成的数组 <code>nums</code>。</p><p>数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。<br>例如，序列 <code>[4,6,16]</code> 的最大公约数是 2 。<br>数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。<br>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,2,4,1,5,10]</code> 的一个子序列。<br>计算并返回 <code>nums</code> 的所有 非空 子序列中 不同 最大公约数的 数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">10</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：上图显示了所有的非空子序列与各自的最大公约数。</span><br><span class="line">不同的最大公约数为 <span class="number">6</span> 、<span class="number">10</span> 、<span class="number">3</span> 、<span class="number">2</span> 和 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">15</span>,<span class="number">40</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 105</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题，素数筛选法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先对于素数筛选法还是非常熟悉的，如果一个数<code>x</code>为素数，则<code>x</code>的倍数一定不是素数。我们知道可以在$O(n)$的时间复杂度内筛选出所有的从$[1,n]$的素数。</li><li>我们知道如果<code>x</code>为某个数组的最大公约数，则我们可以知道如下结论:</li></ol><ul><li>数组中的每个元素都能被$x$整除；</li><li>数组中的所有元素除以<code>x</code>以后组成的数组的最大公约数为<code>1</code>。</li><li>数组中所有元素都是$x$的倍数；</li></ul><ol><li>此时我们就可以参考素数筛选法，尝试从$[1,200000]$中所有的可能的最大公约数，则此时我们假设<code>x</code>为公约数，则我们测试所有的$x$的倍数是否存在于原数组中，如果存在我们则求最大公约数，最终我们测试所有可能的元素的最大公约数是否为$x$。</li><li>题目的算法时间复杂度计算公式为：<script type="math/tex; mode=display">O(n) = \frac{n}{1} + \frac{n}{2} + \frac{n}{3} + ... + \frac{n}{n} \\\approx n*lg(n)</script>非常喜欢这种思考类型的题目，但是感觉就是刷题而已。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) valid[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= <span class="number">200000</span>; j = j + i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="number">0</span>) curr = j;</span><br><span class="line">                    <span class="keyword">else</span> curr = __gcd(curr,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == i) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) valid[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= <span class="number">200000</span>; j = j + i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">                        curr = j/i;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        curr = __gcd(curr,j/i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="number">1</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-weekly-contest-235&quot;&gt;&lt;a href=&quot;#leetcode-weekly-contest-235&quot; class=&quot;headerlink&quot; title=&quot;leetcode weekly contest 235&quot;&gt;&lt;/a&gt;leetcode weekly contest 235&lt;/h1&gt;&lt;p&gt;还是依旧三道题，最后一题的思考确实比较难。&lt;/p&gt;&lt;h2 id=&quot;5722-截断句子&quot;&gt;&lt;a href=&quot;#5722-截断句子&quot; class=&quot;headerlink&quot; title=&quot;5722. 截断句子&quot;&gt;&lt;/a&gt;5722. 截断句子&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。&lt;/p&gt;&lt;p&gt;例如，&lt;code&gt;&amp;quot;Hello World&amp;quot;、&amp;quot;HELLO&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;hello world hello world&amp;quot;&lt;/code&gt;都是句子。&lt;br&gt;给你一个句子 &lt;code&gt;s​​​​​​&lt;/code&gt; 和一个整数&lt;code&gt;k​​​​​​&lt;/code&gt; ，请你将 &lt;code&gt;s​​&lt;/code&gt; 截断 ​，​​​使截断后的句子仅含 前 &lt;code&gt;k​​​​​​&lt;/code&gt; 个单词。返回 截断 &lt;code&gt;s​​​​​​&lt;/code&gt; 后得到的句子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Atcoder】</title>
    <link href="http://yoursite.com/2021/03/29/267/"/>
    <id>http://yoursite.com/2021/03/29/267/</id>
    <published>2021-03-29T14:16:04.543Z</published>
    <updated>2021-03-31T11:43:29.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="atcoder-197"><a href="#atcoder-197" class="headerlink" title="atcoder 197"></a>atcoder 197</h1><p>atcoder的题目难度还是非常高的，非常适合ACM的比赛，难度还是不小的，仔细做了一下，发现自己也就3到4题的水平，<code>e</code>和<code>f</code>的难度还是非常大。</p><h2 id="e"><a href="#e" class="headerlink" title="e"></a>e</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/31/7ZVcTIYC9uWfrma.png" alt><br>给编号从<code>1</code>到<code>n</code>的球的坐标和颜色，要求按照颜色的升序进行进行遍历。其中球的颜色可以重复，从<code>0</code>点开始起遍历所有的球，并返回到<code>0</code>点的最短路径。</p><a id="more"></a><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc197/tasks/abc197_e" target="_blank" rel="noopener">https://atcoder.jp/contests/abc197/tasks/abc197_e</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  dp</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本题的<code>dp</code>还是非常值得思考的一个<code>dp</code>，我们假设不考虑球的颜色，我们按照球的坐标的大小进行排序<script type="math/tex; mode=display">x_{1} < x_{2} < x_{3} < x_{4} ... < x_{n}</script>按照所有球的坐标从小到大进行访问即可。但在实际的过程中因为要求必须按照球的颜色大小进行访问，此时我们首先必须按照球的颜色编号大小对所有的球进行排序。我们仔细观察一下，假设对于第<code>i</code>种颜色的球总共有<code>m</code>个，它的所有的坐标按照从小到大分布如下：<script type="math/tex; mode=display">x^{i}_{1} < x^{i}_{2} < x^{i}_{3} < x^{i}_{4}< x^{i}_{5}...< x^{i}_{m}</script>我们仔细思索一下，假设我们从坐标$x^{i}_{k}$开始访问第<code>i</code>种颜色的球，无论访问顺序如何，最小的访问路径的终点一定是要么是$x^{i}_{1}$,要么是$x^{i}_{m}$,相当于要么是第<code>i</code>种颜色的球中坐标最小的球，要么是第<code>i</code>种颜色的球中坐标最大的球。<br>2.基于此种情况下，我们可以推到出<code>dp</code>的递推公式，我们设：</li></ol><ul><li><code>dp[i][0]</code>表示已经遍历了前<code>i</code>种颜色的球，且最后访问的球位于第<code>i</code>种颜色的球的坐标的首位。</li><li><code>dp[i][1]</code>表示已经遍历了前<code>i</code>种颜色的球，且最后访问的球位于第<code>i</code>种颜色的球的坐标的末位。</li></ul><ol><li>基于上述的推断，我们设<code>arr[i][0]</code>表示第<code>i</code>种球的坐标的首位，<code>arr[i][1]</code>表示第<code>i</code>种球的坐标的末位,我们可以得到递推公式如下：<script type="math/tex; mode=display">dp[i][0] = min(dp[i][0],dp[i-1][0] + abs(arr[i-1][0] - arr[i][1]) + arr[i][1] - arr[i][0); \\dp[i][0] = min(dp[i][0],dp[i-1][1] + abs(arr[i-1][1] - arr[i][1]) + arr[i][1] - arr[i][0); \\dp[i][1] = min(dp[i][1],dp[i-1][0] + abs(arr[i-1][0] - arr[i][0]) + arr[i][1] - arr[i][0); \\dp[i][1] = min(dp[i][1],dp[i-1][1] + abs(arr[i-1][1] - arr[i][0]) + arr[i][1] - arr[i][0); \\</script></li><li>此题的重点在于如何理解跨越时最小的移动轨迹，从某一点到某一点的最小的移动轨迹一般都是确定的。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;sz[find(x)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; y1) swap(x1,y1);</span><br><span class="line">        parent[y1] = x1;</span><br><span class="line">        sz[x1] += sz[y1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x,c;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        cnt[c].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        sort(cnt[v.first].begin(),cnt[v.first].end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        arr.push_back(&#123;v.second[<span class="number">0</span>],v.second.back()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push_back(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> m = arr.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>,LONG_MAX));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = arr[i][<span class="number">1</span>] - arr[i][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">0</span>] = min(dp[i][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">0</span>] - arr[i][<span class="number">1</span>]) + l);</span><br><span class="line">        dp[i][<span class="number">0</span>] = min(dp[i][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">1</span>] - arr[i][<span class="number">1</span>]) + l);</span><br><span class="line">        dp[i][<span class="number">1</span>] = min(dp[i][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">0</span>] - arr[i][<span class="number">0</span>]) + l);</span><br><span class="line">        dp[i][<span class="number">1</span>] = min(dp[i][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">1</span>] - arr[i][<span class="number">0</span>]) + l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(dp[m<span class="number">-1</span>][<span class="number">0</span>],dp[m<span class="number">-1</span>][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;atcoder-197&quot;&gt;&lt;a href=&quot;#atcoder-197&quot; class=&quot;headerlink&quot; title=&quot;atcoder 197&quot;&gt;&lt;/a&gt;atcoder 197&lt;/h1&gt;&lt;p&gt;atcoder的题目难度还是非常高的，非常适合ACM的比赛，难度还是不小的，仔细做了一下，发现自己也就3到4题的水平，&lt;code&gt;e&lt;/code&gt;和&lt;code&gt;f&lt;/code&gt;的难度还是非常大。&lt;/p&gt;&lt;h2 id=&quot;e&quot;&gt;&lt;a href=&quot;#e&quot; class=&quot;headerlink&quot; title=&quot;e&quot;&gt;&lt;/a&gt;e&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/7ZVcTIYC9uWfrma.png&quot; alt&gt;&lt;br&gt;给编号从&lt;code&gt;1&lt;/code&gt;到&lt;code&gt;n&lt;/code&gt;的球的坐标和颜色，要求按照颜色的升序进行进行遍历。其中球的颜色可以重复，从&lt;code&gt;0&lt;/code&gt;点开始起遍历所有的球，并返回到&lt;code&gt;0&lt;/code&gt;点的最短路径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="atcoder" scheme="http://yoursite.com/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 234</title>
    <link href="http://yoursite.com/2021/03/28/266/"/>
    <id>http://yoursite.com/2021/03/28/266/</id>
    <published>2021-03-28T05:22:16.985Z</published>
    <updated>2021-03-31T02:57:22.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-234"><a href="#leetcode-contest-234" class="headerlink" title="leetcode contest 234"></a>leetcode contest 234</h1><p>本周的题目质量太差了，没有特别需要思考的地方，除了第二题是个数学题以外，本周的题目感觉基本上都是数学问题，最有意思和思考的题目竟然是第二题。</p><h2 id="5713-字符串中不同整数的数目"><a href="#5713-字符串中不同整数的数目" class="headerlink" title="5713. 字符串中不同整数的数目"></a>5713. 字符串中不同整数的数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p><p>请你用空格替换每个不是数字的字符。例如，<code>&quot;a123bc34d8ef34&quot;</code> 将会变成 <code>&quot; 123  34 8  34&quot;</code> 。注意，剩下的这些整数间至少要用一个空格隔开：<code>&quot;123&quot;、&quot;34&quot;、&quot;8&quot; 和 &quot;34&quot;</code>。</p><a id="more"></a><p>返回对 <code>word</code> 完成替换后形成的 不同 整数的数目。</p><p>如果两个整数的 不含前导零 的十进制表示不同，则认为这两个整数也不同。</p><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"a123bc34d8ef34"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：不同的整数有 <span class="string">"123"</span>、<span class="string">"34"</span> 和 <span class="string">"8"</span> 。注意，<span class="string">"34"</span> 只计数一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"leet1234code234"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"a1b01c001"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="string">"1"</span>、<span class="string">"01"</span> 和 <span class="string">"001"</span> 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 1000</code></li><li><code>word</code> 由数字和小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-different-integers-in-a-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>取出字符串中连续的数字的字符串放入到集合中。对于字符串需要处理去掉前导<code>0</code>，然后将剩余的数字作为一个完整的字符串放入到集合中。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDifferentIntegers</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'a'</span> &amp;&amp; s[i] &lt;= <span class="string">'z'</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> curr;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] == <span class="string">'0'</span>) i++;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                    curr.push_back(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.size() == <span class="number">0</span>) curr.push_back(<span class="string">'0'</span>);</span><br><span class="line">                cnt.insert(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5715-还原排列的最少操作步数"><a href="#5715-还原排列的最少操作步数" class="headerlink" title="5715. 还原排列的最少操作步数"></a>5715. 还原排列的最少操作步数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个偶数 <code>n</code>​​​​​​ ，已知存在一个长度为 <code>n</code> 的排列 <code>perm</code>，其中 <code>perm[i] == i​</code>（下标 从 0 开始 计数）。</p><p>一步操作中，你将创建一个新数组 <code>arr</code>，对于每个 <code>i</code> ：</p><ul><li>如果 <code>i % 2 == 0</code>，那么 <code>arr[i] = perm[i / 2]</code></li><li>如果 <code>i % 2 == 1</code>，那么 <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code><br>然后将 <code>arr</code>​​ 赋值​​给<code>perm</code> 。</li></ul><p>要想使 <code>perm</code> 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">所以，仅需执行 <span class="number">1</span> 步操作</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">2</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">所以，仅需执行 <span class="number">2</span> 步操作</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>n</code>​​​​​​ 是一个偶数</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题，暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>如果不知道如何解决，我们可以建设最终变换的次数肯定不会多于<code>n</code>，则此时我们直接用暴力变换，知道变换出来的数组的每个元素满足<code>arr[i] == i</code>即回到初始值。<br>2.首先我们可以尝试进行变换一下题目中的变换规则：</li></ol><ul><li>如果 <code>i &lt; n/2</code>，那么 <code>arr[2*i] = perm[i]</code></li><li>如果 <code>i &gt;= n/2</code>，那么 <code>arr[2*i-n] = perm[i]</code><br>如果用数学问题来分析，我们可以看到第一次变换的情况如下，最开始的数组为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...,n<span class="number">-1</span></span><br></pre></td></tr></table></figure>经过第一次变换后，假设<code>n=10</code>，我们可以仔细观察它的变化规则，我们可以知道变换后的数组元素为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span>：<span class="number">0</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> </span><br><span class="line"><span class="number">2</span>：<span class="number">0</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">9</span> </span><br><span class="line"><span class="number">3</span>: <span class="number">0</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">9</span> </span><br><span class="line"><span class="number">4</span>: <span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">1</span> <span class="number">5</span> <span class="number">9</span> </span><br><span class="line"><span class="number">5</span>: <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> </span><br><span class="line"><span class="number">6</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>我们假设试着开始进行逆变换，即从上述的状态<code>6</code>向状态<code>5</code>开始变换，一直到变换出来状态<code>0</code>为止，如果为逆变换则我们应当遵循如下变换：</li><li>如果 <code>i &lt; n/2</code>，那么 <code>arr[i] = perm[2*i]</code></li><li>如果 <code>i &gt;= n/2</code>，那么 <code>arr[i] = perm[2*i-n]</code><br>则此时我们可以知道如下第一次变换时:</li><li>当$i &lt; \frac{n}{2}$时，此时我们可以知道$f(i) = 2*i$;</li><li>当$i \ge \frac{n}{2}$时，此时我们可以知道$f(i) = 2*i - (n-1)$;</li><li>$perm[0],perm[n-1]$这两个元素始终保持不变；<br>仔细观察其规律，我们可以得到结论得到结论，$f(i) = 2<em>i\quad mod (n-1)$，因为当$i &lt; \frac{n}{2}$时，此时我们可以知道$f(i) = 2</em>i$，此时$2*i &lt; (n-1)$.<br>根据上述得到的结论后，我们可以知道：<br>第<code>k</code>的结果与第<code>k-1</code>次的变换结果如下：<script type="math/tex; mode=display">f_{k}(i) = 2*f_{k-1}(i) \quad mod \quad (n-1)</script>则此时我们将$f_{1}(i)$代入到上述的公式中，可以得到：<script type="math/tex; mode=display">f_{k}(i) = 2^{k}*i \quad mod \quad(n-1)</script>因此我们只需要满足如下时，即表示我们当前的变换到了最终的结果：<script type="math/tex; mode=display">f_{k}(1) = 2^{k}*1 \quad mod \quad(n-1) = 1 \\ f_{k}(2) = 2^{k}*2 \quad mod \quad(n-1) = 2 \\f_{k}(3) = 2^{k}*3 \quad mod \quad(n-1) = 3 \\... \\f_{k}(n-1) = 2^{k}*(n-2) \quad mod \quad(n-1) = n-2</script>仔细观察一下，我们是需要满足$2^{k}<em>1 \quad mod \quad(n-1) = 1$这个等式，其余的等式都可以满足，所以我们求出最小的<code>k</code>满足$2^{k}</em>1 \quad mod \quad(n-1) = 1$即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reinitializePermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; perm(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) perm[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) arr[i] = perm[i/<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) arr[i] = perm[n/<span class="number">2</span> + (i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        perm = arr;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(perm[i] != i)&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) arr[i] = perm[i/<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) arr[i] = perm[n/<span class="number">2</span> + (i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            perm = arr;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reinitializePermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pow2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (pow2 != <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            pow2 = pow2 * <span class="number">2</span> % (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5714-替换字符串中的括号内容"><a href="#5714-替换字符串中的括号内容" class="headerlink" title="5714. 替换字符串中的括号内容"></a>5714. 替换字符串中的括号内容</h2><p>给你一个字符串 <code>s</code>，它包含一些括号对，每个括号中包含一个 非空 的键。</p><p>比方说，字符串 <code>&quot;(name)is(age)yearsold&quot;</code> 中，有 两个 括号对，分别包含键 <code>&quot;name&quot;</code> 和 <code>&quot;age&quot;</code> 。<br>你知道许多键对应的值，这些关系由二维字符串数组<code>knowledge</code> 表示，其中 <code>knowledge[i] = [keyi, valuei]</code> ，表示键 <code>keyi</code>对应的值为 <code>valuei</code>。</p><p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p><ul><li>将<code>keyi</code>和括号用对应的值 <code>valuei</code> 替换。</li><li>如果从 <code>knowledge</code>中无法得知某个键对应的值，你需要将 <code>keyi</code>和括号用问号 “?” 替换（不需要引号）。</li><li><code>knowledge</code>中每个键最多只会出现一次。<code>s</code> 中不会有嵌套的括号。</li></ul><p>请你返回替换 所有 括号对后的结果字符串。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(name)is(age)yearsold"</span>, knowledge = [[<span class="string">"name"</span>,<span class="string">"bob"</span>],[<span class="string">"age"</span>,<span class="string">"two"</span>]]</span><br><span class="line">输出：<span class="string">"bobistwoyearsold"</span></span><br><span class="line">解释：</span><br><span class="line">键 <span class="string">"name"</span> 对应的值为 <span class="string">"bob"</span> ，所以将 <span class="string">"(name)"</span> 替换为 <span class="string">"bob"</span> 。</span><br><span class="line">键 <span class="string">"age"</span> 对应的值为 <span class="string">"two"</span> ，所以将 <span class="string">"(age)"</span> 替换为 <span class="string">"two"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"hi(name)"</span>, knowledge = <span class="string">[["a","b"]]</span></span><br><span class="line">输出：<span class="string">"hi?"</span></span><br><span class="line">解释：由于不知道键 <span class="string">"name"</span> 对应的值，所以用 <span class="string">"?"</span> 替换 <span class="string">"(name)"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"(a)(a)(a)aaa"</span>, knowledge = [[<span class="comment">"a"</span>,<span class="comment">"yes"</span>]]</span><br><span class="line">输出：<span class="comment">"yesyesyesaaa"</span></span><br><span class="line">解释：相同的键在 s 中可能会出现多次。</span><br><span class="line">键 <span class="comment">"a"</span> 对应的值为 <span class="comment">"yes"</span> ，所以将所有的 <span class="comment">"(a)"</span> 替换为 <span class="comment">"yes"</span> 。</span><br><span class="line">注意，不在括号里的 <span class="comment">"a"</span> 不需要被替换。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(a)(b)"</span>, knowledge = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"a"</span>]]</span><br><span class="line">输出：<span class="string">"ba"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>0 &lt;= knowledge.length &lt;= 105</code></li><li><code>knowledge[i].length == 2</code></li><li><code>1 &lt;= keyi.length, valuei.length &lt;= 10</code></li><li>s 只包含小写英文字母和圆括号 ‘(‘ 和 ‘)’ 。</li><li>s 中每一个左圆括号 ‘(‘ 都有对应的右圆括号 ‘)’ 。</li><li>s 中每对括号内的键都不会为空。</li><li>s 中不会有嵌套括号对。</li><li><code>keyi</code>和 <code>valuei</code> 只包含小写英文字母。</li><li><code>knowledge</code> 中的 <code>keyi</code> 不会重复。<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>这个题目可以算是简单题目，只需要用<code>hashtable</code>保存<code>key</code>对应的<code>value</code>即可，取出括号中的<code>key</code>，然后用对应的<code>value</code>替换即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">evaluate</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; knowledge)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; dict;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : knowledge) dict[v[<span class="number">0</span>]] = v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); )&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">'('</span>)&#123;</span><br><span class="line">                ans.push_back(s[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) i++;</span><br><span class="line">                <span class="built_in">string</span> key;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] != <span class="string">')'</span>)&#123;</span><br><span class="line">                    key.push_back(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) i++;</span><br><span class="line">                <span class="keyword">if</span>(dict.count(key))&#123;</span><br><span class="line">                    ans += dict[key];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans.push_back(<span class="string">'?'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5716-好因子的最大数目"><a href="#5716-好因子的最大数目" class="headerlink" title="5716. 好因子的最大数目"></a>5716. 好因子的最大数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数 <code>primeFactors</code> 。你需要构造一个正整数 n ，它满足以下条件：</p><p>n 质因数（质因数需要考虑重复的情况）的数目 不超过 <code>primeFactors</code> 个。<br>n 好因子的数目最大化。如果 <code>n</code> 的一个因子可以被<code>n</code>的每一个质因数整除，我们称这个因子是 好因子 。比方说，如果 n = 12 ，那么它的质因数为 [2,2,3] ，那么 6 和 12 是好因子，但 3 和 4 不是。<br>请你返回 n 的好因子的数目。由于答案可能会很大，请返回答案对 <code>109 + 7</code>取余 的结果。</p><p>请注意，一个质数的定义是大于 1 ，且不能被分解为两个小于该数的自然数相乘。一个数 <code>n</code> 的质因子是将 <code>n</code> 分解为若干个质因子，且它们的乘积为 n 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：primeFactors = <span class="number">5</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="number">200</span> 是一个可行的 n 。</span><br><span class="line">它有 <span class="number">5</span> 个质因子：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>] ，且有 <span class="number">6</span> 个好因子：[<span class="number">10</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>] 。</span><br><span class="line">不存在别的 n 有至多 <span class="number">5</span> 个质因子，且同时有更多的好因子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：primeFactors = <span class="number">8</span></span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= primeFactors &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-233/problems/count-pairs-with-xor-in-a-range/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-233/problems/count-pairs-with-xor-in-a-range/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目弄得太啰嗦了，本质就是正整数分解使得乘积最大问题，如果转化为这个问题得话，本题就十分简单了，本质就变成了一个数学问题。<br><a href="https://blog.csdn.net/xiaoquantouer/article/details/70142739" target="_blank" rel="noopener">正整数分解使得乘积最大问题</a></li><li>按照题目中给定得意思，假设我们设<code>n</code>有<code>k</code>个不同的质因子，每个不同的质因子的数目分别为$p_{0},p_{1}，…,p_{k-1}$则我们可以知道如下：<script type="math/tex; mode=display">primeFactors = \sum_{i = 0}^{k-1}p_{i}</script>按照题目中要求好因子必须能够被所有的质因子整除，这就表示好因子必须包含每一个不同的质因子，根据组合定理可以知道，这样的好因子的数目即为:<script type="math/tex; mode=display">good = \prod_{i=0}^{k-1}p_{i}</script>题目中要求使得<code>good</code>的值最大，因此这就转为了正整数分解使得乘积最大问题。最大的分解的原则如下：</li></ol><ul><li>能被<code>3</code>除断，那么就分解为<code>3+3+...+3</code>的情况即可。例如<code>9=3+3+3</code>。</li><li>被<code>3</code>除余<code>1</code>，分解为<code>3+3+...+3+2+2</code>或者<code>3+3+...+3+4</code>的情况，例如<code>10=3+3+2+2</code></li><li>被<code>3</code>除余<code>2</code>，分解为<code>3+3+...+3+2</code>的情况，例如<code>11=3+3+3+2</code>。</li></ul><ol><li>我们根据<code>primeFactors</code>的大小按照上述规则进行分解即可，稍微麻烦点的我们可以利用二分法进行快速的求幂。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = fastpow(x,y/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(y%<span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (curr*curr)%mod;</span><br><span class="line">        <span class="keyword">return</span> (curr*curr*x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNiceDivisors</span><span class="params">(<span class="keyword">int</span> primeFactors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(primeFactors%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> fastpow(<span class="number">3</span>,primeFactors/<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primeFactors%<span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(primeFactors == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>*fastpow(<span class="number">3</span>,(primeFactors<span class="number">-4</span>)/<span class="number">3</span>)%mod; </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primeFactors%<span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*fastpow(<span class="number">3</span>,(primeFactors<span class="number">-2</span>)/<span class="number">3</span>)%mod;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-234&quot;&gt;&lt;a href=&quot;#leetcode-contest-234&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 234&quot;&gt;&lt;/a&gt;leetcode contest 234&lt;/h1&gt;&lt;p&gt;本周的题目质量太差了，没有特别需要思考的地方，除了第二题是个数学题以外，本周的题目感觉基本上都是数学问题，最有意思和思考的题目竟然是第二题。&lt;/p&gt;&lt;h2 id=&quot;5713-字符串中不同整数的数目&quot;&gt;&lt;a href=&quot;#5713-字符串中不同整数的数目&quot; class=&quot;headerlink&quot; title=&quot;5713. 字符串中不同整数的数目&quot;&gt;&lt;/a&gt;5713. 字符串中不同整数的数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;word&lt;/code&gt; ，该字符串由数字和小写英文字母组成。&lt;/p&gt;&lt;p&gt;请你用空格替换每个不是数字的字符。例如，&lt;code&gt;&amp;quot;a123bc34d8ef34&amp;quot;&lt;/code&gt; 将会变成 &lt;code&gt;&amp;quot; 123  34 8  34&amp;quot;&lt;/code&gt; 。注意，剩下的这些整数间至少要用一个空格隔开：&lt;code&gt;&amp;quot;123&amp;quot;、&amp;quot;34&amp;quot;、&amp;quot;8&amp;quot; 和 &amp;quot;34&amp;quot;&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 2021 Google Kick Start roundA</title>
    <link href="http://yoursite.com/2021/03/26/265/"/>
    <id>http://yoursite.com/2021/03/26/265/</id>
    <published>2021-03-26T05:54:42.650Z</published>
    <updated>2021-03-27T09:37:40.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2021-google-kick-start-roundA"><a href="#2021-google-kick-start-roundA" class="headerlink" title="2021 google kick start roundA"></a>2021 google kick start roundA</h1><p><code>kick start</code>的题目果真质量非常高，非常值得学习和练习的题目，非常喜欢这类的题目，前三题都可以做出来，不过题目<code>D</code>确实很难，我感觉自己肯定想不到解答的答案的。前三题就是<code>leetcode</code>的难度，最后一题确实很难。</p><h2 id="K-Goodness-String-5pts-7pts"><a href="#K-Goodness-String-5pts-7pts" class="headerlink" title="K-Goodness String (5pts, 7pts)"></a>K-Goodness String (5pts, 7pts)</h2><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/26/ERxJvVkZF1rYitD.png" alt><br>给定字符串，求出给定分值得最小变换次数</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cca3" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cca3</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单题目</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们只需要求出$s[i] != s[n-1-i]$得字符对个数，最小的变换次数等于不同的字符对的个数与<code>k</code>的绝对值之差。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> good = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bad = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n&gt;&gt;<span class="number">1</span>); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str[n<span class="number">-1</span>-i]) good++;</span><br><span class="line">        <span class="keyword">else</span> bad++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;<span class="built_in">abs</span>(k-bad)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="L-Shaped-Plots-8pts-12pts"><a href="#L-Shaped-Plots-8pts-12pts" class="headerlink" title="L Shaped Plots (8pts, 12pts)"></a>L Shaped Plots (8pts, 12pts)</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/26/3TnVvd1utlzsgqR.png" alt><br>求出给定的矩阵中<code>L</code>的个数，<code>L</code>形要求：</p><ul><li><code>L</code>的两个线段必须分别在一行和一列，两个线段必须必须与行、列平行；</li><li><code>L</code>的两个线段有且只有一个点相交，且一条线段的长度为另一条线段的长度的两倍；</li><li><code>L</code>的两个线段的长度必须大于等于<code>2</code>;<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c509" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c509</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口 + 前缀和</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>我们分别求出以点<code>(x,y)</code>为起点，分别往上下左右四个方向的最长的连续的<code>1</code>的长度。</li><li>分别求出以点<code>(x,y)</code>为起点相交顶点的<code>L</code>的个数，分别在上下左右四个方向求一边，我们设<code>L</code>的两个线段的长度分别为$m,n$,则以<code>m,n</code>为长度的两个线段可能组成的<code>L</code>的形状个数为：<script type="math/tex; mode=display">cnt = max(0,min(m/2,n)-1) + max(0,min(m,n/2)-1)</script></li><li>时间复杂度$O(m<em>n)$,空间复杂度$O(m</em>n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;row&gt;&gt;col;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; left(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; right(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; down(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; up(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            left[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            right[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">         <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            up[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            down[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            ans += max(min(left[i][j],up[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(left[i][j]/<span class="number">2</span>,up[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(right[i][j],up[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(right[i][j]/<span class="number">2</span>,up[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(left[i][j],down[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(left[i][j]/<span class="number">2</span>,down[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(right[i][j],down[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += max(min(right[i][j]/<span class="number">2</span>,down[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Rabbit-House-9pts-15pts"><a href="#Rabbit-House-9pts-15pts" class="headerlink" title="Rabbit House (9pts, 15pts)"></a>Rabbit House (9pts, 15pts)</h2><p><img src="https://i.loli.net/2021/03/26/o8TjBu3RcAtbyVp.png" alt><br>这个题目跟<code>leetcode</code>上的那个容器的题目很像，所以是中规中矩的题目，不算很难，靠自己还能思考出来。</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cb14" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cb14</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们将矩阵中所有单元的高度按照从高到底依次排列，每次从队列中取除当前高度最高的单元$(x,y)$,高度为$h$,则此时必须满足$(x,y)$周围的四个格子$(x-1,y),(x+1,y),(x,y+1),(x,y-1)$必须要大于等于$h-1$,如果当前格子的高度发生改变则将其从新放入队列中。</li><li>非常简单的优先级对即可解决，时间复杂度为$O(m<em>nlg(m</em>n))$,空间复杂度为$O(m*n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a,Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;row&gt;&gt;col;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">    priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;matrix[i][j];</span><br><span class="line">            pq.push(&#123;i,j,matrix[i][j]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">        Node curr = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        visit[curr.x][curr.y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr.val != matrix[curr.x][curr.y]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = curr.x + d[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = curr.y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visit[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &lt; curr.val - <span class="number">1</span>)&#123;</span><br><span class="line">                ans += curr.val - <span class="number">1</span> - matrix[x][y];</span><br><span class="line">                matrix[x][y] = curr.val - <span class="number">1</span>;</span><br><span class="line">                pq.push(&#123;x,y,matrix[x][y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Checksum-10pts-17pts-17pts"><a href="#Checksum-10pts-17pts-17pts" class="headerlink" title="Checksum (10pts, 17pts, 17pts)"></a>Checksum (10pts, 17pts, 17pts)</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/26/L8D2wuAkR5f6B3p.png" alt><br>给定矩阵和每行每列的异或校验和，求恢复矩阵所需要的最小代价。</p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c2c3" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c2c3</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>最小生成树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目还是非常难的，根本不容易想到，我们首先将已经恢复的单元视作代价为$0$的未恢复的单元。</li><li>首先我们需要想到一个问题，思考一下我们至少需要恢复多少个单元，才能将所有的单元全部恢复，这个就是一个非常值得思考得问题，我们仔细想一下，因为已知每一行所有元素得异或校验和，则我们如果已经知道每一行的$n-1$个值，则我们就能通过校验和计算最后一个未知的数，对于每一列同样也是如此，所以我们可以猜测一下，我们至少需要恢复$(n-1)^{2}$个数据，才能完成所有的$n^{2}$数据恢复。</li></ol><ul><li>我们可以计算一下，如果恢复的元素超过$(n-1)^{2}$个，则我们可以计算出肯定存在某一行或者某一列恢复的数据为$n$个，这个对于我们来说是不必要的。</li><li>如果恢复的数据少于$(n-1)^{2}$,则此时我们还至少需要恢复$2*N$个数据，而我们实际上根据异或的校验和，至多能够推导出$2N-1$个数据。</li></ul><ol><li>根据以上推论，我们可以知道可以知道选择出最大的未解的$2n-1$个数据，剩余的$(n-1)^{2}$的数据恢复则花费的代价可能最小。如何选择$2n-1$个数据呢？假设我们按照以下顺序通过校验和来恢复最后剩余的$(2n-1)$个数据，顺序为：<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">9</span> <span class="number">0</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">0</span> <span class="number">0</span> <span class="number">10</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>$1 \rightarrow 2 \rightarrow 3 \rightarrow 4\rightarrow 5\rightarrow 6\rightarrow 7\rightarrow 8\rightarrow 9\rightarrow 10 \rightarrow 11$<br>我们实际可以知道将行与列分别看成生成树中的两个顶点，我们实际可以看出由行与列组成成的图不能有环，如果存在环的话，则一定存在某一行或者某一列中有两个未知数，则此时就不可能恢复该行或者该列的元素。</li><li>根据以上得出我们只需要选出边与行的顶点组成的最大生成树，可以用<code>prim</code>或者<code>Kruskal</code>算法即可。因为在此图中一个顶点连接的边很多，此时明显我们用<code>prim</code>算法的时间复杂度更好。</li><li>代码直接<code>copy lucifer</code>的。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> c = getchar();</span><br><span class="line">  T sig = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar())</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">      sig = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar())</span><br><span class="line">    x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">  x *= sig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent, size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    size = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      parent[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[idx] == idx)</span><br><span class="line">      <span class="keyword">return</span> idx;</span><br><span class="line">    <span class="keyword">return</span> parent[idx] = find(parent[idx]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(a), fb = find(b);</span><br><span class="line">    <span class="keyword">if</span> (fa != fb) &#123;</span><br><span class="line">      <span class="keyword">if</span> (size[fa] &gt; size[fb]) &#123;</span><br><span class="line">        parent[fb] = fa;</span><br><span class="line">        size[fa] += size[fb];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[fa] = fb;</span><br><span class="line">        size[fb] += size[fa];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> case_num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, case_num);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; b(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        read(a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        read(b[i][j]);</span><br><span class="line">        tot += b[i][j];</span><br><span class="line">        edges.emplace_back(b[i][j], i, n + j);</span><br><span class="line">      &#125;</span><br><span class="line">    sort(edges.rbegin(), edges.rend());</span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      read(r[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      read(c[i]);</span><br><span class="line"></span><br><span class="line">    ll remove = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [weight, u, v] : edges) &#123;</span><br><span class="line">      <span class="keyword">if</span> (uf.find(u) == uf.find(v))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      remove += weight;</span><br><span class="line">      uf.connect(u, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tot - remove);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  read(t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    Solution solution = Solution();</span><br><span class="line">    solution.solve(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2021-google-kick-start-roundA&quot;&gt;&lt;a href=&quot;#2021-google-kick-start-roundA&quot; class=&quot;headerlink&quot; title=&quot;2021 google kick start roundA&quot;&gt;&lt;/a&gt;2021 google kick start roundA&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kick start&lt;/code&gt;的题目果真质量非常高，非常值得学习和练习的题目，非常喜欢这类的题目，前三题都可以做出来，不过题目&lt;code&gt;D&lt;/code&gt;确实很难，我感觉自己肯定想不到解答的答案的。前三题就是&lt;code&gt;leetcode&lt;/code&gt;的难度，最后一题确实很难。&lt;/p&gt;&lt;h2 id=&quot;K-Goodness-String-5pts-7pts&quot;&gt;&lt;a href=&quot;#K-Goodness-String-5pts-7pts&quot; class=&quot;headerlink&quot; title=&quot;K-Goodness String (5pts, 7pts)&quot;&gt;&lt;/a&gt;K-Goodness String (5pts, 7pts)&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 233</title>
    <link href="http://yoursite.com/2021/03/20/264/"/>
    <id>http://yoursite.com/2021/03/20/264/</id>
    <published>2021-03-20T15:47:39.102Z</published>
    <updated>2021-03-21T15:45:16.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-233"><a href="#leetcode-contest-233" class="headerlink" title="leetcode contest 233"></a>leetcode contest 233</h1><p>周赛还算三道题的节奏，最后一题太难了，不会做，没有想到会用<code>trie</code>的解法，确实非常巧妙的解法。</p><h2 id="5709-最大升序子数组和"><a href="#5709-最大升序子数组和" class="headerlink" title="5709. 最大升序子数组和"></a>5709. 最大升序子数组和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数组成的数组 <code>nums</code> ，返回 nums 中一个 升序 子数组的最大可能元素和。</p><p>子数组是数组中的一个连续数字序列。</p><p>已知子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，若对所有 <code>i（l &lt;= i &lt; r）</code>，<code>numsi &lt; numsi+1</code>都成立，则称这一子数组为 升序 子数组。注意，大小为 <code>1</code> 的子数组也视作 升序 子数组。</p><a id="more"></a><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-233/problems/maximum-ascending-subarray-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-233/problems/maximum-ascending-subarray-sum/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力滑动窗口即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>求出每个连续升序的子数组，然后求和即可。时间复杂度$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAscendingSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curr = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                curr += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5711-有界数组中指定下标处的最大值"><a href="#5711-有界数组中指定下标处的最大值" class="headerlink" title="5711. 有界数组中指定下标处的最大值"></a>5711. 有界数组中指定下标处的最大值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你三个正整数 <code>n</code>、<code>index</code> 和 <code>maxSum</code> 。你需要构造一个同时满足下述所有条件的数组 <code>nums</code>（下标 从 <code>0</code> 开始 计数）：</p><ul><li><code>nums.length == n</code></li><li><code>nums[i]</code> 是 正整数 ，其中 <code>0 &lt;= i &lt; n</code></li><li><code>abs(nums[i] - nums[i+1]) &lt;= 1</code> ，其中 <code>0 &lt;= i &lt; n-1</code></li><li><code>nums</code>中所有元素之和不超过 <code>maxSum</code></li><li><code>nums[index]</code> 的值被 最大化<br>返回你所构造的数组中的 <code>nums[index]</code> 。</li></ul><p>注意：<code>abs(x)</code> 等于 <code>x</code> 的前提是 <code>x &gt;= 0</code> ；否则，<code>abs(x)</code>等于 <code>-x</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, index = <span class="number">2</span>,  maxSum = <span class="number">6</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：数组 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 和 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, index = <span class="number">1</span>,  maxSum = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= maxSum &lt;= 109</code></li><li><code>0 &lt;= index &lt; n</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找+贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目写的太长，感觉写的太奇怪。首先我们可以按照题目要求，如果给定<code>index</code>处的值为<code>val</code>,则此时我们既可以构造出最小能够满足题意要求的序列可能为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,..,<span class="number">1</span>,<span class="number">2</span>,...,val<span class="number">-1</span>,val,val<span class="number">-1</span>,val<span class="number">-2</span>,...,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>即以<code>index</code>为中心，左右两边分别为差为为<code>1</code>的等差数列，我们可以很容易利用等差数列的求和公式求出左右两边的和，此时:<script type="math/tex; mode=display">minSum = calc(val,index) + val + calc(val,n-1-index)</script>函数$calc(val,index)$表示计算出的最大值为<code>val-1</code>且长度为<code>index</code>的数列的和。<br>如果此时计算的$minSum \le maxSum$我们则认为其符合条件。</li><li>二分查找即为非常简单的操作，时间复杂度为$O(lg(maxV))$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= val)&#123;</span><br><span class="line">            <span class="keyword">return</span> (val + val - n + <span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (val + <span class="number">1</span>)*val/<span class="number">2</span> + n - val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> maxSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> sum = mid + calc(mid<span class="number">-1</span>,index) + calc(mid<span class="number">-1</span>,n<span class="number">-1</span>-index);</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= maxSum)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5710-积压订单中的订单总数"><a href="#5710-积压订单中的订单总数" class="headerlink" title="5710. 积压订单中的订单总数"></a>5710. 积压订单中的订单总数</h2><p>给你一个二维整数数组 <code>orders</code> ，其中每个 <code>orders[i] = [pricei, amounti, orderTypei]</code>表示有 <code>amounti</code> 笔类型为 <code>orderTypei</code> 、价格为 <code>pricei</code> 的订单。</p><p>订单类型 <code>orderTypei</code> 可以分为两种：</p><ul><li><code>0</code> 表示这是一批采购订单 <code>buy</code></li><li><code>1</code> 表示这是一批销售订单 <code>sell</code><br>注意，<code>orders[i]</code>表示一批共计 <code>amounti</code> 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 <code>i</code>，由 <code>orders[i]</code>表示的所有订单提交时间均早于 <code>orders[i+1]</code>表示的所有订单。</li></ul><p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p><ul><li>如果该订单是一笔采购订单 <code>buy</code> ，则可以查看积压订单中价格 最低 的销售订单 <code>sell</code> 。如果该销售订单 <code>sell</code> 的价格 低于或等于 当前采购订单 <code>buy</code>的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 <code>buy</code> 将会添加到积压订单中。</li><li>反之亦然，如果该订单是一笔销售订单 <code>sell</code> ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单<code>buy</code>的价格 高于或等于 当前销售订单 <code>sell</code>的价格，则匹配并执行这两笔订单，并将采购订单<code>buy</code>从积压订单中删除。否则，销售订单 <code>sell</code> 将会添加到积压订单中。<br>输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 <code>109 + 7</code> 取余的结果。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">15</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">25</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">30</span>,<span class="number">4</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：输入订单后会发生下述情况：</span><br><span class="line">- 提交 <span class="number">5</span> 笔采购订单，价格为 <span class="number">10</span> 。没有销售订单，所以这 <span class="number">5</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">2</span> 笔销售订单，价格为 <span class="number">15</span> 。没有采购订单的价格大于或等于 <span class="number">15</span> ，所以这 <span class="number">2</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">1</span> 笔销售订单，价格为 <span class="number">25</span> 。没有采购订单的价格大于或等于 <span class="number">25</span> ，所以这 <span class="number">1</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">4</span> 笔采购订单，价格为 <span class="number">30</span> 。前 <span class="number">2</span> 笔采购订单与价格最低（价格为 <span class="number">15</span>）的 <span class="number">2</span> 笔销售订单匹配，从积压订单中删除这 <span class="number">2</span> 笔销售订单。第 <span class="number">3</span> 笔采购订单与价格最低的 <span class="number">1</span> 笔销售订单匹配，销售订单价格为 <span class="number">25</span> ，从积压订单中删除这 <span class="number">1</span> 笔销售订单。积压订单中不存在更多销售订单，所以第 <span class="number">4</span> 笔采购订单需要添加到积压订单中。</span><br><span class="line">最终，积压订单中有 <span class="number">5</span> 笔价格为 <span class="number">10</span> 的采购订单，和 <span class="number">1</span> 笔价格为 <span class="number">30</span> 的采购订单。所以积压订单中的订单总数为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="number">7</span>,<span class="number">1000000000</span>,<span class="number">1</span>],[<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">999999995</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">999999984</span></span><br><span class="line">解释：输入订单后会发生下述情况：</span><br><span class="line">- 提交 <span class="number">109</span> 笔销售订单，价格为 <span class="number">7</span> 。没有采购订单，所以这 <span class="number">109</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">3</span> 笔采购订单，价格为 <span class="number">15</span> 。这些采购订单与价格最低（价格为 <span class="number">7</span> ）的 <span class="number">3</span> 笔销售订单匹配，从积压订单中删除这 <span class="number">3</span> 笔销售订单。</span><br><span class="line">- 提交 <span class="number">999999995</span> 笔采购订单，价格为 <span class="number">5</span> 。销售订单的最低价为 <span class="number">7</span> ，所以这 <span class="number">999999995</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">1</span> 笔销售订单，价格为 <span class="number">5</span> 。这笔销售订单与价格最高（价格为 <span class="number">5</span> ）的 <span class="number">1</span> 笔采购订单匹配，从积压订单中删除这 <span class="number">1</span> 笔采购订单。</span><br><span class="line">最终，积压订单中有 (<span class="number">1000000000</span><span class="number">-3</span>) 笔价格为 <span class="number">7</span> 的销售订单，和 (<span class="number">999999995</span><span class="number">-1</span>) 笔价格为 <span class="number">5</span> 的采购订单。所以积压订单中的订单总数为 <span class="number">1999999991</span> ，等于 <span class="number">999999984</span> % (<span class="number">109</span> + <span class="number">7</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= orders.length &lt;= 105</li><li>orders[i].length == 3</li><li>1 &lt;= pricei, amounti &lt;= 109</li><li>orderTypei 为 0 或 1</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-orders-in-the-backlog</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目很简单，就是容易出错。题目太长了，感觉应该短点。</li><li>设置积压订单中的<code>buy</code>积压的订单，按照购买价格从高到低进行排列。设置积压订单中的<code>sell</code>积压的订单，按照出售价格从低到高排列。每次当前订单如果为<code>buy</code>定时，则从<code>sell</code>的积压队列中找到出售价格小于等于<code>buy</code>的价格，并同时将积压订单数量进行核减掉。每次当前订单如果为<code>sell</code>定单时，则从<code>buy</code>的积压队列中找到购买价格大于等于<code>sell</code>的价格，并同时将积压订单数量进行核减掉。</li><li>时间复杂度$O(nlgn)$,空间复杂度$O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a, pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp2</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a, pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfBacklogOrders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; orders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = orders.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp1&gt; sell;</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp2&gt; buy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : orders)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">2</span>] == <span class="number">0</span>)&#123;<span class="comment">//buy</span></span><br><span class="line">                <span class="keyword">if</span>(sell.empty())&#123;</span><br><span class="line">                    buy.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!sell.empty() &amp;&amp; sell.top().first &lt;= v[<span class="number">0</span>])&#123;</span><br><span class="line">                        pii curr = sell.top();</span><br><span class="line">                        sell.pop();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(curr.second &lt;= v[<span class="number">1</span>])&#123;</span><br><span class="line">                            v[<span class="number">1</span>] -= curr.second;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            curr.second -= v[<span class="number">1</span>];</span><br><span class="line">                            v[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                            sell.push(curr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(v[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        buy.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//sell</span></span><br><span class="line">                <span class="keyword">if</span>(buy.empty())&#123;</span><br><span class="line">                    sell.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!buy.empty() &amp;&amp; buy.top().first &gt;= v[<span class="number">0</span>])&#123;</span><br><span class="line">                        pii curr = buy.top();</span><br><span class="line">                        buy.pop();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(curr.second &lt;= v[<span class="number">1</span>])&#123;</span><br><span class="line">                            v[<span class="number">1</span>] -= curr.second;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            curr.second -= v[<span class="number">1</span>];</span><br><span class="line">                            v[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                            buy.push(curr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(v[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        sell.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!buy.empty())&#123;</span><br><span class="line">            ans = (ans + buy.top().second)%mod;</span><br><span class="line">            buy.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">while</span>(!sell.empty())&#123;</span><br><span class="line">            ans = (ans + sell.top().second)%mod;</span><br><span class="line">            sell.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5696-统计异或值在范围内的数对有多少"><a href="#5696-统计异或值在范围内的数对有多少" class="headerlink" title="5696. 统计异或值在范围内的数对有多少"></a>5696. 统计异或值在范围内的数对有多少</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> （下标 从 <code>0</code> 开始 计数）以及两个整数：<code>low</code> 和 <code>high</code>，请返回 漂亮数对 的数目。</p><p>漂亮数对 是一个形如 <code>(i, j)</code> 的数对，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code>且 <code>low &lt;= (nums[i] XOR nums[j]) &lt;= high</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>], low = <span class="number">2</span>, high = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：所有漂亮数对 (i, j) 列出如下：</span><br><span class="line">    - (<span class="number">0</span>, <span class="number">1</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">1</span>] = <span class="number">5</span> </span><br><span class="line">    - (<span class="number">0</span>, <span class="number">2</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">    - (<span class="number">0</span>, <span class="number">3</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">2</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">3</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    - (<span class="number">2</span>, <span class="number">3</span>): nums[<span class="number">2</span>] XOR nums[<span class="number">3</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>], low = <span class="number">5</span>, high = <span class="number">14</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：所有漂亮数对 (i, j) 列出如下：</span><br><span class="line">​​​​​    - (<span class="number">0</span>, <span class="number">2</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">2</span>] = <span class="number">13</span></span><br><span class="line">    - (<span class="number">0</span>, <span class="number">3</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">3</span>] = <span class="number">11</span></span><br><span class="line">    - (<span class="number">0</span>, <span class="number">4</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">2</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">2</span>] = <span class="number">12</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">3</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">3</span>] = <span class="number">10</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">4</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">    - (<span class="number">2</span>, <span class="number">3</span>): nums[<span class="number">2</span>] XOR nums[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    - (<span class="number">2</span>, <span class="number">4</span>): nums[<span class="number">2</span>] XOR nums[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">2</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">2</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= low &lt;= high &lt;= <span class="number">2</span> * <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-233/problems/count-pairs-with-xor-in-a-range/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt; 异或</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 核心问题记住异或的时候需要用到`trie`的结构，感觉类似的题目确实非常少碰到，所以不会做。与下列两个题目类似，又一次碰到类似的题目了，我还以为需要用到数位`dp`，实际不需要。</span><br><span class="line">+ [LC421](https:<span class="comment">//leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/) 数组中两个数的最大异或值。</span></span><br><span class="line">+ [LC1707](https:<span class="comment">//leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/) 与数组中元素的最大异或值。</span></span><br><span class="line"><span class="number">2.</span> 我们建立`trie`记录下第`i`为`<span class="number">0</span>`或者`<span class="number">1</span>`的数的个数，我们可以深刻的理解题意，如果满足异或的值小于某个数`key`的话，只需要某一位比`key`的值不同，且为`<span class="number">0</span>`即可。</span><br><span class="line"><span class="number">3.</span> 根据容斥定理，我们只需要找到当前小于`target`的数组元素的个数即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line">struct TrieNode&#123;</span><br><span class="line">    TrieNode *next[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">int</span> cnt;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next[<span class="number">0</span>] = NULL;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next[<span class="number">1</span>] = NULL;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> insertTrie(TrieNode * root,<span class="built_in">int</span> val)&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">int</span> x = (val&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;next[x])&#123;</span><br><span class="line">            node-&gt;next[x] = new TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next[x];</span><br><span class="line">        node-&gt;cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> search(TrieNode * root,<span class="built_in">int</span> num,<span class="built_in">int</span> low)&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">int</span> x = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> y = (low&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">1</span>)&#123; <span class="comment">//当前位不同，则我们找到当前位异或结果为`0`的数目统计。</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[x])&#123;</span><br><span class="line">                ans += node-&gt;next[x]-&gt;cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[<span class="number">1</span>-x];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//当前位相同，我们直接按照相同的位进行查找。</span></span><br><span class="line">            node = node-&gt;next[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> countPairs(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> low, <span class="built_in">int</span> high) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        TrieNode * root = new TrieNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            ans += search(root,nums[i],high+<span class="number">1</span>) - search(root,nums[i],low);</span><br><span class="line">            insertTrie(root,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-233&quot;&gt;&lt;a href=&quot;#leetcode-contest-233&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 233&quot;&gt;&lt;/a&gt;leetcode contest 233&lt;/h1&gt;&lt;p&gt;周赛还算三道题的节奏，最后一题太难了，不会做，没有想到会用&lt;code&gt;trie&lt;/code&gt;的解法，确实非常巧妙的解法。&lt;/p&gt;&lt;h2 id=&quot;5709-最大升序子数组和&quot;&gt;&lt;a href=&quot;#5709-最大升序子数组和&quot; class=&quot;headerlink&quot; title=&quot;5709. 最大升序子数组和&quot;&gt;&lt;/a&gt;5709. 最大升序子数组和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个正整数组成的数组 &lt;code&gt;nums&lt;/code&gt; ，返回 nums 中一个 升序 子数组的最大可能元素和。&lt;/p&gt;&lt;p&gt;子数组是数组中的一个连续数字序列。&lt;/p&gt;&lt;p&gt;已知子数组 &lt;code&gt;[numsl, numsl+1, ..., numsr-1, numsr]&lt;/code&gt;，若对所有 &lt;code&gt;i（l &amp;lt;= i &amp;lt; r）&lt;/code&gt;，&lt;code&gt;numsi &amp;lt; numsi+1&lt;/code&gt;都成立，则称这一子数组为 升序 子数组。注意，大小为 &lt;code&gt;1&lt;/code&gt; 的子数组也视作 升序 子数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 48</title>
    <link href="http://yoursite.com/2021/03/20/263/"/>
    <id>http://yoursite.com/2021/03/20/263/</id>
    <published>2021-03-20T14:27:10.130Z</published>
    <updated>2021-03-21T10:07:04.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-48"><a href="#leetcode-contest-48" class="headerlink" title="leetcode contest 48"></a>leetcode contest 48</h1><p><img src="https://i.loli.net/2021/03/21/mPKJugl2FU1aBon.png" alt><br>又是三道题的节奏，很多题目还是想不出来，只能说太菜了。最后一题简直是模板题目，状态压缩dp，一点意思也没有，竟然卡在第三题上。</p><h2 id="5693-字符串中第二大的数字"><a href="#5693-字符串中第二大的数字" class="headerlink" title="5693. 字符串中第二大的数字"></a>5693. 字符串中第二大的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。</p><a id="more"></a><p>混合字符串 由小写英文字母和数字组成。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"dfa12321afd"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：出现在 s 中的数字包括 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] 。第二大的数字是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc1111"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：出现在 s 中的数字只包含 [<span class="number">1</span>] 。没有第二大的数字。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母和（或）数字。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/second-largest-digit-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/second-largest-digit-in-a-string/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力统计<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                cnt.insert(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = cnt.end();</span><br><span class="line">        it--;</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">return</span> *it - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5694-设计一个验证系统"><a href="#5694-设计一个验证系统" class="headerlink" title="5694. 设计一个验证系统"></a>5694. 设计一个验证系统</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code>时刻之后 <code>timeToLive</code>秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code>（可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p><p>请你实现 <code>AuthenticationManager</code>类：</p><ul><li><code>AuthenticationManager(int timeToLive)</code>构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code>参数。</li><li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code>，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li><li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 未过期 的验证码在 <code>currentTime</code>时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li><li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，未过期 的验证码数目。<br>如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生<code>（renew</code>或者 <code>countUnexpiredTokens</code>操作），过期事件 优先于 其他操作。</li></ul><p>示例 1：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"AuthenticationManager"</span>, <span class="string">"renew"</span>, <span class="string">"generate"</span>, <span class="string">"countUnexpiredTokens"</span>, <span class="string">"generate"</span>, <span class="string">"renew"</span>, <span class="string">"renew"</span>, <span class="string">"countUnexpiredTokens"</span>]</span><br><span class="line">[[<span class="number">5</span>], [<span class="string">"aaa"</span>, <span class="number">1</span>], [<span class="string">"aaa"</span>, <span class="number">2</span>], [<span class="number">6</span>], [<span class="string">"bbb"</span>, <span class="number">7</span>], [<span class="string">"aaa"</span>, <span class="number">8</span>], [<span class="string">"bbb"</span>, <span class="number">10</span>], [<span class="number">15</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">1</span>, null, null, null, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">AuthenticationManager authenticationManager = new AuthenticationManager(<span class="number">5</span>); <span class="comment">// 构造 AuthenticationManager ，设置 timeToLive = 5 秒。</span></span><br><span class="line">authenticationManager.renew(<span class="string">"aaa"</span>, <span class="number">1</span>); <span class="comment">// 时刻 1 时，没有验证码的 tokenId 为 "aaa" ，没有验证码被更新。</span></span><br><span class="line">authenticationManager.generate(<span class="string">"aaa"</span>, <span class="number">2</span>); <span class="comment">// 时刻 2 时，生成一个 tokenId 为 "aaa" 的新验证码。</span></span><br><span class="line">authenticationManager.countUnexpiredTokens(<span class="number">6</span>); <span class="comment">// 时刻 6 时，只有 tokenId 为 "aaa" 的验证码未过期，所以返回 1 。</span></span><br><span class="line">authenticationManager.generate(<span class="string">"bbb"</span>, <span class="number">7</span>); <span class="comment">// 时刻 7 时，生成一个 tokenId 为 "bbb" 的新验证码。</span></span><br><span class="line">authenticationManager.renew(<span class="string">"aaa"</span>, <span class="number">8</span>); <span class="comment">// tokenId 为 "aaa" 的验证码在时刻 7 过期，且 8 &gt;= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。</span></span><br><span class="line">authenticationManager.renew(<span class="string">"bbb"</span>, <span class="number">10</span>); <span class="comment">// tokenId 为 "bbb" 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。</span></span><br><span class="line">authenticationManager.countUnexpiredTokens(<span class="number">15</span>); <span class="comment">// tokenId 为 "bbb" 的验证码在时刻 15 过期，tokenId 为 "aaa" 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= timeToLive &lt;= 108</code></li><li><code>1 &lt;= currentTime &lt;= 108</code></li><li><code>1 &lt;= tokenId.length &lt;= 5</code></li><li><code>tokenId</code> 只包含小写英文字母。</li><li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li><li>所有函数调用中，<code>currentTime</code>的值 严格递增 。</li><li>所有函数的调用次数总共不超过 2000 次。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/design-authentication-manager/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/design-authentication-manager/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力统计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的非常不好，给定的数据量又很小，全部用暴力都可以实现。</li><li>每次<code>generate</code>时记录下生成<code>token</code>的时间，<code>renew</code>时检查是否超时，如果超时则删除，<code>countUnexpiredTokens</code>则直接暴力查找统计，感觉就是送分题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManager</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AuthenticationManager(<span class="keyword">int</span> timeToLive) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;live = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="built_in">string</span> tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        token[tokenId] = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renew</span><span class="params">(<span class="built_in">string</span> tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!token.count(tokenId)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>((currentTime - token[tokenId])&gt;= live)&#123;</span><br><span class="line">            token.erase(tokenId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        token[tokenId] = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countUnexpiredTokens</span><span class="params">(<span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = token.begin(); it != token.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentTime - it-&gt;second &lt; live)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; token;</span><br><span class="line">    <span class="keyword">int</span> live;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5712-你能构造出连续值的最大数目"><a href="#5712-你能构造出连续值的最大数目" class="headerlink" title="5712. 你能构造出连续值的最大数目"></a>5712. 你能构造出连续值的最大数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3>给你一个长度为<code>n</code>的整数数组 <code>coins</code> ，它代表你拥有的 n 个硬币。第 <code>i</code>个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为<code>x</code>，那么称，你可以 构造 出<code>x</code> 。</li></ol></blockquote><p>请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">2</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">- <span class="number">2</span>：取 [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">3</span>：取 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">4</span>：取 [<span class="number">4</span>]</span><br><span class="line">- <span class="number">5</span>：取 [<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">6</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">7</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">8</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>coins.length == n</code></li><li><code>1 &lt;= n &lt;= 4 * 104</code></li><li><code>1 &lt;= coins[i] &lt;= 4 * 104</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>假设数组中的部分元素能否构成$[0,x]$中的所有整数，此时我们再加入整数$y$,则此时我们知道肯定可以构成的整数范围为$[y,y+x]$,假设满足$y \le x+1$,则我们可以将$[0,x]$与$[y,y+x]$进行合并跟新为新的连续区间为$[0,y+x]$,此时我们即扩大了连续整数的范围。否则如果$y &gt; x+1$则不会对最终的结果产生任何影响。</li><li>我们首先将数组按照升序进行排列，我们每次选取最小的<code>nums[i]</code>看是否能增加当前的选择范围，如果可以增加，则我们将对数据的范围进行扩展长度为$nums[i]$。</li><li>非常喜欢这类思考性质的数学题目，虽然比较难，但是思考的深度非常不错。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(coins.begin(),coins.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coins[i] &lt;= ans + <span class="number">1</span>)&#123;</span><br><span class="line">                ans += coins[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5712-你能构造出连续值的最大数目-1"><a href="#5712-你能构造出连续值的最大数目-1" class="headerlink" title="5712. 你能构造出连续值的最大数目"></a>5712. 你能构造出连续值的最大数目</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>coins</code> ，它代表你拥有的<code>n</code>个硬币。第 <code>i</code>个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。</p><p>请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">2</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">- <span class="number">2</span>：取 [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">3</span>：取 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">4</span>：取 [<span class="number">4</span>]</span><br><span class="line">- <span class="number">5</span>：取 [<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">6</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">7</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">8</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>coins.length == n</code></li><li><code>1 &lt;= n &lt;= 4 * 104</code></li><li><code>1 &lt;= coins[i] &lt;= 4 * 104</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>标准的模板题，状态压缩<code>dp</code>加上子空间遍历。</li><li>设<code>dp[state]</code>表示当前已经选择的元素的掩码为<code>state</code>时，所能获取到的最大分数。首先我们需要确定的是<code>state</code>中一定包含偶数个元素，我们设然<code>state</code>包含的元素个数为<code>x</code>，我们遍历<code>state</code>的状态子空间<code>prevstate</code>，当且仅当<code>prevstate</code>包含<code>x-2</code>个元素时，此时我们就可以得到<code>dp</code>的递推公式:<script type="math/tex; mode=display">dp[state] = max(dp[state],dp[prevstate] + \frac{x}{2}*dp[prevstate\bigoplus state])</script></li><li>非常典型的状态压缩和子空间遍历。稍微用点技巧的时可以用快速的<code>n&amp;(n-1)</code>的方法来得到数中<code>1</code>的个数。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp[(<span class="number">1</span>&lt;&lt;i)|(<span class="number">1</span>&lt;&lt;j)] = __gcd(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count(i)%<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">0</span>; j = (j<span class="number">-1</span>)&amp;i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count(i) - count(j) == <span class="number">2</span>)&#123;</span><br><span class="line">                    dp[i] = max(dp[i],dp[j] + (count(i)/<span class="number">2</span>)*dp[i^j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>贪心算法：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                arr.push_back(Node(i,j,__gcd(nums[i],nums[j])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](Node &amp; a,Node &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.v &gt; b.v;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[arr[i].x] == <span class="literal">false</span> &amp;&amp; visit[arr[i].y] == <span class="literal">false</span>)&#123;</span><br><span class="line">                res.push_back(arr[i].v);</span><br><span class="line">                visit[arr[i].x] = <span class="literal">true</span>;</span><br><span class="line">                visit[arr[i].y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); ++i)&#123;</span><br><span class="line">            ans += (i+<span class="number">1</span>)*res[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-48&quot;&gt;&lt;a href=&quot;#leetcode-contest-48&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 48&quot;&gt;&lt;/a&gt;leetcode contest 48&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/21/mPKJugl2FU1aBon.png&quot; alt&gt;&lt;br&gt;又是三道题的节奏，很多题目还是想不出来，只能说太菜了。最后一题简直是模板题目，状态压缩dp，一点意思也没有，竟然卡在第三题上。&lt;/p&gt;&lt;h2 id=&quot;5693-字符串中第二大的数字&quot;&gt;&lt;a href=&quot;#5693-字符串中第二大的数字&quot; class=&quot;headerlink&quot; title=&quot;5693. 字符串中第二大的数字&quot;&gt;&lt;/a&gt;5693. 字符串中第二大的数字&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT】 2021 MIT6.824 Lab1</title>
    <link href="http://yoursite.com/2021/03/16/262/"/>
    <id>http://yoursite.com/2021/03/16/262/</id>
    <published>2021-03-16T01:51:21.636Z</published>
    <updated>2021-03-16T03:39:10.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MIT6-824-2021-lab1"><a href="#MIT6-824-2021-lab1" class="headerlink" title="MIT6.824 2021 lab1"></a>MIT6.824 2021 lab1</h1><p>终于在跌跌撞撞中完成了<code>MIT lab1 map-reduce</code>的<code>lab</code>，仔细对比了一下，<code>2021</code>年的<code>lab</code>要比之前的<code>lab</code>要复杂一些，以前的<code>map-reduce lab</code>基本上只是<code>Coordinator</code>对任务进行主动调度，<code>2021</code>的<code>lab</code>会涉及到<code>Coordinator</code>被动接受<code>worker</code>的任务请求，然后进行被动的调度，同时加入了防止任务意外中止的校验，使得系统更加完善和健壮。所有的测试结果如下所示：<br><img src="https://i.loli.net/2021/03/16/2TsRwIzVidc8apv.png" alt><br>所有的代码都放在github上.</p><a id="more"></a><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>按照题目要求实现<code>map-reduce</code>系统，按照<code>lab</code>的要求实现调度器<code>Coordinator</code>和<code>worker</code>的基本功能，<code>lab</code>要求由<code>woker</code>主动向调度器发起任务请求，<code>Coordinator</code>按照当前的任务分配进度为每个<code>worker</code>分配<code>map</code>或者<code>reduce</code>任务，<code>reduce</code>任务必须在所有的<code>map</code>任务都完成后才能开始启动。其中的核心的难点并不是在于<code>map</code>和<code>reduce</code>的实现，难点在于如何做好<code>worker</code>和<code>Coordinator</code>之间的任务分配和调度。</p><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><ul><li><code>Coordinator</code>作为一个<code>rpc server</code>,处理所有从<code>worker</code>发送过来的<code>rpc</code>请求，当然在此也顺便学习了一下<code>go</code>的<code>rpc</code>框架，其实还是挺有意思的，非常方便的消息处理框架，首先我们需要设置好双方进行消息交互的<code>rpc</code>消息格式定义，目前定义如下：<br><code>option</code>请求定义:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OpType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">TaskReq OpType = <span class="literal">iota</span> <span class="comment">//请求分配任务</span></span><br><span class="line">TaskMap               <span class="comment">//分配一个map类型的任务</span></span><br><span class="line">TaskReduce            <span class="comment">//分配一个reduce类型的任务</span></span><br><span class="line">TaskMapDone           <span class="comment">//完成一个map任务</span></span><br><span class="line">TaskReduceDone        <span class="comment">//完成一个reduce任务</span></span><br><span class="line">TaskDone              <span class="comment">//所有任务均已完成</span></span><br><span class="line">TaskWait              <span class="comment">//等待当前任务完成</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><code>rpc</code>请求消息定义:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReqArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">ReqId <span class="keyword">int64</span>    <span class="comment">// timestamp，作为本次请求分配的唯一标识。</span></span><br><span class="line">ReqOp OpType   <span class="comment">// 消息类型</span></span><br><span class="line">ReqTaskId <span class="keyword">int</span>  <span class="comment">// 任务的ID编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>rpc</code>回应消息定义：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplyArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">RepId <span class="keyword">int64</span>   <span class="comment">// timestamp，作为某次请求的唯一标识。</span></span><br><span class="line">RepOp OpType  <span class="comment">//消息类型</span></span><br><span class="line">RepTaskId <span class="keyword">int</span> <span class="comment">//分配的任务ID</span></span><br><span class="line">RepnMap <span class="keyword">int</span>   <span class="comment">//map任务的总数</span></span><br><span class="line">RepnReduce <span class="keyword">int</span> <span class="comment">//reduce任务的总数</span></span><br><span class="line">RepContent <span class="keyword">string</span> <span class="comment">//map任务的文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>Coordinator</code>定义：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">mapTasks <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//待分配的map任务列表</span></span><br><span class="line">reduceTasks <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//待分配的reduce任务列表</span></span><br><span class="line">nReduce <span class="keyword">int</span> <span class="comment">//reduce任务的数量</span></span><br><span class="line">nMap <span class="keyword">int</span>    <span class="comment">//map的任务数量</span></span><br><span class="line">mapRuning []<span class="keyword">int64</span> <span class="comment">//map任务状态</span></span><br><span class="line">reduceRuning []<span class="keyword">int64</span> <span class="comment">//reduce任务状态</span></span><br><span class="line">tasks []<span class="keyword">string</span> <span class="comment">//待处理的文件名称</span></span><br><span class="line">mapCnt <span class="keyword">int</span>   <span class="comment">//当前未完成的map数量</span></span><br><span class="line">reduceCnt <span class="keyword">int</span> <span class="comment">//当前未完成的reduce任务数量</span></span><br><span class="line">taskDone <span class="keyword">bool</span>  <span class="comment">//任务是否全部完成</span></span><br><span class="line">lock *sync.Cond  <span class="comment">//互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Coordinator</code>接受到<code>worker</code>的请求后，根据请求的消息类型进行回应，如果当前的任务已经完成，则直接回应；如果请求的消息为任务请求，则查看是否存在待处理的<code>map</code>任务，如果存在则分发一个<code>map</code>类型的任务，如果<code>map</code>任务都已经下发但是还未全部完成，则通知<code>worker</code>进行等待；如果所有的<code>map</code>任务都已经下发且已经完成，则分配一个<code>reduce</code>类型的任务交给<code>worker</code>进行处理；如果接受的消息为<code>worker</code>通知任务完成，我们会校验该任务的标识，如果校验通过，我们将相应的任务状态设置为已经完成。</li><li>最关键的一点处理，每当<code>Coordinator</code>分配一个任务后，就会启动一个定时器任务，该定时器任务会在<code>10s</code>后检查该任务的状态是否已经完成，如果未完成，则将该任务再次进入到待分配列表中。</li><li>关键的临界区处理，这点我处理的不太好，为了图简单，直接在所有的存在竞争的数据访问处都用的互斥锁锁，其实也可以试试用<code>go</code>的<code>atmoic</code>来定义某些关键数据类型，后面如果需要改进的话重点放在临界区访问的控制上。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">c.lock.L.Lock()</span><br><span class="line">allDone := c.taskDone </span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">if</span> allDone &#123; <span class="comment">//检验当前所有任务的状态，如果已经全部完成则直接返回</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskDone</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> args.ReqOp&#123;</span><br><span class="line"><span class="keyword">case</span> TaskReq: <span class="comment">//任务请求</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.mapTasks) &gt; <span class="number">0</span> &#123; <span class="comment">//如果存在待分配的map任务，则分配一个任务给当前的worker</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskMap</span><br><span class="line">reply.RepTaskId = &lt;-c.mapTasks</span><br><span class="line">reply.RepnMap = c.nMap</span><br><span class="line">reply.RepContent = c.tasks[reply.RepTaskId]</span><br><span class="line">reply.RepnReduce = c.nReduce</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line">c.mapRuning[reply.RepTaskId] = args.ReqId <span class="comment">//记录当前任务请求的标识</span></span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="keyword">int</span>)</span></span>&#123; <span class="comment">// 10s后检查该任务是否完成，如果未完成则将该任务再次进入待分配列表</span></span><br><span class="line">time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.mapRuning[taskId] != <span class="number">1</span>&#123;</span><br><span class="line">c.mapTasks&lt;-taskId</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c.mapCnt--</span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line">&#125;(reply.RepTaskId)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(c.mapTasks) == <span class="number">0</span> &#123;</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line">mapCurr := c.mapCnt</span><br><span class="line">reduceCurr := c.reduceCnt</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  mapCurr &gt; <span class="number">0</span> &#123; <span class="comment">// map任务全部分配，但是并未全部完成，此时需要通知worker进行等待</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskWait</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.reduceTasks) &gt; <span class="number">0</span> &#123;<span class="comment">// 如果存在待分配的reduce任务，则分配一个任务给当前的worker</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskReduce</span><br><span class="line">reply.RepTaskId = &lt;-c.reduceTasks</span><br><span class="line">reply.RepnMap = c.nMap</span><br><span class="line">reply.RepnReduce = c.nReduce</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line">c.reduceRuning[reply.RepTaskId] = args.ReqId</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">time.Sleep(<span class="number">10</span>*time.Second) <span class="comment">//  10s后检查该任务是否完成，如果未完成则将该任务再次进入待分配列表</span></span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.reduceRuning[taskId] != <span class="number">1</span>&#123;</span><br><span class="line">c.reduceTasks&lt;-taskId</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c.reduceCnt--</span><br><span class="line"><span class="keyword">if</span> c.reduceCnt == <span class="number">0</span>&#123;</span><br><span class="line">c.taskDone = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line">&#125;(reply.RepTaskId)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> reduceCurr &gt; <span class="number">0</span> &#123; <span class="comment">// reduce任务全部分配，但是并未全部完成，此时需要通知worker进行等待</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskWait</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> TaskMapDone: <span class="comment">// map任务完成，将该任务的状态置为完成</span></span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.mapRuning[args.ReqTaskId] == args.ReqId &#123;</span><br><span class="line">c.mapRuning[args.ReqTaskId] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">case</span> TaskReduceDone: <span class="comment">// reduce任务完成，将该任务的状态置为完成</span></span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.reduceRuning[args.ReqTaskId] == args.ReqId&#123;</span><br><span class="line">c.reduceRuning[args.ReqTaskId] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><code>worker</code>的处理就简单许多，主要是<code>map</code>处理和<code>reduce</code>处理，这个基本上可以参考<code>lab</code>给定的<code>mrsequential</code>代码即可，此时我们主要对<code>map</code>进行处理产生中间文件交给<code>reduce</code>处理即可。</li><li><code>map</code>:从文件种读取所有的<code>key-value</code>数据，然后根据<code>hash</code>值写入不同的文件即可，当然这里的优化完全可以按照hash值进行排序，这样可以一次性将hash值相同的元素写入同一个文件，避免每次写入时写入不同的文件，从而可以加快处理速度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// process a map task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startMapTask</span><span class="params">(timestamp <span class="keyword">int64</span>,reply * ReplyArgs,mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">ifile, err := os.Open(reply.RepContent)</span><br><span class="line"><span class="keyword">defer</span> ifile.Close()</span><br><span class="line"><span class="comment">// read content from the file</span></span><br><span class="line">content, err := ioutil.ReadAll(ifile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"can not read %v"</span>, reply.RepContent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intermediate := mapf(reply.RepContent, <span class="keyword">string</span>(content)) <span class="comment">// map任务处理</span></span><br><span class="line">ofile := <span class="built_in">make</span>([]*os.File,reply.RepnReduce)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.RepnReduce; i++ &#123;</span><br><span class="line">ofname := <span class="string">"mr-"</span> + strconv.Itoa(reply.RepTaskId) + <span class="string">"-"</span> + strconv.Itoa(i)</span><br><span class="line">ofile[i], _ = os.Create(ofname)</span><br><span class="line"><span class="keyword">defer</span> ofile[i].Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,kv := <span class="keyword">range</span> intermediate&#123; <span class="comment">// 根据key的hash值写入相应的中间文件</span></span><br><span class="line">reduceId := ihash(kv.Key)%reply.RepnReduce</span><br><span class="line">enc := json.NewEncoder(ofile[reduceId])</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span>(err != <span class="literal">nil</span>)&#123;</span><br><span class="line">log.Fatalf(<span class="string">"can not read %v"</span>, ofile[reduceId])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//notice the server task finished</span></span><br><span class="line">args := ReqArgs&#123;&#125; <span class="comment">// 向Coordinator回应本次任务处理完成</span></span><br><span class="line">args.ReqId = timestamp</span><br><span class="line">args.ReqOp = TaskMapDone</span><br><span class="line">args.ReqTaskId = reply.RepTaskId</span><br><span class="line">nextreply := ReplyArgs&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> call(<span class="string">"Coordinator.Request"</span>, &amp;args, &amp;nextreply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>reduce</code>:从文件种读取所有的<code>key hash</code>值相同的数据，然后根据<code>key</code>进行排序，将相同的<code>key</code>的元素进行<code>reduce</code>处理，处理完成后结果写入到目标文件种，全部完成后通知<code>Coordinator</code>本次任务完成。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/ process a reduce task</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startReduceTask</span><span class="params">(timestamp <span class="keyword">int64</span>,reply * ReplyArgs,reducef <span class="keyword">func</span>(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// we check every intermediate map task file</span></span><br><span class="line">kva := []KeyValue&#123;&#125; </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.RepnMap; i++ &#123; <span class="comment">//读取所有的中间文件</span></span><br><span class="line">ifilename := <span class="string">"mr-"</span> + strconv.Itoa(i) + <span class="string">"-"</span> + strconv.Itoa(reply.RepTaskId)</span><br><span class="line">ifile, err := os.Open(ifilename)</span><br><span class="line"><span class="keyword">defer</span> ifile.Close()</span><br><span class="line"><span class="comment">// open file error</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">"Open File Error."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read all intermediate data from the file</span></span><br><span class="line">dec := json.NewDecoder(ifile)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; </span><br><span class="line">kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//store intermediate data to the out file</span></span><br><span class="line">sort.Sort(ByKey(kva)) <span class="comment">//排序</span></span><br><span class="line"><span class="comment">// write to the target file</span></span><br><span class="line">ofilename := <span class="string">"mr-out-"</span> + strconv.Itoa(reply.RepTaskId)</span><br><span class="line"><span class="comment">//fmt.Println("out file %v",ofilename)</span></span><br><span class="line">ofile,err := os.Create(ofilename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">"Creat Open File Error."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ofile.Close()</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(kva) &#123; <span class="comment">//按照相同的key进行分配，并进行reduce处理</span></span><br><span class="line">j := i + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="built_in">len</span>(kva) &amp;&amp; kva[j].Key == kva[i].Key &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">values := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">values = <span class="built_in">append</span>(values, kva[k].Value)</span><br><span class="line">&#125;</span><br><span class="line">output := reducef(kva[i].Key, values)</span><br><span class="line"><span class="comment">// this is the correct format for each line of Reduce output.</span></span><br><span class="line">fmt.Fprintf(ofile, <span class="string">"%v %v\n"</span>, kva[i].Key, output)</span><br><span class="line">i = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//notice the server task finished</span></span><br><span class="line">args := ReqArgs&#123;&#125; <span class="comment">// 向Coordinator回应本次任务处理完成</span></span><br><span class="line">args.ReqId = timestamp</span><br><span class="line">args.ReqOp = TaskReduceDone</span><br><span class="line">args.ReqTaskId = reply.RepTaskId</span><br><span class="line">nextreply := ReplyArgs&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> call(<span class="string">"Coordinator.Request"</span>, &amp;args, &amp;nextreply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h3>根据<code>paper</code>中的描述如下：<br><img src="https://i.loli.net/2021/03/16/GQntKroZga4NE6j.png" alt></li></ul><ol><li>假设有 <code>M</code> 个 <code>map</code>   操作， <code>n</code> 个 <code>reduce</code>  操作， 那么<code>master</code>一共要安排<code>M +N</code> 个<code>worker</code>任务 。</li><li>每个 <code>map</code> 操作将生成  <code>n</code>个文件，<code>map</code>过程一共产生  <code>m*n</code> 个文件.</li><li><code>map</code> 操作完成后的数据是以文件的形式存储的.<br>实际处理过程：首先将 文档分成  <code>m</code>份，每一份调用一个 <code>map</code> 函数操作并生成 <code>n</code>个文件  。所有 <code>map</code>操作完成后进行 <code>reduce</code>操作，对于 每个 <code>reduce</code> 操作，从上一步生成 的<code>m*n</code> 个文件中选取对应的<code>m</code>个文件 进行<code>reduce</code> 操作，完成后将结果写入$n_{i}$ 中。 所有 <code>reduce</code> 操作完成后将 <code>n</code>个临时文件合并成最终的 <code>output</code> 文件<br><img src="https://i.loli.net/2021/03/16/W2GvcPOLAkXbtMH.png" alt><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MIT6-824-2021-lab1&quot;&gt;&lt;a href=&quot;#MIT6-824-2021-lab1&quot; class=&quot;headerlink&quot; title=&quot;MIT6.824 2021 lab1&quot;&gt;&lt;/a&gt;MIT6.824 2021 lab1&lt;/h1&gt;&lt;p&gt;终于在跌跌撞撞中完成了&lt;code&gt;MIT lab1 map-reduce&lt;/code&gt;的&lt;code&gt;lab&lt;/code&gt;，仔细对比了一下，&lt;code&gt;2021&lt;/code&gt;年的&lt;code&gt;lab&lt;/code&gt;要比之前的&lt;code&gt;lab&lt;/code&gt;要复杂一些，以前的&lt;code&gt;map-reduce lab&lt;/code&gt;基本上只是&lt;code&gt;Coordinator&lt;/code&gt;对任务进行主动调度，&lt;code&gt;2021&lt;/code&gt;的&lt;code&gt;lab&lt;/code&gt;会涉及到&lt;code&gt;Coordinator&lt;/code&gt;被动接受&lt;code&gt;worker&lt;/code&gt;的任务请求，然后进行被动的调度，同时加入了防止任务意外中止的校验，使得系统更加完善和健壮。所有的测试结果如下所示：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/03/16/2TsRwIzVidc8apv.png&quot; alt&gt;&lt;br&gt;所有的代码都放在github上.&lt;/p&gt;
    
    </summary>
    
    
      <category term="公开课" scheme="http://yoursite.com/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
      <category term="MIT" scheme="http://yoursite.com/tags/MIT/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 232</title>
    <link href="http://yoursite.com/2021/03/14/261/"/>
    <id>http://yoursite.com/2021/03/14/261/</id>
    <published>2021-03-14T08:17:04.714Z</published>
    <updated>2021-03-14T09:18:34.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-232"><a href="#leetcode-contest-232" class="headerlink" title="leetcode contest 232"></a>leetcode contest 232</h1><p>本周的周赛题目还是质量非常高的，最后两道题目的解法还是非常有意思的题目，虽然解法很简单，但是非常值得深入思考的题目，特别是第三题，给人印象深刻。</p><h2 id="5701-仅执行一次字符串交换能否使两个字符串相等"><a href="#5701-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="5701. 仅执行一次字符串交换能否使两个字符串相等"></a>5701. 仅执行一次字符串交换能否使两个字符串相等</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。</p><a id="more"></a><p>如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"bank"</span>, <span class="built_in">s2</span> = <span class="string">"kanb"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：例如，交换 <span class="built_in">s2</span> 中的第一个和最后一个字符可以得到 <span class="string">"bank"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"attack"</span>, <span class="attr">s2</span> = <span class="string">"defend"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：一次字符串交换无法使两个字符串相等</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"kelb"</span>, <span class="attr">s2</span> = <span class="string">"kelb"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：两个字符串已经相等，所以不需要进行字符串交换</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"abcd"</span>, <span class="attr">s2</span> = <span class="string">"dcba"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= s1.length, s2.length &lt;= 100</li><li>s1.length == s2.length</li><li>s1 和 s2 仅由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>如果仅要求交换一次就可完成两个字符串的相等排列，我们即判断字符串是否只有两个字符不同，然后判断是否相等。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areAlmostEqual</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[i])&#123;</span><br><span class="line">                diff.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(diff.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(diff.size() != <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1[diff[<span class="number">0</span>]] == s2[diff[<span class="number">1</span>]] &amp;&amp; s1[diff[<span class="number">1</span>]] == s2[diff[<span class="number">0</span>]])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5702-找出星型图的中心节点"><a href="#5702-找出星型图的中心节点" class="headerlink" title="5702. 找出星型图的中心节点"></a>5702. 找出星型图的中心节点</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有一个无向的 星型 图，由 <code>n</code>个编号从 <code>1</code>到 <code>n</code>的节点组成。星型图有一个 中心 节点，并且恰有 <code>n - 1</code>条边将中心节点与其他每个节点连接起来。</p><p>给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示在节点 <code>ui</code> 和 <code>vi</code> 之间存在一条边。请你找出并返回 <code>edges</code> 所表示星型图的中心节点。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如上图所示，节点 <span class="number">2</span> 与其他每个节点都相连，所以节点 <span class="number">2</span> 是中心节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>3 &lt;= n &lt;= 105</li><li>edges.length == n - 1</li><li>edges[i].length == 2</li><li>1 &lt;= ui, vi &lt;= n</li><li>ui != vi</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-center-of-star-graph" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-center-of-star-graph</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 图论</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>此题非常简单，我们只需要判断是否存在度为<code>n-1</code>的顶点即可，非常简单的实现即可，简单的有点离谱。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCenter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            degree[v[<span class="number">0</span>]<span class="number">-1</span>]++;</span><br><span class="line">            degree[v[<span class="number">1</span>]<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i] == n<span class="number">-1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5703-最大平均通过率"><a href="#5703-最大平均通过率" class="headerlink" title="5703. 最大平均通过率"></a>5703. 最大平均通过率</h2><p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 <code>classes</code> ，其中 <code>classes[i] = [passi, totali]</code> ，表示你提前知道了第 <code>i</code> 个班级总共有 <code>totali</code>个学生，其中只有 <code>passi</code>个学生可以通过考试。</p><p>给你一个整数 <code>extraStudents</code> ，表示额外有 <code>extraStudents</code>个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 <code>extraStudents</code>个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。</p><p>一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。</p><p>请你返回在安排这 <code>extraStudents</code>个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 <code>10-5</code>以内的结果都会视为正确结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：classes = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>]], extraStudents = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0.78333</span></span><br><span class="line">解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (<span class="number">3</span>/<span class="number">4</span> + <span class="number">3</span>/<span class="number">5</span> + <span class="number">2</span>/<span class="number">2</span>) / <span class="number">3</span> = <span class="number">0.78333</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：classes = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">9</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">10</span>]], extraStudents = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0.53485</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= classes.length &lt;= 105</code></li><li><code>classes[i].length == 2</code></li><li><code>1 &lt;= passi &lt;= totali &lt;= 105</code></li><li><code>1 &lt;= extraStudents &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-average-pass-ratio</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始这个题目，自己想的太复杂了，后来相明白了，就是非常简单的贪心算法。</li><li>我们设总通过班级通过率之和为$tot$,如果我们想增加最大平均通过率，本质就是如何使得总的班级通过率之和最大。此时我们就需要思考如何分配增加人数，我们根据贪心策略则优先将通过的学生分配给增加的通过率最大的班级即可，这样即保证最终得到的通过率之和最大。</li><li>我们可以通过数学计算得出每增加一个学生，该班级的通过率增加的多少，我们设该班级原有的总人数为$n$,通过考试的人数为$m$,如果增加$1$人后，则增加的通过率为：<script type="math/tex; mode=display">\frac{m+1}{n+1} - \frac{m}{n}</script>我们按照贪心策略，每次为增加的通过率最大的班级分配一个学生即可,我们用优先级队列，每次弹出最优策略的班级，然后给其增加$1$个学生，然后再将其放入队列。时间复杂度为$O(mlgn)$,其中$m$为增加的学生人数，$n$为班级的数目。空间复杂度为$O(n)$.</li><li>我们同时也可以得到策略可以知道，不断给某个班级增加人数，那么它增加的通过率实际上是递减的。<script type="math/tex; mode=display">\frac{m+1}{n+1} - \frac{m}{n} > \frac{m+2}{n+2} - \frac{m+1}{n+1}</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">double</span> p;</span><br><span class="line">    Node(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">double</span> p)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Node &amp; a,Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.p &lt; b.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = classes.size();</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">auto</span> diff = [&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>(x+<span class="number">1</span>)/(y+<span class="number">1</span>) - <span class="keyword">double</span>(x)/y;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : classes)&#123;</span><br><span class="line">            pq.push(Node(v[<span class="number">0</span>],v[<span class="number">1</span>],diff(v[<span class="number">0</span>],v[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; extraStudents; ++i)&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            curr.m++;</span><br><span class="line">            curr.n++;</span><br><span class="line">            curr.p = diff(curr.m,curr.n);</span><br><span class="line">            pq.push(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> tot = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            tot += <span class="keyword">double</span>(curr.m)/curr.n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tot/n;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;tuple&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> diff = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(x + <span class="number">1</span>) / (y + <span class="number">1</span>) - (<span class="keyword">double</span>)x / y;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: classes) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[<span class="number">0</span>], y = c[<span class="number">1</span>];</span><br><span class="line">            ans += (<span class="keyword">double</span>)x / y;</span><br><span class="line">            q.emplace(diff(x, y), x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> _ = <span class="number">0</span>; _ &lt; extraStudents; ++_) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [d, x, y] = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans += d;</span><br><span class="line">            q.emplace(diff(x + <span class="number">1</span>, y + <span class="number">1</span>), x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / classes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5704-好子数组的最大分数"><a href="#5704-好子数组的最大分数" class="headerlink" title="5704. 好子数组的最大分数"></a>5704. 好子数组的最大分数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> （下标从 0 开始）和一个整数 <code>k</code>。<br>一个子数组 <code>(i, j)</code> 的 分数 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code>。一个 好 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。<br>请你返回 好 子数组的最大可能 分数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：最优子数组的左右端点下标是 (<span class="number">1</span>, <span class="number">5</span>) ，分数为 min(<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>) * (<span class="number">5</span><span class="number">-1</span>+<span class="number">1</span>) = <span class="number">3</span> * <span class="number">5</span> = <span class="number">15</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：最优子数组的左右端点下标是 (<span class="number">0</span>, <span class="number">4</span>) ，分数为 min(<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>) * (<span class="number">4</span><span class="number">-0</span>+<span class="number">1</span>) = <span class="number">4</span> * <span class="number">5</span> = <span class="number">20</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 104</code></li><li><code>0 &lt;= k &lt; nums.length</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>双指针或者二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目还是非常不错的，但是总体来说本题比起之前的题目都偏简单。</li><li>我们可以求出有的以索引$k$为结尾的连续子字符串的最小数的前缀$left$，我们同时也可以求出所有以索引$k$为结尾的连续子字符串的最小数的后缀$right$。我们设$left[i]$表示子数组$[i,k]$的最小值，$right[j]$表示子数组$[k,j]$的最小值,我们可以很明显的看出$left$数组为递减，而$right$数组为递减.</li><li>我们可以固定目标子数组的起始索引为$i$,子数组的结束索引为$k$,满足$0 \le i \le k$，此时很容易求出数组索引$[i,k]$之间的最小元素为$left[i]$,而此时我们则去查找满足以$k$为起始索引的连续子数组，且子数组的最小值大于等于$left[i]$的最大长度,我们依次遍历用双指针所有可能的$i$即可;</li><li>此时我们可以固定目标子数组起始索引为$k$,结束索引为$j$,满足$k \le j \le n-1$，此时很容易求出数组索引$[k,j]$之间的最小元素为$right[j]$,而此时我们则去查找满足以$k$为结尾索引的连续子数组，且子数组的最小值大于等于$right[j]$的最大长度,我们依次遍历用双指针所有可能的$j$即可;</li><li>时间复杂度为$O(n)$,空间复杂度为$O(n)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = nums[k];</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        curr = nums[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            curr = min(curr,nums[i]);</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(arr.begin(),arr.end());</span><br><span class="line">        curr = nums[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k+<span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr = min(curr,nums[i]);</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &gt; arr[r]) r--;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">                ans = max(ans,arr[l]*(r-l+<span class="number">1</span>));</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt; arr[r]) l++;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">                ans = max(ans,arr[r]*(r-l+<span class="number">1</span>));</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-232&quot;&gt;&lt;a href=&quot;#leetcode-contest-232&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 232&quot;&gt;&lt;/a&gt;leetcode contest 232&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，最后两道题目的解法还是非常有意思的题目，虽然解法很简单，但是非常值得深入思考的题目，特别是第三题，给人印象深刻。&lt;/p&gt;&lt;h2 id=&quot;5701-仅执行一次字符串交换能否使两个字符串相等&quot;&gt;&lt;a href=&quot;#5701-仅执行一次字符串交换能否使两个字符串相等&quot; class=&quot;headerlink&quot; title=&quot;5701. 仅执行一次字符串交换能否使两个字符串相等&quot;&gt;&lt;/a&gt;5701. 仅执行一次字符串交换能否使两个字符串相等&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你长度相等的两个字符串 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 231</title>
    <link href="http://yoursite.com/2021/03/07/260/"/>
    <id>http://yoursite.com/2021/03/07/260/</id>
    <published>2021-03-07T13:17:33.864Z</published>
    <updated>2021-03-08T03:19:29.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-231"><a href="#leetcode-contest-231" class="headerlink" title="leetcode contest 231"></a>leetcode contest 231</h1><p>本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。周赛的题目质量就是非常高，非常喜欢这种有思考的题目。</p><h2 id="5697-检查二进制字符串字段"><a href="#5697-检查二进制字符串字段" class="headerlink" title="5697. 检查二进制字符串字段"></a>5697. 检查二进制字符串字段</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 <code>s</code> ，该字符串 不含前导零 。</p><a id="more"></a><p>如果 s 最多包含 一个由连续的 <code>&#39;1&#39;</code> 组成的字段 ，返回 <code>true​​​</code> 。否则，返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1001"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：字符串中的 <span class="number">1</span> 没有形成一个连续字段。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"110"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]​​​​</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li><li><code>s[0]</code> 为 <code>&#39;1&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力搜索即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOnesSegment</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'1'</span>) i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'0'</span>) i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5698-构成特定和需要添加的最少元素"><a href="#5698-构成特定和需要添加的最少元素" class="headerlink" title="5698. 构成特定和需要添加的最少元素"></a>5698. 构成特定和需要添加的最少元素</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，和两个整数 <code>limit</code> 与<code>goal</code>。数组 <code>nums</code> 有一条重要属性：<code>abs(nums[i]) &lt;= limit</code> 。</p><p>返回使数组元素总和等于 <code>goal</code> 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 <code>abs(nums[i]) &lt;= limit</code> 这一属性。</p><p>注意，如果 <code>x &gt;= 0</code> ，那么 <code>abs(x)</code> 等于 <code>x</code> ；否则，等于 <code>-x</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>], limit = <span class="number">3</span>, goal = <span class="number">-4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：可以将 <span class="number">-2</span> 和 <span class="number">-3</span> 添加到数组中，数组的元素总和变为 <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> - <span class="number">2</span> - <span class="number">3</span> = <span class="number">-4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-10</span>,<span class="number">9</span>,<span class="number">1</span>], limit = <span class="number">100</span>, goal = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= limit &lt;= 106</code></li><li><code>-limit &lt;= nums[i] &lt;= limit</code></li><li><code>-109 &lt;= goal &lt;= 109</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质为贪心算法，首先我们求出目标数组的和$sum$与$goal$之间的差距，题目中要求增加绝对值不大于等于<code>limit</code>的元素，我们则利用贪心法，每次增加绝对值最大的元素即可，这样即可使得增加的元素最少。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) sum += v;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">abs</span>(goal - sum) + limit - <span class="number">1</span>)/limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5699-从第一个节点出发到最后一个节点的受限路径数"><a href="#5699-从第一个节点出发到最后一个节点的受限路径数" class="headerlink" title="5699. 从第一个节点出发到最后一个节点的受限路径数"></a>5699. 从第一个节点出发到最后一个节点的受限路径数</h2><p>现有一个加权无向连通图。给你一个正整数 <code>n</code>，表示图中有 <code>n</code> 个节点，并按从 <code>1</code> 到 <code>n</code> 给节点编号；另给你一个数组 <code>edges</code> ，其中每个 <code>edges[i] = [ui, vi, weighti]</code> 表示存在一条位于节点 <code>ui</code>和 <code>vi</code> 之间的边，这条边的权重为 <code>weighti</code> 。</p><p>从节点 <code>start</code> 出发到节点 end 的路径是一个形如 <code>[z0, z1, z2, ..., zk]</code> 的节点序列，满足<code>z0 = start 、zk = end</code> 且在所有符合<code>0 &lt;= i &lt;= k-1</code> 的节点 <code>zi</code> 和 <code>zi+1</code>之间存在一条边。</p><p>路径的距离定义为这条路径上所有边的权重总和。用 <code>distanceToLastNode(x)</code>表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 <code>distanceToLastNode(zi) &gt; distanceToLastNode(zi+1)</code> 的一条路径，其中 <code>0 &lt;= i &lt;= k-1</code>。</p><p>返回从节点 1 出发到节点 <code>n</code> 的 受限路径数 。由于数字可能很大，请返回对 <code>109 + 7</code> 取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">5</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">3</span> --&gt; <span class="number">5</span></span><br><span class="line"><span class="number">3</span>) <span class="number">1</span> --&gt; <span class="number">3</span> --&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：<span class="number">1</span> --&gt; <span class="number">3</span> --&gt; <span class="number">7</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>n - 1 &lt;= edges.length &lt;= 4 * 104</code></li><li><code>edges[i].length == 3</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li><code>1 &lt;= weighti &lt;= 105</code></li><li>任意两个节点之间至多存在一条边</li><li>任意两个节点之间至少存在一条路径</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 迪杰斯特拉算法 + dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们需要求出所有点到节点<code>end</code>的最小距离，这个解法很多，经典的<code>dijistra</code>算法即可解决。</li><li>我们则需要求出所有的受限路径，按照题目的要求，首先路径中满足<code>distanceToLastNode(zi) &gt; distanceToLastNode(zi+1)</code>，则此时我们很容易联想到将所有的路径按照<code>distanceToLastNode</code>的大小进行排序，此时我们即可利用<code>dp</code>的特性，因为前面的数一定比后面的数小。此时我们可以设$dp[n] = 1$,按照所有排序的顺序依次对该顶点的邻接节点进行依次遍历。</li><li>时间复杂度为$O(nlgn + n + 2n)$，空间复杂度为$O(n)$.</li><li>另一种解法则为<code>dfs</code>我们也可以很快求出，但是还是感觉太复杂，只贴代码不讲原理了。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>dp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRestrictedPaths</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,INT_MAX);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">1</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">0</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        qu.push(make_pair(n<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">        dist[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.first])&#123;</span><br><span class="line">                <span class="keyword">int</span> x = v.first;</span><br><span class="line">                <span class="keyword">int</span> d = v.second;</span><br><span class="line">                <span class="keyword">if</span>(curr.second + d &lt; dist[x])&#123;</span><br><span class="line">                    dist[x] = curr.second + d;</span><br><span class="line">                    qu.push(make_pair(x,dist[x]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) arr[i] = i;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> dist[a] &lt; dist[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        dp[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[arr[i]])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[v.first] &gt; <span class="number">0</span> &amp;&amp; dist[arr[i]] &gt; dist[v.first])&#123;</span><br><span class="line">                    dp[arr[i]] = (dp[arr[i]] + dp[v.first])%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>dfs<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; dist,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; graph,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp; count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == dist.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count[curr] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v.first;</span><br><span class="line">            <span class="keyword">if</span>(dist[curr] &lt;= dist[x] || count[x] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(count[x] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                count[curr] = (count[x] + count[curr])%MOD;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count[x] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(x,dist,graph,count);</span><br><span class="line">                <span class="keyword">if</span>(count[x] &gt; <span class="number">0</span>) count[curr] = (count[curr] + count[x])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRestrictedPaths</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,INT_MAX);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">1</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">0</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        qu.push(make_pair(n<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">        dist[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.first])&#123;</span><br><span class="line">                <span class="keyword">int</span> x = v.first;</span><br><span class="line">                <span class="keyword">int</span> d = v.second;</span><br><span class="line">                <span class="keyword">if</span>(curr.second + d &lt; dist[x])&#123;</span><br><span class="line">                    dist[x] = curr.second + d;</span><br><span class="line">                    qu.push(make_pair(x,dist[x]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; count(n,<span class="number">0</span>);</span><br><span class="line">        count[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">0</span>,dist,graph,count);</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>]%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5700-使所有区间的异或结果为零"><a href="#5700-使所有区间的异或结果为零" class="headerlink" title="5700. 使所有区间的异或结果为零"></a>5700. 使所有区间的异或结果为零</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k​​​​​</code> 。区间 <code>[left, right]（left &lt;= right）</code>的 异或结果 是对下标位于 <code>left</code>和 <code>right</code>（包括 <code>left</code> 和 <code>right</code> ）之间所有元素进行 <code>XOR</code> 运算的结果：<br><code>nums[left] XOR nums[left+1] XOR ... XOR nums[right]</code>。</p><p>返回数组中 要更改的最小元素数 ，以使所有长度为 <code>k</code> 的区间异或结果等于零。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将数组 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>] 修改为 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将数组 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>] 修改为 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将数组[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>] 修改为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 2000</code><br>​+ ​​​​​<code>0 &lt;= nums[i] &lt; 210</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学 + dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们我们可以得出以下推论<script type="math/tex; mode=display">nums[i] \bigoplus nums[i+1] \bigoplus ... \bigoplus nums[i+k-1] = 0 \\nums[i+1] \bigoplus nums[i+1] \bigoplus ... \bigoplus nums[i+k] = 0</script>通过上述我们可以发现$nums[i]  = nums[i+k]$.因此我们可以优先筛选$nums[i],nums[i+k],nums[i+2k]…$中频次最高的数。</li><li>仔细思考以下，我们如何让前$k$个元素异或的结果为<code>0</code>,我们可以设<code>dp</code>递推公式，例如<code>dp[i][val]</code>,表示前前<code>i</code>个元素异或的结果为$val$的最小替换数次数。则我们遇到第<code>i+1</code>个元素时，如果要使的前<code>i+1</code>个元素为<code>x</code>时，此时第<code>i+1</code>个元素有两种选择：</li></ol><ul><li>从选择一个全新的并且未在当前待选元素中出现过的，我们设前<code>i</code>个元素变为某个特定的值的最小替换次数为<code>dp[y]</code>, 此时我们需要将前<code>i+1</code>个元素的最小变化次数则为$dp[i+1][x] = sz[i+1] + dp[i][y]$,而此时需满足第<code>i+1</code>个元素的选择为$nums[i+1] = x\bigoplus y$.</li><li>从待选元素中选择一个值为$s$,则此时需要增加的替换最小次数为$dp[i][x\bigoplus s] + sz[i+1] - freq[i+1][s]$，此时我们将计算待选元素第<code>i+1</code>个分组中的$s$的统计统计次数，并计算第<code>i+1</code>个不等于$s$的次数。</li></ul><ol><li>总的来说感觉还是非常需要想像的一个<code>dp</code>，题目还是非常难的。自己都想了一个小时，才想明白这个题目。非常难思考的动态规划题目。题目太难了，确实不太会。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minChanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; cnt(k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sz[i%k]++;</span><br><span class="line">            cnt[i%k][nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1025</span>,<span class="number">-2000</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = *max_element(dp.begin(),dp.end());</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextdp(<span class="number">1025</span>,hi);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;<span class="number">10</span>); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y] : cnt[i])&#123;</span><br><span class="line">                    nextdp[j^x] = max(nextdp[j^x],dp[j] + y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = nextdp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n - dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-231&quot;&gt;&lt;a href=&quot;#leetcode-contest-231&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 231&quot;&gt;&lt;/a&gt;leetcode contest 231&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。周赛的题目质量就是非常高，非常喜欢这种有思考的题目。&lt;/p&gt;&lt;h2 id=&quot;5697-检查二进制字符串字段&quot;&gt;&lt;a href=&quot;#5697-检查二进制字符串字段&quot; class=&quot;headerlink&quot; title=&quot;5697. 检查二进制字符串字段&quot;&gt;&lt;/a&gt;5697. 检查二进制字符串字段&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个二进制字符串 &lt;code&gt;s&lt;/code&gt; ，该字符串 不含前导零 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 47</title>
    <link href="http://yoursite.com/2021/03/07/259/"/>
    <id>http://yoursite.com/2021/03/07/259/</id>
    <published>2021-03-07T13:17:21.442Z</published>
    <updated>2021-03-07T14:25:25.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-47"><a href="#leetcode-biweekly-contest-47" class="headerlink" title="leetcode biweekly contest 47"></a>leetcode biweekly contest 47</h1><p>本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。本周的状态真差，每次都是3题，<code>hard</code>难度没能做出来。</p><h2 id="5680-找到最近的有相同-X-或-Y-坐标的点"><a href="#5680-找到最近的有相同-X-或-Y-坐标的点" class="headerlink" title="5680. 找到最近的有相同 X 或 Y 坐标的点"></a>5680. 找到最近的有相同 X 或 Y 坐标的点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数 <code>x</code> 和 <code>y</code> ，表示你在一个笛卡尔坐标系下的 <code>(x, y)</code>处。同时，在同一个坐标系下给你一个数组 <code>points</code> ，其中 <code>points[i] = [ai, bi]</code>表示在 <code>(ai, bi)</code> 处有一个点。当一个点与你所在的位置有相同的 <code>x</code> 坐标或者相同的 <code>y</code> 坐标时，我们称这个点是 有效的 。</p><a id="more"></a><p>请返回距离你当前位置 曼哈顿距离 最近的 有效 点的下标（下标从 0 开始）。如果有多个最近的有效点，请返回下标 最小 的一个。如果没有有效点，请返回 -1 。</p><p>两个点 <code>(x1, y1)</code> 和<code>(x2, y2)</code> 之间的 曼哈顿距离 为 <code>abs(x1 - x2) + abs(y1 - y2)</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">3</span>, y = <span class="number">4</span>, points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：所有点中，[<span class="number">3</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">4</span>] 是有效点。有效点中，[<span class="number">2</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">4</span>] 距离你当前位置的曼哈顿距离最小，都为 <span class="number">1</span> 。[<span class="number">2</span>,<span class="number">4</span>] 的下标最小，所以返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">3</span>, y = <span class="number">4</span>, points = [[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">提示：答案可以与你当前所在位置坐标相同。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">3</span>, y = <span class="number">4</span>, points = [[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：没有有效点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= points.length &lt;= 104</code></li><li><code>points[i].length == 2</code></li><li><code>1 &lt;= x, y, ai, bi &lt;= 104</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力搜索即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nearestValidPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> dist = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] == x || points[i][<span class="number">1</span>] == y)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-x) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-y) &lt; dist)&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    dist = <span class="built_in">abs</span>(points[i][<span class="number">0</span>]-x) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5681-判断一个数字是否可以表示成三的幂的和"><a href="#5681-判断一个数字是否可以表示成三的幂的和" class="headerlink" title="5681. 判断一个数字是否可以表示成三的幂的和"></a>5681. 判断一个数字是否可以表示成三的幂的和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> ，如果你可以将 <code>n</code>表示成若干个不同的三的幂之和，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p><p>对于一个整数 <code>y</code> ，如果存在整数 <code>x</code> 满足 <code>y == 3x</code> ，我们称这个整数 <code>y</code> 是三的幂。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">12</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">12</span> = <span class="number">31</span> + <span class="number">32</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">91</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">91</span> = <span class="number">30</span> + <span class="number">32</span> + <span class="number">34</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">21</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>`1 &lt;= n &lt;= 107<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/check-if-number-is-a-sum-of-powers-of-three" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-number-is-a-sum-of-powers-of-three</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 位图暴力搜索或者<code>dfs</code></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>由于题目中给定的目标<code>n</code>的最大值为$10^{7}$,我们可以通过计算得知，最大的数可能为$3^{16} = 43,046,721$，因次我们很容易计算出所有的$3$的幂，通过暴力穷举所有的组合数即可。</li><li>我们用$32$位整数的图表示即可，通过暴力遍历出所有的组合数，整体的时间复杂度为$O(17*3^{16})$,可以计算出在允许的时间复杂度范围内。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>暴力<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPowersOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)&#123;</span><br><span class="line">            arr[i] = <span class="built_in">pow</span>(<span class="number">3</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>&lt;&lt;<span class="number">17</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">17</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr += arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>找规律<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPowersOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">3</span> == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5682-所有子字符串美丽值之和"><a href="#5682-所有子字符串美丽值之和" class="headerlink" title="5682. 所有子字符串美丽值之和"></a>5682. 所有子字符串美丽值之和</h2><p>一个字符串的 美丽值 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。</p><p>比方说，<code>&quot;abaacc&quot;</code>的美丽值为 <code>3 - 1 = 2</code>。<br>给你一个字符串 <code>s</code> ，请你返回它所有子字符串的 美丽值 之和。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabcb"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：美丽值不为零的字符串包括 [<span class="string">"aab"</span>,<span class="string">"aabc"</span>,<span class="string">"aabcb"</span>,<span class="string">"abcb"</span>,<span class="string">"bcb"</span>] ，每一个字符串的美丽值都为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabcbaa"</span></span><br><span class="line">输出：<span class="number">17</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-beauty-of-all-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-beauty-of-all-substrings</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash统计或者暴力统计</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>枚举所有的子串，然后统计所有子串的字符的频数，然后计算出最多的和最少的字符的个数，即求出美丽值，感觉不需要什么技巧。时间复杂度为$O(26*n^{2})$,空间复杂度为$O(26)$.</li><li>另一种方法是只快速统计频次，可以用有序<code>hash</code>保存当前所有字符的频次，每次取出最大的频次和最小的频次即可。时间复杂度为$O(lg26 * n^{2})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beautySum</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; freq;</span><br><span class="line">            cnt[s[i]-<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">            freq[cnt[s[i]-<span class="string">'a'</span>]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[s[j]-<span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> prev = cnt[s[j]-<span class="string">'a'</span>];</span><br><span class="line">                    freq[prev]--;</span><br><span class="line">                    <span class="keyword">if</span>(freq[prev] == <span class="number">0</span>) freq.erase(prev);</span><br><span class="line">                    cnt[s[j]-<span class="string">'a'</span>]++;</span><br><span class="line">                    freq[cnt[s[j]-<span class="string">'a'</span>]]++;</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt[s[j]-<span class="string">'a'</span>]++;</span><br><span class="line">                    freq[cnt[s[j]-<span class="string">'a'</span>]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += (freq.rbegin()-&gt;first - freq.begin()-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>暴力统统计<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 出现最大次数 - 最小最小次数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calcDiff</span><span class="params">(<span class="keyword">int</span> *cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = fmax(max, cnt[i]);</span><br><span class="line">            min = fmin(min, cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beautySum</span><span class="params">(<span class="keyword">char</span> * s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 枚举所有子串, 计算其字母出现次数, 计算美丽值 */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; len; j++) &#123;</span><br><span class="line">                cnt[s[j] - <span class="string">'a'</span>]++;</span><br><span class="line">                res += calcDiff(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5683-统计点对的数目"><a href="#5683-统计点对的数目" class="headerlink" title="5683. 统计点对的数目"></a>5683. 统计点对的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个无向图，无向图由整数 n  ，表示图中节点的数目，和 edges 组成，其中 edges[i] = [ui, vi] 表示 ui 和 vi 之间有一条无向边。同时给你一个代表查询的整数数组 queries 。</p><p>第 j 个查询的答案是满足如下条件的点对 (a, b) 的数目：</p><p>a &lt; b<br>cnt 是与 a 或者 b 相连的边的数目，且 cnt 严格大于 queries[j] 。<br>请你返回一个数组 answers ，其中 answers.length == queries.length 且 answers[j] 是第 j 个查询的答案。</p><p>请注意，图中可能会有 重复边 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">1</span>]], queries = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">解释：每个点对中，与至少一个点相连的边的数目如上图所示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>]], queries = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">10</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 2 * 104</code></li><li><code>1 &lt;= edges.length &lt;= 105</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li><code>1 &lt;= queries.length &lt;= 20</code></li><li><code>0 &lt;= queries[j] &lt; edges.length</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-pairs-of-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-pairs-of-nodes</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 容斥问题，经典的双指针</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目拿到以后我们首先看到不太好做，既然题目要求求出所有符合要求的点对的组合数目，很明显的我们首先需要求出所有顶点的度数，后面我们再分情况讨论。</li><li>我们可以知道如果有一个$query = x$,此时要求我们求出组合点的非重合的度数大于$x$的组合数目，这里就对组合$(ea,eb)$需要分为两种情况来讨论。</li></ol><ul><li>$(ea,eb)$不相邻，则此时我们很容易求出与点对$(ea,eb)$相邻的边数为$degree[a] + degree[b]$, 则此时我们已经知道所有顶点的度数，如何求出数组中其两个元素的值大于等于$x$的组合数目有多少，这是个经典的双指针问题，或者我们也可以用二分查找的方法解决。<script type="math/tex; mode=display">f(ea,eb) = degree[a] + degree[b]</script></li><li>$(ea,eb)$相邻，则此时我们就需要把相邻的边重复计算的次数减掉。此时的判断条件则为<script type="math/tex; mode=display">degree[a] + degree[b] > x \\f(ea,eb) = degree[a] + degree[b] - edges[a][b] > x</script></li></ul><ol><li>根据容斥原理，则首先我们找到所有可能的组合，然后我们再减去可能重复计算的组合数，即可得到最终的结果。题目整体还是非常好的题目，非常值得思考。双指针的时间复杂度为$O(n<em>m)$,二分查找的时间复杂度为$O(m</em>n*lgn)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countPairs(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(n,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;pii,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            v[<span class="number">0</span>]--;</span><br><span class="line">            v[<span class="number">1</span>]--;</span><br><span class="line">            degree[v[<span class="number">0</span>]]++;</span><br><span class="line">            degree[v[<span class="number">1</span>]]++;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] &gt; v[<span class="number">1</span>]) swap(v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">            cnt[make_pair(v[<span class="number">0</span>],v[<span class="number">1</span>])]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = degree;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : queries)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = n<span class="number">-1</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; i &amp;&amp; arr[i] + arr[j] &gt; x) j--;</span><br><span class="line">                curr += n - <span class="number">1</span> - max(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*remove the repeat edges*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = v.first.first;</span><br><span class="line">                <span class="keyword">int</span> b = v.first.second;</span><br><span class="line">                <span class="keyword">if</span>(degree[a] + degree[b] &gt; x &amp;&amp; (degree[a] + degree[b] - v.second) &lt;= x) curr--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>二分查找</li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-47&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-47&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 47&quot;&gt;&lt;/a&gt;leetcode biweekly contest 47&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。本周的状态真差，每次都是3题，&lt;code&gt;hard&lt;/code&gt;难度没能做出来。&lt;/p&gt;&lt;h2 id=&quot;5680-找到最近的有相同-X-或-Y-坐标的点&quot;&gt;&lt;a href=&quot;#5680-找到最近的有相同-X-或-Y-坐标的点&quot; class=&quot;headerlink&quot; title=&quot;5680. 找到最近的有相同 X 或 Y 坐标的点&quot;&gt;&lt;/a&gt;5680. 找到最近的有相同 X 或 Y 坐标的点&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个整数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ，表示你在一个笛卡尔坐标系下的 &lt;code&gt;(x, y)&lt;/code&gt;处。同时，在同一个坐标系下给你一个数组 &lt;code&gt;points&lt;/code&gt; ，其中 &lt;code&gt;points[i] = [ai, bi]&lt;/code&gt;表示在 &lt;code&gt;(ai, bi)&lt;/code&gt; 处有一个点。当一个点与你所在的位置有相同的 &lt;code&gt;x&lt;/code&gt; 坐标或者相同的 &lt;code&gt;y&lt;/code&gt; 坐标时，我们称这个点是 有效的 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 230</title>
    <link href="http://yoursite.com/2021/03/01/257/"/>
    <id>http://yoursite.com/2021/03/01/257/</id>
    <published>2021-03-01T04:28:34.667Z</published>
    <updated>2021-03-02T02:19:54.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-230"><a href="#leetcode-contest-230" class="headerlink" title="leetcode contest 230"></a>leetcode contest 230</h1><p>本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。</p><h2 id="1773-统计匹配检索规则的物品数量"><a href="#1773-统计匹配检索规则的物品数量" class="headerlink" title="1773. 统计匹配检索规则的物品数量"></a>1773. 统计匹配检索规则的物品数量</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>items</code> ，其中<code>items[i] = [typei, colori, namei]</code>，描述第 i 件物品的类型、颜色以及名称。</p><a id="more"></a><p>另给你一条由两个字符串 <code>ruleKey</code> 和 <code>ruleValue</code> 表示的检索规则。</p><p>如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：</p><ul><li><code>ruleKey == &quot;type&quot;</code> 且 <code>ruleValue == typei</code> 。</li><li><code>ruleKey == &quot;color&quot;</code> 且 <code>ruleValue == colori</code>。</li><li><code>ruleKey == &quot;name&quot;</code> 且 <code>ruleValue == namei</code> 。<br>统计并返回 匹配检索规则的物品数量 。</li></ul><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="string">"phone"</span>,<span class="string">"blue"</span>,<span class="string">"pixel"</span>],[<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"lenovo"</span>],[<span class="string">"phone"</span>,<span class="string">"gold"</span>,<span class="string">"iphone"</span>]], ruleKey = <span class="string">"color"</span>, ruleValue = <span class="string">"silver"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只有一件物品匹配检索规则，这件物品是 [<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"lenovo"</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="string">"phone"</span>,<span class="string">"blue"</span>,<span class="string">"pixel"</span>],[<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"phone"</span>],[<span class="string">"phone"</span>,<span class="string">"gold"</span>,<span class="string">"iphone"</span>]], ruleKey = <span class="string">"type"</span>, ruleValue = <span class="string">"phone"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：只有两件物品匹配检索规则，这两件物品分别是 [<span class="string">"phone"</span>,<span class="string">"blue"</span>,<span class="string">"pixel"</span>] 和 [<span class="string">"phone"</span>,<span class="string">"gold"</span>,<span class="string">"iphone"</span>] 。注意，[<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"phone"</span>] 未匹配检索规则。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= items.length &lt;= 104</code></li><li><code>1 &lt;= typei.length, colori.length, namei.length, ruleValue.length &lt;= 10</code></li><li><code>ruleKey 等于 &quot;type&quot;、&quot;color&quot; 或 &quot;name&quot;</code></li><li>所有字符串仅由小写字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-items-matching-a-rule/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-items-matching-a-rule/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力搜索即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; items, <span class="built_in">string</span> ruleKey, <span class="built_in">string</span> ruleValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : items)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ruleKey == <span class="string">"type"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[<span class="number">0</span>] == ruleValue) ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ruleKey == <span class="string">"color"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[<span class="number">1</span>] == ruleValue) ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ruleKey == <span class="string">"name"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[<span class="number">2</span>] == ruleValue) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1774-最接近目标价格的甜点成本"><a href="#1774-最接近目标价格的甜点成本" class="headerlink" title="1774. 最接近目标价格的甜点成本"></a>1774. 最接近目标价格的甜点成本</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你打算做甜点，现在需要购买配料。目前共有 <code>n</code>种冰激凌基料和 <code>m</code> 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><ul><li>必须选择 一种 冰激凌基料。</li><li>可以添加 一种或多种 配料，也可以不添加任何配料。</li><li>每种类型的配料 最多两份 。<br>给你以下三个输入：<br><code>baseCosts</code> ，一个长度为 <code>n</code> 的整数数组，其中每个 <code>baseCosts[i]</code>表示第 <code>i</code> 种冰激凌基料的价格。<br><code>toppingCosts</code>，一个长度为 <code>m</code>的整数数组，其中每个 <code>toppingCosts[i]</code> 表示 一份 第 <code>i</code> 种冰激凌配料的价格。<br><code>target</code> ，一个整数，表示你制作甜点的目标价格。<br>你希望自己做的甜点总成本尽可能接近目标价格 <code>target</code>。</li></ul><p>返回最接近 <code>target</code> 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">1</span>,<span class="number">7</span>], toppingCosts = [<span class="number">3</span>,<span class="number">4</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：考虑下面的方案组合（所有下标均从 <span class="number">0</span> 开始）：</span><br><span class="line">- 选择 <span class="number">1</span> 号基料：成本 <span class="number">7</span></span><br><span class="line">- 选择 <span class="number">1</span> 份 <span class="number">0</span> 号配料：成本 <span class="number">1</span> x <span class="number">3</span> = <span class="number">3</span></span><br><span class="line">- 选择 <span class="number">0</span> 份 <span class="number">1</span> 号配料：成本 <span class="number">0</span> x <span class="number">4</span> = <span class="number">0</span></span><br><span class="line">总成本：<span class="number">7</span> + <span class="number">3</span> + <span class="number">0</span> = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">2</span>,<span class="number">3</span>], toppingCosts = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">100</span>], target = <span class="number">18</span></span><br><span class="line">输出：<span class="number">17</span></span><br><span class="line">解释：考虑下面的方案组合（所有下标均从 <span class="number">0</span> 开始）：</span><br><span class="line">- 选择 <span class="number">1</span> 号基料：成本 <span class="number">3</span></span><br><span class="line">- 选择 <span class="number">1</span> 份 <span class="number">0</span> 号配料：成本 <span class="number">1</span> x <span class="number">4</span> = <span class="number">4</span></span><br><span class="line">- 选择 <span class="number">2</span> 份 <span class="number">1</span> 号配料：成本 <span class="number">2</span> x <span class="number">5</span> = <span class="number">10</span></span><br><span class="line">- 选择 <span class="number">0</span> 份 <span class="number">2</span> 号配料：成本 <span class="number">0</span> x <span class="number">100</span> = <span class="number">0</span></span><br><span class="line">总成本：<span class="number">3</span> + <span class="number">4</span> + <span class="number">10</span> + <span class="number">0</span> = <span class="number">17</span> 。不存在总成本为 <span class="number">18</span> 的甜点制作方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">3</span>,<span class="number">10</span>], toppingCosts = [<span class="number">2</span>,<span class="number">5</span>], target = <span class="number">9</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：可以制作总成本为 <span class="number">8</span> 和 <span class="number">10</span> 的甜点。返回 <span class="number">8</span> ，因为这是成本更低的方案。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">10</span>], toppingCosts = [<span class="number">1</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == baseCosts.length</code></li><li><code>m == toppingCosts.length</code></li><li><code>1 &lt;= n, m &lt;= 10</code></li><li><code>1 &lt;= baseCosts[i], toppingCosts[i] &lt;= 104</code></li><li><code>1 &lt;= target &lt;= 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/closest-dessert-cost" target="_blank" rel="noopener">https://leetcode-cn.com/problems/closest-dessert-cost</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力搜索</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>由于题目中给定的数据量很小，我们则可以用3进制的状态掩码来表示配料的组合，因为每种配料只有三种状态，分别为<code>0,1,2</code>.</li><li>然后分别遍历每种基料和配料的所有组合即可求出接近的值。时间复杂度为$O(n*3^{n})$,空间复杂度为$O(3^{n})$.</li><li>另一种解法，将其转化为背包问题，限定每种配料的数量为<code>2</code>,也可以转化为<code>0,1</code>背包问题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; baseCosts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; toppingCosts, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = baseCosts.size();</span><br><span class="line">        <span class="keyword">int</span> m = toppingCosts.size();</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(mask,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = i/<span class="built_in">pow</span>(<span class="number">3</span>,j);</span><br><span class="line">                cost += (x%<span class="number">3</span>)*toppingCosts[j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(baseCosts[j] + dp[i] - target) &lt; <span class="built_in">abs</span>(ans-target))&#123;</span><br><span class="line">                    ans = baseCosts[j] + dp[i];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(baseCosts[j] + dp[i] - target) == <span class="built_in">abs</span>(ans-target) &amp;&amp; (baseCosts[j] + dp[i]) &lt; ans)&#123;</span><br><span class="line">                    ans = baseCosts[j] + dp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1775-通过最少操作次数使数组的和相等"><a href="#1775-通过最少操作次数使数组的和相等" class="headerlink" title="1775. 通过最少操作次数使数组的和相等"></a>1775. 通过最少操作次数使数组的和相等</h2><p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 1 和 6）。</p><p>每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。</p><p>请你返回使 <code>nums1</code>中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], nums2 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以通过 <span class="number">3</span> 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 <span class="number">0</span> 开始。</span><br><span class="line">- 将 nums2[<span class="number">0</span>] 变为 <span class="number">6</span> 。 nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], nums2 = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将 nums1[<span class="number">5</span>] 变为 <span class="number">1</span> 。 nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>], nums2 = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将 nums1[<span class="number">2</span>] 变为 <span class="number">2</span> 。 nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>], nums2 = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], nums2 = [<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">6</span>,<span class="number">6</span>], nums2 = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以通过 <span class="number">3</span> 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 <span class="number">0</span> 开始。</span><br><span class="line">- 将 nums1[<span class="number">0</span>] 变为 <span class="number">2</span> 。 nums1 = [<span class="number">2</span>,<span class="number">6</span>], nums2 = [<span class="number">1</span>] 。</span><br><span class="line">- 将 nums1[<span class="number">1</span>] 变为 <span class="number">2</span> 。 nums1 = [<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>] 。</span><br><span class="line">- 将 nums2[<span class="number">0</span>] 变为 <span class="number">4</span> 。 nums1 = [<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">4</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们设数组<code>nums1</code>的和为$s_{1}$,数组<code>nums2</code>的和为$s_{2}$,假设有$s_{1} &lt; s_{2}$,则此时我们如果想要使得变换步数最小，则此时我们需要尽可能的将$num1$中的元素变大，将数组$nums2$中的元素变小。可以实际参考<a href="https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations/solution/tong-guo-zui-shao-cao-zuo-ci-shu-shi-shu-o8no/" target="_blank" rel="noopener">zerotrac</a>的解法，写的非常详细。我们知道：</li></ol><ul><li>可以将数组$nums1$中的每个元素变大，每个元素$x$变大的变化量为$6-x$,$x\in[1,6]$;</li><li>可以将数组$nums2$中的每个元素变小，每个元素$x$变小的变化量为$x-1$,$x\in[1,6]$;</li></ul><ol><li>我们设$diff = abs(s_{1} -s_{2})$,则此时我们可以应当尽可能的使得元素变大或者变小的变化量之和大于等于$diff$,且尽可能的使用最少的元素的变化量，此时我们可以利用贪心法，每次从最大的变化量中选择，直到选择的变化量之和满足$sum_{c} \ge diff$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1) s1 += v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2) s2 += v;</span><br><span class="line">        <span class="keyword">if</span>(s1 &gt; s2) <span class="keyword">return</span> minOperations(nums2,nums1);</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="built_in">abs</span>(s1 - s2);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1) cnt[<span class="number">6</span>-v]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2) cnt[v<span class="number">-1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(diff &gt; <span class="number">0</span> &amp;&amp; cnt[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                diff -= i;</span><br><span class="line">                cnt[i]--;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(diff &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5692-车队-II"><a href="#5692-车队-II" class="headerlink" title="5692. 车队 II"></a>5692. 车队 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在一条单车道上有 <code>n</code>辆车，它们朝着同样的方向行驶。给你一个长度为 <code>n</code> 的数组 <code>cars</code> ，其中 <code>cars[i] = [positioni, speedi]</code> ，它表示：</p><p><code>positioni</code> 是第 <code>i</code>辆车和道路起点之间的距离（单位：米）。题目保证 <code>positioni &lt; positioni+1</code> 。<br><code>speedi</code> 是第 <code>i</code> 辆车的初始速度（单位：米/秒）。<br>简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 最慢 一辆车的速度。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 i 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 <code>answer[i]</code> 为 -1 。答案精度误差需在 <code>10-5</code>以内。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cars = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">7</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">1.00000</span>,<span class="number">-1.00000</span>,<span class="number">3.00000</span>,<span class="number">-1.00000</span>]</span><br><span class="line">解释：经过恰好 <span class="number">1</span> 秒以后，第一辆车会与第二辆车相遇，并形成一个 <span class="number">1</span> m/s 的车队。经过恰好 <span class="number">3</span> 秒以后，第三辆车会与第四辆车相遇，并形成一个 <span class="number">2</span> m/s 的车队。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cars = [[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">3</span>],[<span class="number">9</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="number">2.00000</span>,<span class="number">1.00000</span>,<span class="number">1.50000</span>,<span class="number">-1.00000</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= cars.length &lt;= 105</code></li><li><code>1 &lt;= positioni, speedi &lt;= 106</code></li><li><code>positioni &lt; positioni+1</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/car-fleet-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/car-fleet-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>优先级队列或者栈</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目的思路还是非常好的，对于算法的思考方面来说还算是一个非常好的题目，对于具体的解法有两种解法，首先需要我们重点思考以下几个重要的结论，对于第<code>i</code>辆车来说，它左边的$i-1$辆车的最终合并后的最大时速肯定不会超过第<code>i</code>辆车，所以我们可以看到最终的车辆的运行速度肯定有以下结论:<script type="math/tex; mode=display">speed[j] \le speed[i] \qquad if (j  < i)</script>我们依次排列车辆的$a,b,c$,假设$b$车与$c$车相遇的时间比$a$车与$c$车相遇的时间要早，则我们可以知道$a$车与$b$车相遇的时候，这是与$a$相遇的车应该是$b,c$合并的车队，此时$a$车与$b$车相遇的时间即等于$a$车与$c$车相遇的时间。我们计算第<code>i</code>辆车与第<code>j</code>辆车的相遇时间一般为:<script type="math/tex; mode=display">\frac{p_{j}-p_{i}}{speed_{i}-speed_{j}}</script></li><li>单调栈的解法：因为我们知道$1$的结论，对于第<code>i</code>辆车来说，它左边的$i-1$辆车的最终合并后的最大时速肯定不会超过第<code>i</code>辆车，所以无论前<code>i-1</code>辆车的如何合并与否并不影响第<code>i</code>辆车与第<code>i+1</code>辆车相遇的时间。因此我们知道第<code>i</code>辆车的与合并的时间只与其后$[i+1,n]$的车辆相关，则我们可以利用栈的特性，每次第<code>i</code>车时，它会查看后面$[i+1,n]$车的状态，因此我们利用栈的功能。</li><li>优先级队列模拟：</li></ol><ul><li>我们将所有的车辆全部编为车队，$left[i]$表示以第<code>i</code>辆车为结尾的车队的最左侧的车辆的编号，因此$(left[i],i)$代表从$left[i]$到$i$的车队。</li><li>我们设$x &lt; y$,以我们每次将可能会相遇的车队$(left[x],x),(x+1,y)$，计算前后车队相遇的时间并进入优先级队列，每次从队列中取出最早相遇的车队，并将两个车队合并，则我们可以知道车队$(left[x],x),(x+1,y)$合并后的车队则为$(left[x],y)$,并同时将$(left[x],x)$从所有的车队中移除，因为我们知道以$y$为结尾的车队与后车相遇的时间不会受到前$y$辆车的合并的影响。</li><li>同时我们需要计算车队$(left[left[x]-1],left[x]-1)$与后车$left[x]$相遇的时间，并更新队列。如此就可以不断模拟，想法还是非常有意思的。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>优先级队列模拟<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    Node(<span class="keyword">double</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a, Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.t &gt; b.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; getCollisionTimes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cars) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = cars.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans(n,<span class="number">-1.0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; remove(n,<span class="literal">false</span>);</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[i] = i;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; cars[i][<span class="number">1</span>] &lt; cars[i<span class="number">-1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                pq.push(Node(<span class="number">1.0</span>*(cars[i][<span class="number">0</span>] - cars[i<span class="number">-1</span>][<span class="number">0</span>])/(cars[i<span class="number">-1</span>][<span class="number">1</span>]-cars[i][<span class="number">1</span>]),i<span class="number">-1</span>,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(remove[curr.x] || remove[curr.y]) <span class="keyword">continue</span>;</span><br><span class="line">            left[curr.y] = left[curr.x];</span><br><span class="line">            remove[curr.x] = <span class="literal">true</span>;</span><br><span class="line">            ans[curr.x] = curr.t;</span><br><span class="line">            <span class="keyword">if</span>(left[curr.x] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> prev = left[curr.x] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cars[prev][<span class="number">1</span>] &gt; cars[curr.y][<span class="number">1</span>])&#123;</span><br><span class="line">                    pq.push(Node(<span class="number">1.0</span>*(cars[curr.y][<span class="number">0</span>]-cars[prev][<span class="number">0</span>])/(cars[prev][<span class="number">1</span>]-cars[curr.y][<span class="number">1</span>]),prev,curr.y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>栈<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; getCollisionTimes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cars) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = cars.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans(n,<span class="number">-1.0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = cars[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> s = cars[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = cars[st.top()][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> s1 = cars[st.top()][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> j = st.top();</span><br><span class="line">                <span class="keyword">if</span>(s &lt;= s1 || (ans[j] &gt; <span class="number">0</span> &amp;&amp; <span class="number">1.0</span>*(p1-p)/(s-s1) &gt; ans[j]))&#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">                ans[i] = <span class="number">1.0</span>*(cars[st.top()][<span class="number">0</span>]-p)/(s-cars[st.top()][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-230&quot;&gt;&lt;a href=&quot;#leetcode-contest-230&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 230&quot;&gt;&lt;/a&gt;leetcode contest 230&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。&lt;/p&gt;&lt;h2 id=&quot;1773-统计匹配检索规则的物品数量&quot;&gt;&lt;a href=&quot;#1773-统计匹配检索规则的物品数量&quot; class=&quot;headerlink&quot; title=&quot;1773. 统计匹配检索规则的物品数量&quot;&gt;&lt;/a&gt;1773. 统计匹配检索规则的物品数量&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;items&lt;/code&gt; ，其中&lt;code&gt;items[i] = [typei, colori, namei]&lt;/code&gt;，描述第 i 件物品的类型、颜色以及名称。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
