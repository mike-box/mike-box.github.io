<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-30T07:01:40.689Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中国金</title>
    <link href="http://yoursite.com/2020/09/30/209/"/>
    <id>http://yoursite.com/2020/09/30/209/</id>
    <published>2020-09-30T07:01:22.162Z</published>
    <updated>2020-09-30T07:01:40.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中国金"><a href="#中国金" class="headerlink" title="中国金"></a>中国金</h1><p>最近花了差不多一个月左右的时间断断续续读完成了《china gold》这部历史巨作，感慨颇多，总的来说这是一部优秀的学术类的历史图书，非常喜欢这类详细而又严谨的著作，喜欢学术作品的严谨，不像某些快餐式的流行书，基本看完就可以扔掉了。希望以后能够多读一些这类数据和材料详实，论据充分，结构清晰的学术类著作。</p><a id="more"></a><h2 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h2><p>本书由加州阿普托斯卡布里洛学院的历史教授桑迪。莱登著作，由语言学教授尚余玉明翻译，翻译的质量非常高，感觉好书就是好书。本书的主要内容其实主要描述了早期美国加州的在蒙特里湾区的华人的移民史，着重描述了华人在当时战乱的背景下远离他乡，带着“淘金”的梦想踏入美国，在加州蒙特里湾区落脚，然后一步步的扎根与发展的奋斗史。作为中国人来说，从内心感受到早期侨民华人的勇敢和艰苦奋斗的精神，非常值得后辈们学习，他们能够忍受一切移民初期的不公，干着最辛苦最低贱的工作，许多人耗费了自己一生漂泊在他乡，正是华人的坚韧，渐渐在加州蒙特里湾区部分地方站住了脚跟，牺牲了自己的一生，能够让自己的后代有所提升。本书中最后一章着重讲了许多移民的后代们的发展，他们大都受到了良好的教育，有着较为光鲜的职业，同时渐渐在融入了美国主流社会，能够为华人在主流社会中发声和争取利益。<br>这也是类似遵循着以前在美国的湾区流行的一段话，一代当”engineer”,二代当”lawyer”,三代当“artist”。移民作为第一代，大部分只能做一些美国国内年轻人不爱干的工作，比如当工程师，当然并不是说工程师不好，工程师在主流的社会中只能作为工具人被政治和商业所左右，并没有当上管理层，就没有话语权，没有话语权就意味着没有利益分配权，可能永远都是边缘人。第一代移民主要负责扎根，二代和三代才能依靠自己的努力，逐渐向核心圈子靠拢，踏入美国的主流社会，为自己的梦想而奋斗。</p><h2 id="时间跨越"><a href="#时间跨越" class="headerlink" title="时间跨越"></a>时间跨越</h2><p>本书也分了几个时间维度来描述蒙特弯曲的中国人的移民状态，主要从移民初期，刚踏入到美国加州进行谋生，到中期在蒙特里湾区站稳脚跟，建设了唐人街，能够有一定的影响力的对外输出中国的传统文化，再到后期谋发展，包括在商业和政治的主流社会中开始有华人的后代崭露头角，后期还描述了湾区里面中国人的后代们的发展境况。</p><h3 id="移民初期"><a href="#移民初期" class="headerlink" title="移民初期"></a>移民初期</h3><p>一百多年前，中国大陆从1840年鸦片战争后都一直处于混乱时期，再加上太平天国运动，大清当时的落后的封建制度下，民不聊生，少数广东地区的华人带着“谋生发财”的想法，远离他乡，敢拼敢闯，来到美国加州蒙特里湾区，刚开始都是从事的最简单的农业生产和渔业捕捞，输出劳工。中国移民刚开都是抱着出去闯一闯的心态，远离他乡，踏上加州，在人生地不熟的环境中，最重要的是生存下去。所以当地人基本上都不愿意从事的脏活累活，由移民的中国人承担，一切为了生存，虽然在异国他乡，受尽歧视，但是总的生活状态和收入还是比国内要好太多了，所以在当时只要不是特别懒惰，总能够在当地糊口，并且能够为远方的家人提供一份不错的收入。</p><h4 id="农业生产"><a href="#农业生产" class="headerlink" title="农业生产"></a>农业生产</h4><p>由于土地制度的限制，美国的土地在当时是不允许中国人购买的，所以中国人只能从美国人手里租地，当然也是许多沼泽荒地，价格很便宜。中国人不怕辛苦，以极低的价格租下土地，然后从头开始开荒，勤劳耕种，中国人以坚韧的精神从事辛苦的劳作，逐渐能够安顿下来。当然中国人也发挥自己的聪明才智，尝试种植各类经济作物，能够快速的适应市场的需要，另辟蹊径中寻找商机，逐步立足。中国分别尝试的有烟草、啤酒花、芥末、甜菜、草莓、苹果等，纷纷敢于尝试，到后期书中描述了，湾区的中国人在当地的农业生产中已经占据了非常重要的地位。</p><h4 id="渔业捕捞"><a href="#渔业捕捞" class="headerlink" title="渔业捕捞"></a>渔业捕捞</h4><p>由于许多移民都是从当时大陆的沿海城市过去的，他们首先就将国内的造船术和扑鱼技能带过去了，在当时的蒙特里湾区是一个暖流，鱼类繁多，所以当时捕鱼很容易谋生，当初的移民在海边靠自己进行立足，然后在夹缝中生存，靠捕鱼为生，一度占据了市场上鲜鱼供应商的主力，后来在其他族裔的挤压下，中国移民退出了鲜鱼市场。中国移民也改变了自己的策略，发展新的渔业，比如当地根本就不吃的鲍鱼、海胆、海菜，后来由于中国移民发明了鱿鱼打包的机器，从而在蒙特里湾区大力发展鱿鱼干交易，当时由于晾晒鱿鱼的味道给当地人的生活带来了麻烦，遭到当地人的强烈反对，后来就渐渐没落。</p><h4 id="劳工输出"><a href="#劳工输出" class="headerlink" title="劳工输出"></a>劳工输出</h4><p>当时的美国正值铁路建设的高峰期，需要大量的劳力。当地人本来劳力不足，也不爱干这种苦力，自然而然勤劳刻苦的中国移民就作为当地最大的劳力输出。实际上当时他们作为劳力，在美国从事劳力取得的报酬是远远高于远在大陆的人们。书中也详细的描写了当时劳工组织在铁路建设时期的巨大付出，不光付出了新勤的劳动，甚至还付出了生命。书中详细了描述了建设南太平海岸铁路时发生的瓦斯爆炸事故，在事故中有几十人中国移民为此付出了生命。虽然中国劳工为美国的铁路建设付出了巨大的牺牲，但并没有在美国主流社会所承认和认可，作者为这些默默辛勤工作的中国移民们感到可惜。当然在后来，在中国移民的后代的争取下，让这些早期的铁路建设付出血与汗的中国劳工们在官方渠道中终于得到了肯定。d</p><h3 id="扎根异乡"><a href="#扎根异乡" class="headerlink" title="扎根异乡"></a>扎根异乡</h3><p>本书的第二章节详细的描述了排华浪潮和蒙特里湾区的唐人街。当然一开始并没有唐人街，书中描述的唐人街其实最早起源于中国移民海岸边的渔村。在19世纪初期，美国全面的排华浪潮，在移民法律制定中对中国移民做了严格的限制，不允许中国移民成为美国公民，且不允许中国移民购买土地，导致远在他乡的中国移民们一直生活在美国社会边缘中，受尽各种歧视。自然而然的，中国的传统也时抱团取暖，中国移民尽量聚集在一起，远离白人，在自己的独立小圈子中谋求发展和生存，自然而然的中国人的积聚性居住就产生了唐人街。文章中描写，许多唐人街一开始是租的，一般都有某个白人负责建设好房屋，然后将这些房屋租给中国移民。<br>在唐人街里，还保留着许多传统的中国文化，例如传统的中秋节、春节，中国人有自己的文化归属，这些传统文化和教育是刻在中国人骨子里，及时远在他乡，也不忘回忆自己的故乡。当然中国的传统也流行着“落叶归根”的传统，许多中国移民在自己年老的时候都希望能够回归自己的故乡。书中也详细的描述了蒙特里湾区的好处的唐人街，其中有蒙特里、沃森威尔、圣塔克鲁斯、萨利纳斯、卡斯特罗威尔的唐人街。<br>书中分别对几处的唐人街都有详细的描述，其中描述了唐人街的起源、中国移民在唐人街中生活的日常以及唐人街内部中国传统文化。书中的材料非常详细，对于唐人街这部分的描述中，作者煞费苦心的收集了非常多的珍贵的历史资料，包括图片、笔录、对话、档案材料等。重点阅读这部分就能深深的感受到早期中国移民的不易，在夹缝中生存求发展，极尽中国人灵活多变的智慧。当然也看到了中国移民在立足之后做的各种努力，包括在商业上展露头角，开办菜园、洗衣房、中国商店、苹果干加工厂、甜菜种植业等，可以细细的品味这些历史记载。<br>书中详细了描述了唐人街经历的一场大火，几乎打击了所有的中国移民的信心，但是中国移民也很多顽强的站立起来，在白人的帮助下很快重建了家园。</p><h3 id="谋求发展"><a href="#谋求发展" class="headerlink" title="谋求发展"></a>谋求发展</h3><p>第三部分重点描述了唐人街的消亡，实际上也是中国移民的后代在受到良好的教育后，凭借自己的努力也逐渐走出了唐人街，慢慢融入美国主流社会，随着老一辈的移民慢慢逝去，而导致了唐人街的慢慢的消亡。当然同时也体现了时代的发展，毕竟任何一个种族如果想要融入主流社会，不能老是一直畏缩在一角，努力的去出击。<br>在谋求发展中也看到中国的移民在商业中逐步踏入了主流地位，比如中国人在加州开设了鱿鱼加工厂，苹果干加工厂，特别是中国移民主流开设的百货商场在当地颇有影响力。<br>在谋求发展中中国移民的后代也凭借自己的努力，在政治社会中开启了新篇章。部分中国人成了市里的议员，参与议政事物，为华人社区争取利益。</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>总的来说，本书是本不错的书，华人在美国的移民史也是华人在美国的奋斗史，他们凭借着坚韧的毅力，不辞辛苦的劳作，为自己的后代在美国繁荣发展打下了基础。我们作为新生代的中国公民，我们应当永远缅怀自己的华人祖先们经历的痛苦，更应该对自己的祖先充满敬意，在当今的社会发展中更应该不怕辛苦，不畏艰难去打拼属于自己的事业，能够使得中国在世界的商业政治舞台上有一席之地，能够将中国传统文化发扬光大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;中国金&quot;&gt;&lt;a href=&quot;#中国金&quot; class=&quot;headerlink&quot; title=&quot;中国金&quot;&gt;&lt;/a&gt;中国金&lt;/h1&gt;&lt;p&gt;最近花了差不多一个月左右的时间断断续续读完成了《china gold》这部历史巨作，感慨颇多，总的来说这是一部优秀的学术类的历史图书，非常喜欢这类详细而又严谨的著作，喜欢学术作品的严谨，不像某些快餐式的流行书，基本看完就可以扔掉了。希望以后能够多读一些这类数据和材料详实，论据充分，结构清晰的学术类著作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书总结" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="读书感想" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 周赛208</title>
    <link href="http://yoursite.com/2020/09/27/208/"/>
    <id>http://yoursite.com/2020/09/27/208/</id>
    <published>2020-09-27T05:33:34.230Z</published>
    <updated>2020-09-30T07:01:35.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="contest-208"><a href="#contest-208" class="headerlink" title="contest 208"></a>contest 208</h1><p>这周的比赛垃圾题目不少，题目质量非常差。基本上全是暴力。怀疑是不是国内公司出的题目，太垃圾了。</p><h2 id="5523-文件夹操作日志搜集器"><a href="#5523-文件夹操作日志搜集器" class="headerlink" title="5523. 文件夹操作日志搜集器"></a>5523. 文件夹操作日志搜集器</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>每当用户执行变更文件夹操作时，<code>LeetCode</code> 文件系统都会保存一条日志记录。</p><p>下面给出对变更操作的说明：</p><ul><li>“../“ ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。</li><li>“./“ ：继续停留在当前文件夹。</li><li>“x/“ ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。</li><li>给你一个字符串列表 <code>logs</code> ，其中 <code>logs[i]</code> 是用户在 <code>ith</code> 步执行的操作。</li></ul><a id="more"></a><p>文件系统启动时位于主文件夹，然后执行 <code>logs</code> 中的操作。</p><p>执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [<span class="string">"d1/"</span>,<span class="string">"d2/"</span>,<span class="string">"../"</span>,<span class="string">"d21/"</span>,<span class="string">"./"</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：执行 <span class="string">"../"</span> 操作变更文件夹 <span class="number">2</span> 次，即可回到主文件夹</span><br></pre></td></tr></table></figure><br>示例 2：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [<span class="string">"d1/"</span>,<span class="string">"d2/"</span>,<span class="string">"./"</span>,<span class="string">"d3/"</span>,<span class="string">"../"</span>,<span class="string">"d31/"</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [<span class="string">"d1/"</span>,<span class="string">"../"</span>,<span class="string">"../"</span>,<span class="string">"../"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= logs.length &lt;= 103</li><li>2 &lt;= logs[i].length &lt;= 10</li><li>logs[i] 包含小写英文字母，数字，’.’ 和 ‘/‘</li><li>logs[i] 符合语句中描述的格式</li><li>文件夹名称由小写英文字母和数字组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/crawler-log-folder" target="_blank" rel="noopener">https://leetcode-cn.com/problems/crawler-log-folder</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目太啰嗦，反而不清楚要讲什么，最后算法的时候太过于简单。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : logs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">"../"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &gt; <span class="number">0</span>) ans--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">"./"</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5524-经营摩天轮的最大利润"><a href="#5524-经营摩天轮的最大利润" class="headerlink" title="5524. 经营摩天轮的最大利润"></a>5524. 经营摩天轮的最大利润</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 <code>runningCost</code>。摩天轮每次轮转都恰好转动<code>1 / 4</code>周。</p><p>给你一个长度为 n 的数组 <code>customers</code> ， <code>customers[i]</code>是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 <code>boardingCost</code>，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。<br>你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。</p><p>返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。</p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [<span class="number">8</span>,<span class="number">3</span>], boardingCost = <span class="number">5</span>, runningCost = <span class="number">6</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：座舱上标注的数字是该座舱的当前游客数。</span><br><span class="line"><span class="number">1.</span> <span class="number">8</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">4</span> 位等待下一舱，摩天轮轮转。当前利润为 <span class="number">4</span> * $<span class="number">5</span> - <span class="number">1</span> * $<span class="number">6</span> = $<span class="number">14</span> 。</span><br><span class="line"><span class="number">2.</span> <span class="number">3</span> 位游客抵达，<span class="number">4</span> 位在等待的游客登舱，其他 <span class="number">3</span> 位等待，摩天轮轮转。当前利润为 <span class="number">8</span> * $<span class="number">5</span> - <span class="number">2</span> * $<span class="number">6</span> = $<span class="number">28</span> 。</span><br><span class="line"><span class="number">3.</span> 最后 <span class="number">3</span> 位游客登舱，摩天轮轮转。当前利润为 <span class="number">11</span> * $<span class="number">5</span> - <span class="number">3</span> * $<span class="number">6</span> = $<span class="number">37</span> 。</span><br><span class="line">轮转 <span class="number">3</span> 次得到最大利润，最大利润为 $<span class="number">37</span> 。</span><br></pre></td></tr></table></figure><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [<span class="number">10</span>,<span class="number">9</span>,<span class="number">6</span>], boardingCost = <span class="number">6</span>, runningCost = <span class="number">4</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">1.</span> <span class="number">10</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">6</span> 位等待下一舱，摩天轮轮转。当前利润为 <span class="number">4</span> * $<span class="number">6</span> - <span class="number">1</span> * $<span class="number">4</span> = $<span class="number">20</span> 。</span><br><span class="line"><span class="number">2.</span> <span class="number">9</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">11</span> 位等待（<span class="number">2</span> 位是先前就在等待的，<span class="number">9</span> 位新加入等待的），摩天轮轮转。当前利润为 <span class="number">8</span> * $<span class="number">6</span> - <span class="number">2</span> * $<span class="number">4</span> = $<span class="number">40</span> 。</span><br><span class="line"><span class="number">3.</span> 最后 <span class="number">6</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">13</span> 位等待，摩天轮轮转。当前利润为 <span class="number">12</span> * $<span class="number">6</span> - <span class="number">3</span> * $<span class="number">4</span> = $<span class="number">60</span> 。</span><br><span class="line"><span class="number">4.</span> <span class="number">4</span> 位登舱，<span class="number">9</span> 位等待，摩天轮轮转。当前利润为 * $<span class="number">6</span> - <span class="number">4</span> * $<span class="number">4</span> = $<span class="number">80</span> 。</span><br><span class="line"><span class="number">5.</span> <span class="number">4</span> 位登舱，<span class="number">5</span> 位等待，摩天轮轮转。当前利润为 <span class="number">20</span> * $<span class="number">6</span> - <span class="number">5</span> * $<span class="number">4</span> = $<span class="number">100</span> 。</span><br><span class="line"><span class="number">6.</span> <span class="number">4</span> 位登舱，<span class="number">1</span> 位等待，摩天轮轮转。当前利润为 <span class="number">24</span> * $<span class="number">6</span> - <span class="number">6</span> * $<span class="number">4</span> = $<span class="number">120</span> 。</span><br><span class="line"><span class="number">7.</span> <span class="number">1</span> 位登舱，摩天轮轮转。当前利润为 <span class="number">25</span> * $<span class="number">6</span> - <span class="number">7</span> * $<span class="number">4</span> = $<span class="number">122</span> 。</span><br><span class="line">轮转 <span class="number">7</span> 次得到最大利润，最大利润为$<span class="number">122</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>], boardingCost = <span class="number">1</span>, runningCost = <span class="number">92</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">1.</span> <span class="number">3</span> 位游客抵达，<span class="number">3</span> 位登舱，<span class="number">0</span> 位等待，摩天轮轮转。当前利润为 <span class="number">3</span> * $<span class="number">1</span> - <span class="number">1</span> * $<span class="number">92</span> = -$<span class="number">89</span> 。</span><br><span class="line"><span class="number">2.</span> <span class="number">4</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">0</span> 位等待，摩天轮轮转。当前利润为 <span class="keyword">is</span> <span class="number">7</span> * $<span class="number">1</span> - <span class="number">2</span> * $<span class="number">92</span> = -$<span class="number">177</span> 。</span><br><span class="line"><span class="number">3.</span> <span class="number">0</span> 位游客抵达，<span class="number">0</span> 位登舱，<span class="number">0</span> 位等待，摩天轮轮转。当前利润为 <span class="number">7</span> * $<span class="number">1</span> - <span class="number">3</span> * $<span class="number">92</span> = -$<span class="number">269</span> 。</span><br><span class="line"><span class="number">4.</span> <span class="number">5</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">1</span> 位等待，摩天轮轮转。当前利润为 <span class="number">12</span> * $<span class="number">1</span> - <span class="number">4</span> * $<span class="number">92</span> = -$<span class="number">356</span> 。</span><br><span class="line"><span class="number">5.</span> <span class="number">1</span> 位游客抵达，<span class="number">2</span> 位登舱，<span class="number">0</span> 位等待，摩天轮轮转。当前利润为 <span class="number">13</span> * $<span class="number">1</span> - <span class="number">5</span> * $<span class="number">92</span> = -$<span class="number">447</span> 。</span><br><span class="line">利润永不为正，所以返回 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [<span class="number">10</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>], boardingCost = <span class="number">3</span>, runningCost = <span class="number">8</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">1.</span> <span class="number">10</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">6</span> 位等待，摩天轮轮转。当前利润为 <span class="number">4</span> * $<span class="number">3</span> - <span class="number">1</span> * $<span class="number">8</span> = $<span class="number">4</span> 。</span><br><span class="line"><span class="number">2.</span> <span class="number">10</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">12</span> 位等待，摩天轮轮转。当前利润为 <span class="number">8</span> * $<span class="number">3</span> - <span class="number">2</span> * $<span class="number">8</span> = $<span class="number">8</span> 。</span><br><span class="line"><span class="number">3.</span> <span class="number">6</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">14</span> 位等待，摩天轮轮转。当前利润为 <span class="number">12</span> * $<span class="number">3</span> - <span class="number">3</span> * $<span class="number">8</span> = $<span class="number">12</span> 。</span><br><span class="line"><span class="number">4.</span> <span class="number">4</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">14</span> 位等待，摩天轮轮转。当前利润为 <span class="number">16</span> * $<span class="number">3</span> - <span class="number">4</span> * $<span class="number">8</span> = $<span class="number">16</span> 。</span><br><span class="line"><span class="number">5.</span> <span class="number">7</span> 位游客抵达，<span class="number">4</span> 位登舱，<span class="number">17</span> 位等待，摩天轮轮转。当前利润为 <span class="number">20</span> * $<span class="number">3</span> - <span class="number">5</span> * $<span class="number">8</span> = $<span class="number">20</span> 。</span><br><span class="line"><span class="number">6.</span> <span class="number">4</span> 位登舱，<span class="number">13</span> 位等待，摩天轮轮转。当前利润为 <span class="number">24</span> * $<span class="number">3</span> - <span class="number">6</span> * $<span class="number">8</span> = $<span class="number">24</span> 。</span><br><span class="line"><span class="number">7.</span> <span class="number">4</span> 位登舱，<span class="number">9</span> 位等待，摩天轮轮转。当前利润为 <span class="number">28</span> * $<span class="number">3</span> - <span class="number">7</span> * $<span class="number">8</span> = $<span class="number">28</span> 。</span><br><span class="line"><span class="number">8.</span> <span class="number">4</span> 位登舱，<span class="number">5</span> 位等待，摩天轮轮转。当前利润为 <span class="number">32</span> * $<span class="number">3</span> - <span class="number">8</span> * $<span class="number">8</span> = $<span class="number">32</span> 。</span><br><span class="line"><span class="number">9.</span> <span class="number">4</span> 位登舱，<span class="number">1</span> 位等待，摩天轮轮转。当前利润为 <span class="number">36</span> * $<span class="number">3</span> - <span class="number">9</span> * $<span class="number">8</span> = $<span class="number">36</span> 。</span><br><span class="line">​​​​​​​<span class="number">10.</span> <span class="number">1</span> 位登舱，<span class="number">0</span> 位等待，摩天轮轮转。当前利润为 <span class="number">37</span> * $<span class="number">3</span> - <span class="number">10</span> * $<span class="number">8</span> = $<span class="number">31</span> 。</span><br><span class="line">轮转 <span class="number">9</span> 次得到最大利润，最大利润为 $<span class="number">36</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == customers.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= customers[i] &lt;= 50</code></li><li><code>1 &lt;= boardingCost, runningCost &lt;= 100</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-profit-of-operating-a-centennial-wheel" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-profit-of-operating-a-centennial-wheel</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接模拟</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们每次从排队队列中取出等待的人数，且小于4个，大于4个的人数再放回队列中等待下一次的乘坐即可。</li><li>题目的结论又太垃圾，啰里啰唆的说了一大堆，结论又过于简单，竟然是求最小轮数。</li><li>用双端队列模拟即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperationsMaxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="keyword">int</span> boardingCost, <span class="keyword">int</span> runningCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = customers.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : customers)&#123;</span><br><span class="line">            qu.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span>  curr = qu.front();</span><br><span class="line">            qu.pop_front();</span><br><span class="line">            profit += min(curr,<span class="number">4</span>)*boardingCost;</span><br><span class="line">            curr = curr &gt; <span class="number">4</span> ? (curr<span class="number">-4</span>) : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!qu.empty())&#123;</span><br><span class="line">                    curr += qu.front();</span><br><span class="line">                    qu.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">                qu.push_front(curr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t++;</span><br><span class="line">            profit -= runningCost;</span><br><span class="line">            <span class="keyword">if</span>(profit &gt; maxProfit)&#123;</span><br><span class="line">                maxProfit = profit;</span><br><span class="line">                ans = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans == <span class="number">0</span>?(<span class="number">-1</span>):ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5525-皇位继承顺序"><a href="#5525-皇位继承顺序" class="headerlink" title="5525. 皇位继承顺序"></a>5525. 皇位继承顺序</h2><p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p><p>这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 <code>Successor(x, curOrder)</code> ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Successor(<span class="keyword">x</span>, curOrder):</span><br><span class="line">    如果 <span class="keyword">x</span> 没有孩子或者所有 <span class="keyword">x</span> 的孩子都在 curOrder 中：</span><br><span class="line">        如果 <span class="keyword">x</span> 是国王，那么返回 <span class="keyword">null</span></span><br><span class="line">        否则，返回 Successor(<span class="keyword">x</span> 的父亲, curOrder)</span><br><span class="line">    否则，返回 <span class="keyword">x</span> 不在 curOrder 中最年长的孩子</span><br></pre></td></tr></table></figure><br>比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一开始， curOrder 为 [<span class="string">"king"</span>].</span><br><span class="line">调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [<span class="string">"king"</span>, <span class="string">"Alice"</span>] 。</span><br><span class="line">调用 Successor(Alice, curOrder) ，返回 <span class="keyword">Jack </span>，所以我们将 <span class="keyword">Jack </span>放入 curOrder 中，得到 [<span class="string">"king"</span>, <span class="string">"Alice"</span>, <span class="string">"Jack"</span>] 。</span><br><span class="line">调用 Successor(<span class="keyword">Jack, </span>curOrder) ，返回 <span class="keyword">Bob </span>，所以我们将 <span class="keyword">Bob </span>放入 curOrder 中，得到 [<span class="string">"king"</span>, <span class="string">"Alice"</span>, <span class="string">"Jack"</span>, <span class="string">"Bob"</span>] 。</span><br><span class="line">调用 Successor(<span class="keyword">Bob, </span>curOrder) ，返回 null 。最终得到继承顺序为 [<span class="string">"king"</span>, <span class="string">"Alice"</span>, <span class="string">"Jack"</span>, <span class="string">"Bob"</span>] 。</span><br><span class="line">通过以上的函数，我们总是能得到一个唯一的继承顺序。</span><br></pre></td></tr></table></figure><br>请你实现 ThroneInheritance 类：</p><ul><li><code>ThroneInheritance(string kingName)</code>初始化一个 <code>ThroneInheritance</code> 类的对象。国王的名字作为构造函数的参数传入。</li><li><code>void birth(string parentName, string childName)</code> 表示 <code>parentName</code>新拥有了一个名为 <code>childName</code>的孩子。</li><li><code>void death(string name)</code> 表示名为 <code>name</code> 的人死亡。一个人的死亡不会影响 <code>Successor</code> 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</li><li><code>string[] getInheritanceOrder()</code>返回 除去 死亡人员的当前继承顺序列表。</li></ul><p>示例：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"ThroneInheritance"</span>, <span class="string">"birth"</span>, <span class="string">"birth"</span>, <span class="string">"birth"</span>, <span class="string">"birth"</span>, <span class="string">"birth"</span>, <span class="string">"birth"</span>, <span class="string">"getInheritanceOrder"</span>, <span class="string">"death"</span>, <span class="string">"getInheritanceOrder"</span>]</span><br><span class="line">[[<span class="string">"king"</span>], [<span class="string">"king"</span>, <span class="string">"andy"</span>], [<span class="string">"king"</span>, <span class="string">"bob"</span>], [<span class="string">"king"</span>, <span class="string">"catherine"</span>], [<span class="string">"andy"</span>, <span class="string">"matthew"</span>], [<span class="string">"bob"</span>, <span class="string">"alex"</span>], [<span class="string">"bob"</span>, <span class="string">"asha"</span>], [null], [<span class="string">"bob"</span>], [null]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, null, null, null, null, [<span class="string">"king"</span>, <span class="string">"andy"</span>, <span class="string">"matthew"</span>, <span class="string">"bob"</span>, <span class="string">"alex"</span>, <span class="string">"asha"</span>, <span class="string">"catherine"</span>], null, [<span class="string">"king"</span>, <span class="string">"andy"</span>, <span class="string">"matthew"</span>, <span class="string">"alex"</span>, <span class="string">"asha"</span>, <span class="string">"catherine"</span>]]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="symbol">ThroneInheritance</span> t= new <span class="symbol">ThroneInheritance</span>(<span class="string">"king"</span>); // 继承顺序：king</span><br><span class="line">t.birth(<span class="string">"king"</span>, <span class="string">"andy"</span>); // 继承顺序：king &gt; andy</span><br><span class="line">t.birth(<span class="string">"king"</span>, <span class="string">"bob"</span>); // 继承顺序：king &gt; andy &gt; bob</span><br><span class="line">t.birth(<span class="string">"king"</span>, <span class="string">"catherine"</span>); // 继承顺序：king &gt; andy &gt; bob &gt; catherine</span><br><span class="line">t.birth(<span class="string">"andy"</span>, <span class="string">"matthew"</span>); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; catherine</span><br><span class="line">t.birth(<span class="string">"bob"</span>, <span class="string">"alex"</span>); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; catherine</span><br><span class="line">t.birth(<span class="string">"bob"</span>, <span class="string">"asha"</span>); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; asha &gt; catherine</span><br><span class="line">t.getInheritanceOrder(); // 返回 [<span class="string">"king"</span>, <span class="string">"andy"</span>, <span class="string">"matthew"</span>, <span class="string">"bob"</span>, <span class="string">"alex"</span>, <span class="string">"asha"</span>, <span class="string">"catherine"</span>]</span><br><span class="line">t.death(<span class="string">"bob"</span>); // 继承顺序：king &gt; andy &gt; matthew &gt; bob（已经去世）&gt; alex &gt; asha &gt; catherine</span><br><span class="line">t.getInheritanceOrder(); // 返回 [<span class="string">"king"</span>, <span class="string">"andy"</span>, <span class="string">"matthew"</span>, <span class="string">"alex"</span>, <span class="string">"asha"</span>, <span class="string">"catherine"</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15</code></li><li><code>kingName，parentName， childName</code> 和 <code>name</code>仅包含小写英文字母。</li><li>所有的参数 <code>childName</code> 和 <code>kingName</code> 互不相同。</li><li>所有 <code>death</code> 函数中的死亡名字 <code>name</code> 要么是国王，要么是已经出生了的人员名字。</li><li>每次调用 <code>birth(parentName, childName)</code> 时，测试用例都保证 <code>parentName</code>对应的人员是活着的。</li><li>最多调用 <code>105</code> 次<code>birth</code>和 <code>death</code>。</li><li>最多调用 <code>10</code> 次 <code>getInheritanceOrder</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/throne-inheritance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/throne-inheritance/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 递归DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目太长太罗嗦，并且描述也不是很清楚。</li><li>题目好无聊，直接DFS暴力解决即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThroneInheritance</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; child;</span><br><span class="line">    <span class="built_in">string</span> king;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; order;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; die;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ThroneInheritance(<span class="built_in">string</span> kingName) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;king = kingName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">birth</span><span class="params">(<span class="built_in">string</span> parentName, <span class="built_in">string</span> childName)</span> </span>&#123;</span><br><span class="line">        child[parentName].emplace_back(childName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">death</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        die.insert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!die.count(root))&#123;</span><br><span class="line">            order.push_back(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : child[root])&#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; getInheritanceOrder() &#123;</span><br><span class="line">        order.clear();</span><br><span class="line">        dfs(<span class="keyword">this</span>-&gt;king);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ThroneInheritance object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ThroneInheritance* obj = new ThroneInheritance(kingName);</span></span><br><span class="line"><span class="comment"> * obj-&gt;birth(parentName,childName);</span></span><br><span class="line"><span class="comment"> * obj-&gt;death(name);</span></span><br><span class="line"><span class="comment"> * vector&lt;string&gt; param_3 = obj-&gt;getInheritanceOrder();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5526-最多可达成的换楼请求数目"><a href="#5526-最多可达成的换楼请求数目" class="headerlink" title="5526. 最多可达成的换楼请求数目"></a>5526. 最多可达成的换楼请求数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>我们有 <code>n</code> 栋楼，编号从 <code>0</code> 到 <code>n - 1</code> 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。</p><p>给你一个数组 <code>requests</code> ，其中 <code>requests[i] = [fromi, toi]</code>，表示一个员工请求从编号为 <code>fromi</code> 的楼搬到编号为 <code>toi</code> 的楼。</p><p>一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。</p><p>请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, requests = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：请求列表如下：</span><br><span class="line">从楼 <span class="number">0</span> 离开的员工为 x 和 y ，且他们都想要搬到楼 <span class="number">1</span> 。</span><br><span class="line">从楼 <span class="number">1</span> 离开的员工为 a 和 b ，且他们分别想要搬到楼 <span class="number">2</span> 和 <span class="number">0</span> 。</span><br><span class="line">从楼 <span class="number">2</span> 离开的员工为 z ，且他想要搬到楼 <span class="number">0</span> 。</span><br><span class="line">从楼 <span class="number">3</span> 离开的员工为 c ，且他想要搬到楼 <span class="number">4</span> 。</span><br><span class="line">没有员工从楼 <span class="number">4</span> 离开。</span><br><span class="line">我们可以让 x 和 b 交换他们的楼，以满足他们的请求。</span><br><span class="line">我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。</span><br><span class="line">所以最多可以满足 <span class="number">5</span> 个请求。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, requests = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：请求列表如下：</span><br><span class="line">从楼 <span class="number">0</span> 离开的员工为 x ，且他想要回到原来的楼 <span class="number">0</span> 。</span><br><span class="line">从楼 <span class="number">1</span> 离开的员工为 y ，且他想要搬到楼 <span class="number">2</span> 。</span><br><span class="line">从楼 <span class="number">2</span> 离开的员工为 z ，且他想要搬到楼 <span class="number">1</span> 。</span><br><span class="line">我们可以满足所有的请求。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, requests = [[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= requests.length &lt;= 16</code></li><li><code>requests[i].length == 2</code></li><li><code>0 &lt;= fromi, toi &lt; n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>状态枚举</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>对可以选择的边的状态用二进制掩码进行压缩表示。我们设<code>degree[i][state]</code>表示节点<code>i</code>在状态<code>state</code>下所有的边的总度数。</li><li>我们遍历所有的边，并计算所有的节点在不同的状态下的度数统计之和。</li><li>我们遍历所有的状态，判断在该状态下，是否每个点的度数都为0，如果全部为<code>0</code>则表明该状态符合要求，求改状态下请求边的数目即可。</li><li>本质就是暴力搜索，没啥难度。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> degree[<span class="number">20</span>][<span class="number">1</span>&lt;&lt;<span class="number">16</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumRequests</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requests)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = requests.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(degree,<span class="number">0</span>,<span class="keyword">sizeof</span>(degree));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = requests[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = requests[j][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    degree[x][i]--;</span><br><span class="line">                    degree[y][i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(degree[j][i] != <span class="number">0</span>)&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                ans = max(ans,countOne(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;contest-208&quot;&gt;&lt;a href=&quot;#contest-208&quot; class=&quot;headerlink&quot; title=&quot;contest 208&quot;&gt;&lt;/a&gt;contest 208&lt;/h1&gt;&lt;p&gt;这周的比赛垃圾题目不少，题目质量非常差。基本上全是暴力。怀疑是不是国内公司出的题目，太垃圾了。&lt;/p&gt;&lt;h2 id=&quot;5523-文件夹操作日志搜集器&quot;&gt;&lt;a href=&quot;#5523-文件夹操作日志搜集器&quot; class=&quot;headerlink&quot; title=&quot;5523. 文件夹操作日志搜集器&quot;&gt;&lt;/a&gt;5523. 文件夹操作日志搜集器&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;每当用户执行变更文件夹操作时，&lt;code&gt;LeetCode&lt;/code&gt; 文件系统都会保存一条日志记录。&lt;/p&gt;&lt;p&gt;下面给出对变更操作的说明：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;“../“ ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。&lt;/li&gt;
&lt;li&gt;“./“ ：继续停留在当前文件夹。&lt;/li&gt;
&lt;li&gt;“x/“ ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。&lt;/li&gt;
&lt;li&gt;给你一个字符串列表 &lt;code&gt;logs&lt;/code&gt; ，其中 &lt;code&gt;logs[i]&lt;/code&gt; 是用户在 &lt;code&gt;ith&lt;/code&gt; 步执行的操作。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 Build a Modern Computer From First Principles:Nand to Tetris Part II</title>
    <link href="http://yoursite.com/2020/09/24/207/"/>
    <id>http://yoursite.com/2020/09/24/207/</id>
    <published>2020-09-24T08:30:48.248Z</published>
    <updated>2020-09-24T08:30:55.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-II-week-7-amp-week-8"><a href="#Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-II-week-7-amp-week-8" class="headerlink" title="Build a Modern Computer from First Principles: Nand to Tetris Part II (week 7 &amp; week 8)"></a>Build a Modern Computer from First Principles: Nand to Tetris Part II (week 7 &amp; week 8)</h1><p>花了将近两个星期完成了<code>project 7</code>和<code>project 8</code>写完了，主要是集中精力去弄这个两个project就会很快，另外我感觉看视频的效率太低了，不如看书效率高。视频虽然讲的非常细，但是确实太耗费时间了，感觉还是看书效率高，对于简单得部分可以快速得过去，对于不懂理解得部分，再仔细琢磨，然后看视频了解细节，我觉得这样不断的调整自己的策略才能加快自己的速度，否则每周都是几个小时的视频学习起来让人非常疲惫，不过视频里面确实对于细节讲得非常透彻，不过总得来说感觉下半部分得课程确实比上半部分要稍微难一点。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200827235402.png" alt="1"></p><a id="more"></a><ul><li><code>week7 &amp; week8</code>部分主要讲得是<code>jack</code>语言得虚拟机部分，类似于<code>java</code>得<code>jvm</code>,同样也是采用<code>stack machine</code>的原理来实现的，但是在本课程中关于虚拟机部分的实现就简单的多。这两周的课程主要讲的是讲<code>vm</code>的高级语言翻译成<code>hack</code>汇编语言。本质还是类似，是一个小型的类似于模拟的计算机系统。虽然总的来说实现这个虚拟机还是非常简单的，但是通过这个简单的虚拟机能够让人了解到计算机系统的基础知识能够让人对复杂的计算机系统有了初步的宏观了解和掌握。下一阶段准备完成的《csapp》的<code>project</code>也是作为最基础的计算机知识了解计算机的基础知识。<br><img src="https://i.loli.net/2020/09/24/C2hNH9VE5FDbYmM.png" alt><br>所有的代码均存放在<a href="https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects/08" target="_blank" rel="noopener">github</a>，可以参考代码。</li></ul><h2 id="week7-Boolean-Logic"><a href="#week7-Boolean-Logic" class="headerlink" title="week7 Boolean Logic"></a>week7 Boolean Logic</h2><p>在<code>week 7</code>章节中主要实现讲虚拟机语言转化为汇编语言，</p><h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><p>在<code>week7</code>七中中主要描述了以下几种基本操作：</p><ol><li><strong>arithmetic</strong>：算术运算又可以细分为双操作数运算与单操作数运算，在本次的虚拟机中支持八种基本的算术运算和布尔代数运算，涉及到的细节可以参考github中的代码，注意的地方是在<code>hack</code>系统的虚拟机中，<code>boolean</code>变量中的<code>true</code>用<code>-1</code>表示，<code>false</code>用<code>0</code>表示，因此在本系统中稍微麻烦的处理<code>boolean</code>变量，由于在底层汇编语言中只有跳转指令能够进行比较操作，因此此处我们用<code>JMP</code>指令来处理该操作。<br><img src="https://i.loli.net/2020/09/24/fKkpMqoSanglcsu.png" alt></li></ol><ul><li>C_ARITHMETIC_ADD: 将栈顶的两个元素取出<code>M[SP-1],M[SP-2]</code>，然后相加，将结果<code>M[SP-2] + M[SP-1]</code>再压入栈中。</li><li>C_ARITHMETIC_SUB: 将栈顶的两个元素取出<code>M[SP-1],M[SP-2]</code>，然后相减，将结果<code>M[SP-2] - M[SP-1]</code>再压入栈中。</li><li>C_ARITHMETIC_NEG: 将栈顶的元素<code>M[SP-1]</code>直接进行取反变为负数<code>-M[SP-1]</code>。</li><li>C_ARITHMETIC_EQ: 将栈顶的两个元素取出<code>M[SP-1],M[SP-2]</code>，然后判断两个元素是否相等<code>M[SP-1] == M[SP-2]</code>，将结果压入栈中。</li><li>C_ARITHMETIC_GT: 将栈顶的两个元素取出<code>M[SP-1],M[SP-2]</code>，然后判断<code>M[SP-2] &gt; M[SP-1]</code>，将结果压入栈中。</li><li>C_ARITHMETIC_LT: 将栈顶的两个元素取出<code>M[SP-1],M[SP-2]</code>，然后判断<code>M[SP-2] &lt; M[SP-1]</code>，将结果压入栈中。</li><li>C_ARITHMETIC_AND:将栈顶的两个元素取出<code>M[SP-1],M[SP-2]</code>，然后判断<code>M[SP-2] &amp; M[SP-1]</code>，将结果压入栈中。</li><li>C_ARITHMETIC_OR: 将栈顶的两个元素取出<code>M[SP-1],M[SP-2]</code>，然后判断<code>M[SP-2] | M[SP-1]</code>，将结果压入栈中。</li><li>C_ARITHMETIC_NOT: 将栈顶的元素<code>M[SP-1]</code>直接进行取反变为<code>~M[SP-1]</code>。</li></ul><ol><li><strong>push</strong>：将新的元素<code>X</code>从特定位置取出压入栈中，<code>M[SP] = X</code>,并且将栈顶加1，<code>SP = SP + 1</code>.<br><img src="https://i.loli.net/2020/09/24/Esq398Ck1fz7xLc.png" alt></li><li><strong>pop</strong>： 将栈顶元素弹出存储到特定位置中，<code>M[X] = M[SP-1]</code>,并且将栈顶加1，<code>SP = SP - 1</code>.</li></ol><h3 id="存储段"><a href="#存储段" class="headerlink" title="存储段"></a>存储段</h3><p>由于计算机系统的特殊性，在<code>hack</code>计算机系统中将所有存储空间划分成不同的区域作为不同的用途使用，防止出现内存被意外占用的情况，程序出现混乱的情况，我们应根据实际的情况来划分。当然实际的情况可能会更复杂，因为还涉及到权限的问题，实际的计算系统也会给不同的用户划分不同的权限，根据不同的权限来划分不同的内存访问权限。在<code>hack</code>计算机系统中我们划分为以下几种不同的<code>segment</code>,不同的<code>segment</code>用途不同:<br><img src="https://i.loli.net/2020/09/24/bYJ9hCLyXmzHDF8.png" alt><br><img src="https://i.loli.net/2020/09/24/csPL7RVDu6wt8Of.png" alt><br>实际对于段的空间存储如下：<br><img src="https://i.loli.net/2020/09/24/6fd1xUbnijmEDwt.png" alt></p><ol><li><strong>SEG_ARGUMENT</strong>: <code>ARG</code>地址存放的是<code>argument</code>段的起始地址。</li><li><strong>SEG_LOCAL</strong>: <code>LCL</code>地址存放的是<code>argument</code>段的起始地址。</li><li><strong>SEG_STATIC</strong>: <code>ram[16-255]</code>为static存放的空间，为全局所共享。</li><li><strong>SEG_CONSTANT</strong>: 常量我们直接存储即可。</li><li><strong>SEG_THIS</strong>:  <code>THIS</code>地址存放的是<code>this</code>段的起始地址。</li><li><strong>SEG_THAT</strong>:  <code>THAT</code>地址存放的是<code>that</code>段的起始地址。</li><li><strong>SEG_POINTER</strong>: pointer作为指针，它所指向的位置存在的变量的地址。</li><li><strong>SEG_TMP</strong>:  <code>ram[5-12]</code>.</li><li><strong>SEG_SP</strong>: <code>SP</code>地址存放的是<code>stack</code>段的起始地址。</li></ol><h2 id="week8-Memory"><a href="#week8-Memory" class="headerlink" title="week8 Memory"></a>week8 Memory</h2><p><code>week8</code>部分主要描述的是程序的过程控制部分，如果对于阅读过<code>CSAPP</code>的同学来说，这部分就相当简单了，基本上是程序需要进入不同的函数之间进行跳转时，也即将现场的地址和变量保存到栈中，然后进行条跳转指令执行即可。主要由几个不同的部分组成:</p><h3 id="操作指令-1"><a href="#操作指令-1" class="headerlink" title="操作指令"></a>操作指令</h3><ol><li><strong>label</strong>：为特定跳转位置打上标签，对于标签的处理,实际的程序中<code>label</code>分为三种：<br><img src="https://i.loli.net/2020/09/24/YPWVzpvXqbCBLM1.png" alt></li><li><strong>goto</strong>：因为内部的标签基本上固定的格式，我们直接将生成的固定标签地址写入到地址寄存器，然后再进行跳转即可，固定的格式为 <code>functionname + $ + label</code>.<br><img src="https://i.loli.net/2020/09/24/nf4FrkpgELqYiOQ.png" alt></li><li><strong>if-goto</strong>：<code>if-goto</code>与<code>goto</code>的处理非常类似，我们直接进行处理即可，只不过加了一个判断而已，处理稍微复杂点，如果判断不过则不进行跳转即可。</li><li><strong>function</strong>：对于<code>function</code>的处理我们主要做好标签和<code>local</code>变量的空间开辟即可，非常简单。<br><img src="https://i.loli.net/2020/09/24/VUhzXgPNqjvkCYw.png" alt></li><li><strong>call</strong>：对于函数跳转指令则稍微复杂点，需要处理的较多。详细的可以参考上述图片中的内容。</li></ol><h3 id="stack-frame"><a href="#stack-frame" class="headerlink" title="stack frame"></a>stack frame</h3><p><img src="https://i.loli.net/2020/09/24/nWYp8sjJO2LHSaQ.png" alt><br>关于详细的栈中的空间描述可以参考图中所描述，对于函数即将进行跳转时，现场分别保存了哪些变量都由非常详细的描述，<code>call</code>指令的实现大概用了50多行汇编代码才完成，还是比较复杂的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于<code>week7 &amp; 8</code>讲的是关于程序的底层控制和实现，具体来说还是比较复杂，但是对于学过计算机组成原理和<code>CSAPP</code>的同学来说这部分实际也非常简单，后面一部分即将进入对于<code>jack</code>编译器的描述，非常期待能够进入这一让人兴奋的章节，一直都有一个情节，想实现一个编译器，后面两章中有一个<code>project</code>即为实现一门语言的编译器，希望能够在后面的project中好好发挥。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-II-week-7-amp-week-8&quot;&gt;&lt;a href=&quot;#Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-II-week-7-amp-week-8&quot; class=&quot;headerlink&quot; title=&quot;Build a Modern Computer from First Principles: Nand to Tetris Part II (week 7 &amp;amp; week 8)&quot;&gt;&lt;/a&gt;Build a Modern Computer from First Principles: Nand to Tetris Part II (week 7 &amp;amp; week 8)&lt;/h1&gt;&lt;p&gt;花了将近两个星期完成了&lt;code&gt;project 7&lt;/code&gt;和&lt;code&gt;project 8&lt;/code&gt;写完了，主要是集中精力去弄这个两个project就会很快，另外我感觉看视频的效率太低了，不如看书效率高。视频虽然讲的非常细，但是确实太耗费时间了，感觉还是看书效率高，对于简单得部分可以快速得过去，对于不懂理解得部分，再仔细琢磨，然后看视频了解细节，我觉得这样不断的调整自己的策略才能加快自己的速度，否则每周都是几个小时的视频学习起来让人非常疲惫，不过视频里面确实对于细节讲得非常透彻，不过总得来说感觉下半部分得课程确实比上半部分要稍微难一点。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200827235402.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="公开课" scheme="http://yoursite.com/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
      <category term="coursera" scheme="http://yoursite.com/tags/coursera/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 LCCUP团体赛</title>
    <link href="http://yoursite.com/2020/09/23/206/"/>
    <id>http://yoursite.com/2020/09/23/206/</id>
    <published>2020-09-23T09:27:06.346Z</published>
    <updated>2020-09-23T09:27:11.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCCUP团体赛"><a href="#LCCUP团体赛" class="headerlink" title="LCCUP团体赛"></a>LCCUP团体赛</h1><p>LCCUP团体赛的题目比个人赛南多了，基本上达到<code>NOI</code>区域赛的水平，难度还是不小，需要仔细分析和解析。每道题目都值得仔细思考和总结，主要是学习相关的思路。</p><h2 id="LCP-22-黑白方格画"><a href="#LCP-22-黑白方格画" class="headerlink" title="LCP 22. 黑白方格画"></a>LCP 22. 黑白方格画</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有<code>n * n</code>的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色，所选行数、列数均可为 0。</p><a id="more"></a><p>小扣希望最终的成品上需要有 k 个黑色格子，请返回小扣共有多少种涂色方案。</p><p>注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：一共有四种不同的方案：</span><br><span class="line">第一种方案：涂第一列；</span><br><span class="line">第二种方案：涂第二列；</span><br><span class="line">第三种方案：涂第一行；</span><br><span class="line">第四种方案：涂第二行。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：不可行，因为第一次涂色至少会涂两个黑格。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：共有 <span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span> 个格子，仅有一种涂色方案。</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= n &lt;= 6</code></li><li><code>0 &lt;= k &lt;= n * n</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/ccw6C7" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ccw6C7</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  签到数学题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们知道如果<code>x</code>行和<code>y</code>列，则去掉重复的格子后，总共有$(x+y)<em>n - x</em>y$个格子，其中重复了$x*y$个格子。</li><li>我们直接遍历所有的可能的<code>x,y</code>排列组合即可，有一个情况除外，即所有的格子都被染色，则此时只有一种方案。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">paintingPlan</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> C[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span>(C));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">            C[j][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j+<span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                   C[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                   C[i][j] = (C[i<span class="number">-1</span>][j<span class="number">-1</span>] + C[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k == n*n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((n*(i+j) - i*j) == k)&#123;</span><br><span class="line">                    ans += (C[n][i]*C[n][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-23-魔术排列"><a href="#LCP-23-魔术排列" class="headerlink" title="LCP 23. 魔术排列"></a>LCP 23. 魔术排列</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>秋日市集上，魔术师邀请小扣与他互动。魔术师的道具为分别写有数字 1~N 的 <code>N</code> 张卡牌，然后请小扣思考一个 <code>N</code> 张卡牌的排列 <code>target</code>。</p><p>魔术师的目标是找到一个数字<code>k（k &gt;= 1）</code>，使得初始排列顺序为 <code>1~N</code>的卡牌经过特殊的洗牌方式最终变成小扣所想的排列 target，特殊的洗牌方式为：</p><ul><li>第一步，魔术师将当前位于 偶数位置 的卡牌（下标自 1 开始），保持 当前排列顺序 放在位于 奇数位置 的卡牌之前。例如：将当前排列<code>[1,2,3,4,5]</code> 位于偶数位置的 <code>[2,4]</code>置于奇数位置的 <code>[1,3,5]</code>前，排列变为 <code>[2,4,1,3,5]</code>；</li><li>第二步，若当前卡牌数量小于等于<code>k</code>，则魔术师按排列顺序取走全部卡牌；若当前卡牌数量大于<code>k</code>，则取走前 <code>k</code>张卡牌，剩余卡牌继续重复这两个步骤，直至所有卡牌全部被取走；<br>卡牌按照魔术师取走顺序构成的新排列为「魔术取数排列」，请返回是否存在这个数字 k 使得「魔术取数排列」恰好就是 <code>target</code>，从而让小扣感到大吃一惊。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">解释：排列 target 长度为 <span class="number">5</span>，初始排列为：<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>。我们选择 k = <span class="number">2</span>：</span><br><span class="line">第一次：将当前排列 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 位于偶数位置的 [<span class="number">2</span>,<span class="number">4</span>] 置于奇数位置的 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>] 前，排列变为 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]。取走前 <span class="number">2</span> 张卡牌 <span class="number">2</span>,<span class="number">4</span>，剩余 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]；</span><br><span class="line">第二次：将当前排列 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>] 位于偶数位置的 [<span class="number">3</span>] 置于奇数位置的 [<span class="number">1</span>,<span class="number">5</span>] 前，排列变为 [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]。取走前 <span class="number">2</span> 张 <span class="number">3</span>,<span class="number">1</span>，剩余 [<span class="number">5</span>]；</span><br><span class="line">第三次：当前排列为 [<span class="number">5</span>]，全部取出。</span><br><span class="line">最后，数字按照取出顺序构成的「魔术取数排列」<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span> 恰好为 target。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">解释：无法找到一个数字 k 可以使「魔术取数排列」恰好为 target。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= target.length = N &lt;= 5000</code></li><li>题目保证 <code>target</code> 是 <code>1~N</code> 的一个排列。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/er94lq" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er94lq</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 模拟洗牌过程</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们第一步进行模拟洗牌过程，找到第一个与第一次模拟洗牌过程不同的数，即为所寻找的目标<code>k</code>.</li><li>我们仔细推理可以发现，第一次的从洗牌中取出的数据顺序由<code>k</code>的大小决定，且一定是唯一的，因为它是唯一的，所以我们第一次模拟即可找到<code>k</code>的值。</li><li>我们后续的依次进行模拟即可，检测能够完成该数目的全部模拟即可。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMagic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = target.size();</span><br><span class="line">        <span class="keyword">int</span> k = n;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>)&#123;</span><br><span class="line">            arr.emplace_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>)&#123;</span><br><span class="line">            arr.emplace_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i] != arr[i])&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = k;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l+<span class="number">1</span>; i &lt; n; i += <span class="number">2</span>)&#123;</span><br><span class="line">                tmp[j++] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt; n; i += <span class="number">2</span>)&#123;</span><br><span class="line">                tmp[j++] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class="line">                arr[i] = tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; (l+i) &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[l+i] != target[l+i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l += k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LCP-24-数字游戏"><a href="#LCP-24-数字游戏" class="headerlink" title="LCP 24. 数字游戏"></a>LCP 24. 数字游戏</h2><p>小扣在秋日市集入口处发现了一个数字游戏。主办方共有 <code>N</code>个计数器，计数器编号为<code>0 ~ N-1</code>。每个计数器上分别显示了一个数字，小扣按计数器编号升序将所显示的数字记于数组 nums。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。</p><p>主办方请小扣回答出一个长度为<code>N</code>的数组，第 <code>i</code>个元素<code>(0 &lt;= i &lt; N)</code>表示将 <code>0~i</code>号计数器 初始 所示数字操作成满足所有条件 <code>nums[a]+1 == nums[a+1],(0 &lt;= a &lt; i)</code>的最小操作数。回答正确方可进入秋日市集。</p><p>由于答案可能很大，请将每个最小操作数对 <code>1,000,000,007</code> 取余。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">i = <span class="number">0</span>，[<span class="number">3</span>] 无需操作</span><br><span class="line">i = <span class="number">1</span>，[<span class="number">3</span>,<span class="number">4</span>] 无需操作；</span><br><span class="line">i = <span class="number">2</span>，[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 无需操作；</span><br><span class="line">i = <span class="number">3</span>，将 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>] 操作成 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], 最少 <span class="number">5</span> 次操作；</span><br><span class="line">i = <span class="number">4</span>，将 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>] 操作成 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], 最少 <span class="number">6</span> 次操作；</span><br><span class="line">i = <span class="number">5</span>，将 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>] 操作成 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]，最少 <span class="number">7</span> 次操作；</span><br><span class="line">返回 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">解释：对于任意计数器编号 i 都无需操作。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">i = <span class="number">0</span>，无需操作；</span><br><span class="line">i = <span class="number">1</span>，将 [<span class="number">1</span>,<span class="number">1</span>] 操作成 [<span class="number">1</span>,<span class="number">2</span>] 或 [<span class="number">0</span>,<span class="number">1</span>] 最少 <span class="number">1</span> 次操作；</span><br><span class="line">i = <span class="number">2</span>，将 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 操作成 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 或 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]，最少 <span class="number">2</span> 次操作；</span><br><span class="line">i = <span class="number">3</span>，将 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] 操作成 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 或 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，最少 <span class="number">3</span> 次操作；</span><br><span class="line">i = <span class="number">4</span>，将 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 操作成 [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，最少 <span class="number">3</span> 次操作；</span><br><span class="line">i = <span class="number">5</span>，将 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 操作成 [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，最少 <span class="number">3</span> 次操作；</span><br><span class="line">返回 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^3</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/5TxKeK" target="_blank" rel="noopener">https://leetcode-cn.com/problems/5TxKeK</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 中位数</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目还是非常有意思的，首先我们设将前<code>i</code>个元素变为目标的递增即可。我们设前<code>i</code>个元素的目标递增等差数列为：<br>$[0+k,1+k,2+k,…,A_{i-1}+k]$,则我们可以求得前<code>i</code>项变为等差数列所需要的操作步数之和为：<script type="math/tex; mode=display">sum_{i} = \sum_{j=1}^{i}|A_{j} - j - k|</script></li><li>我们需要求得上述表达式的最小值即可。我们直接求上述的表达式可能不太好求，但是如果我们将数列变为如下：<script type="math/tex; mode=display">[A_{0}-0,A_{1} -1 ,A_{2} - 2,...,A_{i} - i] \\sum_{i} = \sum_{j=1}^{i}|(A_{j} - j) - k|</script>则我们根据数学定理可以知道，数组的中位数与数组中的各元素的绝对值之差的和最小，所以$k = median_{0..i}$。</li><li>我们知道后，即可根据实际情况将$sum$进行展开：<script type="math/tex; mode=display">sum_{i} = \sum_{A_[i] > A_{median}}A_{i} - \sum_{A_[i] < A_{median}}A_{i}</script>我们进行利用前缀和即可很快的完成上述的求合操作。</li><li>题目还是非常经典的题目，值得思考的地方很多，非常喜欢这类题目。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numsGame(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> suml = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sumr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n,<span class="number">0</span>);</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; pq1;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; pq2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            nums[i] -= i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pq1.push(nums[<span class="number">0</span>]);</span><br><span class="line">        suml = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt;= pq1.top())&#123;</span><br><span class="line">                    pq2.push(nums[i]);</span><br><span class="line">                    sumr += nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sumr += pq1.top();</span><br><span class="line">                    pq2.push(pq1.top());</span><br><span class="line">                    suml -= pq1.top();</span><br><span class="line">                    pq1.pop();</span><br><span class="line">                    suml += nums[i];</span><br><span class="line">                    pq1.push(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i] = (sumr - suml)%mod;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= pq2.top())&#123;</span><br><span class="line">                    pq1.push(nums[i]);</span><br><span class="line">                    suml += nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sumr += nums[i];</span><br><span class="line">                    pq2.push(nums[i]);</span><br><span class="line">                    suml += pq2.top();</span><br><span class="line">                    pq1.push(pq2.top());</span><br><span class="line">                    sumr -= pq2.top();</span><br><span class="line">                    pq2.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i] = (sumr - suml + pq1.top())%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LCP-25-古董键盘"><a href="#LCP-25-古董键盘" class="headerlink" title="LCP 25. 古董键盘"></a>LCP 25. 古董键盘</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>小扣在秋日市集购买了一个古董键盘。由于古董键盘年久失修，键盘上只有 26 个字母 <code>a~z</code> 可以按下，且每个字母最多仅能被按 <code>k</code>次。</p><p>小扣随机按了 <code>n</code> 次按键，请返回小扣总共有可能按出多少种内容。由于数字较大，最终答案需要对 <code>1000000007 (1e9 + 7)</code>取模。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">26</span></span><br><span class="line"></span><br><span class="line">解释：由于只能按一次按键，所有可能的字符串为 <span class="string">"a"</span>, <span class="string">"b"</span>, ... <span class="string">"z"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">650</span></span><br><span class="line"></span><br><span class="line">解释：由于只能按两次按键，且每个键最多只能按一次，所有可能的字符串（按字典序排序）为 <span class="string">"ab"</span>, <span class="string">"ac"</span>, ... <span class="string">"zy"</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= k &lt;= 5</code></li><li><code>1 &lt;= n &lt;= 26*k</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/Uh984O" target="_blank" rel="noopener">https://leetcode-cn.com/problems/Uh984O</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>DP</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的dp模板，需要找到推理公式即可。</li><li>这个dp不太好想到，<code>dp[i][j]</code>代表选择前<code>i</code>个字符组成长度为<code>j</code>的字符串的数目。如果新增加一个字符，组成长度为<code>j</code>的字符串，则要么从n个字符中选择出$x \le k$个空余位置来放置新的字符即可。所以递推公式如下：<script type="math/tex; mode=display">dp[i][j] = \sum_{c=0}^{min(j,k)}dp[i-1][j-c]*C_{j}^{c}</script></li><li>这个递推公式确实不太好想到，智商不够。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">131</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> C[N][N];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">27</span>][N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">keyboard</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span>(C));</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            C[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= min(k,j); ++c)&#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i<span class="number">-1</span>][j-c]*C[j][c])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">26</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-26-导航装置"><a href="#LCP-26-导航装置" class="headerlink" title="LCP 26. 导航装置"></a>LCP 26. 导航装置</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>小扣参加的秋日市集景区共有 <code>N</code>个景点，景点编号为 <code>1~N</code>。景点内设有 <code>N-1</code>条双向道路，使所有景点形成了一个二叉树结构，根结点记为 <code>root</code>，景点编号即为节点值。</p><p>由于秋日市集景区的结构特殊，游客很容易迷路，主办方决定在景区的若干个景点设置导航装置，按照所在景点编号升序排列后定义装置编号为 <code>1 ~ M</code>。导航装置向游客发送数据，数据内容为列表 [游客与装置 1 的相对距离,游客与装置 <code>2</code> 的相对距离,…,游客与装置<code>M</code>的相对距离]。由于游客根据导航装置发送的信息来确认位置，因此主办方需保证游客在每个景点接收的数据信息皆不相同。请返回主办方最少需要设置多少个导航装置。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：在景点 <span class="number">1</span>、<span class="number">3</span> 或景点 <span class="number">1</span>、<span class="number">4</span> 或景点 <span class="number">3</span>、<span class="number">4</span> 设置导航装置。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：在景点 <span class="number">3</span>、<span class="number">4</span> 设置导航装置皆可。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= N &lt;= 50000</code></li><li>二叉树的非空节点值为 1~N 的一个排列。</li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/hSRGyL" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hSRGyL</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>图论</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><h2 id="LCP-27-黑盒光线反射"><a href="#LCP-27-黑盒光线反射" class="headerlink" title="LCP 27. 黑盒光线反射"></a>LCP 27. 黑盒光线反射</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>秋日市集上有个奇怪的黑盒，黑盒的主视图为 <code>n*m</code>的矩形。从黑盒的主视图来看，黑盒的上面和下面各均匀分布有 m 个小孔，黑盒的左面和右面各均匀分布有<code>n</code> 个小孔。黑盒左上角小孔序号为 <code>0</code>，按顺时针编号，总共有 <code>2*(m+n)</code> 个小孔。每个小孔均可以打开或者关闭，初始时，所有小孔均处于关闭状态。每个小孔上的盖子均为镜面材质。例如一个 <code>2*3</code> 的黑盒主视图与其小孔分布如图所示:</p><p>店长告诉小扣，这里是「几何学的快问快答」，店长可能有两种操作：</p><ul><li><code>open(int index, int direction)</code> - 若小孔处于关闭状态，则打开小孔，照入光线；否则直接照入光线；</li><li><p><code>close(int index)</code>- 关闭处于打开状态小孔，店长保证不会关闭已处于关闭状态的小孔；<br>其中：</p></li><li><p><code>index</code>： 表示小孔序号</p></li><li><code>direction：1</code>表示光线沿 <code>y=x</code>方向，-1 表示光线沿 <code>y=-x</code> 方向。</li></ul><p>当光线照至边界时：若边界上的小孔为开启状态，则光线会射出；否则，光线会在小孔之间进行反射。特别地：</p><p>若光线射向未打开的拐角（黑盒顶点），则光线会原路反射回去；<br>光线自拐角处的小孔照入时，只有一种入射方向（如自序号为<code>0</code>的小孔照入方向只能为 <code>-1</code>）</p><p>请帮助小扣判断并返回店长每次照入的光线从几号小孔射出。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"BlackBox"</span>,<span class="string">"open"</span>,<span class="string">"open"</span>,<span class="string">"open"</span>,<span class="string">"close"</span>,<span class="string">"open"</span>]</span><br><span class="line">[[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">-1</span>],[<span class="number">4</span>,<span class="number">-1</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">6</span>],[<span class="number">0</span>,<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">输出：[null,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,null,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">BlackBox b = BlackBox(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 新建一个 2x3 的黑盒</span></span><br><span class="line">b.open(<span class="number">6</span>,<span class="number">-1</span>) <span class="comment">// 打开 6 号小孔，并沿 y=-x 方向照入光线，光线至 0 号小孔反射，从 6 号小孔射出</span></span><br><span class="line">b.open(<span class="number">4</span>,<span class="number">-1</span>) <span class="comment">// 打开 4 号小孔，并沿 y=-x 方向照入光线，光线轨迹为 4-2-8-2-4，从 4 号小孔射出</span></span><br><span class="line">b.open(<span class="number">0</span>,<span class="number">-1</span>) <span class="comment">// 打开 0 号小孔，并沿 y=-x 方向照入光线，由于 6 号小孔为开启状态，光线从 6 号小孔射出</span></span><br><span class="line">b.close(<span class="number">6</span>) <span class="comment">// 关闭 6 号小孔</span></span><br><span class="line">b.shoot(<span class="number">0</span>,<span class="number">-1</span>) <span class="comment">// 从 0 号小孔沿 y=-x 方向照入光线，由于 6 号小孔为关闭状态，4 号小孔为开启状态，光线轨迹为 0-6-4，从 4 号小孔射出</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"BlackBox"</span>,<span class="string">"open"</span>,<span class="string">"open"</span>,<span class="string">"open"</span>,<span class="string">"open"</span>,<span class="string">"close"</span>,<span class="string">"open"</span>,<span class="string">"close"</span>,<span class="string">"open"</span>]</span><br><span class="line">[[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">-1</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">11</span>,<span class="number">-1</span>],[<span class="number">11</span>,<span class="number">1</span>],[<span class="number">1</span>],[<span class="number">11</span>,<span class="number">1</span>],[<span class="number">5</span>],[<span class="number">11</span>,<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">输出：[null,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>,null,<span class="number">5</span>,null,<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BlackBox b = BlackBox(<span class="number">3</span>,<span class="number">3</span>); <span class="comment">// 新建一个 3x3 的黑盒</span></span><br><span class="line">b.open(<span class="number">1</span>,<span class="number">-1</span>) <span class="comment">// 打开 1 号小孔，并沿 y=-x 方向照入光线，光线轨迹为 1-5-7-11-1，从 1 号小孔射出</span></span><br><span class="line">b.open(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">// 打开 5 号小孔，并沿 y=x 方向照入光线，光线轨迹为 5-7-11-1，从 1 号小孔射出</span></span><br><span class="line">b.open(<span class="number">11</span>,<span class="number">-1</span>) <span class="comment">// 打开 11 号小孔，并沿逆 y=-x 方向照入光线，光线轨迹为 11-7-5，从 5 号小孔射出</span></span><br><span class="line">b.open(<span class="number">11</span>,<span class="number">1</span>) <span class="comment">// 从 11 号小孔沿 y=x 方向照入光线，光线轨迹为 11-1，从 1 号小孔射出</span></span><br><span class="line">b.close(<span class="number">1</span>) <span class="comment">// 关闭 1 号小孔</span></span><br><span class="line">b.open(<span class="number">11</span>,<span class="number">1</span>) <span class="comment">// 从 11 号小孔沿 y=x 方向照入光线，光线轨迹为 11-1-5，从 5 号小孔射出</span></span><br><span class="line">b.close(<span class="number">5</span>) <span class="comment">// 关闭 5 号小孔</span></span><br><span class="line">b.open(<span class="number">11</span>,<span class="number">-1</span>) <span class="comment">// 从 11 号小孔沿 y=-x 方向照入光线，光线轨迹为 11-1-5-7-11，从 11 号小孔射出</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= n, m &lt;= 10000</code></li><li><code>1 &lt;= 操作次数 &lt;= 10000</code></li><li><code>direction</code> 仅为<code>1</code> 或<code>-1</code></li><li><code>0 &lt;= index &lt; 2*(m+n)</code></li></ul><h3 id="地址-5"><a href="#地址-5" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/IQvJ9i" target="_blank" rel="noopener">https://leetcode-cn.com/problems/IQvJ9i</a></p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><blockquote><p>图论</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LCCUP团体赛&quot;&gt;&lt;a href=&quot;#LCCUP团体赛&quot; class=&quot;headerlink&quot; title=&quot;LCCUP团体赛&quot;&gt;&lt;/a&gt;LCCUP团体赛&lt;/h1&gt;&lt;p&gt;LCCUP团体赛的题目比个人赛南多了，基本上达到&lt;code&gt;NOI&lt;/code&gt;区域赛的水平，难度还是不小，需要仔细分析和解析。每道题目都值得仔细思考和总结，主要是学习相关的思路。&lt;/p&gt;&lt;h2 id=&quot;LCP-22-黑白方格画&quot;&gt;&lt;a href=&quot;#LCP-22-黑白方格画&quot; class=&quot;headerlink&quot; title=&quot;LCP 22. 黑白方格画&quot;&gt;&lt;/a&gt;LCP 22. 黑白方格画&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有&lt;code&gt;n * n&lt;/code&gt;的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色，所选行数、列数均可为 0。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 207周周赛</title>
    <link href="http://yoursite.com/2020/09/21/205/"/>
    <id>http://yoursite.com/2020/09/21/205/</id>
    <published>2020-09-21T06:16:54.429Z</published>
    <updated>2020-09-21T14:53:56.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="207周周赛"><a href="#207周周赛" class="headerlink" title="207周周赛"></a>207周周赛</h1><p>本周赛因为家庭有事，因此没有时间参加，回来后补解答。前三题常规题目，最后一题真是不错的好题目，题目很少不罗嗦，但是思考程度深入。目测也就是一个小时前三题的节奏，最后一题没有好的思路，知道肯定是状态压缩<code>dp</code>，但是没有想到递推公式。</p><h2 id="1592-重新排列单词间的空格"><a href="#1592-重新排列单词间的空格" class="headerlink" title="1592. 重新排列单词间的空格"></a>1592. 重新排列单词间的空格</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>text</code> ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 <code>text</code>至少包含一个单词 。</p><a id="more"></a><p>请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。</p><p>返回 重新排列空格后的字符串 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text = <span class="string">"  this   is  a sentence "</span></span><br><span class="line">输出：<span class="string">"this   is   a   sentence"</span></span><br><span class="line">解释：总共有 <span class="number">9</span> 个空格和 <span class="number">4</span> 个单词。可以将 <span class="number">9</span> 个空格平均分配到相邻单词之间，相邻单词间空格数为：<span class="number">9</span> / (<span class="number">4</span><span class="number">-1</span>) = <span class="number">3</span> 个。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text = <span class="string">" practice   makes   perfect"</span></span><br><span class="line">输出：<span class="string">"practice   makes   perfect "</span></span><br><span class="line">解释：总共有 <span class="number">7</span> 个空格和 <span class="number">3</span> 个单词。<span class="number">7</span> / (<span class="number">3</span><span class="number">-1</span>) = <span class="number">3</span> 个空格加上 <span class="number">1</span> 个多余的空格。多余的空格需要放在字符串的末尾。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"hello   world"</span></span><br><span class="line">输出：<span class="string">"hello   world"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = <span class="comment">"  walks  udp package   into  bar a"</span></span><br><span class="line">输出：<span class="comment">"walks  udp  package  into  bar  a "</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = <span class="comment">"a"</span></span><br><span class="line">输出：<span class="comment">"a"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= text.length &lt;= 100</code></li><li><code>text</code> 由小写英文字母和 ‘ ‘ 组成</li><li><code>text</code> 中至少包含一个单词</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/rearrange-spaces-between-words" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rearrange-spaces-between-words</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环，检查行与列即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reorderSpaces</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// trim去除头尾空格 在JDK11中加入了strip</span></span><br><span class="line">        String[] splited = text.trim().split(<span class="string">"\\s+"</span>);</span><br><span class="line">        <span class="comment">// String[] splited = text.strip().split("\\s+");</span></span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(splited));</span></span><br><span class="line">        <span class="comment">// 记录多少个单词</span></span><br><span class="line">        <span class="keyword">int</span> wordCnt = splited.length;</span><br><span class="line">        <span class="comment">// 记录单词总长</span></span><br><span class="line">        <span class="keyword">int</span> wordLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String word : splited) &#123;</span><br><span class="line">            wordLen += word.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 空格数量</span></span><br><span class="line">        <span class="keyword">int</span> spaceCnt = text.length() - wordLen;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 只用在前n-1个单词后面加空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; splited.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            sb.append(splited[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; spaceCnt / (wordCnt - <span class="number">1</span>); j++) &#123;</span><br><span class="line">                sb.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个单词直接加上去</span></span><br><span class="line">        sb.append(splited[splited.length - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 补齐剩余的空格</span></span><br><span class="line">        <span class="keyword">while</span> (sb.length() &lt; text.length()) &#123;</span><br><span class="line">            sb.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1593-拆分字符串使唯一子字符串的数目最大"><a href="#1593-拆分字符串使唯一子字符串的数目最大" class="headerlink" title="1593. 拆分字符串使唯一子字符串的数目最大"></a>1593. 拆分字符串使唯一子字符串的数目最大</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。</p><p>字符串 <code>s</code> 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。</p><p>注意：子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"ababccc"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一种最大拆分方法为 [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'ab'</span>, <span class="string">'c'</span>, <span class="string">'cc'</span>] 。像 [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'cc'</span>] 这样拆分不满足题目要求，因为其中的 <span class="string">'a'</span> 和 <span class="string">'b'</span> 都出现了不止一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aba"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：一种最大拆分方法为 [<span class="string">'a'</span>, <span class="string">'ba'</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aa"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：无法进一步拆分字符串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s 仅包含小写英文字母</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目一开始想到的就是回溯，但是觉得没有这么简单吧，竟然出现DFS的简单题目，后来发现是自己想复杂了。</li><li>简单的回溯，利用set剪枝即可实现，太无趣的题目了。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp; s,<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp; curr, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> left = s.substr(l,i-l+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(curr.count(left)) <span class="keyword">continue</span>;</span><br><span class="line">            curr.insert(left);</span><br><span class="line">            <span class="keyword">int</span> x = dfs(s,curr,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                ans = max(ans,<span class="number">1</span> + x);</span><br><span class="line">            &#125;</span><br><span class="line">            curr.erase(left);</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUniqueSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; curr;</span><br><span class="line">        <span class="keyword">return</span> dfs(s,curr,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1594-矩阵的最大非负积"><a href="#1594-矩阵的最大非负积" class="headerlink" title="1594. 矩阵的最大非负积"></a>1594. 矩阵的最大非负积</h2><p>给你一个大小为 <code>rows x cols</code> 的矩阵 <code>grid</code>。最初，你位于左上角<code>(0, 0)</code> ，每一步，你可以在矩阵中 向右 或 向下 移动。</p><p>在从左上角<code>(0, 0)</code> 开始到右下角<code>(rows - 1, cols - 1)</code>结束的所有路径中，找出具有 最大非负积 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p><p>返回 最大非负积 对 <code>109 + 7</code> 取余 的结果。如果最大积为负数，则返回 <code>-1</code>。</p><p>注意，取余是在得到最大积之后执行的。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>],</span><br><span class="line">             [<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-3</span>],</span><br><span class="line">             [<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：从 (<span class="number">0</span>, <span class="number">0</span>) 到 (<span class="number">2</span>, <span class="number">2</span>) 的路径中无法得到非负积，所以返回 <span class="number">-1</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">3</span>,<span class="number">-4</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：最大非负积对应的路径已经用粗体标出 (<span class="number">1</span> * <span class="number">1</span> * <span class="number">-2</span> * <span class="number">-4</span> * <span class="number">1</span> = <span class="number">8</span>)</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">-4</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最大非负积对应的路径已经用粗体标出 (<span class="number">1</span> * <span class="number">0</span> * <span class="number">-4</span> = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[ <span class="number">1</span>, <span class="number">4</span>,<span class="number">4</span>,<span class="number">0</span>],</span><br><span class="line">             [<span class="number">-2</span>, <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">             [ <span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最大非负积对应的路径已经用粗体标出 (<span class="number">1</span> * <span class="number">-2</span> * <span class="number">1</span> * <span class="number">-1</span> * <span class="number">1</span> * <span class="number">1</span> = <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= rows, cols &lt;= 15</code></li><li><code>-4 &lt;= grid[i][j] &lt;= 4</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的dp，因为这里涉及到数据正负的问题，所以我们可以利用最小值和最大值的dp。<code>leetcode</code>上应该有原题，非常无趣的题目。</li><li>也可以dfs回溯。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProductPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp1(row,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(col,INT_MIN));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp2(row,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(col,INT_MAX));</span><br><span class="line">        </span><br><span class="line">        dp1[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        dp2[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            dp1[i][<span class="number">0</span>] = dp1[i<span class="number">-1</span>][<span class="number">0</span>]*grid[i][<span class="number">0</span>];</span><br><span class="line">            dp2[i][<span class="number">0</span>] = dp2[i<span class="number">-1</span>][<span class="number">0</span>]*grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            dp1[<span class="number">0</span>][j] = dp1[<span class="number">0</span>][j<span class="number">-1</span>]*grid[<span class="number">0</span>][j];</span><br><span class="line">            dp2[<span class="number">0</span>][j] = dp2[<span class="number">0</span>][j<span class="number">-1</span>]*grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                dp1[i][j] = max(dp1[i][j],(<span class="keyword">long</span> <span class="keyword">long</span>)grid[i][j]*dp1[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp1[i][j] = max(dp1[i][j],(<span class="keyword">long</span> <span class="keyword">long</span>)grid[i][j]*dp1[i][j<span class="number">-1</span>]);</span><br><span class="line">                dp1[i][j] = max(dp1[i][j],(<span class="keyword">long</span> <span class="keyword">long</span>)grid[i][j]*dp2[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp1[i][j] = max(dp1[i][j],(<span class="keyword">long</span> <span class="keyword">long</span>)grid[i][j]*dp2[i][j<span class="number">-1</span>]);</span><br><span class="line">                dp2[i][j] = min(dp2[i][j],(<span class="keyword">long</span> <span class="keyword">long</span>)grid[i][j]*dp1[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp2[i][j] = min(dp2[i][j],(<span class="keyword">long</span> <span class="keyword">long</span>)grid[i][j]*dp1[i][j<span class="number">-1</span>]);</span><br><span class="line">                dp2[i][j] = min(dp2[i][j],(<span class="keyword">long</span> <span class="keyword">long</span>)grid[i][j]*dp2[i<span class="number">-1</span>][j]);</span><br><span class="line">                dp2[i][j] = min(dp2[i][j],(<span class="keyword">long</span> <span class="keyword">long</span>)grid[i][j]*dp2[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp1[row<span class="number">-1</span>][col<span class="number">-1</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp1[row<span class="number">-1</span>][col<span class="number">-1</span>]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="595-连通两组点的最小成本"><a href="#595-连通两组点的最小成本" class="headerlink" title="595. 连通两组点的最小成本"></a>595. 连通两组点的最小成本</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两组点，其中第一组中有 <code>size1</code> 个点，第二组中有 <code>size2</code>个点，且 <code>size1 &gt;= size2</code> 。</p><p>任意两点间的连接成本 <code>cost</code>由大小为 <code>size1 x size2</code>矩阵给出，其中 <code>cost[i][j]</code>是第一组中的点 i 和第二组中的点 j 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。</p><p>返回连通两组点所需的最小成本。</p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [[<span class="number">15</span>, <span class="number">96</span>], [<span class="number">36</span>, <span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">17</span></span><br><span class="line">解释：连通两组点的最佳方法是：</span><br><span class="line"><span class="number">1</span>--A</span><br><span class="line"><span class="number">2</span>--B</span><br><span class="line">总成本为 <span class="number">17</span> 。</span><br></pre></td></tr></table></figure><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：连通两组点的最佳方法是：</span><br><span class="line"><span class="number">1</span>--A</span><br><span class="line"><span class="number">2</span>--B</span><br><span class="line"><span class="number">2</span>--C</span><br><span class="line"><span class="number">3</span>--A</span><br><span class="line">最小成本为 <span class="number">4</span> 。</span><br><span class="line">请注意，虽然有多个点连接到第一组中的点 <span class="number">2</span> 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [[<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">8</span>, <span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>size1 == cost.length</code></li><li><code>size2 == cost[i].length</code></li><li><code>1 &lt;= size1, size2 &lt;= 12</code></li><li><code>size1 &gt;= size2</code></li><li><code>0 &lt;= cost[i][j] &lt;= 100</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-connect-two-groups-of-points" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-connect-two-groups-of-points</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩DP</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先拿到题目一看估计就是<code>dp</code>,然后再看数据量级基本就可以确定本题是状态压缩<code>dp</code>. 关键在于递推公式的确定。</li><li>我们设$dp[i][state]$表示数组1前<code>i</code>个元素与数组2中的$x$个元素相连的最小代价，其中$state$代表x个元素的分布状态。我们再计算加入第<code>i+1</code>个元素的转移方程。</li><li>当加入第<code>i+1</code>个元素时，第一种做法是直接在第二个数组中已连接的元素中找一个，进行连接即可，我们直接枚举$2^{n}$次即可;</li><li>当加入第<code>i+1</code>个元素时，第二种做法是从第二个数组中未连接的元素中找出任意的$x$个元素进行连接即可。对于第二种做法，我们可以直接枚举所有的$x$,用$state_{x}$表示，这里可以用位运算枚举子集的方法来进行优化。</li><li>最后的总时间复杂度为$O(NM\cdot3^M)$。</li><li>题目确实很难，这个题目确实不会。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">13</span>][<span class="number">4097</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connectTwoGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = cost.size();</span><br><span class="line">        <span class="keyword">int</span> n = cost[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;n); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] == INF) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = (<span class="number">1</span>&lt;&lt;k)|j;</span><br><span class="line">                    dp[i][nx] = min(dp[i][nx],dp[i<span class="number">-1</span>][j] + cost[i<span class="number">-1</span>][k]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*取反*/</span></span><br><span class="line">                <span class="keyword">int</span> v = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> - j;</span><br><span class="line">                <span class="keyword">if</span> (v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/*每次进行减1操作*/</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x &gt; <span class="number">0</span>; x = v &amp; (x - <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; ++y)</span><br><span class="line">                            <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; y))</span><br><span class="line">                                c += cost[i<span class="number">-1</span>][y];</span><br><span class="line">                        <span class="keyword">int</span> nxt = j | x;</span><br><span class="line">                        dp[i][nxt] = min(dp[i][nxt],dp[i<span class="number">-1</span>][j] + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;207周周赛&quot;&gt;&lt;a href=&quot;#207周周赛&quot; class=&quot;headerlink&quot; title=&quot;207周周赛&quot;&gt;&lt;/a&gt;207周周赛&lt;/h1&gt;&lt;p&gt;本周赛因为家庭有事，因此没有时间参加，回来后补解答。前三题常规题目，最后一题真是不错的好题目，题目很少不罗嗦，但是思考程度深入。目测也就是一个小时前三题的节奏，最后一题没有好的思路，知道肯定是状态压缩&lt;code&gt;dp&lt;/code&gt;，但是没有想到递推公式。&lt;/p&gt;&lt;h2 id=&quot;1592-重新排列单词间的空格&quot;&gt;&lt;a href=&quot;#1592-重新排列单词间的空格&quot; class=&quot;headerlink&quot; title=&quot;1592. 重新排列单词间的空格&quot;&gt;&lt;/a&gt;1592. 重新排列单词间的空格&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串&lt;code&gt;text&lt;/code&gt; ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 &lt;code&gt;text&lt;/code&gt;至少包含一个单词 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 35周双周赛</title>
    <link href="http://yoursite.com/2020/09/20/204/"/>
    <id>http://yoursite.com/2020/09/20/204/</id>
    <published>2020-09-20T14:29:07.452Z</published>
    <updated>2020-09-20T14:29:12.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="35周双周赛"><a href="#35周双周赛" class="headerlink" title="35周双周赛"></a>35周双周赛</h1><p>最后一题确实不懂，其余题目比较中规中矩。最后排名191.<br><img src="https://i.loli.net/2020/09/20/sawo7BzC6cPimrA.png" alt="1"></p><h2 id="5503-所有奇数长度子数组的和"><a href="#5503-所有奇数长度子数组的和" class="headerlink" title="5503. 所有奇数长度子数组的和"></a>5503. 所有奇数长度子数组的和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数数组 <code>arr</code> ，请你计算所有可能的奇数长度子数组的和。</p><p>子数组 定义为原数组中的一个连续子序列。</p><p>请你返回 <code>arr</code> 中 所有奇数长度子数组的和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">58</span></span><br><span class="line">解释：所有奇数长度子数组和它们的和为：</span><br><span class="line">[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">[<span class="number">5</span>] = <span class="number">5</span></span><br><span class="line">[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>] = <span class="number">7</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] = <span class="number">11</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>] = <span class="number">10</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>] = <span class="number">15</span></span><br><span class="line">我们将所有值求和得到 <span class="number">1</span> + <span class="number">4</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">3</span> + <span class="number">7</span> + <span class="number">11</span> + <span class="number">10</span> + <span class="number">15</span> = <span class="number">58</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：总共只有 <span class="number">2</span> 个长度为奇数的子数组，[<span class="number">1</span>] 和 [<span class="number">2</span>]。它们的和为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="number">66</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 100</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环，检查行与列即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;  j + i &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k)&#123;</span><br><span class="line">                    sum += arr[j+k];</span><br><span class="line">                &#125;</span><br><span class="line">                ans += sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5505-所有排列中的最大和"><a href="#5505-所有排列中的最大和" class="headerlink" title="5505. 所有排列中的最大和"></a>5505. 所有排列中的最大和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有一个整数数组 <code>nums</code> ，和一个查询数组 <code>requests</code> ，其中 <code>requests[i] = [starti, endi]</code> 。第 <code>i</code> 个查询求 <code>nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]</code>的结果 ，<code>starti</code> 和 <code>endi</code> 数组索引都是 从 <code>0</code> 开始 的。</p><p>你可以任意排列 <code>nums</code> 中的数字，请你返回所有查询结果之和的最大值。</p><p>由于答案可能会很大，请你将它对 <code>109 + 7</code> 取余 后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], requests = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">19</span></span><br><span class="line">解释：一个可行的 nums 排列为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]，并有如下结果：</span><br><span class="line">requests[<span class="number">0</span>] -&gt; nums[<span class="number">1</span>] + nums[<span class="number">2</span>] + nums[<span class="number">3</span>] = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">8</span></span><br><span class="line">requests[<span class="number">1</span>] -&gt; nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">总和为：<span class="number">8</span> + <span class="number">3</span> = <span class="number">11</span>。</span><br><span class="line">一个总和更大的排列为 [<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]，并有如下结果：</span><br><span class="line">requests[<span class="number">0</span>] -&gt; nums[<span class="number">1</span>] + nums[<span class="number">2</span>] + nums[<span class="number">3</span>] = <span class="number">5</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">11</span></span><br><span class="line">requests[<span class="number">1</span>] -&gt; nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">3</span> + <span class="number">5</span>  = <span class="number">8</span></span><br><span class="line">总和为： <span class="number">11</span> + <span class="number">8</span> = <span class="number">19</span>，这个方案是所有排列中查询之和最大的结果。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], requests = [[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：一个总和最大的排列为 [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] ，查询和为 [<span class="number">11</span>]。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>], requests = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">47</span></span><br><span class="line">解释：一个和最大的排列为 [<span class="number">4</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] ，查询结果分别为 [<span class="number">19</span>,<span class="number">18</span>,<span class="number">10</span>]。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 105</li><li>0 &lt;= nums[i] &lt;= 105</li><li>1 &lt;= requests.length &lt;= 105</li><li>requests[i].length == 2</li><li>0 &lt;= starti &lt;= endi &lt; n</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-sum-obtained-of-any-permutation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-sum-obtained-of-any-permutation</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 查分数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较典型的查分数组。我们求出所有索引位置的查询次数，我们按照查询次数从小到大依次填入数组中的元素即可。</li><li>这个题目关键在于如何在低于<code>O(n^2)</code>的时间复杂度内求出所有的索引位置的查询次数。</li><li>差分数组很方便的解决了这个问题。或者更麻烦的，我们可以利用线段数，O(lgn)时间复杂度内完成范围数据的更新。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumRangeQuery</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requests)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; query(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : requests)&#123;</span><br><span class="line">            query[v[<span class="number">0</span>]]++;</span><br><span class="line">            query[v[<span class="number">1</span>]+<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            query[i] += query[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        sort(query.begin(),query.end()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans = (ans + (<span class="keyword">long</span> <span class="keyword">long</span>)query[i]*nums[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5504-使数组和能被-P-整除"><a href="#5504-使数组和能被-P-整除" class="headerlink" title="5504. 使数组和能被 P 整除"></a>5504. 使数组和能被 P 整除</h2><p>给你一个正整数数组 <code>nums</code>，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被<code>p</code>整除。 不允许 将整个数组都移除。</p><p>请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 <code>-1</code>。</p><p>子数组 定义为原数组中连续的一组元素。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>], p = <span class="number">6</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：nums 中元素和为 <span class="number">10</span>，不能被 p 整除。我们可以移除子数组 [<span class="number">4</span>] ，剩余元素的和为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>], p = <span class="number">9</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：我们无法移除任何一个元素使得和被 <span class="number">9</span> 整除，最优方案是移除子数组 [<span class="number">5</span>,<span class="number">2</span>] ，剩余元素为 [<span class="number">6</span>,<span class="number">3</span>]，和为 <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], p = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：和恰好为 <span class="number">6</span> ，已经能被 <span class="number">3</span> 整除了。所以我们不需要移除任何元素。</span><br></pre></td></tr></table></figure><br>示例  4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], p = <span class="number">7</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：没有任何方案使得移除子数组后剩余元素的和被 <span class="number">7</span> 整除。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1000000000</span>,<span class="number">1000000000</span>,<span class="number">1000000000</span>], p = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li><li><code>1 &lt;= p &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-sum-divisible-by-p" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-sum-divisible-by-p</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 典型的滑动窗口</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个类型的题目可以与很多题目类似，可以把这些类似的题目全部总结道一块。凡是涉及道子数组和的问题，全部都可以用类似的解法来做。</li><li>设<code>dp[i]</code>代表前缀和对$p$取模结果为$i$的最大长度。则我们首先求出数组的总和对<code>p</code>取模的余数$rest$.</li><li>我们其实只需要在数组中找到连续子树的和对$p$取模的余数也为$rest$的最短长度即可，我们减去该子数组即可。</li><li>如果求对$p$取模的余数也为$rest$的最短长度的子数组，需要仔细思考一下，我们求出每个以<code>i</code>为结尾的符合要求的子数组的最短长度即可。</li><li>我们求的从<code>0</code>到<code>i</code>的前缀和为$pre[i]$，$pre[i]$对<code>p</code>取模的结果为<code>x</code>,则此时我们需要求出前缀和中是否存在取模的余数为$(x-rest+p) \mod p$即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sum += nums[i];</span><br><span class="line">        <span class="keyword">int</span> rest = sum%p;</span><br><span class="line">        <span class="keyword">if</span>(rest == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            sum += nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> x = (sum - rest + p)%p;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(x))&#123;</span><br><span class="line">                ans = min(ans,i - cnt[x]);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[sum%p] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5506-奇怪的打印机-II"><a href="#5506-奇怪的打印机-II" class="headerlink" title="5506. 奇怪的打印机 II"></a>5506. 奇怪的打印机 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个奇怪的打印机，它有如下两个特殊的打印规则：</p><p>每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。<br>一旦矩形根据上面的规则使用了一种颜色，那么 相同的颜色不能再被使用 。<br>给你一个初始没有颜色的 <code>m x n</code> 的矩形 <code>targetGrid</code>，其中 <code>targetGrid[row][col]</code>是位置 <code>(row, col)</code> 的颜色。</p><p>如果你能按照上述规则打印出矩形 <code>targetGrid</code>，请你返回 <code>true</code> ，否则返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：targetGrid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：targetGrid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：targetGrid = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：没有办法得到 targetGrid ，因为每一轮操作使用的颜色互不相同。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：targetGrid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == targetGrid.length</code></li><li><code>n == targetGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 60</code></li><li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/strange-printer-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/strange-printer-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>拓扑排序</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目好奇怪，实际我们根据当前图中颜色的情况，预测出每种颜色的所占的区域的矩形的空间。</li><li>凡是存在颜色重叠的区域的点，则该点中已经被覆盖的颜色肯定是在最终的颜色之前所涂。</li><li>我们求出所有颜色的先后依赖关系，然后进行拓扑排序，查看所有的颜色是否可以完成拓扑排序即可。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">61</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPrintable</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; targetGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = targetGrid.size();</span><br><span class="line">        <span class="keyword">int</span> col = targetGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minX(N,INT_MAX);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minY(N,INT_MAX);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxX(N,INT_MIN);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxY(N,INT_MIN);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; g(N,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; exsit(N,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*get all the retangle*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> c = targetGrid[i][j];</span><br><span class="line">                exsit[c] = <span class="literal">true</span>;</span><br><span class="line">                minX[c] = min(minX[c],i);</span><br><span class="line">                minY[c] = min(minY[c],j);</span><br><span class="line">                maxX[c] = max(maxX[c],i);</span><br><span class="line">                maxY[c] = max(maxY[c],j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> c = targetGrid[i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; N; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!exsit[k] || k == c) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= minX[k] &amp;&amp; j &gt;= minY[k] &amp;&amp; </span><br><span class="line">                       i &lt;= maxX[k] &amp;&amp; j &lt;= maxY[k])&#123;</span><br><span class="line">                           g[k][c] = <span class="literal">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*top sort*/</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(N,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j])&#123;</span><br><span class="line">                    indegree[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(N,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(exsit[i] &amp;&amp; indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                qu.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            visit[curr] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(exsit[i] &amp;&amp; g[curr][i])&#123;</span><br><span class="line">                    indegree[i]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                        qu.push(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(exsit[i]&amp;&amp;!visit[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;35周双周赛&quot;&gt;&lt;a href=&quot;#35周双周赛&quot; class=&quot;headerlink&quot; title=&quot;35周双周赛&quot;&gt;&lt;/a&gt;35周双周赛&lt;/h1&gt;&lt;p&gt;最后一题确实不懂，其余题目比较中规中矩。最后排名191.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/09/20/sawo7BzC6cPimrA.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5503-所有奇数长度子数组的和&quot;&gt;&lt;a href=&quot;#5503-所有奇数长度子数组的和&quot; class=&quot;headerlink&quot; title=&quot;5503. 所有奇数长度子数组的和&quot;&gt;&lt;/a&gt;5503. 所有奇数长度子数组的和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个正整数数组 &lt;code&gt;arr&lt;/code&gt; ，请你计算所有可能的奇数长度子数组的和。&lt;/p&gt;&lt;p&gt;子数组 定义为原数组中的一个连续子序列。&lt;/p&gt;&lt;p&gt;请你返回 &lt;code&gt;arr&lt;/code&gt; 中 所有奇数长度子数组的和 。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;58&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：所有奇数长度子数组和它们的和为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们将所有值求和得到 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;58&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：总共只有 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 个长度为奇数的子数组，[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] 和 [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]。它们的和为 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;66&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 LCCUP个人赛</title>
    <link href="http://yoursite.com/2020/09/17/203/"/>
    <id>http://yoursite.com/2020/09/17/203/</id>
    <published>2020-09-16T16:16:46.787Z</published>
    <updated>2020-09-17T04:22:23.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCCUP个人赛"><a href="#LCCUP个人赛" class="headerlink" title="LCCUP个人赛"></a>LCCUP个人赛</h1><p>LCCUP个人赛做出了三道题，T4题目的思路是对的，为什么测试用例总是过不了，仔细查看了下代码，没有什么问题。后来测试了<br><img src="https://i.loli.net/2020/09/13/iWRbT3OUQdSVezv.png" alt></p><h2 id="1-速算机器人"><a href="#1-速算机器人" class="headerlink" title="1. 速算机器人"></a>1. 速算机器人</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 x 和 y），请小扣说出计算指令：</p><ul><li><code>&quot;A&quot;</code>运算：使 <code>x = 2 * x + y</code>；</li><li><code>&quot;B&quot;</code> 运算：使 <code>y = 2 * y + x</code>。<br>在本次游戏中，店家说出的数字为 <code>x = 1</code>和 <code>y = 0</code>，小扣说出的计算指令记作仅由大写字母 <code>A、B</code> 组成的字符串 s，字符串中字符的顺序表示计算顺序，请返回最终 <code>x</code> 与 <code>y</code> 的和为多少。</li></ul><a id="more"></a><p>示例 1：<br><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"AB"</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">经过一次 A 运算后，<span class="symbol">x</span> = <span class="number">2</span>, <span class="symbol">y</span> = <span class="number">0</span>。</span><br><span class="line">再经过一次 B 运算，<span class="symbol">x</span> = <span class="number">2</span>, <span class="symbol">y</span> = <span class="number">2</span>。</span><br><span class="line">最终 <span class="symbol">x</span> 与 <span class="symbol">y</span> 之和为 <span class="number">4</span>。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>0 &lt;= s.length &lt;= 10</code></li><li><code>s 由 &#39;A&#39; 和 &#39;B&#39; 组成</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2020-fall/problems/nGK0Fy/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2020-fall/problems/nGK0Fy/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>签到题<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'A'</span>)&#123;</span><br><span class="line">                x = <span class="number">2</span> * x + y;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'B'</span>)&#123;</span><br><span class="line">                y = <span class="number">2</span> * y + x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="2-早餐组合"><a href="#2-早餐组合" class="headerlink" title="2. 早餐组合"></a>2. 早餐组合</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>小扣在秋日市集选择了一家早餐摊位，一维整型数组 <code>staple</code>中记录了每种主食的价格，一维整型数组<code>drinks</code>中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过 <code>x</code>元。请返回小扣共有多少种购买方案。</p><p>注意：答案需要以 <code>1e9 + 7 (1000000007)</code>为底取模，如：计算初始结果为：<code>1000000008</code>，请返回 1</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：staple = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">5</span>], drinks = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>], x = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">解释：小扣有 <span class="number">6</span> 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：</span><br><span class="line">第 <span class="number">1</span> 种方案：staple[<span class="number">0</span>] + drinks[<span class="number">0</span>] = <span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span>；</span><br><span class="line">第 <span class="number">2</span> 种方案：staple[<span class="number">0</span>] + drinks[<span class="number">1</span>] = <span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span>；</span><br><span class="line">第 <span class="number">3</span> 种方案：staple[<span class="number">0</span>] + drinks[<span class="number">2</span>] = <span class="number">10</span> + <span class="number">2</span> = <span class="number">12</span>；</span><br><span class="line">第 <span class="number">4</span> 种方案：staple[<span class="number">2</span>] + drinks[<span class="number">0</span>] = <span class="number">5</span> + <span class="number">5</span> = <span class="number">10</span>；</span><br><span class="line">第 <span class="number">5</span> 种方案：staple[<span class="number">2</span>] + drinks[<span class="number">1</span>] = <span class="number">5</span> + <span class="number">5</span> = <span class="number">10</span>；</span><br><span class="line">第 <span class="number">6</span> 种方案：staple[<span class="number">2</span>] + drinks[<span class="number">2</span>] = <span class="number">5</span> + <span class="number">2</span> = <span class="number">7</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：staple = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>], drinks = [<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">1</span>], x = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line"></span><br><span class="line">解释：小扣有 <span class="number">8</span> 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：</span><br><span class="line">第 <span class="number">1</span> 种方案：staple[<span class="number">0</span>] + drinks[<span class="number">2</span>] = <span class="number">2</span> + <span class="number">5</span> = <span class="number">7</span>；</span><br><span class="line">第 <span class="number">2</span> 种方案：staple[<span class="number">0</span>] + drinks[<span class="number">3</span>] = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span>；</span><br><span class="line">第 <span class="number">3</span> 种方案：staple[<span class="number">1</span>] + drinks[<span class="number">0</span>] = <span class="number">1</span> + <span class="number">8</span> = <span class="number">9</span>；</span><br><span class="line">第 <span class="number">4</span> 种方案：staple[<span class="number">1</span>] + drinks[<span class="number">2</span>] = <span class="number">1</span> + <span class="number">5</span> = <span class="number">6</span>；</span><br><span class="line">第 <span class="number">5</span> 种方案：staple[<span class="number">1</span>] + drinks[<span class="number">3</span>] = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>；</span><br><span class="line">第 <span class="number">6</span> 种方案：staple[<span class="number">2</span>] + drinks[<span class="number">0</span>] = <span class="number">1</span> + <span class="number">8</span> = <span class="number">9</span>；</span><br><span class="line">第 <span class="number">7</span> 种方案：staple[<span class="number">2</span>] + drinks[<span class="number">2</span>] = <span class="number">1</span> + <span class="number">5</span> = <span class="number">6</span>；</span><br><span class="line">第 <span class="number">8</span> 种方案：staple[<span class="number">2</span>] + drinks[<span class="number">3</span>] = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>；</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= staple.length &lt;= 10^5</code></li><li><code>1 &lt;= drinks.length &lt;= 10^5</code></li><li><code>1 &lt;= staple[i],drinks[i] &lt;= 10^5</code></li><li><code>1 &lt;= x &lt;= 2*10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2020-fall/problems/2vYnGI/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2020-fall/problems/2vYnGI/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找模板提</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>二分查找。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">breakfastNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; staple, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; drinks, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        sort(staple.begin(),staple.end());</span><br><span class="line">        sort(drinks.begin(),drinks.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; staple.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(staple[i] &gt; x) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">auto</span> it = upper_bound(drinks.begin(),drinks.end(),x-staple[i]);</span><br><span class="line">            ans = (ans + (it-drinks.begin()))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-秋叶收藏集"><a href="#3-秋叶收藏集" class="headerlink" title="3.秋叶收藏集"></a>3.秋叶收藏集</h2><p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 <code>leaves</code>， 字符串 <code>leaves</code> 仅包含小写字符 <code>r</code> 和 <code>y</code>， 其中字符 <code>r</code>表示一片红叶，字符 <code>y</code>表示一片黄叶。<br>出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">leaves</span> = <span class="string">"rrryyyrryyyrr"</span></span><br></pre></td></tr></table></figure><br>输出：2<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解释：调整两次，将中间的两片红叶替换成黄叶，得到 <span class="string">"rrryyyyyyyyrr"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：leaves = <span class="string">"ryr"</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：已符合要求，不需要额外操作</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>3 &lt;= leaves.length &lt;= 10^5</code></li><li><code>leaves</code>中只包含字符 <code>&#39;r&#39;</code>和字符 <code>&#39;y&#39;</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2020-fall/problems/UlBDOe/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2020-fall/problems/UlBDOe/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们设<code>dp[i]</code>表示当前<code>i</code>作为调整为<code>[红、黄]</code>两部分的最小操作，则递推公式如下：</li></ol><ul><li>假设当前的<code>leaves[i]</code>为黄色<code>y</code>,则我们可以有两种选择，要么将<code>[0,i-1]</code>的叶子全部变为红色,此时的操作数目为<code>[0,n-1]</code>中的黄色叶子数目，则直接调整完成满足要求;要么直接将当前的黄色叶子加入到已经调整完成前<code>i-1</code>个叶子后面即可。则此时：<script type="math/tex; mode=display">dp[i] = min(dp[i],ly[i-1])\\</script></li><li>假设当前的<code>leaves[i]</code>为红色<code>r</code>,首先我们需要将当前的红色变为黄色<code>y</code>,后续的操作与上述相同。<script type="math/tex; mode=display">dp[i] = min(dp[i],ly[i-1]) + 1\\</script></li><li>对于索引<code>0</code>处，应当特殊处理，因为<code>0</code>只有一片叶子。</li></ul><ol><li>我们将前<code>i</code>个叶子完成<code>[红、黄]</code>调整后，再将<code>i+1</code>以后的叶子全部变为红色即可满足题目<code>[红、黄、红]</code>要求。则此时：<script type="math/tex; mode=display">ans = min(ans,dp[i] + ry[i+1])</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">string</span> leaves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = leaves.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ly(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ry(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">2</span>,INT_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cly = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leaves[i] == <span class="string">'y'</span>) cly++;</span><br><span class="line">            <span class="keyword">if</span>(leaves[n<span class="number">-1</span>-i] == <span class="string">'y'</span>) cry++;    </span><br><span class="line">            ly[i] = cly;    </span><br><span class="line">            ry[n<span class="number">-1</span>-i] = cry;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = (leaves[<span class="number">0</span>] == <span class="string">'y'</span> ? <span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            dp[i] = min(dp[i<span class="number">-1</span>],ly[i<span class="number">-1</span>]) + (leaves[i] == <span class="string">'r'</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            ans = min(ans,dp[i] + ry[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-20-快速公交"><a href="#LCP-20-快速公交" class="headerlink" title="LCP 20. 快速公交"></a>LCP 20. 快速公交</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>小扣打算去秋日市集，由于游客较多，小扣的移动速度受到了人流影响：</p><ul><li>小扣从 <code>x</code> 号站点移动至 <code>x + 1</code> 号站点需要花费的时间为 <code>inc</code>；</li><li>小扣从 <code>x</code>号站点移动至 <code>x - 1</code>号站点需要花费的时间为 <code>dec</code>。<br>现有 m 辆公交车，编号为 <code>0</code> 到<code>m-1</code>。小扣也可以通过搭乘编号为 i 的公交车，从 x 号站点移动至 <code>jump[i]*x</code>号站点，耗时仅为 <code>cost[i]</code>。小扣可以搭乘任意编号的公交车且搭乘公交次数不限。</li></ul><p>假定小扣起始站点记作 0，秋日市集站点记作 <code>target</code>，请返回小扣抵达秋日市集最少需要花费多少时间。由于数字较大，最终答案需要对 <code>1000000007 (1e9 + 7)</code>取模。</p><p>注意：小扣可在移动过程中到达编号大于 <code>target</code> 的站点。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">31</span>, inc = <span class="number">5</span>, dec = <span class="number">3</span>, jump = [<span class="number">6</span>], cost = [<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">33</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">小扣步行至 <span class="number">1</span> 号站点，花费时间为 <span class="number">5</span>；</span><br><span class="line">小扣从 <span class="number">1</span> 号站台搭乘 <span class="number">0</span> 号公交至 <span class="number">6</span> * <span class="number">1</span> = <span class="number">6</span> 站台，花费时间为 <span class="number">10</span>；</span><br><span class="line">小扣从 <span class="number">6</span> 号站台步行至 <span class="number">5</span> 号站台，花费时间为 <span class="number">3</span>；</span><br><span class="line">小扣从 <span class="number">5</span> 号站台搭乘 <span class="number">0</span> 号公交至 <span class="number">6</span> * <span class="number">5</span> = <span class="number">30</span> 站台，花费时间为 <span class="number">10</span>；</span><br><span class="line">小扣从 <span class="number">30</span> 号站台步行至 <span class="number">31</span> 号站台，花费时间为 <span class="number">5</span>；</span><br><span class="line">最终小扣花费总时间为 <span class="number">33</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">612</span>, inc = <span class="number">4</span>, dec = <span class="number">5</span>, jump = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">4</span>], cost = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">26</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">小扣步行至 <span class="number">1</span> 号站点，花费时间为 <span class="number">4</span>；</span><br><span class="line">小扣从 <span class="number">1</span> 号站台搭乘 <span class="number">0</span> 号公交至 <span class="number">3</span> * <span class="number">1</span> = <span class="number">3</span> 站台，花费时间为 <span class="number">4</span>；</span><br><span class="line">小扣从 <span class="number">3</span> 号站台搭乘 <span class="number">3</span> 号公交至 <span class="number">11</span> * <span class="number">3</span> = <span class="number">33</span> 站台，花费时间为 <span class="number">3</span>；</span><br><span class="line">小扣从 <span class="number">33</span> 号站台步行至 <span class="number">34</span> 站台，花费时间为 <span class="number">4</span>；</span><br><span class="line">小扣从 <span class="number">34</span> 号站台搭乘 <span class="number">0</span> 号公交至 <span class="number">3</span> * <span class="number">34</span> = <span class="number">102</span> 站台，花费时间为 <span class="number">4</span>；</span><br><span class="line">小扣从 <span class="number">102</span> 号站台搭乘 <span class="number">1</span> 号公交至 <span class="number">6</span> * <span class="number">102</span> = <span class="number">612</span> 站台，花费时间为 <span class="number">7</span>；</span><br><span class="line">最终小扣花费总时间为 <span class="number">26</span>。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= target &lt;= 10^9</code></li><li><code>1 &lt;= jump.length, cost.length &lt;= 10</code></li><li><code>2 &lt;= jump[i] &lt;= 10^6</code></li><li><code>1 &lt;= inc, dec, cost[i] &lt;= 10^6</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/meChtZ" target="_blank" rel="noopener">https://leetcode-cn.com/problems/meChtZ</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>记忆式搜索DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目与<code>1533</code>题吃橘子基本上思路是一样的，只要会拿到题目，这个题目就很简单。比较坑得是，因为把全局变量写在<code>class</code>外面，导致怎么提交都会报错，后来改正过来后，就提交通过了。对于后续得提交代码时，一定需要注意这点小错误。</li><li>通过递归记忆化搜索，我们可以知道要么小扣通过一步一步的递加到达终点，要么通过一次跳跃后，再前进或者后退到达终点。知道这点思路后，就非常简单。</li><li>要么小扣在<code>n/jump[i]</code>处乘坐公交车到达<code>(n/jump[i])*jump[i]</code>处后，再往正向走<code>n%jump[i]</code>布即可，此时的总的花费时间应该为:<script type="math/tex; mode=display">T = dfs(n/jump[i]) + (n\mod jump)*inc + cost[i]</script>要么小扣在<code>n/jump[i]+1</code>处乘坐公交车到达<code>(n/jump[i]+1)*jump[i]</code>处后，再往反向走<code>n-n%jump[i]</code>布即可，此时的总的花费时间应该为:<script type="math/tex; mode=display">T = dfs(n/jump[i]+1) + (n - (n\mod jump))*dec + cost[i]</script>需要注意的是，如果当<code>n = 1</code>或者<script type="math/tex">n\mod jump = 0</script>时，此时不应该进行反向走。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp.count(n)) <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = (<span class="keyword">long</span> <span class="keyword">long</span>)n*x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> jump = a[i];</span><br><span class="line">            <span class="keyword">int</span> cost = b[i];</span><br><span class="line"></span><br><span class="line">            ans = min(ans, dfs(n/jump) + (<span class="keyword">long</span> <span class="keyword">long</span>)(n%jump)*x + cost);</span><br><span class="line">            <span class="keyword">if</span>(n &gt; <span class="number">1</span> &amp;&amp; (n%jump))&#123;</span><br><span class="line">                ans = min(ans , dfs((n/jump) + <span class="number">1</span> ) + (<span class="keyword">long</span> <span class="keyword">long</span>)(jump - n%jump)*y + cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busRapidTransit</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> inc, <span class="keyword">int</span> dec, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jump, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        m = cost.size();</span><br><span class="line">        x = inc;</span><br><span class="line">        y = dec;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cost.size(); ++i)&#123;</span><br><span class="line">            a[i] = jump[i];</span><br><span class="line">            b[i] = cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(target)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LCP-21-追逐游戏"><a href="#LCP-21-追逐游戏" class="headerlink" title="LCP 21. 追逐游戏"></a>LCP 21. 追逐游戏</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>秋游中的小力和小扣设计了一个追逐游戏。他们选了秋日市集景区中的<code>N</code>个景点，景点编号为 <code>1~N</code>。此外，他们还选择了 N 条小路，满足任意两个景点之间都可以通过小路互相到达，且不存在两条连接景点相同的小路。整个游戏场景可视作一个无向连通图，记作二维数组 <code>edge</code>s，数组中以 <code>[a,b]</code> 形式表示景点 <code>a</code> 与景点 <code>b</code> 之间有一条小路连通。</p><p>小力和小扣只能沿景点间的小路移动。小力的目标是在最快时间内追到小扣，小扣的目标是尽可能延后被小力追到的时间。游戏开始前，两人分别站在两个不同的景点 <code>startA</code> 和 <code>startB</code>。每一回合，小力先行动，小扣观察到小力的行动后再行动。小力和小扣在每回合可选择以下行动之一：</p><p>移动至相邻景点<br>留在原地<br>如果小力追到小扣（即两人于某一时刻出现在同一位置），则游戏结束。若小力可以追到小扣，请返回最少需要多少回合；若小力无法追到小扣，请返回 -1。</p><p>注意：小力和小扣一定会采取最优移动策略。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">6</span>]], startA = <span class="number">3</span>, startB = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一回合，小力移动至 <span class="number">2</span> 号点，小扣观察到小力的行动后移动至 <span class="number">6</span> 号点；</span><br><span class="line">第二回合，小力移动至 <span class="number">5</span> 号点，小扣无法移动，留在原地；</span><br><span class="line">第三回合，小力移动至 <span class="number">6</span> 号点，小力追到小扣。返回 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">1</span>]], startA = <span class="number">1</span>, startB = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">小力如果不动，则小扣也不动；否则小扣移动到小力的对角线位置。这样小力无法追到小扣。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>edges</code> 的长度等于图中节点个数</li><li><code>3 &lt;= edges.length &lt;= 10^5</code></li><li><code>1 &lt;= edges[i][0], edges[i][1] &lt;= edges.length</code> 且 <code>edges[i][0] != edges[i][1]</code></li><li><code>1 &lt;= startA, startB &lt;= edges.length</code> 且 <code>startA != startB</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/Za25hA" target="_blank" rel="noopener">https://leetcode-cn.com/problems/Za25hA</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>图论</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题综合考察了图上的DFS和BFS，有一定的思考价值。<br>NN个节点NN条边的连通图，一定有且只有一个环。这是解决本题必须想到的一点。想一想为什么？<br>接下来，我们就开始分情况讨论了：</p></blockquote><ul><li>如果A、B一开始就相邻（有一条A—B的边），那么A第一回合就直接捉到了B。</li><li>否则，我们找到图中唯一的那个环，将环上的点进行标记。</li></ul><ul><li><ul><li>如果环的长度为3，那么这个环并不能让B永远绕着走下去。<br>如果环的长度大于等于4，我们求出B进入环的位置和需要走的距离，再求出A到这个位置的距离。如果A的距离大于B的距离加一，那么B就可以在环上一直绕下去而不被捉到。</li></ul></li></ul><ul><li>如果环长为3或A可以在环上拦截B，我们需要找出游戏最多进行的回合数。我们求出A和B到图上所有点的距离，然后枚举各个点。</li><li><ul><li>如果A到某个点的距离小于等于B的距离加一，说明A有可能在这个点之前拦截到B，想一想为什么？</li></ul></li><li><ul><li>否则，B可以移动到这个点，游戏至少需要进行的回合数为A到这个点的距离。</li></ul></li><li><ul><li>枚举所有点，就可以找到合法的最大距离。</li></ul></li></ul><ol><li>题目非常有意思的在于如何找到图中的环的算法，这点是可以终点参考的解法。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; depth, parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; in_loop;</span><br><span class="line">    <span class="keyword">int</span> n, loop = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        parent[u] = p;</span><br><span class="line">        depth[u] = depth[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == p)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!depth[v]) </span><br><span class="line">                dfs(v, u);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (depth[v] &lt; depth[u]) &#123;</span><br><span class="line">                <span class="comment">// 发现反向边，说明找到了环</span></span><br><span class="line">                <span class="keyword">int</span> cu = u;</span><br><span class="line">                <span class="keyword">while</span> (cu != v) &#123;</span><br><span class="line">                    in_loop[cu] = <span class="literal">true</span>;</span><br><span class="line">                    loop++;</span><br><span class="line">                    cu = parent[cu];</span><br><span class="line">                &#125;</span><br><span class="line">                in_loop[v] = <span class="literal">true</span>;</span><br><span class="line">                loop++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bfs(<span class="keyword">int</span> u, <span class="keyword">bool</span> detect_loop) &#123;</span><br><span class="line">        <span class="comment">// detect_loop为标志位，为true表示BFS的目标是找到环的入口</span></span><br><span class="line">        <span class="comment">// 如果detect_loop为false，表示BFS的目标是求出到所有点的最短距离</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n + <span class="number">1</span>, INF);</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        dist[u] = <span class="number">0</span>;</span><br><span class="line">        q.push(u);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (detect_loop &amp;&amp; in_loop[x])</span><br><span class="line">                <span class="keyword">return</span> &#123;x, dist[x]&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y : adj[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[y] &lt;= dist[x] + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                dist[y] = dist[x] + <span class="number">1</span>;</span><br><span class="line">                q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">chaseGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> startA, <span class="keyword">int</span> startB)</span> </span>&#123;</span><br><span class="line">        n = edges.size();</span><br><span class="line">        adj = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : edges) &#123;</span><br><span class="line">            adj[v[<span class="number">0</span>]].emplace_back(v[<span class="number">1</span>]);</span><br><span class="line">            adj[v[<span class="number">1</span>]].emplace_back(v[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 如果两个人一开始就相邻，第一回合就能抓住</span></span><br><span class="line">            <span class="keyword">if</span> (v[<span class="number">0</span>] == startA &amp;&amp; v[<span class="number">1</span>] == startB)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (v[<span class="number">0</span>] == startB &amp;&amp; v[<span class="number">1</span>] == startA)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// DFS找环</span></span><br><span class="line">        depth = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">        parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">        in_loop = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BFS求出A和B到所有点的最短距离</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; da = bfs(startA, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; db = bfs(startB, <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果环的长度大于等于4，那么存在B永远无法被捉到的可能性</span></span><br><span class="line">        <span class="keyword">if</span> (loop &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// 寻找B到环的入口（可能就是B本身），及距离</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qb = bfs(startB, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 如果A到B的入口的距离大于B到环的入口距离加一，则B可以永远不被捉到</span></span><br><span class="line">            <span class="keyword">if</span> (qb[<span class="number">1</span>] + <span class="number">1</span> &lt; da[qb[<span class="number">0</span>]])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// A一定可以捉到B，B要使自己尽可能晚被捉到</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="comment">// 如果一个点到A的最短距离大于到B的最短距离加一</span></span><br><span class="line">            <span class="comment">// 这个点就是B可以安全到达的点</span></span><br><span class="line">            <span class="comment">// 用它更新最后的结果</span></span><br><span class="line">            <span class="keyword">if</span> (da[i] &gt; db[i] + <span class="number">1</span>)</span><br><span class="line">                ans = max(ans, da[i]);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> p,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; cycle, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; graph,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*get cycle*/</span></span><br><span class="line">        <span class="keyword">bool</span> inCycle = <span class="literal">false</span>;</span><br><span class="line">        cycle.push_back(u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == p) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">                visit[v] = <span class="literal">true</span>;</span><br><span class="line">                inCycle = inCycle||dfs(v,u,cycle,visit,graph,res);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.insert(v);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = cycle.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cycle[i] != v)&#123;</span><br><span class="line">                        res.insert(cycle[i]);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!inCycle) cycle.pop_back();</span><br><span class="line">        <span class="keyword">return</span> inCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bfs(<span class="keyword">int</span> s,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; graph,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        visit[s] = <span class="literal">true</span>;</span><br><span class="line">        qu.push(s);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                ans[curr] = step;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">chaseGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="keyword">int</span> startA, <span class="keyword">int</span> startB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cycle;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*creat graph*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : A)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = v[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x == startA &amp;&amp; y == startB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(y == startA &amp;&amp; x == startB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            graph[x].insert(y);</span><br><span class="line">            graph[y].insert(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*get the cycle of the graph*/</span></span><br><span class="line">        visit[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>,cycle,visit,graph,res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*check A &amp; B at the same cycle*/</span></span><br><span class="line">        <span class="keyword">bool</span> ina = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> inb = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/*check A &amp; B*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : res)&#123;</span><br><span class="line">            <span class="keyword">if</span>(startA == v) ina = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(startB == v) inb = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ina &amp;&amp; inb &amp;&amp; res.size() &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; da = bfs(startA,graph,n);   </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; db = bfs(startB,graph,n);</span><br><span class="line">        <span class="keyword">int</span> minCycleB = n;</span><br><span class="line">        <span class="keyword">int</span> bestB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.count(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(db[i] &lt; minCycleB)&#123;</span><br><span class="line">                    minCycleB = db[i];</span><br><span class="line">                    bestB = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cycle.size() &gt; <span class="number">3</span> &amp;&amp; da[bestB] &gt;= minCycleB+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(da[i] &gt; db[i] + <span class="number">1</span>)&#123;</span><br><span class="line">                ans = max(ans,da[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LCCUP个人赛&quot;&gt;&lt;a href=&quot;#LCCUP个人赛&quot; class=&quot;headerlink&quot; title=&quot;LCCUP个人赛&quot;&gt;&lt;/a&gt;LCCUP个人赛&lt;/h1&gt;&lt;p&gt;LCCUP个人赛做出了三道题，T4题目的思路是对的，为什么测试用例总是过不了，仔细查看了下代码，没有什么问题。后来测试了&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/09/13/iWRbT3OUQdSVezv.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;1-速算机器人&quot;&gt;&lt;a href=&quot;#1-速算机器人&quot; class=&quot;headerlink&quot; title=&quot;1. 速算机器人&quot;&gt;&lt;/a&gt;1. 速算机器人&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 x 和 y），请小扣说出计算指令：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;A&amp;quot;&lt;/code&gt;运算：使 &lt;code&gt;x = 2 * x + y&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;B&amp;quot;&lt;/code&gt; 运算：使 &lt;code&gt;y = 2 * y + x&lt;/code&gt;。&lt;br&gt;在本次游戏中，店家说出的数字为 &lt;code&gt;x = 1&lt;/code&gt;和 &lt;code&gt;y = 0&lt;/code&gt;，小扣说出的计算指令记作仅由大写字母 &lt;code&gt;A、B&lt;/code&gt; 组成的字符串 s，字符串中字符的顺序表示计算顺序，请返回最终 &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;y&lt;/code&gt; 的和为多少。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 206周周赛</title>
    <link href="http://yoursite.com/2020/09/16/202/"/>
    <id>http://yoursite.com/2020/09/16/202/</id>
    <published>2020-09-16T01:07:30.309Z</published>
    <updated>2020-09-16T01:07:34.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206周周赛"><a href="#206周周赛" class="headerlink" title="206周周赛"></a>206周周赛</h1><p>周日在加班，没有时间参加周赛，所以只是稍微看了下题目，前三题就是常规送分题目。</p><h2 id="1582-二进制矩阵中的特殊位置"><a href="#1582-二进制矩阵中的特殊位置" class="headerlink" title="1582. 二进制矩阵中的特殊位置"></a>1582. 二进制矩阵中的特殊位置</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>rows x cols</code> 的矩阵 <code>mat</code>，其中 <code>mat[i][j]</code>是 <code>0</code> 或 <code>1</code>，请返回 矩阵 <code>mat</code> 中特殊位置的数目 。</p><p>特殊位置 定义：如果 <code>mat[i][j] == 1</code>并且第 <code>i</code> 行和第<code>j</code>列中的所有其他元素均为<code>0</code>（行和列的下标均 从 0 开始 ），则位置 <code>(i, j)</code>被称为特殊位置。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：(<span class="number">1</span>,<span class="number">2</span>) 是一个特殊位置，因为 mat[<span class="number">1</span>][<span class="number">2</span>] == <span class="number">1</span> 且所处的行和列上所有其他元素都是 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：(<span class="number">0</span>,<span class="number">0</span>), (<span class="number">1</span>,<span class="number">1</span>) 和 (<span class="number">2</span>,<span class="number">2</span>) 都是特殊位置</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>rows == mat.length</li><li>cols == mat[i].length</li><li>1 &lt;= rows, cols &lt;= 100</li><li>mat[i][j] 是 0 或 1</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环，检查行与列即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSpecial</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">bool</span> rowValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">bool</span> colValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; row; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(mat[k][j] == <span class="number">1</span>) rowValid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; col; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == j) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(mat[i][k] == <span class="number">1</span>) colValid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(rowValid&amp;&amp;colValid) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1583-统计不开心的朋友"><a href="#1583-统计不开心的朋友" class="headerlink" title="1583. 统计不开心的朋友"></a>1583. 统计不开心的朋友</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code>总是 偶数 。</p><p>对每位朋友 <code>i，preferences[i]</code> 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code>的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 <code>n-1</code> 之间的整数表示。</p><p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [xi, yi]</code>表示 <code>xi</code>与 <code>yi</code>配对，且 <code>yi</code>与<code>xi</code>配对。</p><p>但是，这样的配对情况可能会是其中部分朋友感到不开心。在 <code>x</code>与 <code>y</code> 配对且<code>u</code>与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，x 就会不开心：</p><p><code>x</code> 与 <code>u</code>的亲近程度胜过 <code>x</code> 与<code>y</code>，且<br><code>u</code>与 <code>x</code>的亲近程度胜过 <code>u</code> 与<code>v</code><br>返回 不开心的朋友的数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, preferences = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]], pairs = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">朋友 <span class="number">1</span> 不开心，因为：</span><br><span class="line">- <span class="number">1</span> 与 <span class="number">0</span> 配对，但 <span class="number">1</span> 与 <span class="number">3</span> 的亲近程度比 <span class="number">1</span> 与 <span class="number">0</span> 高，且</span><br><span class="line">- <span class="number">3</span> 与 <span class="number">1</span> 的亲近程度比 <span class="number">3</span> 与 <span class="number">2</span> 高。</span><br><span class="line">朋友 <span class="number">3</span> 不开心，因为：</span><br><span class="line">- <span class="number">3</span> 与 <span class="number">2</span> 配对，但 <span class="number">3</span> 与 <span class="number">1</span> 的亲近程度比 <span class="number">3</span> 与 <span class="number">2</span> 高，且</span><br><span class="line">- <span class="number">1</span> 与 <span class="number">3</span> 的亲近程度比 <span class="number">1</span> 与 <span class="number">0</span> 高。</span><br><span class="line">朋友 <span class="number">0</span> 和 <span class="number">2</span> 都是开心的。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, preferences = <span class="string">[[1], [0]]</span>, <span class="built_in">pairs</span> = <span class="string">[[1, 0]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：朋友 <span class="number">0</span> 和 <span class="number">1</span> 都开心。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, preferences = [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]], pairs = [[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 500</code></li><li><code>n</code>是偶数</li><li><code>preferences.length == n</code></li><li><code>preferences[i].length == n - 1</code></li><li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li><li><code>preferences[i]</code> 不包含<code>i</code></li><li><code>preferences[i]</code>中的所有值都是独一无二的</li><li><code>pairs.length == n/2</code></li><li><code>pairs[i].length == 2</code></li><li><code>xi != yi</code></li><li><code>0 &lt;= xi, yi &lt;= n - 1</code></li><li>每位朋友都 恰好 被包含在一对中</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-unhappy-friends" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-unhappy-friends</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 纯粹送分题目</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较奇怪，直接计算任意两个不同人之间的亲密度即可，然后分别进行比较即可。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unhappyFriends</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; preferences, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preferences.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; preferences[i].size(); ++j)&#123;</span><br><span class="line">                graph[i][preferences[i][j]] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = pairs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = pairs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">bool</span> validX = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">bool</span> validY = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pairs.size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> u = pairs[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> v = pairs[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(graph[x][u] &lt; graph[x][y] &amp;&amp; graph[u][x] &lt; graph[u][v]) validX = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(graph[y][u] &lt; graph[y][x] &amp;&amp; graph[u][y] &lt; graph[u][v]) validY = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(graph[x][v] &lt; graph[x][y] &amp;&amp; graph[v][x] &lt; graph[v][u]) validX = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(graph[y][v] &lt; graph[y][x] &amp;&amp; graph[v][y] &lt; graph[v][u]) validY = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(validX) ans++;</span><br><span class="line">            <span class="keyword">if</span>(validY) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584. 连接所有点的最小费用"></a>1584. 连接所有点的最小费用</h2><p>给你一个<code>points</code> 数组，表示 <code>2D</code> 平面上的一些点，其中 <code>points[i] = [xi, yi]</code>。</p><p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code>的费用为它们之间的 曼哈顿距离 ：<code>|xi - xj| + |yi - yj|</code>，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">10</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">我们可以按照上图所示连接所有点得到最小总费用，总费用为 <span class="number">20</span> 。</span><br><span class="line">注意到任意两个点之间只有唯一一条路径互相到达。</span><br></pre></td></tr></table></figure><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">3</span>,<span class="number">12</span>],[<span class="number">-2</span>,<span class="number">5</span>],[<span class="number">-4</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">-1000000</span>,<span class="number">-1000000</span>],[<span class="number">1000000</span>,<span class="number">1000000</span>]]</span><br><span class="line">输出：<span class="number">4000000</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = <span class="string">[[0,0]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= points.length &lt;= 1000</code></li><li><code>-106 &lt;= xi, yi &lt;= 106</code></li><li>所有点<code>(xi, yi)</code>两两不同。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-cost-to-connect-all-points</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 最小生成树</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的最小生成树算法，<code>kruskal</code>或者<code>prim</code>算法即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;d = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a, Node &amp; b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x]) x = f[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> edge = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,pii&gt; graph;</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> d = <span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">                pq.push(&#123;i,j,d&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> x1 = find(curr.x,f);</span><br><span class="line">            <span class="keyword">int</span> x2 = find(curr.y,f);</span><br><span class="line">            <span class="keyword">if</span>(x1 == x2) <span class="keyword">continue</span>;</span><br><span class="line">            f[x1] = x2;</span><br><span class="line">            edge++;</span><br><span class="line">            ans += curr.d;</span><br><span class="line">            <span class="keyword">if</span>(edge == n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1585-检查字符串是否可以通过排序子字符串得到另一个字符串"><a href="#1585-检查字符串是否可以通过排序子字符串得到另一个字符串" class="headerlink" title="1585. 检查字符串是否可以通过排序子字符串得到另一个字符串"></a>1585. 检查字符串是否可以通过排序子字符串得到另一个字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>s</code>和<code>t</code>，请你通过若干次以下操作将字符串 <code>s</code> 转化成字符串 <code>t</code>：</p><p>选择 <code>s</code>中一个 非空 子字符串并将它包含的字符就地 升序 排序。<br>比方说，对下划线所示的子字符串进行操作可以由 <code>&quot;14234&quot;</code>得到<code>&quot;12344&quot;</code>。</p><p>如果可以将字符串 <code>s</code>变成<code>t</code>，返回 <code>true</code>。否则，返回 <code>false</code> 。</p><p>一个 子字符串 定义为一个字符串中连续的若干字符。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"84532"</span>, t = <span class="string">"34852"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：你可以按以下操作将 s 转变为 t ：</span><br><span class="line"><span class="string">"84532"</span> （从下标 <span class="number">2</span> 到下标 <span class="number">3</span>）-&gt; <span class="string">"84352"</span></span><br><span class="line"><span class="string">"84352"</span> （从下标 <span class="number">0</span> 到下标 <span class="number">2</span>） -&gt; <span class="string">"34852"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"34521"</span>, t = <span class="string">"23415"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：你可以按以下操作将 s 转变为 t ：</span><br><span class="line"><span class="string">"34521"</span> -&gt; <span class="string">"23451"</span></span><br><span class="line"><span class="string">"23451"</span> -&gt; <span class="string">"23415"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"12345"</span>, <span class="attr">t</span> = <span class="string">"12435"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1"</span>, <span class="attr">t</span> = <span class="string">"2"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>s.length == t.length</li><li>1 &lt;= s.length &lt;= 105</li><li>s 和 t 都只包含数字字符，即 ‘0’ 到 ‘9’ 。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的相当不错，看似很简单，但是值得思考和回味的地方有很多。</li><li>设给定的字符串$s$和$t$的长度均为$n$。题目描述中允许我们将任意长度的子串进行原地升序排序，这无疑增加了操作的复杂性，我们是否可以将对长度为$ 1, 2, \cdots, n$的子串进行的操作归纳成少数的几种操作呢？<br>答案是可以的，当我们操作长度为 $1$ 的子串时，相当于没有进行任何操作，可以忽略；而当我们操作长度等于 $2$ 的子串时，我们是将相邻的两个字符根据它们的大小关系交换位置，类似于「冒泡排序」中的每一个步骤；而当我们操作长度大于等于 $3$ 的子串时，我们是将对应的子串原地升序排序，但它可以拆分成若干次冒泡排序的步骤，即我们对整个子串进行一次完整的冒泡排序，可以得到和题目描述中的操作相同的结果，而冒泡排序中的每一个步骤就是对长度为 $2$ 的子串进行题目描述中的操作。<br>因此，我们可以得到结论：</li></ol><ul><li>我们依次构建字符串t.每次构建字符串<code>t</code>的第<code>i</code>个字符<code>c</code>时，我们知道，需要进行冒泡排序将字符都一个<code>s[j] = c</code>通过从大到小的排序顺序排在最前面，将<code>c</code>排序到第<code>i</code>个位置，因此，我们需要保证前<code>j-1</code>个字符中不存在比<code>s[j]</code>大的字符，如果已经完成排序的第<code>j</code>个字符，我们可以将其从队列中删除。</li></ul></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTransformable</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; pos(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pos[s[i] - <span class="string">'0'</span>].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = t[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos[digit].empty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; digit; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pos[j].empty() &amp;&amp; pos[j].front() &lt; pos[digit].front()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pos[digit].pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;206周周赛&quot;&gt;&lt;a href=&quot;#206周周赛&quot; class=&quot;headerlink&quot; title=&quot;206周周赛&quot;&gt;&lt;/a&gt;206周周赛&lt;/h1&gt;&lt;p&gt;周日在加班，没有时间参加周赛，所以只是稍微看了下题目，前三题就是常规送分题目。&lt;/p&gt;&lt;h2 id=&quot;1582-二进制矩阵中的特殊位置&quot;&gt;&lt;a href=&quot;#1582-二进制矩阵中的特殊位置&quot; class=&quot;headerlink&quot; title=&quot;1582. 二进制矩阵中的特殊位置&quot;&gt;&lt;/a&gt;1582. 二进制矩阵中的特殊位置&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个大小为 &lt;code&gt;rows x cols&lt;/code&gt; 的矩阵 &lt;code&gt;mat&lt;/code&gt;，其中 &lt;code&gt;mat[i][j]&lt;/code&gt;是 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;，请返回 矩阵 &lt;code&gt;mat&lt;/code&gt; 中特殊位置的数目 。&lt;/p&gt;&lt;p&gt;特殊位置 定义：如果 &lt;code&gt;mat[i][j] == 1&lt;/code&gt;并且第 &lt;code&gt;i&lt;/code&gt; 行和第&lt;code&gt;j&lt;/code&gt;列中的所有其他元素均为&lt;code&gt;0&lt;/code&gt;（行和列的下标均 从 0 开始 ），则位置 &lt;code&gt;(i, j)&lt;/code&gt;被称为特殊位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 205周周赛</title>
    <link href="http://yoursite.com/2020/09/06/201/"/>
    <id>http://yoursite.com/2020/09/06/201/</id>
    <published>2020-09-06T07:29:30.757Z</published>
    <updated>2020-09-11T05:52:17.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="205周周赛"><a href="#205周周赛" class="headerlink" title="205周周赛"></a>205周周赛</h1><p>周赛又翻车了，最后一题竟然还是不会，没有想明白，还是难度大的题目练习较少，没有培养出真正的深入思考的模式。<br><img src="https://i.loli.net/2020/09/11/CBeAkY5qfuaSvw6.png" alt></p><h2 id="5507-替换所有的问号"><a href="#5507-替换所有的问号" class="headerlink" title="5507. 替换所有的问号"></a>5507. 替换所有的问号</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code>字符的字符串<code>s&lt;var&gt; &lt;/var&gt;</code>，请你将所有的 ‘?’ 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。</p><a id="more"></a><p>注意：你 不能 修改非 ‘?’ 字符。</p><p>题目测试用例保证 除 ‘?’ 字符 之外，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"?zs"</span></span><br><span class="line">输出：<span class="string">"azs"</span></span><br><span class="line">解释：该示例共有 <span class="number">25</span> 种解决方案，从 <span class="string">"azs"</span> 到 <span class="string">"yzs"</span> 都是符合题目要求的。只有 <span class="string">"z"</span> 是无效的修改，因为字符串 <span class="string">"zzs"</span> 中有连续重复的两个 'z' 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"ubv?w"</span></span><br><span class="line">输出：<span class="string">"ubvaw"</span></span><br><span class="line">解释：该示例共有 <span class="number">24</span> 种解决方案，只有替换成 <span class="string">"v"</span> 和 <span class="string">"w"</span> 不符合题目要求。因为 <span class="string">"ubvvw"</span> 和 <span class="string">"ubvww"</span> 都包含连续重复的字符。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"j?qg??b"</span></span><br><span class="line">输出：<span class="string">"jaqgacb"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"??yw?ipkj?"</span></span><br><span class="line">输出：<span class="string">"acywaipkja"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母和 ‘?’ 字符</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环,每次替换时，直接找到与前后相邻字符全不相等的字母进行直接替换即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">modifyString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'?'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> pre = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">bool</span> bac = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[i<span class="number">-1</span>] != <span class="string">'a'</span> + j)&#123;</span><br><span class="line">                            pre = <span class="literal">true</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            pre = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[i+<span class="number">1</span>] != <span class="string">'a'</span> + j)&#123;</span><br><span class="line">                            bac = <span class="literal">true</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            bac = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(pre&amp;&amp;bac)&#123;</span><br><span class="line">                        s[i] = <span class="string">'a'</span> + j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5508-数的平方等于两数乘积的方法数"><a href="#5508-数的平方等于两数乘积的方法数" class="headerlink" title="5508. 数的平方等于两数乘积的方法数"></a>5508. 数的平方等于两数乘积的方法数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数数组 <code>nums1</code>和 <code>nums2</code>，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）：</p><ul><li>类型 1：三元组 <code>(i, j, k)</code> ，如果 $nums1[i]^{2} == nums2[j] * nums2[k]$ 其中 <code>0 &lt;= i &lt; nums1.length</code>且 <code>0 &lt;= j &lt; k &lt; nums2.length</code></li><li>类型 2：三元组 <code>(i, j, k)</code>，如果 $nums2[i]^{2} == nums1[j] * nums1[k]$ 其中 <code>0 &lt;= i &lt; nums2.length</code>且 <code>0 &lt;= j &lt; k &lt; nums1.length</code></li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">7</span>,<span class="number">4</span>], nums2 = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：类型 <span class="number">1</span>：(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>), nums1[<span class="number">1</span>]^<span class="number">2</span> = nums2[<span class="number">1</span>] * nums2[<span class="number">2</span>] (<span class="number">4</span>^<span class="number">2</span> = <span class="number">2</span> * <span class="number">8</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>], nums2 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：所有三元组都符合题目要求，因为 <span class="number">1</span>^<span class="number">2</span> = <span class="number">1</span> * <span class="number">1</span></span><br><span class="line">类型 <span class="number">1</span>：(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>), (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>), nums1[i]^<span class="number">2</span> = nums2[j] * nums2[k]</span><br><span class="line">类型 <span class="number">2</span>：(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>), nums2[i]^<span class="number">2</span> = nums1[j] * nums1[k]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>], nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有两个符合题目要求的三元组</span><br><span class="line">类型 <span class="number">1</span>：(<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>), nums1[<span class="number">3</span>]^<span class="number">2</span> = nums2[<span class="number">0</span>] * nums2[<span class="number">2</span>]</span><br><span class="line">类型 <span class="number">2</span>：(<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>), nums2[<span class="number">3</span>]^<span class="number">2</span> = nums1[<span class="number">0</span>] * nums1[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">23</span>], nums2 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1024</span>,<span class="number">12</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在符合题目要求的三元组</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 纯粹送分题目</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>记录两个数组中每个元素的平方的统计数目，用hashmap记录统计数目即可。</li><li>直接求：<script type="math/tex; mode=display">nums1[i]^{2} == nums2[j] * nums2[k] \\nums2[i]^{2} == nums1[j] * nums1[k] \\</script>这两种情况下的发生的数目即可，啃爹的情况是需要注意乘法计算溢出的问题。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> m = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; sq1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; sq2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = nums1[i];</span><br><span class="line">            sq1[x*x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = nums2[i];</span><br><span class="line">            sq2[x*x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> a = nums1[i];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> b = nums1[j];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = a*b;</span><br><span class="line">                <span class="keyword">if</span>(sq2.count(x)) ans += sq2[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> a = nums2[i];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> b = nums2[j];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = a*b;</span><br><span class="line">                <span class="keyword">if</span>(sq1.count(x)) ans += sq1[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5509-避免重复字母的最小删除成本"><a href="#5509-避免重复字母的最小删除成本" class="headerlink" title="5509. 避免重复字母的最小删除成本"></a>5509. 避免重复字母的最小删除成本</h2><p>给你一个字符串 <code>s</code>和一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code>是从 <code>s</code> 中删除字符<code>i</code>的代价。</p><p>返回使字符串任意相邻两个字母不相同的最小删除成本。</p><p>请注意，删除一个字符后，删除其他字符的成本不会改变。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abaac"</span>, cost = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：删除字母 <span class="string">"a"</span> 的成本为 <span class="number">3</span>，然后得到 <span class="string">"abac"</span>（字符串中相邻两个字母不相同）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span>, cost = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无需删除任何字母，因为字符串中不存在相邻两个字母相同的情况。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabaa"</span>, cost = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：删除第一个和最后一个字母，得到字符串 (<span class="string">"aba"</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s.length == cost.length</code></li><li><code>1 &lt;= s.length, cost.length &lt;= 10^5</code></li><li><code>1 &lt;= cost[i] &lt;= 10^4</code></li><li><code>s</code> 中只含有小写英文字母</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-deletion-cost-to-avoid-repeating-letters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-deletion-cost-to-avoid-repeating-letters</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>每次在具有连续相同字符的窗口中找到替换代价最大的字符留下，其余的相同的字符去掉即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sumCost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCost = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            sumCost = <span class="number">0</span>;</span><br><span class="line">            maxCost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] == s[curr])&#123;</span><br><span class="line">                sumCost += cost[i];</span><br><span class="line">                maxCost = max(maxCost,cost[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i-curr &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                ans += sumCost - maxCost;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5510-保证图可完全遍历"><a href="#5510-保证图可完全遍历" class="headerlink" title="5510. 保证图可完全遍历"></a>5510. 保证图可完全遍历</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><code>Alice</code> 和 <code>Bob</code>共有一个无向图，其中包含 <code>n</code> 个节点和 3  种类型的边：</p><ul><li>类型 1：只能由 <code>Alice</code> 遍历。</li><li>类型 2：只能由 <code>Bob</code> 遍历。</li><li>类型 3：<code>Alice</code> 和 <code>Bob</code> 都可以遍历。<br>给你一个数组 <code>edges</code> ，其中 <code>edges[i] = [typei, ui, vi]</code>表示节点 <code>ui</code>和 <code>vi</code> 之间存在类型为 <code>typei</code>的双向边。请你在保证图仍能够被 <code>Alice</code>和 <code>Bob</code>完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，<code>Alice</code>和 <code>Bob</code>都可以到达所有其他节点，则认为图是可以完全遍历的。</li></ul><p>返回可以删除的最大边数，如果 <code>Alice</code>和 <code>Bob</code>无法完全遍历图，则返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如果删除 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] 和 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：在当前图中，Alice 无法从其他节点到达节点 <span class="number">4</span> 。类似地，Bob 也不能达到节点 <span class="number">1</span> 。因此，图无法完全遍历。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2)</code></li><li><code>edges[i].length == 3</code></li><li><code>1 &lt;= edges[i][0] &lt;= 3</code></li><li><code>1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n</code></li><li>所有元组 <code>(typei, ui, vi)</code> 互不相同</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>DSU</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先找到能够成为连通的最小数目的数据结构，我们这里是用<code>DSU</code>.</li><li>首先我们利用<code>DSU</code>去掉多余的第三类边，第三类边我们只需要去掉一次即可，<code>dsu1</code>代表<code>Alice</code>,<code>dsu2</code>代表<code>Bob</code>。</li><li>将第一类边依次加入到<code>dsu1</code>中去，去掉多余的第一类边。将第二类边依次加入到<code>dsu2</code>中去，去掉多余的第二类边。</li><li>最后检查<code>dsu1</code>,<code>dsu1</code>是否都满足联通，如果不满足联通则返回<code>-1</code>.否则则返回结果。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[x] != x) x = parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 == y1) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sz[x1] &gt; sz[y1])&#123;</span><br><span class="line">            parent[y1] = x1;</span><br><span class="line">            sz[x1] += sz[y1];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[x1] = y1;</span><br><span class="line">            sz[y1] += sz[x1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sz[x];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumEdgesToRemove</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; a,b,c;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">Dsu <span class="title">ds1</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">Dsu <span class="title">ds2</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">1</span>) a.push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">2</span>) b.push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">3</span>) c.push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : c)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v.first - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = v.second - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ds1.find(x) == ds1.find(y))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ds1.uni(x,y);</span><br><span class="line">                ds2.uni(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : a)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v.first - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = v.second - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ds1.find(x) == ds1.find(y))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ds1.uni(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : b)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v.first - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = v.second - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ds2.find(x) == ds2.find(y))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ds2.uni(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> valid1 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> valid2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ds1.length(i) == n) valid1 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(ds2.length(i) == n) valid2 = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!valid1||!valid2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;205周周赛&quot;&gt;&lt;a href=&quot;#205周周赛&quot; class=&quot;headerlink&quot; title=&quot;205周周赛&quot;&gt;&lt;/a&gt;205周周赛&lt;/h1&gt;&lt;p&gt;周赛又翻车了，最后一题竟然还是不会，没有想明白，还是难度大的题目练习较少，没有培养出真正的深入思考的模式。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/09/11/CBeAkY5qfuaSvw6.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5507-替换所有的问号&quot;&gt;&lt;a href=&quot;#5507-替换所有的问号&quot; class=&quot;headerlink&quot; title=&quot;5507. 替换所有的问号&quot;&gt;&lt;/a&gt;5507. 替换所有的问号&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个仅包含小写英文字母和 &lt;code&gt;&amp;#39;?&amp;#39;&lt;/code&gt;字符的字符串&lt;code&gt;s&amp;lt;var&amp;gt; &amp;lt;/var&amp;gt;&lt;/code&gt;，请你将所有的 ‘?’ 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 33周双周赛</title>
    <link href="http://yoursite.com/2020/09/06/200/"/>
    <id>http://yoursite.com/2020/09/06/200/</id>
    <published>2020-09-06T07:29:30.642Z</published>
    <updated>2020-09-11T05:52:50.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="33周双周赛"><a href="#33周双周赛" class="headerlink" title="33周双周赛"></a>33周双周赛</h1><p>本周双周赛题目这么简单的情况下，竟然翻车了。<br><img src="https://i.loli.net/2020/09/11/ObI7PTrFmByc4sD.png" alt></p><h2 id="5491-矩阵对角线元素的和"><a href="#5491-矩阵对角线元素的和" class="headerlink" title="5491. 矩阵对角线元素的和"></a>5491. 矩阵对角线元素的和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正方形矩阵<code>mat</code>，请你返回矩阵对角线元素的和。</p><p>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p><p>示例  1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">            [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">            [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：对角线的和为：<span class="number">1</span> + <span class="number">5</span> + <span class="number">9</span> + <span class="number">3</span> + <span class="number">7</span> = <span class="number">25</span></span><br><span class="line">请注意，元素 mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span> 只会被计算一次。</span><br></pre></td></tr></table></figure><br>示例  2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[5]]</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>n == mat.length == mat[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= mat[i][j] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/matrix-diagonal-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/matrix-diagonal-sum</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diagonalSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += mat[i][i];</span><br><span class="line">            ans += mat[i][n<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>) ans -= mat[n/<span class="number">2</span>][n/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5492-分割字符串的方案数"><a href="#5492-分割字符串的方案数" class="headerlink" title="5492. 分割字符串的方案数"></a>5492. 分割字符串的方案数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制串 <code>s</code>  （一个只包含 0 和 1 的字符串），我们可以将 <code>s</code>分割成 3 个 非空 字符串 <code>s1, s2, s3 （s1 + s2 + s3 = s）</code>。</p><p>请你返回分割 s 的方案数，满足 <code>s1，s2</code> 和 <code>s3</code>中字符 ‘1’ 的数目相同。</p><p>由于答案可能很大，请将它对<code>10^9 + 7</code>取余后返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"10101"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：总共有 <span class="number">4</span> 种方法将 s 分割成含有 '<span class="number">1</span>' 数目相同的三个子字符串。</span><br><span class="line"><span class="string">"1|010|1"</span></span><br><span class="line"><span class="string">"1|01|01"</span></span><br><span class="line"><span class="string">"10|10|1"</span></span><br><span class="line"><span class="string">"10|1|01"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1001"</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"0000"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：总共有 <span class="number">3</span> 种分割 s 的方法。</span><br><span class="line"><span class="string">"0|0|00"</span></span><br><span class="line"><span class="string">"0|00|0"</span></span><br><span class="line"><span class="string">"00|0|0"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"100100010100110"</span></span><br><span class="line">输出：<span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s[i] == &#39;0&#39; 或者 s[i] == &#39;1&#39;</code></li><li><code>3 &lt;= s.length &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-34/problems/number-of-ways-to-split-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-34/problems/number-of-ways-to-split-a-string/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学数学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个问题好无聊，首先找到所有<code>1</code>的总数目为<code>n</code>.</li><li>从索引<code>0</code>开始从左到右中含有<code>1</code>的数目分为别$\frac{n}{3}$,$\frac{2n}{3}$的子序列个数。总的数目：<script type="math/tex; mode=display">SUM = C_{\frac{n}{3}}*C_{\frac{2n}{3}}</script></li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> m = s.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'1'</span>) ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ones%<span class="number">3</span> != <span class="number">0</span> || s.size() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ones == <span class="number">0</span>) <span class="keyword">return</span>  ((m<span class="number">-1</span>)*(m<span class="number">-2</span>)/<span class="number">2</span>)%mod;      </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = ones/<span class="number">3</span>;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) curr++;</span><br><span class="line">            <span class="keyword">if</span>(curr == n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt.count(n))&#123;</span><br><span class="line">                    cnt[curr] = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    f1 = max(f1,i-cnt[curr]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="number">2</span>*n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt.count(<span class="number">2</span>*n))&#123;</span><br><span class="line">                    cnt[curr] = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    f2 = max(f2,i-cnt[curr]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)f1*(<span class="keyword">long</span> <span class="keyword">long</span>)f2%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5493-删除最短的子数组使剩余数组有序"><a href="#5493-删除最短的子数组使剩余数组有序" class="headerlink" title="5493. 删除最短的子数组使剩余数组有序"></a>5493. 删除最短的子数组使剩余数组有序</h2><p>给你一个整数数组 <code>arr</code> ，请你删除一个子数组（可以为空），使得 <code>arr</code> 中剩下的元素是 非递减 的。</p><p>一个子数组指的是原数组中连续的一个子序列。</p><p>请你返回满足题目要求的最短子数组的长度。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们需要删除的最短子数组是 [<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>] ，长度为 <span class="number">3</span> 。剩余元素形成非递减数组 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">另一个正确的解为删除子数组 [<span class="number">3</span>,<span class="number">10</span>,<span class="number">4</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 <span class="number">4</span> 的子数组，要么删除 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]，要么删除 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：数组已经是非递减的了，我们不需要删除任何元素。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>0 &lt;= arr[i] &lt;= 10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 双指针</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目翻车了，自己把自己想的太复杂了。</li><li>先却左右两端为升序序列的最大长度，再试着截取两端合适的序列的最大长度。</li><li>我们首先确定右侧的最大升序序列长度，然后我们从最左端开始找起，找到最左端的连续的递升长度$L_{i}$，同时找到最右端能够与 <code>[0,i]</code>形成非减序列的最长长度，我们将有指针右移找到第一个不小于<code>arr[i]</code>的数即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfShortestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(r &gt;= <span class="number">1</span> &amp;&amp; arr[r] &gt;= arr[r<span class="number">-1</span>])&#123;</span><br><span class="line">            maxL++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxL == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; arr[l] &gt; arr[r]) r++;</span><br><span class="line">            maxL = max(maxL,l+<span class="number">1</span>+n-r);</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span>(arr[l] &lt; arr[l<span class="number">-1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> n-maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5494-统计所有可行路径"><a href="#5494-统计所有可行路径" class="headerlink" title="5494. 统计所有可行路径"></a>5494. 统计所有可行路径</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 互不相同 的整数数组，其中 <code>locations[i]</code>表示第 <code>i</code> 个城市的位置。同时给你 <code>start</code>，<code>finish</code>和 <code>fuel</code>分别表示出发城市、目的地城市和你初始拥有的汽油总量</p><p>每一步中，如果你在城市 <code>i</code> ，你可以选择任意一个城市 <code>j</code>，满足  <code>j != i</code>且 <code>0 &lt;= j &lt; locations.length</code>，并移动到城市 j 。从城市 i 移动到 j 消耗的汽油量为 <code>|locations[i] - locations[j]|</code>，<code>|x|</code>表示 x 的绝对值。</p><p>请注意， <code>fuel</code> 任何时刻都 不能 为负，且你 可以 经过任意城市超过一次（包括 start 和 <code>finish</code> ）。</p><p>请你返回从 <code>start</code> 到 <code>finish</code>所有可能路径的数目。</p><p>由于答案可能很大， 请将它对 <code>10^9 + 7</code> 取余后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>], start = <span class="number">1</span>, finish = <span class="number">3</span>, fuel = <span class="number">5</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：以下为所有可能路径，每一条都用了 <span class="number">5</span> 单位的汽油：</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">4</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>], start = <span class="number">1</span>, finish = <span class="number">0</span>, fuel = <span class="number">6</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：以下为所有可能的路径：</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">5</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">5</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>], start = <span class="number">0</span>, finish = <span class="number">2</span>, fuel = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有办法只用 <span class="number">3</span> 单位的汽油从 <span class="number">0</span> 到达 <span class="number">2</span> 。因为最短路径需要 <span class="number">4</span> 单位的汽油。</span><br></pre></td></tr></table></figure><br>示例 4 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>], start = <span class="number">0</span>, finish = <span class="number">0</span>, fuel = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有两条可行路径，<span class="number">0</span> 和 <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], start = <span class="number">0</span>, finish = <span class="number">2</span>, fuel = <span class="number">40</span></span><br><span class="line">输出：<span class="number">615088286</span></span><br><span class="line">解释：路径总数为 <span class="number">2615088300</span> 。将结果对 <span class="number">10</span>^<span class="number">9</span> + <span class="number">7</span> 取余，得到 <span class="number">615088286</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= locations.length &lt;= 100</code></li><li><code>1 &lt;= locations[i] &lt;= 10^9</code></li><li>所有 <code>locations</code> 中的整数 互不相同 。</li><li><code>0 &lt;= start, finish &lt; locations.length</code></li><li><code>1 &lt;= fuel &lt;= 200</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-all-possible-routes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-all-possible-routes</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>常规dp,找到递推公式即可。</li><li>我们设<code>dp[x][y]</code>为到达<code>x</code>处时，汽车中的汽油还剩下<code>y</code>单位的可能路径数目。<script type="math/tex; mode=display">dp[x][y] = \sum_{i=1}^{n}dp[i][y+abs(l_{i}-l_{x})]</script></li><li>实际情况下，我们倒着搜索可能更容易一些，特别是记忆化搜索，速度会快很多，因为它的剪枝条件会好很多，比单纯的<code>dp</code>快很多。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">101</span>][<span class="number">202</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; locations, <span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">int</span> fuel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[start][fuel] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[start][fuel];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == finish) ans++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(start == i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cost = <span class="built_in">abs</span>(locations[start]-locations[i]);</span><br><span class="line">            <span class="keyword">if</span>(fuel &gt;= cost)&#123;</span><br><span class="line">                ans = (ans + dfs(locations,i,finish,fuel-cost))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start][fuel] = ans;</span><br><span class="line">        <span class="keyword">return</span> dp[start][fuel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRoutes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; locations, <span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">int</span> fuel)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">return</span> dfs(locations,start,finish,fuel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">202</span>][<span class="number">101</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRoutes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; locations, <span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">int</span> fuel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = locations.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j) dis[i][j] = <span class="built_in">abs</span>(locations[i]-locations[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[fuel][start] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = fuel; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == k) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= dis[j][k]) dp[i-dis[j][k]][k] = (dp[i-dis[j][k]][k] + dp[i][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fuel; ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i][finish])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;33周双周赛&quot;&gt;&lt;a href=&quot;#33周双周赛&quot; class=&quot;headerlink&quot; title=&quot;33周双周赛&quot;&gt;&lt;/a&gt;33周双周赛&lt;/h1&gt;&lt;p&gt;本周双周赛题目这么简单的情况下，竟然翻车了。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/09/11/ObI7PTrFmByc4sD.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5491-矩阵对角线元素的和&quot;&gt;&lt;a href=&quot;#5491-矩阵对角线元素的和&quot; class=&quot;headerlink&quot; title=&quot;5491. 矩阵对角线元素的和&quot;&gt;&lt;/a&gt;5491. 矩阵对角线元素的和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个正方形矩阵&lt;code&gt;mat&lt;/code&gt;，请你返回矩阵对角线元素的和。&lt;/p&gt;&lt;p&gt;请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。&lt;/p&gt;&lt;p&gt;示例  1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：mat = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：对角线的和为：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请注意，元素 mat[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 只会被计算一次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例  2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：mat = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：mat = &lt;span class=&quot;string&quot;&gt;[[5]]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 Build a Modern Computer From First Principles:Nand to Tetris Part I</title>
    <link href="http://yoursite.com/2020/09/01/199/"/>
    <id>http://yoursite.com/2020/09/01/199/</id>
    <published>2020-09-01T08:13:44.939Z</published>
    <updated>2020-09-11T05:21:54.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-I-project-centered-course"><a href="#Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-I-project-centered-course" class="headerlink" title="Build a Modern Computer from First Principles: Nand to Tetris Part I (project-centered course)"></a>Build a Modern Computer from First Principles: Nand to Tetris Part I (project-centered course)</h1><p>$~~~~$接触到这门课程是在知乎上有人强烈推荐的，感觉这种靠谱的课程特别是有意义。网上搜了下背景资料，似乎这门课程是给哈佛大学的本科生开的课程，我是在工作之余陆陆续续的将这门课程的上半部分学完了，每周差不多要花上至少三个小时，后面的project还是非常有意思的。这门课程上半部分主要是讲如何从最基本的与非门搭建成一个完成的计算机，下半部分主要是讲在自己搭建的计算机上如何实现虚拟机、高级语言编译器、操作系统等等相关的课程。总的来说课程还是非常有意思的，特别适合稍微有计算机基础的人士来学这门课程，这门课程的前置课程是哈佛大学的<code>cs101</code>计算机基础课程。在学习的过程中确实有几个<code>project</code>还是需要费点时间和精力来理解该课程。我觉得最爽的是课程的<code>project</code>，含金量非常高了，主要是有兴趣，各种<code>project</code>的难度适中，并且非常有意思。</p><a id="more"></a><ul><li><p>开发这门课程的作者为<code>Shimon Schocken</code>,作者为上个世纪毕业于<code>mit</code>高材生，目前在以色列的耶路撒冷大学任教，同时作者也是一个非常出色的教育家，在<code>youtube</code>上可以看到作者的演讲：(<a href="https://www.youtube.com/watch?v=iE7YRHxwoDs)，非常适合非专业人士业余学习计算系统。" target="_blank" rel="noopener">https://www.youtube.com/watch?v=iE7YRHxwoDs)，非常适合非专业人士业余学习计算系统。</a></p></li><li><p>通过该课程可以让人快速的接触到计算机系统的从底层到上层的全貌。虽然不如计算专业的学生对计算机系统的每个部分都学习那么深，但是确实是一门能够让人快速入门且有意思的课程，作者从最基础上的与非门讲起，然后逐步深入到<code>mux</code>与<code>demux</code>,然后到最基本的加法器，累加器，逻辑运算器<code>ALU</code>,接着深入到逻辑存储器、寄存器,再到自建的<code>hack</code>汇编语言，最后到包括最基本的<code>CPU</code>,<code>memory</code>,<code>rom</code>的最小计算机系统的搭建，最后一章的内容为搭建一个基本的<code>hack</code>汇编程序的解释器，将<code>hack</code>汇编代码直接翻译成<code>hack</code>的机器码，比较简单。课程的基本路线如下：</p></li></ul><p><img src="https://i.loli.net/2020/09/11/CYjRFA7yud2zpc3.png" alt="1"><br>上半部分课程主要讲了<code>hardware</code>平台，下班部分正在学习主要是<code>software</code>部分。都比较有意思，强烈推荐对技术感兴趣的同学学习这个课程。</p><ul><li>虽然本课程作为基础课程，基本上大部分内容在计算机专业本科的课程计算机组成原理中都学习过，不是特别难。但是本科的课程中，有许多许多的知识点并没有讲清楚，特别是本科课程中基本上只讲理论，并没有将理论联系实际，设计这么具体的计算机系统，十几年前学的计算机组成原理感觉越来越落后时代。但是基本概念还在心中，至少对计算机底层的逻辑架构有了初步的认识，对于最新的技术，其实很快就能捡起来。该课程的<code>project</code>代码全部靠自己业余时间完成，全部通过给出的测试脚本，还是满满的成就感。YouTube有个非常有名的<code>up</code>主<code>Ben Eate</code>，他的课程为自制<code>8</code>位计算机，里面有全部的原理，部分器件的原理可以参考他的<code>YouTube</code>频道，还是非常有意思,f非常不错的学习资料。(<a href="https://www.youtube.com/c/BenEater/" target="_blank" rel="noopener">https://www.youtube.com/c/BenEater/</a>)</li></ul><p>分别分章节来介绍每个章节，所有<code>project</code>的代码全部上传放在<code>github</code>上。<br><a href="https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects" target="_blank" rel="noopener">课程代码</a></p><h2 id="week1-Boolean-Logic"><a href="#week1-Boolean-Logic" class="headerlink" title="week1 Boolean Logic"></a>week1 Boolean Logic</h2><p>$\qquad$第一章主要介绍了最基本的二进制的概念，基本的逻辑布尔代数的运算，并通过<code>HDL</code>语言由最基本的与非门组成各种各样的器件，当然最复杂的可能是<code>dmux</code>和<code>mux</code>电路，这两个基本电路用到的逻辑门器件较多，因为其中都存在各种布尔代数换算，通过公式换算即可。当然最基本的译码器与编码器是组成原理中的基本电路，非常简单。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8-way demultiplexor:</span></span><br><span class="line"><span class="comment"> * &#123;a, b, c, d, e, f, g, h&#125; = &#123;in, 0, 0, 0, 0, 0, 0, 0&#125; if sel == 000</span></span><br><span class="line"><span class="comment"> *                            &#123;0, in, 0, 0, 0, 0, 0, 0&#125; if sel == 001</span></span><br><span class="line"><span class="comment"> *                            etc.</span></span><br><span class="line"><span class="comment"> *                            &#123;0, 0, 0, 0, 0, 0, 0, in&#125; if sel == 111</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/01/DMux4Way.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4-way demultiplexor:</span></span><br><span class="line"><span class="comment"> * &#123;a, b, c, d&#125; = &#123;in, 0, 0, 0&#125; if sel == 00</span></span><br><span class="line"><span class="comment"> *                &#123;0, in, 0, 0&#125; if sel == 01</span></span><br><span class="line"><span class="comment"> *                &#123;0, 0, in, 0&#125; if sel == 10</span></span><br><span class="line"><span class="comment"> *                &#123;0, 0, 0, in&#125; if sel == 11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CHIP DMux &#123;</span><br><span class="line">    IN in, sel;</span><br><span class="line">    OUT a, b;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    Not (in = sel, out = notsel);</span><br><span class="line">    And (a = in, b = notsel, out = a);</span><br><span class="line">    And (a = in, b = sel, out = b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHIP DMux4Way &#123;</span><br><span class="line">    IN in, sel[<span class="number">2</span>];</span><br><span class="line">    OUT a, b, c, d;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">//using Dmux</span></span><br><span class="line">    DMux (in = in, sel = sel[<span class="number">1</span>], a = selab, b = selcd);</span><br><span class="line">    DMux (in = selab, sel = sel[<span class="number">0</span>], a = a, b = b);</span><br><span class="line">    DMux (in = selcd, sel = sel[<span class="number">0</span>], a = c, b = d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHIP DMux8Way &#123;</span><br><span class="line">    IN in, sel[<span class="number">3</span>];</span><br><span class="line">    OUT a, b, c, d, e, f, g, h;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">//DMux 8 way using three DMux</span></span><br><span class="line">    DMux (in = in, sel = sel[<span class="number">2</span>], a = selabcd, b = selefgh);</span><br><span class="line">    DMux4Way(in = selabcd, sel = sel[<span class="number">0.</span><span class="number">.1</span>], a = a, b = b, c = c, d = d);</span><br><span class="line">    DMux4Way(in = selefgh, sel = sel[<span class="number">0.</span><span class="number">.1</span>], a = e, b = f, c = g, d = h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="week2-Boolean-Arithmetic"><a href="#week2-Boolean-Arithmetic" class="headerlink" title="week2 Boolean Arithmetic"></a>week2 Boolean Arithmetic</h2><p>本课程适合有计算机基础的人士，进度非常快，基本上第二章开始就进入基本的加法器、乘法器、累加器的设计，实际还是挺复杂的，需要一定的逻辑电路基础。</p><ul><li><code>16</code>位加法器的实现,具体实现的时候分为两种办法，一种是直接用16个全加器进行串联起来，另一种就是利用公式推导快速加法器。虽然利用全加器串联起来很简单，需要用的门电路也很少，但是在实际工程中肯定是时延非常大。用快速的加法器虽然可以能够减少时延，但是用到的门电路较多，实际成本会很高。因此我们可以选择这种的办法，用4个快速的全加器串联起来组成一个16位的全加器。</li></ul><h3 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">CHIP FastAdd4 &#123;</span><br><span class="line">    IN a[<span class="number">4</span>], b[<span class="number">4</span>], c;</span><br><span class="line">    OUT out[<span class="number">4</span>],</span><br><span class="line">        carry;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    And (a = a[<span class="number">0</span>], b = b[<span class="number">0</span>], out = g0);</span><br><span class="line">    And (a = a[<span class="number">1</span>], b = b[<span class="number">1</span>], out = g1);</span><br><span class="line">    And (a = a[<span class="number">2</span>], b = b[<span class="number">2</span>], out = g2);</span><br><span class="line">    And (a = a[<span class="number">3</span>], b = b[<span class="number">3</span>], out = g3);</span><br><span class="line"></span><br><span class="line">    Or (a = a[<span class="number">0</span>], b = b[<span class="number">0</span>], out = p0);</span><br><span class="line">    Or (a = a[<span class="number">1</span>], b = b[<span class="number">1</span>], out = p1);</span><br><span class="line">    Or (a = a[<span class="number">2</span>], b = b[<span class="number">2</span>], out = p2);</span><br><span class="line">    Or (a = a[<span class="number">3</span>], b = b[<span class="number">3</span>], out = p3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c1 = g0 + p0*c0</span></span><br><span class="line">    And (a = p0, b = c, out = p0c0);</span><br><span class="line">    Or (a = g0, b = p0c0, out = c1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c2 = g1 + p1*g0 + p1*p0*c0</span></span><br><span class="line">    And (a = p1, b = g0, out = p1g0);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p1, in[<span class="number">1</span>] = p0, in[<span class="number">2</span>] = c , in[<span class="number">3</span>] = <span class="literal">true</span>, out = p1p0c0);</span><br><span class="line">    Or4Way  (in[<span class="number">0</span>] = g1, in[<span class="number">1</span>] = p1g0,in[<span class="number">2</span>] = p1p0c0, in[<span class="number">3</span>] = <span class="literal">false</span>, out = c2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c3 = g2 + p2*g1 + p2*p1*g0 + p2*p1*p0*c0</span></span><br><span class="line">    And (a = p2, b = g1, out = p2g1);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p2, in[<span class="number">1</span>] = p1, in[<span class="number">2</span>] = g0, in[<span class="number">3</span>] = <span class="literal">true</span>, out = p2p1g0);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p2, in[<span class="number">1</span>] = p1, in[<span class="number">2</span>] = p0, in[<span class="number">3</span>] = c, out = p2p1p0c0);</span><br><span class="line">    Or4Way (in[<span class="number">0</span>] = g2, in[<span class="number">1</span>] = p2g1, in[<span class="number">2</span>] = p2p1g0, in[<span class="number">3</span>] = p2p1p0c0, out = c3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c4 = g3 + p3*g2 + p3*p2*g1 + p3*p2*p1*g0 + p3*p2*p1*p0*c0</span></span><br><span class="line">    And (a = p3, b = g2, out = p3g2);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p3, in[<span class="number">1</span>] = p2, in[<span class="number">2</span>] = g1, in[<span class="number">3</span>] = <span class="literal">true</span>, out = p3p2g1);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p3, in[<span class="number">1</span>] = p2, in[<span class="number">2</span>] = p1, in[<span class="number">3</span>] = g0, out = p3p2p1g0);</span><br><span class="line">    And8Way (in[<span class="number">0</span>] = p3, in[<span class="number">1</span>] = p2, in[<span class="number">2</span>] = p1, in[<span class="number">3</span>] = p0, in[<span class="number">4</span>] = c, in[<span class="number">5.</span><span class="number">.7</span>] = <span class="literal">true</span>, out = p3p2p1p0c0);</span><br><span class="line">    Or8Way (in[<span class="number">0</span>] = g3, in[<span class="number">1</span>] = p3g2, in[<span class="number">2</span>] = p3p2g1, in[<span class="number">3</span>] = p3p2p1g0, in[<span class="number">4</span>] = p3p2p1p0c0, in[<span class="number">5.</span><span class="number">.7</span>] = <span class="literal">false</span>, out = carry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a + b</span></span><br><span class="line">    Xor (a = a[<span class="number">0</span>], b = b[<span class="number">0</span>], out = add0);</span><br><span class="line">    Xor (a = add0, b = c , out = out[<span class="number">0</span>]);</span><br><span class="line">    Xor (a = a[<span class="number">1</span>], b = b[<span class="number">1</span>], out = add1);</span><br><span class="line">    Xor (a = add1, b = c1 , out = out[<span class="number">1</span>]);</span><br><span class="line">    Xor (a = a[<span class="number">2</span>], b = b[<span class="number">2</span>], out = add2);</span><br><span class="line">    Xor (a = add2, b = c2 , out = out[<span class="number">2</span>]);</span><br><span class="line">    Xor (a = a[<span class="number">3</span>], b = b[<span class="number">3</span>], out = add3);</span><br><span class="line">    Xor (a = add3, b = c3 , out = out[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHIP Add16 &#123;</span><br><span class="line">    IN a[<span class="number">16</span>], b[<span class="number">16</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">   <span class="comment">//Carry-Lookahead Adder , fast adder</span></span><br><span class="line">   FastAdd4 (a = a[<span class="number">0.</span><span class="number">.3</span>], b = b[<span class="number">0.</span><span class="number">.3</span>], c = <span class="literal">false</span>, out = out[<span class="number">0.</span><span class="number">.3</span>], carry = c4);</span><br><span class="line">   FastAdd4 (a = a[<span class="number">4.</span><span class="number">.7</span>], b = b[<span class="number">4.</span><span class="number">.7</span>], c = c4, out = out[<span class="number">4.</span><span class="number">.7</span>], carry = c8);</span><br><span class="line">   FastAdd4 (a = a[<span class="number">8.</span><span class="number">.11</span>], b = b[<span class="number">8.</span><span class="number">.11</span>], c = c8, out = out[<span class="number">8.</span><span class="number">.11</span>], carry = c12);</span><br><span class="line">   FastAdd4 (a = a[<span class="number">12.</span><span class="number">.15</span>], b = b[<span class="number">12.</span><span class="number">.15</span>], c = c12, out = out[<span class="number">12.</span><span class="number">.15</span>], carry = c16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全加器串联:</p><p><img src="https://i.loli.net/2020/09/11/EUjtDbwKPM6BcOy.png" alt="2"><br>全加器直接串联会导致时延</p><p><img src="https://i.loli.net/2020/09/11/mrEAYdo6Z7qsxcF.png" alt><br>全加器的推导，并进行优化</p><p><img src="https://i.loli.net/2020/09/11/PnVvFBZbwH41Eys.png" alt><br>直接对电路进行优化，可以先求出进位直接代入到加法器中。优化电路时延，减少时延。<br><img src="https://i.loli.net/2020/09/11/IvqXaKgQh3OFnZk.png" alt></p><h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><ul><li><p><code>ALU</code>电路的设计，还是稍微复杂，书写<code>hdl</code>语言稍微复杂点，当时还是思考了很长时间，最后全部通过脚本测试。本质上讲控制信号全部转化为公式，很快即可写出逻辑电路语言。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/02/ALU.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The ALU (Arithmetic Logic Unit).</span></span><br><span class="line"><span class="comment"> * Computes one of the following functions:</span></span><br><span class="line"><span class="comment"> * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,</span></span><br><span class="line"><span class="comment"> * x+1, y+1, x-1, y-1, x&amp;y, x|y on two 16-bit inputs, </span></span><br><span class="line"><span class="comment"> * according to 6 input bits denoted zx,nx,zy,ny,f,no.</span></span><br><span class="line"><span class="comment"> * In addition, the ALU computes two 1-bit outputs:</span></span><br><span class="line"><span class="comment"> * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;</span></span><br><span class="line"><span class="comment"> * if the ALU output &lt; 0, ng is set to 1; otherwise ng is set to 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation: the ALU logic manipulates the x and y inputs</span></span><br><span class="line"><span class="comment">// and operates on the resulting values, as follows:</span></span><br><span class="line"><span class="comment">// if (zx == 1) set x = 0        // 16-bit constant</span></span><br><span class="line"><span class="comment">// if (nx == 1) set x = !x       // bitwise not</span></span><br><span class="line"><span class="comment">// if (zy == 1) set y = 0        // 16-bit constant</span></span><br><span class="line"><span class="comment">// if (ny == 1) set y = !y       // bitwise not</span></span><br><span class="line"><span class="comment">// if (f == 1)  set out = x + y  // integer 2's complement addition</span></span><br><span class="line"><span class="comment">// if (f == 0)  set out = x &amp; y  // bitwise and</span></span><br><span class="line"><span class="comment">// if (no == 1) set out = !out   // bitwise not</span></span><br><span class="line"><span class="comment">// if (out == 0) set zr = 1</span></span><br><span class="line"><span class="comment">// if (out &lt; 0) set ng = 1</span></span><br><span class="line"></span><br><span class="line">CHIP ALU &#123;</span><br><span class="line">    IN  </span><br><span class="line">        x[<span class="number">16</span>], y[<span class="number">16</span>],  <span class="comment">// 16-bit inputs        </span></span><br><span class="line">        zx, <span class="comment">// zero the x input?</span></span><br><span class="line">        nx, <span class="comment">// negate the x input?</span></span><br><span class="line">        zy, <span class="comment">// zero the y input?</span></span><br><span class="line">        ny, <span class="comment">// negate the y input?</span></span><br><span class="line">        f,  <span class="comment">// compute out = x + y (if 1) or x &amp; y (if 0)</span></span><br><span class="line">        no; <span class="comment">// negate the out output?</span></span><br><span class="line"></span><br><span class="line">    OUT </span><br><span class="line">        out[<span class="number">16</span>], <span class="comment">// 16-bit output</span></span><br><span class="line">        zr, <span class="comment">// 1 if (out == 0), 0 otherwise</span></span><br><span class="line">        ng; <span class="comment">// 1 if (out &lt; 0),  0 otherwise</span></span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put you code here:</span></span><br><span class="line">    <span class="comment">// clear to zero</span></span><br><span class="line">    <span class="comment">// reverse bit</span></span><br><span class="line">    <span class="comment">// if (zx == 1) set x = 0 </span></span><br><span class="line">    Not (in = zx, out = notzx); </span><br><span class="line">    And1Way16 (a = x, b = notzx, out = zerox);</span><br><span class="line">    <span class="comment">// if (nx == 1) set x = !x</span></span><br><span class="line">    Xor1Way16 (a = zerox, b = nx, out = negx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (zy == 1) set y = 0 </span></span><br><span class="line">    Not (in = zy, out = notzy);</span><br><span class="line">    And1Way16 (a = y, b = notzy, out = zeroy); </span><br><span class="line">    <span class="comment">// if (ny == 1) set y = !y  </span></span><br><span class="line">    Xor1Way16 (a = zeroy, b = ny, out = negy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (f == 1)  set out = x + y</span></span><br><span class="line">    Add16 (a = negx, b = negy, out = sumxy);</span><br><span class="line">    <span class="comment">// if (f == 0)  set out = x &amp; y</span></span><br><span class="line">    And16 (a = negx, b = negy, out = andxy);</span><br><span class="line">    Mux16 (a = andxy, b = sumxy, sel = f ,out = outxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (no == 1) set out = !out </span></span><br><span class="line">    <span class="comment">// if (out &lt; 0) set ng = 1</span></span><br><span class="line">    Xor1Way16 (a = outxy, b = no, out = out);</span><br><span class="line">    Xor1Way16 (a = outxy, b = no, out[<span class="number">0.</span><span class="number">.14</span>] = negxy, out[<span class="number">15</span>] = ng);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (out == 0) set zr = 1</span></span><br><span class="line">    Or16Way  (in[<span class="number">0.</span><span class="number">.14</span>] = negxy, in[<span class="number">15</span>] = <span class="literal">false</span>,out = zeroout);</span><br><span class="line">    Not (in = zeroout, out = zr);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>扩展ALU</strong>：后期准备为ALU增加功能，即增加基本的乘法器、移位器、浮点运算器这些高级功能，同时对其指令集、汇编语言进行扩展。这时后期的重要工作实现。</p></li></ul><h2 id="week3-Memory"><a href="#week3-Memory" class="headerlink" title="week3 Memory"></a>week3 Memory</h2><p>第三章就稍微复杂点了，当时想了很长时间，还查阅了很多资料。这一章主要描写了最基本的<code>D</code>触发器，寄存器，<code>RAM</code>系统等相关器件和系统。在这里其实重点需要阐述一下<code>D</code>触发器，其实非常有意思，当时还在<code>youtube</code>上找到相关的视频，并进行学习。·youtube</p><h3 id="Bit"><a href="#Bit" class="headerlink" title="Bit"></a>Bit</h3><ul><li><strong><code>D</code>触发器</strong><br>D触发器是一个具有记忆功能的，具有两个稳定状态的信息存储器件，是构成多种时序电路的最基本逻辑单元，也是数字逻辑电路中一种重要的单元电路。</li></ul><p><img src="https://i.loli.net/2020/09/11/4jIJB1KmXtFs293.png" alt><br>可以参考<code>youtube</code>的视频。关于<code>d</code>触发器(<a href="https://www.youtube.com/watch?v=YW-_GkUguMM),其中将原理图如下：" target="_blank" rel="noopener">https://www.youtube.com/watch?v=YW-_GkUguMM),其中将原理图如下：</a></p><p><img src="https://i.loli.net/2020/09/11/7vCXQfioMIUTa5R.png" alt><br>我们可以通过D触发器构造基本的存储单元。</p><h3 id="Reigister"><a href="#Reigister" class="headerlink" title="Reigister"></a>Reigister</h3><ul><li><strong>寄存器</strong><br>寄存器即为将16位基本的存储单元并联即可，控制信号共享一位控制信号即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/03/a/Register.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 16-bit register:</span></span><br><span class="line"><span class="comment"> * If load[t] == 1 then out[t+1] = in[t]</span></span><br><span class="line"><span class="comment"> * else out does not change</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CHIP Register &#123;</span><br><span class="line">    IN in[<span class="number">16</span>], load;</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    Bit (in = in[<span class="number">0</span>], load = load, out = out[<span class="number">0</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">1</span>], load = load, out = out[<span class="number">1</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">2</span>], load = load, out = out[<span class="number">2</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">3</span>], load = load, out = out[<span class="number">3</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">4</span>], load = load, out = out[<span class="number">4</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">5</span>], load = load, out = out[<span class="number">5</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">6</span>], load = load, out = out[<span class="number">6</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">7</span>], load = load, out = out[<span class="number">7</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">8</span>], load = load, out = out[<span class="number">8</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">9</span>], load = load, out = out[<span class="number">9</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">10</span>], load = load, out = out[<span class="number">10</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">11</span>], load = load, out = out[<span class="number">11</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">12</span>], load = load, out = out[<span class="number">12</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">13</span>], load = load, out = out[<span class="number">13</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">14</span>], load = load, out = out[<span class="number">14</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">15</span>], load = load, out = out[<span class="number">15</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><ul><li><strong>RAM</strong><br>RAM则类似于多个并联的寄存器组合即可，通过地址码翻译为某个寄存器单元的控制信号即可。比较简单<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/03/a/RAM8.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Memory of 8 registers, each 16 bit-wide. Out holds the value</span></span><br><span class="line"><span class="comment"> * stored at the memory location specified by address. If load==1, then </span></span><br><span class="line"><span class="comment"> * the in value is loaded into the memory location specified by address </span></span><br><span class="line"><span class="comment"> * (the loaded value will be emitted to out from the next time step onward).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CHIP RAM8 &#123;</span><br><span class="line">    IN in[<span class="number">16</span>], load, address[<span class="number">3</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    DMux8Way (in = load, sel = address, a = load0, b = load1 , c = load2, d = load3, e = load4, f = load5, g = load6 , h = load7);</span><br><span class="line">    Register (in = in, load = load0 , out = r0);</span><br><span class="line">    Register (in = in, load = load1 , out = r1);</span><br><span class="line">    Register (in = in, load = load2 , out = r2);</span><br><span class="line">    Register (in = in, load = load3 , out = r3);</span><br><span class="line">    Register (in = in, load = load4 , out = r4);</span><br><span class="line">    Register (in = in, load = load5 , out = r5);</span><br><span class="line">    Register (in = in, load = load6 , out = r6);</span><br><span class="line">    Register (in = in, load = load7 , out = r7);</span><br><span class="line">    Mux8Way16 (a = r0, b = r1, c = r2, d = r3, e = r4, f = r5, g = r6, h = r7, sel = address, out = out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="week4-Machine-Language"><a href="#week4-Machine-Language" class="headerlink" title="week4 Machine Language"></a>week4 Machine Language</h2><p>本周则进入了高级编程环节，主要是讲述了自制计算机的指令编码和汇编语言。在<code>hack</code>计算机系统中，指令集只有追基本的<code>A</code> 指令和<code>C</code>指令。</p><h3 id="A-instruction"><a href="#A-instruction" class="headerlink" title="A instruction"></a>A instruction</h3><ul><li><code>A</code>指令为基本的寻址指令：这个是本科的组成原理中所描述的基本一样，基本的立即寻址、寄存器寻址等等，寻址方式多种。</li></ul><p><img src="https://i.loli.net/2020/09/11/57F2CdWSs8teQxl.png" alt></p><h3 id="C-instruction"><a href="#C-instruction" class="headerlink" title="C instruction"></a>C instruction</h3><ul><li><code>C</code>指令为基本的运算指令：该指令分为三个部分，计算指令 、存储指令、跳转指令。<br>这一章其实也非常有意思，通过最基本的指令集能够了解到计算机系统的基本面貌。</li></ul><p><img src="https://i.loli.net/2020/09/11/QkbmiatBnFzNIYV.png" alt><br>通过最基本的指令集的组合就可以完成许多高级功能。比如最基本的寻址，加减法，乘法，除法。其实还是非常有意思的，对于整个认识计算机系统有很深入而又全面的了解。<br><img src="https://i.loli.net/2020/09/11/sTAGiozmSlw8Ykv.png" alt></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>最基本的乘法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/04/Mult.asm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiplies R0 and R1 and stores the result in R2.</span></span><br><span class="line"><span class="comment">// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)</span></span><br><span class="line"><span class="comment">// created by mike meng @ 2020.7.28</span></span><br><span class="line"><span class="comment">// Put your code here.</span></span><br><span class="line">    @<span class="number">0</span></span><br><span class="line">    D=A</span><br><span class="line">    @R2</span><br><span class="line">    M=D <span class="comment">//set R2 to zero</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @R1</span><br><span class="line">    D=M</span><br><span class="line">    @END</span><br><span class="line">    D;JEQ <span class="comment">// we first need to test if R1 is zero.</span></span><br><span class="line">    @R0</span><br><span class="line">    D=M</span><br><span class="line">    @R2</span><br><span class="line">    M=M+D <span class="comment">// we add R0 once .</span></span><br><span class="line">    @R1</span><br><span class="line">    M=M<span class="number">-1</span> <span class="comment">// we dec R1 one time.</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure></p><h2 id="week5-Computer-Architecture"><a href="#week5-Computer-Architecture" class="headerlink" title="week5 Computer Architecture"></a>week5 Computer Architecture</h2><p>本章的可以算是本课程上半部分的核心，主要讲之前全部设计的器件组合起来，包括ALU、存储器、PC、ROM。通过这些简单的器件组合即可完成，通过理解计算机系统的基本构成和各个部分的基本原理来理解计算机系统的构成。</p><h3 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h3><ul><li>冯诺依曼计算机体系的基本构成，如下图所示。代码和程序放在一个存储器中，通过不同德时钟周期，取指令和取数据来完成计算机系统的运行。另一种讲数据和指令分开存储的称之为哈佛结构，主要是用于<code>DSP</code>上居多。</li></ul><p><img src="https://i.loli.net/2020/09/11/6hswpjAoX8TQEqr.png" alt></p><ul><li>本次涉及的hack系统基本构成如下：其中<code>ROM</code>存储程序指令，<code>CPU</code>发复杂翻译指令并执行，<code>MEMORY</code>复杂存储和读取数据。<br><img src="https://i.loli.net/2020/09/11/lfxhSpP3nIM7z8o.png" alt><br>相关的逻辑部件链接如下，基本上按照图中的连线进行连接即可完成相关的计算机系统，实际非常简单。<br><img src="https://i.loli.net/2020/09/11/xuN9dYi7sKLPBnH.png" alt></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CHIP Computer &#123;</span><br><span class="line">    IN reset;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    ROM32K(address = inAddr, out = outRom);</span><br><span class="line">    CPU(inM = outM,instruction = outRom, reset = reset,outM = value,writeM = loadM,addressM = outAddr,pc = inAddr);</span><br><span class="line">    Memory(in = value, load = loadM, address = outAddr, out = outM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li><strong>CPU</strong><br><code>CPU</code>的结构示意图如下：<br><img src="https://i.loli.net/2020/09/11/nhXMcdkV9eS4W2B.png" alt><br>在<code>hack</code>系统中<code>CPU</code>负责将指令进行翻译，<code>hack</code>系统存在<code>A</code>指令与<code>C</code>指令。翻译指令还是比较复杂，如果发现为<code>A</code>指令，则直接将<code>A</code>寄存器设置为指令中的地址数据，如果发现为<code>C</code>指令则分别存储、运算、跳转三个子部分进行解释:</li></ul><ol><li><code>c</code>指令的基本结构：<br><img src="https://i.loli.net/2020/09/11/QkbmiatBnFzNIYV.png" alt></li><li>计算指令部分解析：<br><img src="https://i.loli.net/2020/09/11/fFDZK8HrBYs9uhQ.png" alt></li><li>存储指令部分解析：<br><img src="https://i.loli.net/2020/09/11/HRDN1X2iuO6BWlr.png" alt></li><li>跳转指令部分解析：<br><img src="https://i.loli.net/2020/09/11/ZNPM2d9aIQYODCl.png" alt><br>CPU的HDL代码稍微复杂点，大概花了半天时间最终搞定，有几个小问题思考花费了不少时间。特别是关于存储指令的部分，需要将<code>ALU</code>的运算结果存储到不同的存储器中需要花费不少的细节问题,可以将其存储到<code>A</code>寄存器，<code>D</code>寄存器，<code>MEMORY</code>中。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CHIP CPU &#123;</span><br><span class="line">    IN  inM[<span class="number">16</span>],         <span class="comment">// M value input  (M = contents of RAM[A])</span></span><br><span class="line">        instruction[<span class="number">16</span>], <span class="comment">// Instruction for execution</span></span><br><span class="line">        reset;           <span class="comment">// Signals whether to re-start the current</span></span><br><span class="line">                         <span class="comment">// program (reset==1) or continue executing</span></span><br><span class="line">                         <span class="comment">// the current program (reset==0).</span></span><br><span class="line"></span><br><span class="line">    OUT outM[<span class="number">16</span>],        <span class="comment">// M value output</span></span><br><span class="line">        writeM,          <span class="comment">// Write to M? </span></span><br><span class="line">        addressM[<span class="number">15</span>],    <span class="comment">// Address in data memory (of M)</span></span><br><span class="line">        pc[<span class="number">15</span>];          <span class="comment">// address of next instruction</span></span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    <span class="comment">//A Instruction</span></span><br><span class="line">    Not(in = instruction[<span class="number">15</span>], out = loadA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C Instruction</span></span><br><span class="line">    Mux16(a = Addr, b = inM, sel = instruction[<span class="number">12</span>], out = outAM);</span><br><span class="line">    ALU(x = outD, y = outAM, zx = instruction[<span class="number">11</span>], nx = instruction[<span class="number">10</span>],zy = instruction[<span class="number">9</span>],ny = instruction[<span class="number">8</span>],f = instruction[<span class="number">7</span>], no = instruction[<span class="number">6</span>], out = outC, out = outM,zr = outZr, ng = outNg);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//store compute result</span></span><br><span class="line">    DMux8Way(in = <span class="literal">true</span>, sel = instruction[<span class="number">3.</span><span class="number">.5</span>], a = selnull, b = selM, c = selD, d = selMD, e = selA, f = selAM, g = selAD, h = selAMD);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//store M </span></span><br><span class="line">    Or8Way(in[<span class="number">0</span>] = selM, in[<span class="number">1</span>] = selMD, in[<span class="number">2</span>] = selMD, in[<span class="number">3</span>] = selAMD,in[<span class="number">4.</span><span class="number">.7</span>] = <span class="literal">false</span>, out = storeM);</span><br><span class="line">    And(a = storeM, b = instruction[<span class="number">15</span>], out = writeM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//store D</span></span><br><span class="line">    Or8Way(in[<span class="number">0</span>] = selD, in[<span class="number">1</span>] = selMD, in[<span class="number">2</span>] = selAD, in[<span class="number">3</span>] = selAMD,in[<span class="number">4.</span><span class="number">.7</span>] = <span class="literal">false</span>, out = storeD);</span><br><span class="line">    And(a = storeD, b = instruction[<span class="number">15</span>], out = writeD);</span><br><span class="line">    DRegister(in = outC ,load = writeD, out = outD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//store A</span></span><br><span class="line">    Or8Way(in[<span class="number">0</span>] = selA, in[<span class="number">1</span>] = selAM, in[<span class="number">2</span>] = selAD, in[<span class="number">3</span>] = selAMD,in[<span class="number">4.</span><span class="number">.7</span>] = <span class="literal">false</span>, out = storeA);</span><br><span class="line">    Mux16(a[<span class="number">15</span>] = <span class="literal">false</span>,a[<span class="number">0.</span><span class="number">.14</span>] = instruction[<span class="number">0.</span><span class="number">.14</span>], b = outC, sel = instruction[<span class="number">15</span>], out = outAddr);</span><br><span class="line">    Or(a = loadA, b = storeA, out = writeA);</span><br><span class="line">    ARegister(in = outAddr, load = writeA, out = Addr,out[<span class="number">0.</span><span class="number">.14</span>] = addressM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Jump PC</span></span><br><span class="line">    DMux8Way(in = instruction[<span class="number">15</span>],sel = instruction[<span class="number">0.</span><span class="number">.2</span>], a = JNULL, b = JGT, c = JEQ, d = JGE, e = JLT, f = JNE, g = JLE, h = JMP);</span><br><span class="line">    Not(in = outZr, out = notZero);</span><br><span class="line">    Not(in = outNg, out = notNeg);</span><br><span class="line">    And(a = JEQ, b = outZr, out = loadEQ);</span><br><span class="line">    And(a = JNE, b = notZero, out = loadNE);</span><br><span class="line">    And(a = JLT, b = outNg, out = loadLT);</span><br><span class="line">    And(a = JGE, b = notNeg, out = loadGE);</span><br><span class="line">    And(a = notZero, b = notNeg, out = outGT);</span><br><span class="line">    And(a = outGT, b = JGT, out = loadGT);</span><br><span class="line">    Or(a = outZr, b = outNg, out = outLE);</span><br><span class="line">    And(a = outLE, b = JLE, out = loadLE);</span><br><span class="line">    Or8Way(in[<span class="number">0</span>] = loadGT, in[<span class="number">1</span>] = loadEQ, in[<span class="number">2</span>] = loadGE, in[<span class="number">3</span>] = loadLT, in[<span class="number">4</span>] = loadNE, in[<span class="number">5</span>] = loadLE, in[<span class="number">6</span>] = JMP, in[<span class="number">7</span>] = <span class="literal">false</span>, out = loadPC);</span><br><span class="line">    PC(in = Addr,load = loadPC,inc = <span class="literal">true</span>,reset = reset, out[<span class="number">0.</span><span class="number">.14</span>] = pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><ul><li><strong>MEMORY</strong><br><strong>memory</strong>部分较为简单，主要是注意到地址信号线的选择计算问题即可。其余的难度不大，基本上是组成原理中学的那套东西。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CHIP Memory &#123;</span><br><span class="line">    IN in[<span class="number">16</span>], load, address[<span class="number">15</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    <span class="comment">//load mux</span></span><br><span class="line">    DMux(in = load, sel = address[<span class="number">14</span>] , a = loadram , b = loadmm);</span><br><span class="line">    DMux(in = loadmm, sel = address[<span class="number">13</span>], a = loadscreen, b = loadkeyboard);</span><br><span class="line">    RAM16K(in = in,load = loadram,address = address[<span class="number">0.</span><span class="number">.13</span>] , out = outram);</span><br><span class="line">    Screen(in = in,load = loadscreen,address = address[<span class="number">0.</span><span class="number">.12</span>] , out = outscreen);</span><br><span class="line">    Keyboard(out = outkeyboard);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//out mux</span></span><br><span class="line">    Mux16(a = outscreen, b = outkeyboard, sel = address[<span class="number">13</span>], out = outmm);</span><br><span class="line">    Mux16(a = outram, b = outmm, sel = address[<span class="number">14</span>], out = out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="week6-Assembler"><a href="#week6-Assembler" class="headerlink" title="week6 Assembler"></a>week6 Assembler</h2><p>本章的内容其实较为简单，主要是为<code>hack</code>系统编写一个汇编解释器，将汇编语言编译为机器码，其实主要是掌握<code>hack</code>系统的基本指令即可。实际的<code>hack</code>系统中有几种指令和符号系统：</p><ul><li><strong>A</strong>指令： 这个基本的汇编语言主要是以<code>@</code>开头的汇编程序指令解析即可。</li><li><strong>C</strong>指令:  这部分也很容易主要查看是否有<code>;</code>与<code>=</code>即可判断该指令，并且将其分为三个部分，<code>计算</code>、<code>存储</code>、<code>跳转</code>。</li><li><strong>固定符号</strong>: 实际指令执行过程中我们只需要将这些固定标签翻译为特定地址即可。</li></ul><p><img src="https://i.loli.net/2020/09/11/2zXTNlhvWBJEytj.png" alt></p><ul><li><strong>变量符号</strong>: 我们在实际过程运算过程中遇到第一个<code>A</code>指令时，则认为该符号变量的地址。后续的变量地址则固定进行递增即可，按照固定的地址是从<code>16</code>开始。我们检测<code>A</code>指令时遇到的第一个标签。</li><li><strong>跳转标签</strong>: 我们在程序的运行过程中有许多程序的跳转指令，比如跳转到某个固定的指令地址起开始执行，实际即为将<code>PC</code>寄存器的内容修改为跳转地址即可。我们解析时主要解析查看汇编语言中是否存在<code>()</code>即可。</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEGBUG_LEVEL 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFO_LEVEL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WARNINT_LEVEL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_LEVEL 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ADDR 190000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START_ADDR_OPEN 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMORY_ADDR_LEN 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> debug = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(<span class="keyword">int</span> level,<span class="built_in">string</span> text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;text&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimSpace</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = s.find_first_not_of(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos1 != <span class="built_in">string</span>::npos) s.erase(<span class="number">0</span>,pos1);</span><br><span class="line">        <span class="keyword">int</span> pos2 = s.find_last_not_of(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos2 != <span class="built_in">string</span>::npos) s.erase(pos2+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimComments</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = s.find_first_of(<span class="string">"//"</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos != <span class="built_in">string</span>::npos) s.erase(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUpper</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; s.size() != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isDigit(s[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum = sum*<span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; MAX_ADDR) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkMnemonics</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isUpper(c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">binaryCode</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        ans = to_string(x%<span class="number">2</span>) + ans;</span><br><span class="line">        x = x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initPredefTable</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp; symbolTable)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*Predefined Symbols*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)&#123;</span><br><span class="line">        symbolTable[<span class="string">"R"</span> + to_string(i)] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    symbolTable[<span class="string">"SP"</span>] = <span class="number">0</span>;</span><br><span class="line">    symbolTable[<span class="string">"LCL"</span>] = <span class="number">1</span>;</span><br><span class="line">    symbolTable[<span class="string">"ARG"</span>] = <span class="number">2</span>;</span><br><span class="line">    symbolTable[<span class="string">"THIS"</span>] = <span class="number">3</span>;</span><br><span class="line">    symbolTable[<span class="string">"THAT"</span>] = <span class="number">4</span>;</span><br><span class="line">    symbolTable[<span class="string">"SCREEN"</span>] = <span class="number">16384</span>;</span><br><span class="line">    symbolTable[<span class="string">"KBD"</span>] = <span class="number">24576</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initJumpTable</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &amp; jumpTable)</span></span>&#123;</span><br><span class="line">    jumpTable[<span class="string">""</span>] = <span class="string">"000"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JGT"</span>] = <span class="string">"001"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JEQ"</span>] = <span class="string">"010"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JGE"</span>] = <span class="string">"011"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JLT"</span>] = <span class="string">"100"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JNE"</span>] = <span class="string">"101"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JLE"</span>] = <span class="string">"110"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JMP"</span>] = <span class="string">"111"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initDestTable</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &amp; destTable)</span></span>&#123;</span><br><span class="line">    destTable[<span class="string">""</span>] = <span class="string">"000"</span>;</span><br><span class="line">    destTable[<span class="string">"M"</span>] = <span class="string">"001"</span>;</span><br><span class="line">    destTable[<span class="string">"D"</span>] = <span class="string">"010"</span>;</span><br><span class="line">    destTable[<span class="string">"MD"</span>] = <span class="string">"011"</span>;</span><br><span class="line">    destTable[<span class="string">"A"</span>] = <span class="string">"100"</span>;</span><br><span class="line">    destTable[<span class="string">"AM"</span>] = <span class="string">"101"</span>;</span><br><span class="line">    destTable[<span class="string">"AD"</span>] = <span class="string">"110"</span>;</span><br><span class="line">    destTable[<span class="string">"AMD"</span>] = <span class="string">"111"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initCompTable</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &amp; compTable)</span></span>&#123;</span><br><span class="line">    compTable[<span class="string">"0"</span>]   = <span class="string">"0101010"</span>;</span><br><span class="line">    compTable[<span class="string">"1"</span>]   = <span class="string">"0111111"</span>;</span><br><span class="line">    compTable[<span class="string">"-1"</span>]  = <span class="string">"0111010"</span>;</span><br><span class="line">    compTable[<span class="string">"D"</span>]   = <span class="string">"0001100"</span>;</span><br><span class="line">    compTable[<span class="string">"A"</span>]   = <span class="string">"0110000"</span>;</span><br><span class="line">    compTable[<span class="string">"M"</span>]   = <span class="string">"1110000"</span>;</span><br><span class="line">    compTable[<span class="string">"!D"</span>]  = <span class="string">"0001101"</span>;</span><br><span class="line">    compTable[<span class="string">"!A"</span>]  = <span class="string">"0110001"</span>;</span><br><span class="line">    compTable[<span class="string">"!M"</span>]  = <span class="string">"1110001"</span>;</span><br><span class="line">    compTable[<span class="string">"-D"</span>]  = <span class="string">"0001111"</span>;</span><br><span class="line">    compTable[<span class="string">"-A"</span>]  = <span class="string">"0110011"</span>;</span><br><span class="line">    compTable[<span class="string">"-M"</span>]  = <span class="string">"1110011"</span>;</span><br><span class="line">    compTable[<span class="string">"D+1"</span>] = <span class="string">"0011111"</span>;</span><br><span class="line">    compTable[<span class="string">"A+1"</span>] = <span class="string">"0110111"</span>;</span><br><span class="line">    compTable[<span class="string">"M+1"</span>] = <span class="string">"1110111"</span>;</span><br><span class="line">    compTable[<span class="string">"D-1"</span>] = <span class="string">"0001110"</span>;</span><br><span class="line">    compTable[<span class="string">"A-1"</span>] = <span class="string">"0110010"</span>;</span><br><span class="line">    compTable[<span class="string">"M-1"</span>] = <span class="string">"1110010"</span>;</span><br><span class="line">    compTable[<span class="string">"D+A"</span>] = <span class="string">"0000010"</span>;</span><br><span class="line">    compTable[<span class="string">"D+M"</span>] = <span class="string">"1000010"</span>;</span><br><span class="line">    compTable[<span class="string">"D-A"</span>] = <span class="string">"0010011"</span>;</span><br><span class="line">    compTable[<span class="string">"D-M"</span>] = <span class="string">"1010011"</span>;</span><br><span class="line">    compTable[<span class="string">"A-D"</span>] = <span class="string">"0000111"</span>;</span><br><span class="line">    compTable[<span class="string">"M-D"</span>] = <span class="string">"1000111"</span>;</span><br><span class="line">    compTable[<span class="string">"D&amp;A"</span>] = <span class="string">"0000000"</span>;</span><br><span class="line">    compTable[<span class="string">"D&amp;M"</span>] = <span class="string">"1000000"</span>;</span><br><span class="line">    compTable[<span class="string">"D|A"</span>] = <span class="string">"0010101"</span>;</span><br><span class="line">    compTable[<span class="string">"D|M"</span>] = <span class="string">"1010101"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    ofstream fout;</span><br><span class="line">    <span class="keyword">int</span> currAddr = START_ADDR_OPEN;</span><br><span class="line">    <span class="keyword">int</span> currLine = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;  symbolTable;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;   labelTable;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; jumpTable;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; destTable;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; compTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*initial symbol table*/</span></span><br><span class="line">    initPredefTable(symbolTable);</span><br><span class="line">    initJumpTable(jumpTable);</span><br><span class="line">    initDestTable(destTable);</span><br><span class="line">    initCompTable(compTable);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        trace(ERROR_LEVEL,<span class="string">"Wrong File, Bad parameter.\n\r"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fin.open(argv[<span class="number">1</span>],<span class="built_in">std</span>::ifstream::in);</span><br><span class="line">    fout.open(argv[<span class="number">2</span>],<span class="built_in">std</span>::ifstream::out);</span><br><span class="line">    <span class="keyword">if</span>(!fin||!fout)&#123;</span><br><span class="line">        trace(ERROR_LEVEL,<span class="string">"Wrong File, Bad parameter.\n\r"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*read assembler program from file*/</span></span><br><span class="line">    <span class="comment">/*parse label*/</span></span><br><span class="line">    <span class="built_in">string</span> assembler;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; assemblerArr;</span><br><span class="line">    <span class="keyword">while</span>(getline(fin,assembler))&#123;</span><br><span class="line">        trimComments(assembler); <span class="comment">// trim comments</span></span><br><span class="line">        trimSpace(assembler); <span class="comment">//trim space</span></span><br><span class="line">        <span class="keyword">if</span>(assembler.empty() || assembler.size() &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(assembler[<span class="number">0</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">            <span class="comment">/*parse Label*/</span></span><br><span class="line">            <span class="keyword">if</span>(assembler.back() != <span class="string">')'</span>)&#123;</span><br><span class="line">                trace(ERROR_LEVEL,<span class="string">"Wrong Assembler, we need right ')'.\n\r"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(assembler.size() &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">                trace(ERROR_LEVEL,<span class="string">"Wrong Assembler, label can not be empty!\n\r"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> label = assembler.substr(<span class="number">1</span>,assembler.size()<span class="number">-2</span>);</span><br><span class="line">            labelTable[label] = currLine;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            assemblerArr.push_back(assembler);</span><br><span class="line">            currLine++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : assemblerArr)&#123;</span><br><span class="line">        <span class="comment">/*parse A instruction*/</span></span><br><span class="line">        <span class="built_in">string</span> instruction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="string">'@'</span>)&#123;</span><br><span class="line">            instruction = <span class="string">"0"</span>;</span><br><span class="line">            <span class="built_in">string</span> var = v.substr(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> address = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isNumber(var))&#123;</span><br><span class="line">                address = stoi(var);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(symbolTable.count(var))&#123;</span><br><span class="line">                    address = symbolTable[var];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(labelTable.count(var))&#123;</span><br><span class="line">                    address = labelTable[var];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    address = currAddr++;</span><br><span class="line">                    symbolTable[var] = address;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            instruction += binaryCode(address,MEMORY_ADDR_LEN);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*parse C instruction*/</span></span><br><span class="line">            instruction = <span class="string">"111"</span>;</span><br><span class="line">            <span class="built_in">string</span> dest = <span class="string">""</span>;</span><br><span class="line">            <span class="built_in">string</span> comp = <span class="string">""</span>;</span><br><span class="line">            <span class="built_in">string</span> jump = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pos1 = v.find_first_of(<span class="string">";"</span>);</span><br><span class="line">            <span class="keyword">int</span> pos2 = v.find_first_of(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pos1 == <span class="built_in">string</span>::npos &amp;&amp; pos2 == <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                trace(ERROR_LEVEL,<span class="string">"Wrong Assembler, we need the right command!\n\r"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pos1 == <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                jump = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span>(pos2 != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                    dest = v.substr(<span class="number">0</span>,pos2);</span><br><span class="line">                    comp = v.substr(pos2+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                jump = v.substr(pos1+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(pos2 != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                    dest = v.substr(<span class="number">0</span>,pos2);</span><br><span class="line">                    comp = v.substr(pos2+<span class="number">1</span>,pos1-pos2<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    comp = v.substr(<span class="number">0</span>,pos1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!jumpTable.count(jump)||</span><br><span class="line">               !compTable.count(comp)||</span><br><span class="line">               !destTable.count(dest))&#123;</span><br><span class="line">                   trace(ERROR_LEVEL,<span class="string">"Wrong Assembler, we need the right command!\n\r"</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            instruction += compTable[comp] + destTable[dest] + jumpTable[jump];</span><br><span class="line">        &#125;</span><br><span class="line">        fout&lt;&lt;instruction&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fin.close();</span><br><span class="line">    fout.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p><code>build a computer</code>该课程上半部分已经全部学完了，总的来说课程还是非常有意思，比本科时上的计算机组成原理有意思多了。还是有很多让人回味的地方，下半部分的课程主要是讲<code>虚拟机</code>,<code>编程语言</code>,<code>编译器</code>,<code>操作系统</code>等纯软件的部分。总的课程还是非常适合计算机专业或者非计算机专业认真学习的，计划在后续的两个月内完成下半部分的课程，主要是写代码较多，<code>project</code>的难度较大。</p><ul><li>后期准备将所有的<code>project</code>用<code>logsim</code>全部重新写一遍。</li><li>扩展ALU的功能，能够实现移位器、乘法器、浮点运算器的实现。</li><li>扩展<code>hack</code>汇编程序，实现基本的支持浮点运算器、移位操作、乘法操作的语言。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-I-project-centered-course&quot;&gt;&lt;a href=&quot;#Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-I-project-centered-course&quot; class=&quot;headerlink&quot; title=&quot;Build a Modern Computer from First Principles: Nand to Tetris Part I (project-centered course)&quot;&gt;&lt;/a&gt;Build a Modern Computer from First Principles: Nand to Tetris Part I (project-centered course)&lt;/h1&gt;&lt;p&gt;$~~~~$接触到这门课程是在知乎上有人强烈推荐的，感觉这种靠谱的课程特别是有意义。网上搜了下背景资料，似乎这门课程是给哈佛大学的本科生开的课程，我是在工作之余陆陆续续的将这门课程的上半部分学完了，每周差不多要花上至少三个小时，后面的project还是非常有意思的。这门课程上半部分主要是讲如何从最基本的与非门搭建成一个完成的计算机，下半部分主要是讲在自己搭建的计算机上如何实现虚拟机、高级语言编译器、操作系统等等相关的课程。总的来说课程还是非常有意思的，特别适合稍微有计算机基础的人士来学这门课程，这门课程的前置课程是哈佛大学的&lt;code&gt;cs101&lt;/code&gt;计算机基础课程。在学习的过程中确实有几个&lt;code&gt;project&lt;/code&gt;还是需要费点时间和精力来理解该课程。我觉得最爽的是课程的&lt;code&gt;project&lt;/code&gt;，含金量非常高了，主要是有兴趣，各种&lt;code&gt;project&lt;/code&gt;的难度适中，并且非常有意思。&lt;/p&gt;
    
    </summary>
    
    
      <category term="公开课" scheme="http://yoursite.com/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
      <category term="coursera" scheme="http://yoursite.com/tags/coursera/"/>
    
  </entry>
  
  <entry>
    <title>【AtCoder】 Contest177</title>
    <link href="http://yoursite.com/2020/08/31/198/"/>
    <id>http://yoursite.com/2020/08/31/198/</id>
    <published>2020-08-31T07:55:56.959Z</published>
    <updated>2020-09-04T04:48:07.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="abc177"><a href="#abc177" class="headerlink" title="abc177"></a>abc177</h1><p><code>atcoder</code>的题目适合初学者，且大部分为数学技巧，还是质量非常高，感觉比<code>cf</code>难度小多了。<br>但是对于实际做题来说，还是非常喜欢atcoder这种风格，主要有以下几个有点。</p><ul><li>题目不罗嗦，就是那么几句话就可以交代清楚了，好多题目啰里啰唆的一大堆才看明白题目。最烦某些OJ的题目一大堆废话，才能看明白题目，纯粹浪费时间。</li><li>题目质量非常高，代码较为精简，因为平时根本没有时间来练习哪些耗费时间的题目。</li><li>时区的问题，日本的时差与中国的时差基本上没有太大区别，<code>atcoder</code>的contest刚好是在周六和周日晚上八点，刚好符合自己的作息习惯，平时根本没有时间来刷题，刚好可以利用这两个时间段好好练习来提高自己的算法能力。</li></ul><a id="more"></a><h2 id="C-Sum-of-product-of-pairs"><a href="#C-Sum-of-product-of-pairs" class="headerlink" title="C - Sum of product of pairs"></a>C - Sum of product of pairs</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200831155743.png" alt="1"></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc177/tasks/abc177_c" target="_blank" rel="noopener">https://atcoder.jp/contests/abc177/tasks/abc177_c</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口实现</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接求出前缀和即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; prefix(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        prefix[i] = (prefix[i<span class="number">-1</span>] + arr[i<span class="number">-1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        ans = (ans + (arr[i<span class="number">-1</span>]*(prefix[n] - prefix[i] + mod)%mod))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="D-Friends"><a href="#D-Friends" class="headerlink" title="D - Friends"></a>D - Friends</h2><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200902173858.png" alt="2"></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc177/tasks/abc177_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc177/tasks/abc177_d</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 集合</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>非常简单的DSU，求最大的集合的数目即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 == y1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(sz[x1] &gt; sz[y1])&#123;</span><br><span class="line">            parent[y1] = x1;</span><br><span class="line">            sz[x1] += sz[y1];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[x1] = y1;</span><br><span class="line">            sz[y1] += sz[x1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;sz[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="function">Dsu <span class="title">du</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        du.uni(x<span class="number">-1</span>,y<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = du.find(i);</span><br><span class="line">        ans = max(ans,du.length(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="E-Coprime-Editorial"><a href="#E-Coprime-Editorial" class="headerlink" title="E - Coprime Editorial"></a>E - Coprime Editorial</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200902174103.png" alt="3"></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc177/tasks/abc177_e" target="_blank" rel="noopener">https://atcoder.jp/contests/abc177/tasks/abc177_e</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>快速素因子筛选</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>直接求pairwise时肯定会超时。我们需要换种思路。</li><li>求出所有从$(i+1,n)$的素数因子集合，如何当前数<code>A[i]</code>的质因子中存在与集合中重复的数，则仍该该序列不为<code>pairwise</code>.</li><li>可以用到快速的最小质因子筛选，在<code>O(n)</code>的时间复杂度内完成。</li><li>我们对每个元素进行质因子分解，时间复杂度为<code>O(lgn)</code>.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MAXN = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line">ll factor[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; arr(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(factor,<span class="number">0</span>,<span class="keyword">sizeof</span>(factor));</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= MAXN; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(factor[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        factor[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(ll j = i*i; j &lt; MAXN; j += i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(factor[j] == <span class="number">0</span>) factor[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 求所有的数的最小质因子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; exists;</span><br><span class="line">    <span class="keyword">bool</span> pairwise = <span class="literal">true</span>;</span><br><span class="line">    ll setwise = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt; curFact;</span><br><span class="line">        ll now = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (now &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ll sml = factor[now];</span><br><span class="line">            <span class="keyword">if</span> (curFact.empty() || curFact.back() != sml) curFact.push_back(sml);</span><br><span class="line">            now /= sml;</span><br><span class="line">        &#125;<span class="comment">//求出该数的所有不同的质因子。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f: curFact) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exists.count(f)) pairwise = <span class="literal">false</span>;</span><br><span class="line">            exists.insert(f);</span><br><span class="line">        &#125;<span class="comment">//如果该数所有的质因子与现有的质因子集合存在交集。</span></span><br><span class="line">        setwise = __gcd(setwise,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pairwise)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pairwise coprime\n"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setwise == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"setwise coprime\n"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not coprime\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="F-I-hate-Shortest-Path-Problem"><a href="#F-I-hate-Shortest-Path-Problem" class="headerlink" title="F - I hate Shortest Path Problem"></a>F - I hate Shortest Path Problem</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200904124742.png" alt="5"></p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc177/tasks/abc177_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc177/tasks/abc177_f</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>线段树</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>直接求pairwise时肯定会超时。我们需要换种思路。</li><li>求出所有从$(i+1,n)$的素数因子集合，如何当前数<code>A[i]</code>的质因子中存在与集合中重复的数，则仍该该序列不为<code>pairwise</code>.</li><li>可以用到快速的最小质因子筛选，在<code>O(n)</code>的时间复杂度内完成。</li><li>我们对每个元素进行质因子分解，时间复杂度为<code>O(lgn)</code>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MAXN = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line">ll factor[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; arr(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(factor,<span class="number">0</span>,<span class="keyword">sizeof</span>(factor));</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= MAXN; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(factor[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        factor[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(ll j = i*i; j &lt; MAXN; j += i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(factor[j] == <span class="number">0</span>) factor[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 求所有的数的最小质因子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; exists;</span><br><span class="line">    <span class="keyword">bool</span> pairwise = <span class="literal">true</span>;</span><br><span class="line">    ll setwise = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt; curFact;</span><br><span class="line">        ll now = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (now &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ll sml = factor[now];</span><br><span class="line">            <span class="keyword">if</span> (curFact.empty() || curFact.back() != sml) curFact.push_back(sml);</span><br><span class="line">            now /= sml;</span><br><span class="line">        &#125;<span class="comment">//求出该数的所有不同的质因子。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f: curFact) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exists.count(f)) pairwise = <span class="literal">false</span>;</span><br><span class="line">            exists.insert(f);</span><br><span class="line">        &#125;<span class="comment">//如果该数所有的质因子与现有的质因子集合存在交集。</span></span><br><span class="line">        setwise = __gcd(setwise,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pairwise)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pairwise coprime\n"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setwise == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"setwise coprime\n"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not coprime\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;abc177&quot;&gt;&lt;a href=&quot;#abc177&quot; class=&quot;headerlink&quot; title=&quot;abc177&quot;&gt;&lt;/a&gt;abc177&lt;/h1&gt;&lt;p&gt;&lt;code&gt;atcoder&lt;/code&gt;的题目适合初学者，且大部分为数学技巧，还是质量非常高，感觉比&lt;code&gt;cf&lt;/code&gt;难度小多了。&lt;br&gt;但是对于实际做题来说，还是非常喜欢atcoder这种风格，主要有以下几个有点。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;题目不罗嗦，就是那么几句话就可以交代清楚了，好多题目啰里啰唆的一大堆才看明白题目。最烦某些OJ的题目一大堆废话，才能看明白题目，纯粹浪费时间。&lt;/li&gt;
&lt;li&gt;题目质量非常高，代码较为精简，因为平时根本没有时间来练习哪些耗费时间的题目。&lt;/li&gt;
&lt;li&gt;时区的问题，日本的时差与中国的时差基本上没有太大区别，&lt;code&gt;atcoder&lt;/code&gt;的contest刚好是在周六和周日晚上八点，刚好符合自己的作息习惯，平时根本没有时间来刷题，刚好可以利用这两个时间段好好练习来提高自己的算法能力。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Facebook Hacker Cup】 2020 Qual</title>
    <link href="http://yoursite.com/2020/08/31/197/"/>
    <id>http://yoursite.com/2020/08/31/197/</id>
    <published>2020-08-31T07:41:53.748Z</published>
    <updated>2020-08-31T07:44:12.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="facebook-hacker-cup-quality-round"><a href="#facebook-hacker-cup-quality-round" class="headerlink" title="facebook hacker cup quality round"></a>facebook hacker cup quality round</h1><p><code>facebook hacker cup</code>比赛还是挺有意思的，前面几轮题目质量还是非常高，正规的比赛题目还是非常的不错。<code>quality round</code>题目就非常容易了，几乎是<code>leetcode medium</code>难度的水平。</p><h2 id="5185-Problem-A-Travel-Restrictions"><a href="#5185-Problem-A-Travel-Restrictions" class="headerlink" title="5185. Problem A: Travel Restrictions"></a>5185. Problem A: Travel Restrictions</h2><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定连续的航班，给定航站的规则，需要按照以下规则来进行飞行。</p><ul><li><code>in[i] = Y</code>表示第<code>i</code>个航站可以允许飞机进入，<code>in[i] = N</code>表示第<code>i</code>个航站禁止飞机进入，</li><li><code>out[i] = Y</code>表示第<code>i</code>个航站可以允许飞机飞出，<code>out[i] = N</code>表示第<code>i</code>个航站禁止飞机飞出。<br>给出所有航站的规则，求出所有航站的之间的飞行是否可达，用矩阵表示。</li></ul><p><strong>Sample Input</strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">YY</span><br><span class="line">YY</span><br><span class="line"><span class="number">2</span></span><br><span class="line">NY</span><br><span class="line">YY</span><br><span class="line"><span class="number">2</span></span><br><span class="line">NN</span><br><span class="line">YY</span><br><span class="line"><span class="number">5</span></span><br><span class="line">YNNYY</span><br><span class="line">YYYNY</span><br><span class="line"><span class="number">10</span></span><br><span class="line">NYYYNNYYYY</span><br><span class="line">YYNYYNYYNY</span><br></pre></td></tr></table></figure><br><strong>Sample Output</strong><br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Case</span> <span class="meta">#1:</span></span><br><span class="line">YY</span><br><span class="line">YY</span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#2:</span></span><br><span class="line">YY</span><br><span class="line">NY</span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#3:</span></span><br><span class="line">YN</span><br><span class="line">NY</span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#4:</span></span><br><span class="line">YNNNN</span><br><span class="line">YYNNN</span><br><span class="line">NNYYN</span><br><span class="line">NNNYN</span><br><span class="line">NNNYY</span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#5:</span></span><br><span class="line">YYYNNNNNNN</span><br><span class="line">NYYNNNNNNN</span><br><span class="line">NNYNNNNNNN</span><br><span class="line">NNYYNNNNNN</span><br><span class="line">NNYYYNNNNN</span><br><span class="line">NNNNNYNNNN</span><br><span class="line">NNNNNNYYYN</span><br><span class="line">NNNNNNYYYN</span><br><span class="line">NNNNNNNNYN</span><br><span class="line">NNNNNNNNYY</span><br></pre></td></tr></table></figure></p><ul><li><code>1 ≤ T ≤ 100</code></li><li><code>2 ≤ N ≤ 50</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/A" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/A</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目要求的最优时间复杂度应该为<code>O(n^2)</code>。</li><li>我们可以求出飞机从航站<code>i</code>向右飞行和向左飞行的最大距离。当坚持能否从<code>i</code>飞向<code>j</code>时，判断<code>j</code>是否在航站<code>i</code>的飞行范围内即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T; </span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"a.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"a.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> case_num = <span class="number">1</span>; case_num &lt;= T; case_num ++) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; case_num &lt;&lt; <span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">string</span> in,out;</span><br><span class="line">        fin&gt;&gt;n;</span><br><span class="line">        fin&gt;&gt;in;</span><br><span class="line">        fin&gt;&gt;out;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrive_left(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrive_right(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxl = i;</span><br><span class="line">            <span class="keyword">if</span>(out[i] == <span class="string">'Y'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(in[j] == <span class="string">'N'</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(out[j] == <span class="string">'N'</span>)&#123;</span><br><span class="line">                        maxl = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxl = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arrive_left[i] = maxl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> minr = i;</span><br><span class="line">            <span class="keyword">if</span>(out[i] == <span class="string">'Y'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(in[j] == <span class="string">'N'</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(out[j] == <span class="string">'N'</span>)&#123;</span><br><span class="line">                        minr = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    minr = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arrive_right[i] = minr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt;= j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arrive_left[i] &gt;= j) fout&lt;&lt;<span class="string">"Y"</span>;</span><br><span class="line">                    <span class="keyword">else</span> fout&lt;&lt;<span class="string">"N"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arrive_right[i] &lt;= j) fout&lt;&lt;<span class="string">"Y"</span>;</span><br><span class="line">                    <span class="keyword">else</span> fout&lt;&lt;<span class="string">"N"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fout&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Problem-B-Alchemy"><a href="#Problem-B-Alchemy" class="headerlink" title="Problem B: Alchemy"></a>Problem B: Alchemy</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定连续数目的单元，每个单元的颜色要么时<code>A</code>,要么是<code>B</code>,每次连续的三个相邻的单元可以进行合并，合并的规则要求是三个单元格不能为相同的颜色，合并后的单元格的颜色与三个单元中颜色最多的单元颜色保持一致。求该数组能否最终合并成一个单元。</p><p><strong>Input</strong><br>Input begins with an integer TT, the number of Philosopher’s Stones that Edgar tries to reconstitute. For each stone there are two lines. The first contains the integer NN. The second contains the length-NN string C_{1..N}C<br>1..N.<br><strong>Output</strong><br>For the iith stone, output a line containing “Case #i: “ followed by a single character, either “Y” if it’s possible For Edgar to end up with the Philosopher’s Stone, or “N” if not.</p><p><strong>Sample Input</strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">BAB</span><br><span class="line"><span class="number">3</span></span><br><span class="line">BBB</span><br><span class="line"><span class="number">5</span></span><br><span class="line">AABBA</span><br><span class="line"><span class="number">7</span></span><br><span class="line">BAAABAA</span><br><span class="line"><span class="number">11</span></span><br><span class="line">BBBAABAAAAB</span><br><span class="line"><span class="number">11</span></span><br><span class="line">BABBBABBABB</span><br></pre></td></tr></table></figure><br><strong>Sample Output</strong><br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Case</span> <span class="meta">#1: Y</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#2: N</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#3: Y</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#4: N</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#5: Y</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#6: N</span></span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/B" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/B</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目实际蛮长，其实很简单，因为每次三个单元格合并成一个单元，数量上肯定是减少了1对<code>A,B</code>.</li><li>最终情况下，就是颜色为<code>A</code>的单元数量与颜色为<code>B</code>的单元数量的绝对值之差为<code>1</code>，如果满足这个条件即可完成最终合并，否则则不可以。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T; </span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"b.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"b.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> case_num = <span class="number">1</span>; case_num &lt;= T; case_num ++) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; case_num &lt;&lt; <span class="string">":"</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">string</span> in;</span><br><span class="line">        fin&gt;&gt;n;</span><br><span class="line">        fin&gt;&gt;in;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[a] == <span class="string">'A'</span>) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a-b) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"N"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Y"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Problem-C-Timber"><a href="#Problem-C-Timber" class="headerlink" title="Problem C: Timber"></a>Problem C: Timber</h2><p>第<code>i</code>棵树的坐标为<code>P[i]</code>,高度为<code>H[i]</code>,树可以向左倒也可以向右倒，如果向左倒，则形成了区间$[P[i] - H[i],P[i]]$,如果向右倒，则形成了区间$[P[i],P[i] + H[i]]$,求问给定的序列中，能够形成连续且不相交的最长区间的长度。</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/C" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/C</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的<code>dp</code>，设<code>dp[x]</code>代表右边终点为<code>x</code>的最长区间长度。</li><li>每次加入第<code>i</code>棵树后，形成的最长区间区间的递推公式为:<script type="math/tex; mode=display">dp[P[i]+ H[i]] = max(dp[P[i]+ H[i]],dp[P[i]] + H[i]) \\dp[P[i]] = max(dp[P[i]],dp[P[i]-H[i]] + H[i]) \\</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T; </span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"c.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"c.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> case_num = <span class="number">1</span>; case_num &lt;= T; case_num ++) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; case_num &lt;&lt; <span class="string">":"</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        fin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p,h;</span><br><span class="line">            fin&gt;&gt;p&gt;&gt;h;</span><br><span class="line">            arr.emplace_back(make_pair(p,h));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = arr[i].first;</span><br><span class="line">            <span class="keyword">int</span> h = arr[i].second;</span><br><span class="line">            dp[p+h] = dp[p] + h;</span><br><span class="line">            dp[p] = dp[p-h] + h;</span><br><span class="line">            ans = max(ans,dp[p+h]);</span><br><span class="line">            ans = max(ans,dp[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        fout&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Problem-D1-Running-on-Fumes-Chapter-1"><a href="#Problem-D1-Running-on-Fumes-Chapter-1" class="headerlink" title="Problem D1: Running on Fumes - Chapter 1"></a>Problem D1: Running on Fumes - Chapter 1</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>该题应该是<code>leetcode</code>上的原始题目，非常简单。汽车加油的行程问题。</p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/D1" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/D1</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>典型的dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该汽车加油从<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Problem-D2-Running-on-Fumes-Chapter-2"><a href="#Problem-D2-Running-on-Fumes-Chapter-2" class="headerlink" title="Problem D2: Running on Fumes - Chapter 2"></a>Problem D2: Running on Fumes - Chapter 2</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/D2" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/D2</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;facebook-hacker-cup-quality-round&quot;&gt;&lt;a href=&quot;#facebook-hacker-cup-quality-round&quot; class=&quot;headerlink&quot; title=&quot;facebook hacker cup quality round&quot;&gt;&lt;/a&gt;facebook hacker cup quality round&lt;/h1&gt;&lt;p&gt;&lt;code&gt;facebook hacker cup&lt;/code&gt;比赛还是挺有意思的，前面几轮题目质量还是非常高，正规的比赛题目还是非常的不错。&lt;code&gt;quality round&lt;/code&gt;题目就非常容易了，几乎是&lt;code&gt;leetcode medium&lt;/code&gt;难度的水平。&lt;/p&gt;&lt;h2 id=&quot;5185-Problem-A-Travel-Restrictions&quot;&gt;&lt;a href=&quot;#5185-Problem-A-Travel-Restrictions&quot; class=&quot;headerlink&quot; title=&quot;5185. Problem A: Travel Restrictions&quot;&gt;&lt;/a&gt;5185. Problem A: Travel Restrictions&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="facebook hacker cup" scheme="http://yoursite.com/tags/facebook-hacker-cup/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 204周周赛</title>
    <link href="http://yoursite.com/2020/08/30/196/"/>
    <id>http://yoursite.com/2020/08/30/196/</id>
    <published>2020-08-30T06:48:11.630Z</published>
    <updated>2020-08-30T07:09:53.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="204场周赛"><a href="#204场周赛" class="headerlink" title="204场周赛"></a>204场周赛</h1><p>周赛的题目质量确实要高一些，本周的周赛题目还是挺难的。特别时最蛋疼的第一题，花了20分钟才把细节搞定。最后一题还是稍微有点坑，第三题毫无思路，直接放弃了，最终排名竟然意外的200名以内。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200830134750.png" alt="1"></p><h2 id="5499-重复至少-K-次且长度为-M-的模式"><a href="#5499-重复至少-K-次且长度为-M-的模式" class="headerlink" title="5499. 重复至少 K 次且长度为 M 的模式"></a>5499. 重复至少 K 次且长度为 M 的模式</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数数组 <code>arr</code>，请你找出一个长度为<code>m</code>且在数组中至少重复<code>k</code>次的模式。</p><a id="more"></a><p>模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。</p><p>如果数组中存在至少重复 <code>k</code> 次且长度为<code>m</code>的模式，则返回 <code>true</code>，否则返回  <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>], m = <span class="number">1</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：模式 (<span class="number">4</span>) 的长度为 <span class="number">1</span> ，且连续重复 <span class="number">4</span> 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>], m = <span class="number">2</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：模式 (<span class="number">1</span>,<span class="number">2</span>) 长度为 <span class="number">2</span> ，且连续重复 <span class="number">2</span> 次。另一个符合题意的模式是 (<span class="number">2</span>,<span class="number">1</span>) ，同样重复 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：模式 (<span class="number">1</span>,<span class="number">2</span>) 长度为 <span class="number">2</span> ，但是只连续重复 <span class="number">2</span> 次。不存在长度为 <span class="number">2</span> 且至少重复 <span class="number">3</span> 次的模式。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], m = <span class="number">2</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：模式 (<span class="number">1</span>,<span class="number">2</span>) 出现 <span class="number">2</span> 次但并不连续，所以不能算作连续重复 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：长度为 <span class="number">2</span> 的模式只有 (<span class="number">2</span>,<span class="number">2</span>) ，但是只连续重复 <span class="number">2</span> 次。注意，不能计算重叠的重复次数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= arr.length &lt;= 100</code></li><li><code>1 &lt;= arr[i] &lt;= 100</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>2 &lt;= k &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times" target="_blank" rel="noopener">https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较坑，直接暴力三重循环搞定，就是太容易出错了。第一题就搞了20分钟，意外的蛋疼。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsPattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span> &amp;&amp; m &lt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+m*k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+m; j &lt; i+m*k; j = j + m)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; j + m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k] != arr[i+k-j])&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!valid) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5500-乘积为正数的最长子数组长度"><a href="#5500-乘积为正数的最长子数组长度" class="headerlink" title="5500. 乘积为正数的最长子数组长度"></a>5500. 乘积为正数的最长子数组长度</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，请你求出乘积为正数的最长子数组的长度。</p><p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p><p>请你返回乘积为正数的最长子数组长度。</p><p>示例  1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：数组本身乘积就是正数，值为 <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-4</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长乘积为正数的子数组为 [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>] ，乘积为 <span class="number">6</span> 。</span><br><span class="line">注意，我们不能把 <span class="number">0</span> 也包括到子数组中，因为这样乘积为 <span class="number">0</span> ，不是正数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：乘积为正数的最长子数组是 [<span class="number">-1</span>,<span class="number">-2</span>] 或者 [<span class="number">-2</span>,<span class="number">-3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">-6</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学数学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>记录当前整数和负数的统计个数和第一次出现负数的位置，<code>posnum</code>和<code>negnum</code>。遇到整数是<code>posnum+1</code>,遇到负数时<code>negnum+1</code>.</li><li>假设当前的数不为<code>0</code>,如果当前统计负数的个数为偶数，以当前数为结尾的最长长度为$posnum+negnum$;如果当前统计负数的个数为奇数，则我们应当从第一个负数后面开始计算长度，以当前数为结尾的最长长度为$i-firstneg$。</li><li>如果当前的数为<code>0</code>，则我们将<code>posnum</code>和<code>negnum</code>、<code>firstneg</code>全部置为初始状态。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first_neg = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                pos += nums[i] &gt; <span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                neg += nums[i] &lt; <span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(neg%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = max(ans,pos + neg);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(first_neg &gt;= <span class="number">0</span>) ans = max(ans,i-first_neg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(first_neg &lt; <span class="number">0</span> &amp;&amp; nums[i] &lt; <span class="number">0</span>) first_neg = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pos  = <span class="number">0</span>;</span><br><span class="line">                neg  = <span class="number">0</span>;</span><br><span class="line">                first_neg = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5501-使陆地分离的最少天数"><a href="#5501-使陆地分离的最少天数" class="headerlink" title="5501. 使陆地分离的最少天数"></a>5501. 使陆地分离的最少天数</h2><p>给你一个由若干 <code>0</code> 和 <code>1</code>组成的二维网格 <code>grid</code>，其中 <code>0</code>表示水，而<code>1</code>表示陆地。岛屿由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p><p>如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。</p><p>一天内，可以将任何单个陆地单元<code>（1）</code>更改为水单元<code>（0）</code>。</p><p>返回使陆地分离的最少天数。</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/1926_island.png" alt="2"><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：至少需要 2 天才能得到分离的陆地。</span><br><span class="line">将陆地 grid[<span class="string">1</span>][<span class="symbol">1</span>] 和 grid[<span class="string">0</span>][<span class="symbol">2</span>] 更改为水，得到两个分离的岛屿。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[1,1]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如果网格中都是水，也认为是分离的 (<span class="string">[[1,1]]</span> -&gt; <span class="string">[[0,0]]</span>)，<span class="number">0</span> 岛屿。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= grid.length, grid[i].length &lt;= 30</code></li><li><code>grid[i][j]</code>为 <code>0</code>或 <code>1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这题在比赛的时候没有做出来，最后看了答案感觉好简单，还是思路不对。</li><li>首先如果题目中的岛屿的数目不为<code>1</code>，则直接返回<code>0</code>即可。其次按照实际的情况下，我们最多只需要去掉<code>2</code>个单元，一定能够使得岛屿进行分离。我们查看岛屿是否存在关键节点，如果存在关键节点，如果存在关键节点，则只需要去掉一个单元即可。</li><li>检查关键节点的方法有很多，比如可以使用<code>tarjan</code>查找强连通分量或者直接暴力检查去掉某个单元后，岛屿会被会被划分成多个即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> visit[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="keyword">int</span> island = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visit[i][j] &amp;&amp; grid[i][j])&#123;</span><br><span class="line">                    island++;</span><br><span class="line">                    qu.push(i*col+j);</span><br><span class="line">                    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                        <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                        qu.pop();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                            <span class="keyword">int</span> x = curr/col + d[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">int</span> y = curr%col + d[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(!visit[x][y] &amp;&amp; grid[x][y])&#123;</span><br><span class="line">                                    qu.push(x*col+y);</span><br><span class="line">                                    visit[x][y] = <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bfs(grid) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(bfs(grid) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, sz, dfn, low;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++idx;</span><br><span class="line">        <span class="keyword">int</span> children = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                children++;</span><br><span class="line">                tarjan(v, u);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">-1</span> &amp;&amp; children &gt;= <span class="number">2</span>)</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="number">-1</span> &amp;&amp; low[v] &gt;= dfn[u])</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v != p)</span><br><span class="line">                low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p[u] == u ? u : p[u] = find(p[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pu = find(u), pv = find(v);</span><br><span class="line">        <span class="keyword">if</span> (pu == pv)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[pu] &gt;= sz[pv]) &#123;</span><br><span class="line">            p[pv] = pu;</span><br><span class="line">            sz[pu] += sz[pv];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[pu] = pv;</span><br><span class="line">            sz[pv] += sz[pu];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> N = n * m;</span><br><span class="line">        p = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">-1</span>);</span><br><span class="line">        sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = N;</span><br><span class="line">        adj = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!grid[i][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> u = i * m + j;</span><br><span class="line">                <span class="keyword">if</span> (p[u] == <span class="number">-1</span>)</span><br><span class="line">                    p[u] = u;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ni = i + dy[k], nj = j + dx[k];</span><br><span class="line">                    <span class="keyword">if</span> (ni &lt; <span class="number">0</span> || ni &gt;= n || nj &lt; <span class="number">0</span> || nj &gt;= m || !grid[ni][nj])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> v = ni * m + nj;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span> (p[v] == <span class="number">-1</span>)</span><br><span class="line">                        p[v] = v;</span><br><span class="line">                    connect(u, v);</span><br><span class="line">                    adj[u].emplace_back(v);</span><br><span class="line">                    adj[v].emplace_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = min(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> components = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != <span class="number">-1</span> &amp;&amp; i == find(i))</span><br><span class="line">                components++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (components &gt;= <span class="number">2</span> || components == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">                dfn = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N);</span><br><span class="line">                low = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N);</span><br><span class="line">                tarjan(i, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> found ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5502-将子数组重新排序得到同一个二叉查找树的方案数"><a href="#5502-将子数组重新排序得到同一个二叉查找树的方案数" class="headerlink" title="5502. 将子数组重新排序得到同一个二叉查找树的方案数"></a>5502. 将子数组重新排序得到同一个二叉查找树的方案数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>nums</code>表示 <code>1</code> 到 <code>n</code>的一个排列。我们按照元素在 <code>nums</code>中的顺序依次插入一个初始为空的二叉查找树（<code>BST</code>）。请你统计将 <code>nums</code> 重新排序后，统计满足如下条件的方案数：重排后得到的二叉查找树与 <code>nums</code> 原本数字顺序得到的二叉查找树相同。</p><p>比方说，给你 <code>nums = [2,1,3]</code>，我们得到一棵 <code>2</code>为根，<code>1</code> 为左孩子，<code>3</code> 为右孩子的树。数组 <code>[2,3,1]</code> 也能得到相同的 <code>BST</code>，但<code>[3,2,1]</code>会得到一棵不同的 <code>BST</code> 。</p><p>请你返回重排<code>nums</code> 后，与原数组 <code>nums</code>得到相同二叉查找树的方案数。</p><p>由于答案可能会很大，请将结果对 <code>10^9 + 7</code>取余数。</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/bb.png" alt="3"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：我们将 nums 重排， [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex1.png" alt="4"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：下面 <span class="number">5</span> 个数组会得到相同的 BST：</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex4.png" alt="4"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有别的排列顺序能得到相同的 BST 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/abc.png" alt="5"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">19</span></span><br></pre></td></tr></table></figure><br>示例  5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">216212978</span></span><br><span class="line">解释：得到相同 BST 的方案数是 <span class="number">3216212999</span>。将它对 <span class="number">10</span>^<span class="number">9</span> + <span class="number">7</span> 取余后得到 <span class="number">216212978</span>。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= nums.length</code></li><li><code>nums</code> 中所有数 互不相同 。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>排列组合加递归</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的相当好，难度适中，有一定的思考技巧，并且特别有意思。考察基本的数学知识。</li><li>首先我们发现题意的本身要对<code>BST</code>的基本知识要有所了解，对于<code>BST</code>的插入操作时，即每次比根节点大，则插入到节点的右子树，如果比根节点小则插入到节点的左子树。我们知道如果保持根节点不变，且保证左右子树的相对前后顺序，右子树的相对顺序即比根节点大的元素的插入排序是相对固定的，左子树的相对顺序即比根节点小的元素的插入排序是相对固定的，并且保证根节点的值不变，在保证这三个条件的前提下，不同的插入序列一定保证能够得到相同的<code>BST</code>.我们设左子树的节点个数为<code>left</code>,右子树的节点个数为<code>right</code>，即为基本的排列组合，从<code>left+right</code>个位置中选出<code>left</code>个位置放置左子树的节点，则相应的总的排序个数按照排列组合应该为:<script type="math/tex; mode=display">num = C_{left+right}^{left}</script></li><li>我们知道<code>2</code>的基本理论后，下面的推论就很方便。我们仔细思考下，左右子树是否存在相同的情况？左子树的节点也保证其根节点不变，也利用<code>2</code>的理论其插入排序也应该有很多种排列组合，右子树的节点也保证其根节点不变，也利用<code>2</code>的理论其插入排序也应该有很多种排列组合。根据<code>3</code>的推论，则我们总的节点的排序数应该为:<script type="math/tex; mode=display">F(tree) = C_{left+right}^{left}*F(leftTree)*F(rightTree)</script></li><li>我们用<code>DFS</code>递归，按照<code>3</code>的排列组合理论，很快就可以求出来总的个数，最后将总的个数减去<code>1</code>即为所求。最终的解法总是非常的简洁和优美，如果自己写代码写的很复杂，可能是自己思考错了。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> C[<span class="number">1002</span>][<span class="number">1002</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[<span class="number">0</span>])&#123;</span><br><span class="line">                left.push_back(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right.push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = left.size();</span><br><span class="line">        <span class="keyword">int</span> r = right.size();</span><br><span class="line">        <span class="keyword">return</span> ((C[l+r][r]*dfs(left))%mod*dfs(right))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span>(C));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            C[j][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j+<span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                   C[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                   C[i][j] = (C[i<span class="number">-1</span>][j<span class="number">-1</span>] + C[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            &#125; <span class="comment">// 计算Cmn</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(nums) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;204场周赛&quot;&gt;&lt;a href=&quot;#204场周赛&quot; class=&quot;headerlink&quot; title=&quot;204场周赛&quot;&gt;&lt;/a&gt;204场周赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量确实要高一些，本周的周赛题目还是挺难的。特别时最蛋疼的第一题，花了20分钟才把细节搞定。最后一题还是稍微有点坑，第三题毫无思路，直接放弃了，最终排名竟然意外的200名以内。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200830134750.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5499-重复至少-K-次且长度为-M-的模式&quot;&gt;&lt;a href=&quot;#5499-重复至少-K-次且长度为-M-的模式&quot; class=&quot;headerlink&quot; title=&quot;5499. 重复至少 K 次且长度为 M 的模式&quot;&gt;&lt;/a&gt;5499. 重复至少 K 次且长度为 M 的模式&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个正整数数组 &lt;code&gt;arr&lt;/code&gt;，请你找出一个长度为&lt;code&gt;m&lt;/code&gt;且在数组中至少重复&lt;code&gt;k&lt;/code&gt;次的模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Google Kickstart】 2020 roundE</title>
    <link href="http://yoursite.com/2020/08/27/195/"/>
    <id>http://yoursite.com/2020/08/27/195/</id>
    <published>2020-08-27T05:52:13.942Z</published>
    <updated>2020-08-27T05:52:20.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-kickstart-2020-roundE"><a href="#google-kickstart-2020-roundE" class="headerlink" title="google kickstart 2020 roundE"></a>google kickstart 2020 roundE</h1><p>类似于google的在线笔试题目，题目难度还是非常不错的，前三题似乎都不是特别难，最后一题确实有难度。也就现在的水平还能勉强做出来前三题，以前的自己肯定水的一比，放在6年前估计一题都做不出来。经常做算法题还是有好处的，至少思考能力能够提升到一定水平。<code>google kickstart</code>的比赛界面不是特别友好，不如<code>leetcode</code>那么人性化，但是题目质量非常高。</p><a id="more"></a><h2 id="Longest-Arithmetic"><a href="#Longest-Arithmetic" class="headerlink" title="Longest Arithmetic"></a>Longest Arithmetic</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>Problem</strong><br>An arithmetic array is an array that contains at least two integers and the differences between consecutive integers are equal. For example, [9, 10], [3, 3, 3], and [9, 7, 5, 3] are arithmetic arrays, while [1, 3, 3, 7], [2, 1, 2], and [1, 2, 4] are not arithmetic arrays.</p><p>Sarasvati has an array of N non-negative integers. The i-th integer of the array is Ai. She wants to choose a contiguous arithmetic subarray from her array that has the maximum length. Please help her to determine the length of the longest contiguous arithmetic subarray.</p><p><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. The second line contains N integers. The i-th integer is Ai.</p><p><strong>Output</strong><br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the length of the longest contiguous arithmetic subarray.</p><p><strong>Limits</strong></p><ul><li>Time limit: 20 seconds per test set.</li><li>Memory limit: 1GB.</li><li>1 ≤ T ≤ 100.</li><li><p>0 ≤ Ai ≤ 109.</p></li><li><p>Test Set 1<br>2 ≤ N ≤ 2000.</p></li><li><p>Test Set 2<br>2 ≤ N ≤ 2 × 105 for at most 10 test cases.<br>For the remaining cases, 2 ≤ N ≤ 2000.</p></li></ul><p>Sample<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">Case #<span class="number">1</span>: <span class="number">4</span></span><br><span class="line">Case #<span class="number">2</span>: <span class="number">4</span></span><br><span class="line">Case #<span class="number">3</span>: <span class="number">3</span></span><br><span class="line">Case #<span class="number">4</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff47/00000000003bf4ed" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff47/00000000003bf4ed</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  求连续子数组为等差数列的最长长度。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>求连续子数组为等差数列的最长长度。这个题目基本上<code>leetcode</code> easy级别的水平题目。差不多10行代码搞定。</li><li>主要判断以下条件即可<script type="math/tex; mode=display">arr[i] - arr[i-1] == arr[i-1] - arr[i-2]</script>如果满足以上条件则便是当前元素可以和前两个元素构成等差序列。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        arr.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((arr[i]-arr[i<span class="number">-1</span>]) == (arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="High-Buildings"><a href="#High-Buildings" class="headerlink" title="High Buildings"></a>High Buildings</h3><p><strong>Problem</strong><br>in an unspecified country, Google has an office campus consisting of N office buildings in a line, numbered from 1 to N from left to right. When represented in meters, the height of each building is an integer between 1 to N, inclusive.</p><p>Andre and Sule are two Google employees working in this campus. On their lunch break, they wanted to see the skyline of the campus they are working in. Therefore, Andre went to the leftmost point of the campus (to the left of building 1), looking towards the rightmost point of the campus (to the right of building N). Similarly, Sule went to the rightmost point of the campus, looking towards the leftmost point of the campus.</p><p>To Andre, a building x is visible if and only if there is no building to the left of building x that is strictly higher than building x. Similarly, to Sule, a building x is visible if and only if there is no building to the right of building x that is strictly higher than building x.</p><p>Andre learned that there are A buildings that are visible to him, while Sule learned that there are B buildings that are visible to him. After they regrouped and exchanged information, they also learned that there are C buildings that are visible to both of them.</p><p>They are wondering about the height of each building. They are giving you the value of N, A, B, and C for your information. As their friend, you would like to construct a possible height for each building such that the information learned on the previous paragraph is correct, or indicate that there is no possible height construction that matches the information learned (thus at least one of them must have been mistaken).</p><p><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each consists of a single line with four integers N, A, B, and C: the information given by Andre and Sule.</p><p><strong>Output</strong><br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is IMPOSSIBLE if there is no possible height for each building according to the above information, or N space-separated integers otherwise. The i-th integer in y must be the height of the i-th building (in meters) between 1 to N.</p><p>Limits</p><ul><li>Time limit: 20 seconds per test set.</li><li>Memory limit: 1GB.</li><li>1 ≤ T ≤ 100.</li><li>1 ≤ C ≤ N.</li><li>C ≤ A ≤ N.</li><li><p>C ≤ B ≤ N.</p></li><li><p>Test Set 1</p></li><li>1 ≤ N ≤ 5.</li><li>Test Set 2</li><li>1 ≤ N ≤ 100.</li></ul><p>Sample<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line"> </span><br><span class="line">Output</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">Case #<span class="number">1</span>: <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line">Case #<span class="number">2</span>: IMPOSSIBLE</span><br><span class="line">Case #<span class="number">3</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目描述过于复杂实际是非常简单的一道类似于小学奥数的题目。<code>Andre</code>在最左侧只能看到严格非递减的楼栋，<code>Sule</code>只能在最右侧看到严格非递减的楼栋，<code>Andre</code>看到的的楼栋的数目为A,<code>Sule</code>看到的建筑的数目为<code>B</code>,两人共同看到的建筑数目为<code>C</code>.题目要求给出符合条件的<code>n</code>个建筑的高度。</li><li>首先我们检测有哪些不符合的情况，整个建筑的数目为<code>n</code>.两人共同看到的数目<code>c</code>肯定为<code>n</code>个建筑中最高的建筑。因此我们首先判断这种情况不可能:<script type="math/tex; mode=display">A + B - C > N</script>因为<code>Andre</code>看到了A个建筑其中包括了<code>C</code>个最高的建筑，同样<code>Sule</code>也看到了<code>B</code>个建筑，也包括了<code>C</code>个最高的建筑。<br>另一种情况，也需要讨论，当<code>A == C</code>且<code>B == C</code>时，这时表示Andre和Sule都只看到了最高的建筑数目<code>C</code>,表示有<code>C</code>个相同高度且最高的建筑。假如当<code>N</code>为<code>1</code>时，则此时C == 1符合条件。假如<code>N &gt; 2</code>时，则此时必须满足第<code>1</code>个建筑和第<code>N</code>个建筑都为最高高度才可以，否则则不可能出现<code>A == C</code>且<code>B == C</code>，因为肯定会有次矮的建筑被看到。</li></ol></blockquote><ol><li>我们再来构建即可，我们直接<code>Andre</code>看到了A个建筑，其中包含C个建筑为最高高度<code>x</code>，次高的建筑数目为<code>A-C</code>个；我们知道<code>Sule</code>看到了B个建筑，其中包含C个建筑为最高高度，次高的建筑数目为<code>B-C</code>个；剩余<code>Andre</code>和<code>Sule</code>未看到的建筑数目为<code>N-A-B+C</code>.我们直接令建筑的组成如下：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200826174654.png" alt="1"></li><li>我们仔细思考一下3的解法，实际有问题，当<code>A == C或者B == C</code>或者 <code>N == 2</code>时上面的建筑的高度分布就有问题，需要重新思考排列方式。因此我们应该分为几种情况来排列即可。</li></ol><ul><li>当<code>A == C 或者 C &gt;= 2</code>时，则我们优先在左侧放置最高高度的建筑。我们优先放置高度为<code>1</code>的建筑可能会被看到。</li><li>当<code>C == 1 或者 B == C</code>时，则我们优先在右侧放置最高高度的建筑。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">bool</span> isPossible = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">if</span>(a+b-c&gt;n || a &lt; c || b &lt; c)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"IMPOSSIBLE"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == c &amp;&amp; b == c &amp;&amp; c &lt; min(n,<span class="number">2</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"IMPOSSIBLE"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = n - a - b + c;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="number">2</span> || a == c)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;<span class="comment">//left</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;<span class="comment">//left</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Toys"><a href="#Toys" class="headerlink" title="Toys"></a>Toys</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><strong>Problem</strong><br>Little Axel has N toys numbered from 1 to N. Each toy has two properties:</p><ul><li><strong>Ei—enjoyment</strong>, which is the number of minutes Axel can play with toy number i without getting bored with it;</li><li><strong>Ri—remembrance</strong>, which is the number of minutes it takes Axel to forget toy number i after having played with it.<br>The toys are arranged in a circle, from 1 to N clockwise. Axel plays with them one by one.</li></ul><p>When Axel reaches toy i which he has not played with yet, or which he has already forgotten about, he plays with it for Ei minutes and then immediately moves to the next one (clockwise).</p><p>If he reaches a toy that he has not forgotten yet (if less than Ri minutes have passed since the last time he finished playing with it), he will stop and cry.</p><p>We can define the time Axel spent playing as the sum of Ei of every toy Axel played with before stopping. If Axel played with a toy several times, it should be counted that many times.</p><p>Given the description of the toys, remove the smallest possible number of them in order to make Axel play either an indefinitely long time, or (if that is not possible) as long as possible before he stops.</p><p>Note:</p><ul><li>Axel has never played with these toys before;</li><li>he cannot be left without toys;</li><li>he always starts with the toy that has the smallest number;</li><li>after finishing playing with the toy that has the largest number, he + will move to the toy that has the smallest number.<br><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. Next N lines contain 2 integers each: Ei and Ri. The i-th line is describing the toy number i.</li></ul><p><strong>Output</strong><br>For each test case, output one line containing Case #x: y z, where:</p><p>x is the test case number (starting from 1);<br>y is the minimal number of toys to remove so that Axel could play with the rest of them either indefinitely or as long as possible;<br>z is the longest time Axel will play in minutes or “INDEFINITELY” (without quotes) if he will play indefinitely long time.<br><strong>Limits</strong></p><ul><li>Time limit: 30 seconds per test set.</li><li>Memory limit: 1GB.</li><li>1 ≤ T ≤ 100.</li><li>1 ≤ Ei ≤ 109.</li><li><p>1 ≤ Ri ≤ 109.</p></li><li><p>Test Set 1</p></li><li>1 ≤ N ≤ 12.</li><li>Test Set 2</li><li>1 ≤ N ≤ 105.</li></ul><p>Sample<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line"> </span><br><span class="line">Output</span><br><span class="line"> </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">30</span> <span class="number">17</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">Case #<span class="number">1</span>: <span class="number">0</span> <span class="number">5</span></span><br><span class="line">Case #<span class="number">2</span>: <span class="number">0</span> INDEFINITELY</span><br><span class="line">Case #<span class="number">3</span>: <span class="number">1</span> INDEFINITELY</span><br><span class="line">Case #<span class="number">4</span>: <span class="number">0</span> <span class="number">25</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//codingcompetitions.withgoogle.com/kickstart/round/000000000019ff47/00000000003bede9</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   优先级队列</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 一圈玩具，题目给出了每个玩具的把玩时间和冷却时间，冷却时间即为下一次玩耍该玩具时必须等待的时间，题目要求可以移走部分玩具，求最长可以玩耍游戏的时间是多少。</span><br><span class="line"><span class="number">2.</span> 我们首先分析一下，假设只有`<span class="number">1</span>`个玩具，该玩具的$E_&#123;i&#125; &gt;= R_&#123;i&#125;$,则表示`Axel`可以一直玩该玩具，否则他最多只能玩一次该玩具后，必须等待冷却时间才可以。</span><br><span class="line">由此，我们首先求出第$n (n&gt; <span class="number">1</span>)$次玩第`i`个玩具的等待时间为：</span><br><span class="line">$$W_&#123;i&#125; = \sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; - E_&#123;i&#125;$$</span><br><span class="line">我们必须满足它的等待时间刚好大于或者等于它的冷却时间，则它刚好可以接着玩该玩具。</span><br><span class="line">$$</span><br><span class="line">W_&#123;i&#125; = \sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; - E_&#123;i&#125; \ge R_&#123;i&#125; \\</span><br><span class="line">\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \ge R_&#123;i&#125; + E_&#123;i&#125;</span><br><span class="line">$$</span><br><span class="line">即该玩具的冷却时间和玩耍时间之和必须小于等于所有玩具的玩耍时间之和，首先需要把这类玩具去掉。</span><br><span class="line"><span class="number">3.</span> 我们不断更新，如果出现剩余的所有的玩具都满足</span><br><span class="line">$$\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \ge R_&#123;i&#125; + E_&#123;i&#125; $$</span><br><span class="line">则这时表示剩下的玩具可以无限玩，直接返回`INDEFINITELY`即可。</span><br><span class="line"><span class="number">4.</span> 如果不能满足出现`INDEFINITELY`，则我们求出剩余的去除部分玩具的可玩的最大时间。首先我们可以肯定所有的玩具都不会被玩三次，如果该玩具被连续玩了三次，则表示 所有的玩具都被玩了两次，则该部分玩具可以被无限的玩`n`次。</span><br><span class="line"><span class="number">5.</span> 首先我们看到假如一个玩具都不会被删除，则在第一次时，所有的玩具都会被玩一次，在第二圈时，可能部分玩具能够被再玩耍一次。</span><br><span class="line"><span class="number">6.</span> 我们首先将所有的玩具按照顺序，依次加入到可玩的优先级序列中，如果发现有玩具`i`出现条件：g</span><br><span class="line">$$\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \le R_&#123;i&#125; + E_&#123;i&#125;$$</span><br><span class="line">则这时我们认为第`i`个玩具肯定不能加入到队列中，次吃我们将所有玩具的等待时间减去$E_&#123;i&#125;$,此时我们更新队列,同时判断队列中的元素是否都符合可以玩第二次的条件。</span><br><span class="line">$$\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \ge R_&#123;i&#125; + E_&#123;i&#125;$$</span><br><span class="line">如果发现不符合，则将其从队列中剔除掉。如果第`i`个玩具符合条件，则将其加入到待选队列中。</span><br><span class="line"><span class="number">7.</span>总的来说该题目还是非常经典。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> cmp(pii &amp; a, pii &amp; b)&#123;</span><br><span class="line">    <span class="built_in">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct cmp1&#123;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>()(pii &amp; a,pii &amp;b)&#123;</span><br><span class="line">        <span class="built_in">if</span>(a.first == b.first) </span><br><span class="line">            <span class="built_in">return</span> a.second &lt; b.second;</span><br><span class="line">        <span class="built_in">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> slove()&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; enjoy;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; remembrance;</span><br><span class="line">    vector&lt;pii&gt; arr;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> e,r;</span><br><span class="line">        cin&gt;&gt;e&gt;&gt;r;</span><br><span class="line">        enjoy.emplace_back(e);</span><br><span class="line">        remembrance.emplace_back(r);</span><br><span class="line">        arr.emplace_back(make_pair(e+r,i));</span><br><span class="line">        total += e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*count the array*/</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = total;</span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">if</span>(arr[i].first &gt; sum)&#123;</span><br><span class="line">            sum -= enjoy[arr[i].second];</span><br><span class="line">        &#125;<span class="built_in">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;n-i<span class="number">-1</span>&lt;&lt;<span class="string">" INDEFINITELY"</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,cmp1&gt; pq;</span><br><span class="line">    sum = total;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> max_val = total;</span><br><span class="line">    <span class="keyword">int</span> min_del = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cdel = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cval = total;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">if</span>(enjoy[i] + remembrance[i] &lt;= sum)&#123;</span><br><span class="line">            pq.push(make_pair(enjoy[i] + remembrance[i],i));</span><br><span class="line">            cval += enjoy[i];</span><br><span class="line">            <span class="built_in">if</span>(cval &gt; max_val)&#123;</span><br><span class="line">                max_val = cval;</span><br><span class="line">                min_del = cdel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="built_in">else</span>&#123;</span><br><span class="line">           sum -= enjoy[i];</span><br><span class="line">           cval -= enjoy[i];</span><br><span class="line">           cdel++;</span><br><span class="line">           <span class="built_in">while</span>(!pq.empty() &amp;&amp; pq.top().first &gt; sum)&#123;</span><br><span class="line">               <span class="keyword">int</span> x = pq.top().second;</span><br><span class="line">               pq.pop();</span><br><span class="line">               sum -= enjoy[x];</span><br><span class="line">               cval -= <span class="number">2</span>*enjoy[x];</span><br><span class="line">               cdel--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;min_del&lt;&lt;<span class="string">" "</span>&lt;&lt;max_val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">        slove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;google-kickstart-2020-roundE&quot;&gt;&lt;a href=&quot;#google-kickstart-2020-roundE&quot; class=&quot;headerlink&quot; title=&quot;google kickstart 2020 roundE&quot;&gt;&lt;/a&gt;google kickstart 2020 roundE&lt;/h1&gt;&lt;p&gt;类似于google的在线笔试题目，题目难度还是非常不错的，前三题似乎都不是特别难，最后一题确实有难度。也就现在的水平还能勉强做出来前三题，以前的自己肯定水的一比，放在6年前估计一题都做不出来。经常做算法题还是有好处的，至少思考能力能够提升到一定水平。&lt;code&gt;google kickstart&lt;/code&gt;的比赛界面不是特别友好，不如&lt;code&gt;leetcode&lt;/code&gt;那么人性化，但是题目质量非常高。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="google kickstart" scheme="http://yoursite.com/tags/google-kickstart/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 203周周赛</title>
    <link href="http://yoursite.com/2020/08/23/194/"/>
    <id>http://yoursite.com/2020/08/23/194/</id>
    <published>2020-08-23T09:00:11.295Z</published>
    <updated>2020-08-23T09:36:44.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="203场周赛"><a href="#203场周赛" class="headerlink" title="203场周赛"></a>203场周赛</h1><p>周赛的题目质量确实要高一些，双周赛的题目简单太多了。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823154253.png" alt="1"></p><h2 id="5495-圆形赛道上经过次数最多的扇区"><a href="#5495-圆形赛道上经过次数最多的扇区" class="headerlink" title="5495. 圆形赛道上经过次数最多的扇区"></a>5495. 圆形赛道上经过次数最多的扇区</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> 和一个整数数组 <code>rounds</code> 。有一条圆形赛道由 <code>n</code>个扇区组成，扇区编号从 <code>1</code> 到 <code>n</code> 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 <code>m</code>个阶段组成。其中，第 i 个阶段将会从扇区 <code>rounds[i - 1]</code> 开始，到扇区 <code>rounds[i]</code>结束。举例来说，第 1 阶段从 <code>rounds[0]</code> 开始，到<code>rounds[1]</code>结束。</p><a id="more"></a><p>请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 升序 排列。</p><p>注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823154505.png" alt="2"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, rounds = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：本场马拉松比赛从扇区 <span class="number">1</span> 开始。经过各个扇区的次序如下所示：</span><br><span class="line"><span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">3</span>（阶段 <span class="number">1</span> 结束）--&gt; <span class="number">4</span> --&gt; <span class="number">1</span>（阶段 <span class="number">2</span> 结束）--&gt; <span class="number">2</span>（阶段 <span class="number">3</span> 结束，即本场马拉松结束）</span><br><span class="line">其中，扇区 <span class="number">1</span> 和 <span class="number">2</span> 都经过了两次，它们是经过次数最多的两个扇区。扇区 <span class="number">3</span> 和 <span class="number">4</span> 都只经过了一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, rounds = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, rounds = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>rounds.length == m + 1</code></li><li><code>1 &lt;= rounds[i] &lt;= n</code></li><li><code>rounds[i] != rounds[i + 1] ，其中 0 &lt;= i &lt; m.</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目描述过于复杂，但实际非常简单，主要是循环数组的处理。</li><li>循环统计每个扇区的通过次数，然后取统计次数的最大值即可。题目可以再增加难度，比如赛道通过的圈数可以为<code>n</code>圈，这样的加法处理又稍微复杂点。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mostVisited(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rounds) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> maxV = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rounds.size(); ++i)&#123;</span><br><span class="line">            rounds[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rounds.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = rounds[i]; j != rounds[i+<span class="number">1</span>] ; j = (j + <span class="number">1</span>)%n)&#123;</span><br><span class="line">                cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[rounds.back()]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            maxV = max(cnt[i],maxV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == maxV) ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5496-你可以获得的最大硬币数目"><a href="#5496-你可以获得的最大硬币数目" class="headerlink" title="5496. 你可以获得的最大硬币数目"></a>5496. 你可以获得的最大硬币数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：</p><p>每一轮中，你将会选出 任意<code>3</code> 堆硬币（不一定连续）。<br><code>Alice</code> 将会取走硬币数量最多的那一堆。<br>你将会取走硬币数量第二多的那一堆。<br>Bob 将会取走最后一堆。<br>重复这个过程，直到没有更多硬币。<br>给你一个整数数组 <code>piles</code>，其中 <code>piles[i]</code>是第 <code>i</code>堆中硬币的数目。</p><p>返回你可以获得的最大硬币数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：选出 (<span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>) ，Alice 取走 <span class="number">8</span> 枚硬币的那堆，你取走 <span class="number">7</span> 枚硬币的那堆，Bob 取走最后一堆。</span><br><span class="line">选出 (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>) , Alice 取走 <span class="number">4</span> 枚硬币的那堆，你取走 <span class="number">2</span> 枚硬币的那堆，Bob 取走最后一堆。</span><br><span class="line">你可以获得的最大硬币数目：<span class="number">7</span> + <span class="number">2</span> = <span class="number">9.</span></span><br><span class="line">考虑另外一种情况，如果选出的是 (<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>) 和 (<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>) ，你就只能得到 <span class="number">2</span> + <span class="number">4</span> = <span class="number">6</span> 枚硬币，这不是最优解。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= piles.length &lt;= 10^5</code></li><li><code>piles.length % 3 == 0</code></li><li><code>1 &lt;= piles[i] &lt;= 10^4</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>如何取最大值，本质是数学问题，我们应当保证尽可能的取到最大值。首先想到的是我们对数组按照从小到大进行排列。</li><li>设数组的长度为<code>3n</code>,则每次取得索引数为$(piles[i],piles[n+2<em>i-1],piles[n+2</em>i])$,则这时</li></ol><ul><li><code>Alice</code>取得得硬币为：<br>$piles[n+2],piles[n+4],…,piles[3n]$</li><li><code>Bob</code>取得得硬币为：<br>$piles[1],piles[2],…,piles[n]$</li><li>自己取得的硬币为：<br>$piles[n+1],piles[n+3],…,piles[3n-1]$</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        <span class="keyword">int</span> x = n/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(piles.begin(),piles.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; n; i = i + <span class="number">2</span>)&#123;</span><br><span class="line">            ans += piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5497-查找大小为-M-的最新分组"><a href="#5497-查找大小为-M-的最新分组" class="headerlink" title="5497. 查找大小为 M 的最新分组"></a>5497. 查找大小为 M 的最新分组</h2><p>给你一个数组 <code>arr</code>，该数组表示一个从 <code>1</code> 到 <code>n</code>的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。</p><p>在从 1 到<code>n</code> 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置<code>arr[i]</code>的位将会设为 1 。</p><p>给你一个整数<code>m</code>，请你找出二进制字符串上存在长度为 <code>m</code>的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。</p><p>返回存在长度 恰好 为 <code>m</code>的 一组 <code>1</code>  的最后步骤。如果不存在这样的步骤，请返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], m = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">步骤 <span class="number">1</span>：<span class="string">"00100"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">2</span>：<span class="string">"00101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">3</span>：<span class="string">"10101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">4</span>：<span class="string">"11101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"111"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">5</span>：<span class="string">"11111"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"11111"</span>]</span><br><span class="line">存在长度为 <span class="number">1</span> 的一组 <span class="number">1</span> 的最后步骤是步骤 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">步骤 <span class="number">1</span>：<span class="string">"00100"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">2</span>：<span class="string">"10100"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">3</span>：<span class="string">"10101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">4</span>：<span class="string">"10111"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"111"</span>]</span><br><span class="line">步骤 <span class="number">5</span>：<span class="string">"11111"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"11111"</span>]</span><br><span class="line">不管是哪一步骤都无法形成长度为 <span class="number">2</span> 的一组 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>], m = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">1</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == arr.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= n</code></li><li><code>arr</code> 中的所有整数 互不相同</li><li><code>1 &lt;= m &lt;= arr.length</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-latest-group-of-size-m" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-latest-group-of-size-m</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>left[x]</code>代表从索引<code>x</code>处开始向左连续的最长<code>1</code>的数目，<code>right[x]</code>代表从索引<code>x</code>处开始向右连续的最长<code>1</code>的数目。<code>count[l]</code>代表当前状态中连续<code>1</code>的长度为<code>l</code>的统计数目。</li><li>每次将<code>x</code>位置为<code>1</code>时，则我们进行左右的连续的<code>1</code>的序列合并，这时合并的总长度为: $l = left[x-1] + 1 + right[x+1]$<br>则我们同时将该区间<code>l</code>的两端的left与right进行更新。同时将连续长度为<code>left[x-1],right[x+1]</code>的统计数目减<code>1</code>,将连续长度为<code>l</code>的统计数目加<code>1</code>.</li><li>每次更新完长度的统计数目后，如果发现长度为<code>m</code>的统计数目大于<code>0</code>，则我们认为此时存在大小为<code>m</code>的最新分组。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823171258.png" alt="3"></li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = arr[i];</span><br><span class="line">            <span class="keyword">int</span> l = left[x<span class="number">-1</span>] + <span class="number">1</span> + right[x+<span class="number">1</span>];</span><br><span class="line">            left[x + right[x+<span class="number">1</span>]] = l;</span><br><span class="line">            right[x - left[x<span class="number">-1</span>]] = l;</span><br><span class="line">            count[left[x<span class="number">-1</span>]]--;</span><br><span class="line">            count[right[x+<span class="number">1</span>]]--;</span><br><span class="line">            count[l]++;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(count[m] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5498-石子游戏-V"><a href="#5498-石子游戏-V" class="headerlink" title="5498. 石子游戏 V"></a>5498. 石子游戏 V</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 <code>stoneValue</code> 给出。</p><p>游戏中的每一轮：<code>Alice</code> 会将这行石子分成两个 非空行（即，左侧行和右侧行）；<code>Bob</code> 负责计算每一行的值，即此行中所有石子的值的总和。<code>Bob</code>会丢弃值最大的行，<code>Alice</code>的得分为剩下那行的值（每轮累加）。如果两行的值相等，<code>Bob</code> 让 <code>Alice</code>决定丢弃哪一行。下一轮从剩下的那一行开始。</p><p>只 剩下一块石子 时，游戏结束。<code>Alice</code>的分数最初为 0 。</p><p>返回 <code>Alice</code>能够获得的最大分数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：stoneValue = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：在第一轮中，Alice 将行划分为 [<span class="number">6</span>，<span class="number">2</span>，<span class="number">3</span>]，[<span class="number">4</span>，<span class="number">5</span>，<span class="number">5</span>] 。左行的值是 <span class="number">11</span> ，右行的值是 <span class="number">14</span> 。Bob 丢弃了右行，Alice 的分数现在是 <span class="number">11</span> 。</span><br><span class="line">在第二轮中，Alice 将行分成 [<span class="number">6</span>]，[<span class="number">2</span>，<span class="number">3</span>] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 <span class="number">16</span>（<span class="number">11</span> + <span class="number">5</span>）。</span><br><span class="line">最后一轮 Alice 只能将行分成 [<span class="number">2</span>]，[<span class="number">3</span>] 。Bob 扔掉右行，Alice 的分数现在是 <span class="number">18</span>（<span class="number">16</span> + <span class="number">2</span>）。游戏结束，因为这行只剩下一块石头了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stoneValue = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stoneValue = [<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= stoneValue.length &lt;= 500</code></li><li><code>1 &lt;= stoneValue[i] &lt;= 10^6</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stone-game-v" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-v</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs记忆化搜索</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该题其实比较简单，不过刚开始自己考虑太复杂了，首先知道是要用<code>dp</code>。但是直接推导<code>dp</code>发现时间复杂度为<code>o(n^3)</code>不太好推，后来想想干脆不如用记忆化搜索。</li><li>首先看到题目中要求数组分组并求数组的左右分组的和，这时肯定想到是要用数组的前缀和，因为利用数组的前缀和可以在<code>o(1)</code>时间复杂度内求出数组的区间的和。</li><li>我们通过<code>dfs</code>搜索区间数组<code>[l,r]</code>时，<code>Alice</code>能取得的最大值。则每次我们从<code>x</code>处断开，分别可以求得数组从<code>l</code>到<code>x</code>的和为<code>sum[l][x]</code>,数组从<code>x+1</code>到<code>r</code>的和为<code>sum[x+1][r]</code>,我们判断其大小，然后根据题意进行下一次迭代即可。</li></ol><ul><li>如果：<code>sum[l][x] &gt; sum[x+1][r]</code>,则<script type="math/tex; mode=display">dp[l][r] = max(dp[l][r],sum[x+1][r] + dp[x+1][r])</script></li><li>如过<code>sum[l][x] &lt; sum[x+1][r]</code>,则<br><script type="math/tex">dp[l][r] = max(dp[l][r],sum[l][x] + dp[l][x])</script>.</li><li>如过<code>sum[l][x] = sum[x+1][r]</code>,则<br><script type="math/tex">dp[l][r] = max(dp[l][r],sum[l][x] + dp[l][x],sum[x+1][r] + dp[x+1][r])</script>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">550</span>][<span class="number">550</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; sum,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[l][r] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            dp[l][r] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> lsum = sum[i] - sum[l<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">int</span> rsum = sum[r] - sum[i];</span><br><span class="line">                <span class="keyword">if</span>(lsum &gt; rsum)&#123;</span><br><span class="line">                    dp[l][r] = max(dp[l][r],rsum + dfs(sum,i+<span class="number">1</span>,r));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lsum &lt; rsum)&#123;</span><br><span class="line">                    dp[l][r] = max(dp[l][r],lsum + dfs(sum,l,i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[l][r] = max(dp[l][r],rsum + dfs(sum,i+<span class="number">1</span>,r));</span><br><span class="line">                    dp[l][r] = max(dp[l][r],lsum + dfs(sum,l,i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += stoneValue[i];</span><br><span class="line">            sum[i+<span class="number">1</span>] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(sum,<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;203场周赛&quot;&gt;&lt;a href=&quot;#203场周赛&quot; class=&quot;headerlink&quot; title=&quot;203场周赛&quot;&gt;&lt;/a&gt;203场周赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量确实要高一些，双周赛的题目简单太多了。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200823154253.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5495-圆形赛道上经过次数最多的扇区&quot;&gt;&lt;a href=&quot;#5495-圆形赛道上经过次数最多的扇区&quot; class=&quot;headerlink&quot; title=&quot;5495. 圆形赛道上经过次数最多的扇区&quot;&gt;&lt;/a&gt;5495. 圆形赛道上经过次数最多的扇区&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; 和一个整数数组 &lt;code&gt;rounds&lt;/code&gt; 。有一条圆形赛道由 &lt;code&gt;n&lt;/code&gt;个扇区组成，扇区编号从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 &lt;code&gt;m&lt;/code&gt;个阶段组成。其中，第 i 个阶段将会从扇区 &lt;code&gt;rounds[i - 1]&lt;/code&gt; 开始，到扇区 &lt;code&gt;rounds[i]&lt;/code&gt;结束。举例来说，第 1 阶段从 &lt;code&gt;rounds[0]&lt;/code&gt; 开始，到&lt;code&gt;rounds[1]&lt;/code&gt;结束。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 33周双周赛</title>
    <link href="http://yoursite.com/2020/08/23/193/"/>
    <id>http://yoursite.com/2020/08/23/193/</id>
    <published>2020-08-23T00:40:24.315Z</published>
    <updated>2020-08-30T07:27:21.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="33场双周赛"><a href="#33场双周赛" class="headerlink" title="33场双周赛"></a>33场双周赛</h1><p>双周赛的题目都好简单，第三题卡壳了好长时间。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823075219.png" alt="1"></p><h2 id="5479-千位分隔数"><a href="#5479-千位分隔数" class="headerlink" title="5479. 千位分隔数"></a>5479. 千位分隔数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。</p><p>示例 1：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">987</span></span><br><span class="line">输出：<span class="string">"987"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">1234</span></span><br><span class="line">输出：<span class="string">"1.234"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">123456789</span></span><br><span class="line">输出："<span class="number">123.456</span>.<span class="number">789</span>"</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>0 &lt;= n &lt; 2^31</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/thousand-separator" target="_blank" rel="noopener">https://leetcode-cn.com/problems/thousand-separator</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">thousandSeparator</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            curr++;</span><br><span class="line">            ans = to_string(n%<span class="number">10</span>) + ans;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; <span class="number">0</span> &amp;&amp; curr%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ans = <span class="string">"."</span> + ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5480-可以到达所有点的最少点数目"><a href="#5480-可以到达所有点的最少点数目" class="headerlink" title="5480. 可以到达所有点的最少点数目"></a>5480. 可以到达所有点的最少点数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 有向无环图 ， <code>n</code>个节点编号为 <code>0</code>到 <code>n-1</code> ，以及一个边数组 <code>edges</code> ，其中 <code>edges[i] = [fromi, toi]</code> 表示一条从点  <code>fromi</code>到点 <code>toi</code>的有向边。</p><p>找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。</p><p>你可以以任意顺序返回这些节点编号。</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e1.png" alt="1"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line">解释：从单个节点出发无法到达所有节点。从 <span class="number">0</span> 出发我们可以到达 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>] 。从 <span class="number">3</span> 出发我们可以到达 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] 。所以我们输出 [<span class="number">0</span>,<span class="number">3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e2.png" alt="2"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：注意到节点 <span class="number">0</span>，<span class="number">3</span> 和 <span class="number">2</span> 无法从其他节点到达，所以我们必须将它们包含在结果点集中，这些点都能到达节点 <span class="number">1</span> 和 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= fromi, toi &lt; n</code></li><li>所有点对 <code>(fromi, toi)</code> 互不相同。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 图</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质就是找到图的入度为<code>0</code>的节点即可，这个题目应该更难点为好。太过于简单了。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSmallestSetOfVertices(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5481-得到目标数组的最少函数调用次数"><a href="#5481-得到目标数组的最少函数调用次数" class="headerlink" title="5481. 得到目标数组的最少函数调用次数"></a>5481. 得到目标数组的最少函数调用次数</h2><p>给你一个与 nums 大小相同且初始值全为 <code>0</code>的数组 <code>arr</code> ，请你调用以上函数得到整数数组 <code>nums</code>。<br>请你返回将 <code>arr</code>变成 <code>nums</code> 的最少函数调用次数。<br>答案保证在 <code>32</code> 位有符号整数以内。<br><img src="https://assets.leetcode.com/uploads/2020/07/10/sample_2_1887.png" alt="3"></p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：给第二个数加 <span class="number">1</span> ：[<span class="number">0</span>, <span class="number">0</span>] 变成 [<span class="number">0</span>, <span class="number">1</span>] （<span class="number">1</span> 次操作）。</span><br><span class="line">将所有数字乘以 <span class="number">2</span> ：[<span class="number">0</span>, <span class="number">1</span>] -&gt; [<span class="number">0</span>, <span class="number">2</span>] -&gt; [<span class="number">0</span>, <span class="number">4</span>] （<span class="number">2</span> 次操作）。</span><br><span class="line">给两个数字都加 <span class="number">1</span> ：[<span class="number">0</span>, <span class="number">4</span>] -&gt; [<span class="number">1</span>, <span class="number">4</span>] -&gt; [<span class="number">1</span>, <span class="number">5</span>] （<span class="number">2</span> 次操作）。</span><br><span class="line">总操作次数为：<span class="number">1</span> + <span class="number">2</span> + <span class="number">2</span> = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：给两个数字都加 <span class="number">1</span> ：[<span class="number">0</span>, <span class="number">0</span>] -&gt; [<span class="number">0</span>, <span class="number">1</span>] -&gt; [<span class="number">1</span>, <span class="number">1</span>] （<span class="number">2</span> 次操作）。</span><br><span class="line">将所有数字乘以 <span class="number">2</span> ： [<span class="number">1</span>, <span class="number">1</span>] -&gt; [<span class="number">2</span>, <span class="number">2</span>] （<span class="number">1</span> 次操作）。</span><br><span class="line">总操作次数为： <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：（初始）[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>] -&gt; [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>] -&gt; [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] （nums 数组）。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>对于数目乘以<code>2</code>的次数与数组中最大的数相关，所以乘以<code>2</code>的次数就等于max取<code>log</code>。</li><li>其余剩下的操作次数即为所有元素取2的模为1的次数。</li><li>这种类型的题目非常好，带有数学问题，并且带有一定的难度。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lg = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(v &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v%<span class="number">2</span>)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    --v;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++t;</span><br><span class="line">                    v /= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lg = max(lg,t);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans += lg;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5482-二维网格图中探测环"><a href="#5482-二维网格图中探测环" class="headerlink" title="5482. 二维网格图中探测环"></a>5482. 二维网格图中探测环</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维字符网格数组 <code>grid</code> ，大小为<code>m x n</code> ，你需要检查 <code>grid</code> 中是否存在 相同值 形成的环。</p><p>一个环是一条开始和结束于同一个格子的长度 大于等于 <code>4</code> 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 相同的值 。</p><p>同时，你也不能回到上一次移动时所在的格子。比方说，环 <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code>是不合法的，因为从 <code>(1, 2)</code> 移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p><p>如果 grid 中有相同值形成的环，请你返回 <code>true</code>，否则返回 <code>false</code> 。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e1.png" alt="5"><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e11.png" alt="6"><br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>],[<span class="comment">"a"</span>,<span class="comment">"b"</span>,<span class="comment">"b"</span>,<span class="comment">"a"</span>],[<span class="comment">"a"</span>,<span class="comment">"b"</span>,<span class="comment">"b"</span>,<span class="comment">"a"</span>],[<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>]]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：如下图所示，有 <span class="number">2</span> 个用不同颜色标出来的环：</span><br></pre></td></tr></table></figure><br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e2.png" alt="7"><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e22.png" alt="8"><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"a"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>],[<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"e"</span>,<span class="string">"c"</span>],[<span class="string">"f"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>]]</span><br><span class="line">输出：true</span><br><span class="line">解释：如下图所示，只有高亮所示的一个合法环：</span><br></pre></td></tr></table></figure><br>示例 3：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e3.png" alt="9"><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"b"</span>,<span class="string">"a"</span>]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m &lt;= 500</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>grid</code> 只包含小写英文字母。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/detect-cycles-in-2d-grid</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs或者BFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该题非常简单，就是简单的BFS或者DFS即可。判断是否有环即可。不晓得为什么是<code>hard</code>难度。</li><li>最后一题都 <code>AC</code>600+了说明非常简单。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    Node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _d)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = _x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = _y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;d = _d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFrom</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((x == <span class="number">0</span> &amp;&amp; y == <span class="number">1</span>)||(x == <span class="number">1</span> &amp;&amp; y == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((x == <span class="number">2</span> &amp;&amp; y == <span class="number">3</span>)||(x == <span class="number">3</span> &amp;&amp; y == <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">if</span>(row &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visit[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">char</span> c = grid[i][j];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> d = k;</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == c)&#123;</span><br><span class="line">                        qu.push(&#123;x,y,d&#125;);</span><br><span class="line">                        visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                    Node curr = qu.front();</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isFrom(k,curr.d)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> x = curr.x + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = curr.y + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">int</span> d = k;</span><br><span class="line">                        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == c)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(visit[x][y]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            qu.push(&#123;x,y,d&#125;);</span><br><span class="line">                            visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;33场双周赛&quot;&gt;&lt;a href=&quot;#33场双周赛&quot; class=&quot;headerlink&quot; title=&quot;33场双周赛&quot;&gt;&lt;/a&gt;33场双周赛&lt;/h1&gt;&lt;p&gt;双周赛的题目都好简单，第三题卡壳了好长时间。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200823075219.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5479-千位分隔数&quot;&gt;&lt;a href=&quot;#5479-千位分隔数&quot; class=&quot;headerlink&quot; title=&quot;5479. 千位分隔数&quot;&gt;&lt;/a&gt;5479. 千位分隔数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;987&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;987&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;1.234&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;123456789&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&quot;&lt;span class=&quot;number&quot;&gt;123.456&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;789&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>火与烬</title>
    <link href="http://yoursite.com/2020/08/17/192/"/>
    <id>http://yoursite.com/2020/08/17/192/</id>
    <published>2020-08-17T04:29:41.217Z</published>
    <updated>2020-08-17T04:32:27.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="火与烬"><a href="#火与烬" class="headerlink" title="火与烬"></a>火与烬</h1><p>断断续续的才看完了这本所谓的《火与烬》这本书，最初被这本书吸引的是本书的内容的描写，相关主要内容主要描述的是哈佛的著名学者叶礼庭回到自己的故乡加拿大参加竞选总理并最终落选的历程，文中详细的描述了作者参选的过程和落选失败后得感受和历程。</p><ul><li>为什么当初要选这种书籍来阅读，因为在国内的一党专政的体制下，许多人对国外的民主投票政治非常向往，或者说过度神话。但是通过此书详细的描写了国外的选票政治的历程，从中可以窥见一斑，了解国外的民主政治运作方式，是一种直观的方式，虽然没有亲身过西方的选举制度，但通过本书详细的描述了加拿大竞选总理的历程，了解国外选举制度的基本知识，了解国外议会立法的基本运作方式，了解国外的行政的基本运作方式，最直观的感受，就是没有了之前那种“非黑即白”的简单是否观念。</li><li>国外的民主选举制度并不是万能的，国内的一党独裁制度也并不是全部的邪恶的，两者都又它的优点和缺点，更应该客观来看，评论政治体制时，更应该客观的看待，政治制度是否与国内自身的政治背景基础匹配，是否兼顾了公平与效率？民主选举制度更注重过程的公平，而缺少对效率和结果的公平，本身也又其缺点。</li><li>国内的政治制度也有其好的一面，在看到国外的选举过程中，两党之间的政治斗争也时充满腥风血雨，对于党员也要求忠诚第一，稍微不注意，党员也可能在政治斗阵中失败，而被淘汰出局，所谓书中描写的完美制度与家园，本质上也并不存在的。国外的政党也面临着在某些重大利益的事情上无所作为的情况，政治本身也时残酷的，而政治家们也并没有书中描述的那么英明俊朗，政治层面以下也有许多见不得光的利益勾兑和妥协，当然不管在哪国的政治家们想要生存，做一个清白且公正无私的“海瑞”，本就不现实的。这些让我想到了国内体制内流行的一句话，“能做事”跟“做成事”两者之间存在的巨大的鸿沟，政治圈里“做成事”这个问题首先就不可能从书本上找到理论，更需要的实践与智慧，就像为什么现在所谓的“专家”和“学者”很多，但是实际成功的“企业家”和“政客”总是稀缺的。培养几个“工程师”很容易，但是培养一个成功的“CEO”很难，因为很多成功的职业生涯根本就没有一个正确的理论来作为指导的，只能通过当事人的自己摸索和临场发挥。</li><li>文中描述的作者参与“总理”选举的五年历程，其中经历的艰辛、曲折，耗费的精力和金钱，面对的困难和挫折，不是一般的人能够承受的，我们作为台下的观众，总是很容易的帮其分析原因，指责他所范的错误，但实际我们亲身并没有参与这些，我们更应该为作者点赞，佩服作者能够参与平常人几乎没有机会能够参与的一种生活体验。</li></ul><a id="more"></a><h2 id="作者背景"><a href="#作者背景" class="headerlink" title="作者背景"></a>作者背景</h2><p>作者英文名迈克尔·伊格纳季耶夫（Michael Ignatieff），中文名叶礼庭,出身在加拿大的一个政治世家，祖父是莎皇时代的教育部长, 在 1917年俄国红色十月革命后逃往满地可, 父亲是加拿大外交官, 他的舅父是 著名 政治哲学家George Grant, 他的姨祖母Alice Massey是前加拿大总督 Vincent Massey的妻子. 家族显赫。他在多伦 多大学历史系毕业，1979年在哈佛大学取得历史博士学，曾在剑桥大学和哈佛大学任教，可以称之为西方世界的精英实至名归。作者在加拿大自由党派的领导人的劝说下，从美国返回到加拿大，后来成为加拿大自由党的党魁，而后又被党内推选为加拿大总理的候选人，参加2008年的加拿大总理竞选，而后又失败</p><h2 id="蹈火（初入政治）"><a href="#蹈火（初入政治）" class="headerlink" title="蹈火（初入政治）"></a>蹈火（初入政治）</h2><p>作者因为家族背景的原因，也是因为自身影响力的原理，从哈佛任教转回加拿大，涉入政坛。由于背景的加持，在党内快速上升，很快就成为加拿大自由党党领袖的候选人，然后第一次党内选举中落败，后来又成为党内的副领袖。200年的经济危机中，由于自由党在竞选中落败，党领袖下台，而他又以外的被推举为自由党的党魁，而又作为在野党的议员，参与行政议政，在议政过程中描写了部分与执政党的有分歧事情和他通过部分事件描述执政党总理的部分观点和看法。从他描述的部分参政议政的过程中，从而对国外的议会制的立法和行政过程有所了解。</p><h2 id="烬余（竞选中期）"><a href="#烬余（竞选中期）" class="headerlink" title="烬余（竞选中期）"></a>烬余（竞选中期）</h2><p>在竞选初期，作者作为自由党的党魁而被党内一致推举为竞选总理的候选人，但反对党借机利用媒体就作者的身份进行大肆宣传，故意丑化作者，“他来自美国，只是一个过客”，这样深入人心的标语，有意丑化候选人，很快就让叶礼庭在大选前的民调中的支持率大幅下降。而竞选过程中并没有我们从前想的那么伟大神圣，保守党主要精力放在恶意丑化对方，能够故意让对方阻挡于“竞选”之外，而并没有去刻意去向选民宣传自己得竞选理念，去争取更多得投标人得支持。自由党作为在野党弱势的一方，作者本身极为辛苦的进行全国巡演，用传统的竞选方式去宣传自己的参政纲领和理念，去与民众亲近，去各地演讲从而寻得全国各地的选民的支持，然而最终竞选结果出来后竞选失败，令作者感到难受，开始反思自己在竞选中所犯的各种错误。</p><h2 id="竞选落败回忆"><a href="#竞选落败回忆" class="headerlink" title="竞选落败回忆"></a>竞选落败回忆</h2><p>作者有句很鲜明的理论，所有的著名的政治学理论都是政治失败者所撰写的，我想只有作者这种亲身参与这样极为重要的政治活动才得出来得理论总结，作者列举了许多著名得政治理论著作，都是由一些落魄得政治失败者反思后所总结撰写得理论，“要么在台上，要么回去教书”，多么形象的比喻。作者总结出，政治这个游戏对参与者的素质要求太高，门槛太高，并不是一般的人能够玩转的。<br>他反思，理论家的独特天分在于，“不计成败的率直、缜密、意志力，以及对独创性的敏锐探寻”，但往往缺乏政界人物需要的谨慎、掩饰、党性、对时势变化的敏锐、灵活的身段、阿谀奉承的口才。尽管叶礼庭自认远远无法与西塞罗、托克维尔这些思想大师并肩，但他的长处依然是在理论研究而非政治实务上，六年从政之路虽然不后悔，但政坛确实不是他真正擅长的地方。<br>“我追求权力的火焰，看到希望逐渐减少为灰烬。”缓慢走出败选阴影的叶礼庭，终于又拿起了笔，唤回那个作为作家的自己。在《火与烬》这本书中，他平和、真诚地讲述自己经历的点点滴滴，毫不留情地分析自己的稚嫩和错误，节制地表达幻灭的痛苦，给我们留下了一份丰富而不失优雅的心灵记录。<br>不得不说，透过本书的描述，让我们对政治生活更有一份客观而又正确的看待，在政治活动中，并没有所谓的绝对的“对与错”，妥协与隐藏是政治活动中的常态，劝诫从政活动中更重要的是要坚守内心的信仰，而不是固守所有的道德准则。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;火与烬&quot;&gt;&lt;a href=&quot;#火与烬&quot; class=&quot;headerlink&quot; title=&quot;火与烬&quot;&gt;&lt;/a&gt;火与烬&lt;/h1&gt;&lt;p&gt;断断续续的才看完了这本所谓的《火与烬》这本书，最初被这本书吸引的是本书的内容的描写，相关主要内容主要描述的是哈佛的著名学者叶礼庭回到自己的故乡加拿大参加竞选总理并最终落选的历程，文中详细的描述了作者参选的过程和落选失败后得感受和历程。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;为什么当初要选这种书籍来阅读，因为在国内的一党专政的体制下，许多人对国外的民主投票政治非常向往，或者说过度神话。但是通过此书详细的描写了国外的选票政治的历程，从中可以窥见一斑，了解国外的民主政治运作方式，是一种直观的方式，虽然没有亲身过西方的选举制度，但通过本书详细的描述了加拿大竞选总理的历程，了解国外选举制度的基本知识，了解国外议会立法的基本运作方式，了解国外的行政的基本运作方式，最直观的感受，就是没有了之前那种“非黑即白”的简单是否观念。&lt;/li&gt;
&lt;li&gt;国外的民主选举制度并不是万能的，国内的一党独裁制度也并不是全部的邪恶的，两者都又它的优点和缺点，更应该客观来看，评论政治体制时，更应该客观的看待，政治制度是否与国内自身的政治背景基础匹配，是否兼顾了公平与效率？民主选举制度更注重过程的公平，而缺少对效率和结果的公平，本身也又其缺点。&lt;/li&gt;
&lt;li&gt;国内的政治制度也有其好的一面，在看到国外的选举过程中，两党之间的政治斗争也时充满腥风血雨，对于党员也要求忠诚第一，稍微不注意，党员也可能在政治斗阵中失败，而被淘汰出局，所谓书中描写的完美制度与家园，本质上也并不存在的。国外的政党也面临着在某些重大利益的事情上无所作为的情况，政治本身也时残酷的，而政治家们也并没有书中描述的那么英明俊朗，政治层面以下也有许多见不得光的利益勾兑和妥协，当然不管在哪国的政治家们想要生存，做一个清白且公正无私的“海瑞”，本就不现实的。这些让我想到了国内体制内流行的一句话，“能做事”跟“做成事”两者之间存在的巨大的鸿沟，政治圈里“做成事”这个问题首先就不可能从书本上找到理论，更需要的实践与智慧，就像为什么现在所谓的“专家”和“学者”很多，但是实际成功的“企业家”和“政客”总是稀缺的。培养几个“工程师”很容易，但是培养一个成功的“CEO”很难，因为很多成功的职业生涯根本就没有一个正确的理论来作为指导的，只能通过当事人的自己摸索和临场发挥。&lt;/li&gt;
&lt;li&gt;文中描述的作者参与“总理”选举的五年历程，其中经历的艰辛、曲折，耗费的精力和金钱，面对的困难和挫折，不是一般的人能够承受的，我们作为台下的观众，总是很容易的帮其分析原因，指责他所范的错误，但实际我们亲身并没有参与这些，我们更应该为作者点赞，佩服作者能够参与平常人几乎没有机会能够参与的一种生活体验。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 202周赛</title>
    <link href="http://yoursite.com/2020/08/16/191/"/>
    <id>http://yoursite.com/2020/08/16/191/</id>
    <published>2020-08-16T05:25:21.003Z</published>
    <updated>2020-08-16T05:25:30.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="202场周赛"><a href="#202场周赛" class="headerlink" title="202场周赛"></a>202场周赛</h1><p>本周的题目都好简单，除了最后一题稍微有点数学知识即可解答出来，其余的题目都非常简单。</p><h2 id="5185-存在连续三个奇数的数组"><a href="#5185-存在连续三个奇数的数组" class="headerlink" title="5185. 存在连续三个奇数的数组"></a>5185. 存在连续三个奇数的数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：不存在连续三个元素都是奇数的情况。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：存在连续三个元素都是奇数的情况，即 [<span class="number">5</span>,<span class="number">7</span>,<span class="number">23</span>] 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/three-consecutive-odds" target="_blank" rel="noopener">https://leetcode-cn.com/problems/three-consecutive-odds</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i<span class="number">-2</span>]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; arr[i<span class="number">-1</span>]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; arr[i]%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5488-使数组中所有元素相等的最小操作数"><a href="#5488-使数组中所有元素相等的最小操作数" class="headerlink" title="5488. 使数组中所有元素相等的最小操作数"></a>5488. 使数组中所有元素相等的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>存在一个长度为 <code>n</code>的数组 <code>arr</code>，其中 <code>arr[i] = (2 * i) + 1 （ 0 &lt;= i &lt; n ）</code>。</p><p>一次操作中，你可以选出两个下标，记作 <code>x</code>和 <code>y （ 0 &lt;= x, y &lt; n ）</code>并使 <code>arr[x]</code> 减去 1 、<code>arr[y]</code>加上 1 （即 <code>arr[x] -=1</code>且 <code>arr[y] += 1</code>）。最终的目标是使数组中的所有元素都 相等 。题目测试用例将会 保证 ：在执行若干步操作后，数组中的所有元素最终可以全部相等。</p><p>给你一个整数 <code>n</code>，即数组的长度。请你返回使数组 <code>arr</code> 中所有元素相等所需的 最小操作数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">第一次操作选出 x = <span class="number">2</span> 和 y = <span class="number">0</span>，使数组变为 [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">第二次操作继续选出 x = <span class="number">2</span> 和 y = <span class="number">0</span>，数组将会变成 [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^4</code><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>本质就是个数学问题，弄清楚等差数列的元素和长度，即可很快的求出来。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (n*n)/<span class="number">4</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (n<span class="number">-1</span>)*(n+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5489-两球之间的磁力"><a href="#5489-两球之间的磁力" class="headerlink" title="5489. 两球之间的磁力"></a>5489. 两球之间的磁力</h2><p>在代号为 <code>C-137</code>的地球上，<code>Rick</code> 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。<code>Rick</code> 有 <code>n</code> 个空的篮子，第 <code>i</code> 个篮子的位置在 <code>position[i]</code> ，<code>Morty</code>想把 <code>m</code> 个球放到这些篮子里，使得任意两球间 最小磁力 最大。</p><p>已知两个球如果分别位于<code>x</code>和<code>y</code>，那么它们之间的磁力为<code>|x - y|</code>。</p><p>给你一个整数数组 <code>position</code>和一个整数<code>m</code>，请你返回最大化的最小磁力。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], m = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将 <span class="number">3</span> 个球分别放入位于 <span class="number">1</span>，<span class="number">4</span> 和 <span class="number">7</span> 的三个篮子，两球间的磁力分别为 [<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>]。最小磁力为 <span class="number">3</span> 。我们没办法让最小磁力大于 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1000000000</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">999999999</span></span><br><span class="line">解释：我们使用位于 <span class="number">1</span> 和 <span class="number">1000000000</span> 的篮子时最小磁力最大。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == position.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= position[i] &lt;= <span class="number">10</span>^<span class="number">9</span>`</span><br><span class="line">+ 所有` position `中的整数 互不相同 。</span><br><span class="line">+ `<span class="number">2</span> &lt;= m &lt;= position.length`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/magnetic-force-between-two-balls</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  二分查找</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的二分查找解法。与之前的类似的题目切巧克力基本上一样的题目，一看基本就直到解法。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> check(vector&lt;<span class="built_in">int</span>&gt;&amp; position, <span class="built_in">int</span> m,<span class="built_in">int</span> distance)&#123;</span><br><span class="line">        m--;</span><br><span class="line">        <span class="built_in">int</span> curr = position[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; position.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(position[i] - curr &gt;= distance)&#123;</span><br><span class="line">                curr = position[i];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> maxDistance(vector&lt;<span class="built_in">int</span>&gt;&amp; position, <span class="built_in">int</span> m) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = position.size();</span><br><span class="line">        long long l = <span class="number">1</span>;</span><br><span class="line">        long long r = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        sort(position.begin(),position.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(position,m,mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5490-吃掉-N-个橘子的最少天数"><a href="#5490-吃掉-N-个橘子的最少天数" class="headerlink" title="5490. 吃掉 N 个橘子的最少天数"></a>5490. 吃掉 N 个橘子的最少天数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p><p>吃掉一个橘子。<br>如果剩余橘子数 <code>n</code> 能被 2 整除，那么你可以吃掉 n/2 个橘子。<br>如果剩余橘子数 <code>n</code>能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。<br>每天你只能从以上 3 种方案中选择一种方案。</p><p>请你返回吃掉所有 <code>n</code>个橘子的最少天数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你总共有 <span class="number">10</span> 个橘子。</span><br><span class="line">第 <span class="number">1</span> 天：吃 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">10</span> - <span class="number">1</span> = <span class="number">9</span>。</span><br><span class="line">第 <span class="number">2</span> 天：吃 <span class="number">6</span> 个橘子，剩余橘子数 <span class="number">9</span> - <span class="number">2</span>*(<span class="number">9</span>/<span class="number">3</span>) = <span class="number">9</span> - <span class="number">6</span> = <span class="number">3</span>。（<span class="number">9</span> 可以被 <span class="number">3</span> 整除）</span><br><span class="line">第 <span class="number">3</span> 天：吃 <span class="number">2</span> 个橘子，剩余橘子数 <span class="number">3</span> - <span class="number">2</span>*(<span class="number">3</span>/<span class="number">3</span>) = <span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>。</span><br><span class="line">第 <span class="number">4</span> 天：吃掉最后 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span>。</span><br><span class="line">你需要至少 <span class="number">4</span> 天吃掉 <span class="number">10</span> 个橘子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你总共有 <span class="number">6</span> 个橘子。</span><br><span class="line">第 <span class="number">1</span> 天：吃 <span class="number">3</span> 个橘子，剩余橘子数 <span class="number">6</span> - <span class="number">6</span>/<span class="number">2</span> = <span class="number">6</span> - <span class="number">3</span> = <span class="number">3</span>。（<span class="number">6</span> 可以被 <span class="number">2</span> 整除）</span><br><span class="line">第 <span class="number">2</span> 天：吃 <span class="number">2</span> 个橘子，剩余橘子数 <span class="number">3</span> - <span class="number">2</span>*(<span class="number">3</span>/<span class="number">3</span>) = <span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>。（<span class="number">3</span> 可以被 <span class="number">3</span> 整除）</span><br><span class="line">第 <span class="number">3</span> 天：吃掉剩余 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span>。</span><br><span class="line">你至少需要 <span class="number">3</span> 天吃掉 <span class="number">6</span> 个橘子。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">56</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 2*10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs + 记忆式搜索</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本质是典型的记忆式搜素，题目非常简单。</li><li>或者简单的BFS快速搜素即可，也没什么好讨论的。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(n)) <span class="keyword">return</span> cnt[n];</span><br><span class="line">        ans = min(ans,dfs(n/<span class="number">2</span>) + n%<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        ans = min(ans,dfs(n/<span class="number">3</span>) + n%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        cnt[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.push(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = que.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> q = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (q == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (q % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; s.count(q / <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q / <span class="number">3</span>);</span><br><span class="line">                    s.insert(q / <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (q % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; s.count(q / <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q / <span class="number">2</span>);</span><br><span class="line">                    s.insert(q / <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.count(q - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q - <span class="number">1</span>);</span><br><span class="line">                    s.insert(q - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;202场周赛&quot;&gt;&lt;a href=&quot;#202场周赛&quot; class=&quot;headerlink&quot; title=&quot;202场周赛&quot;&gt;&lt;/a&gt;202场周赛&lt;/h1&gt;&lt;p&gt;本周的题目都好简单，除了最后一题稍微有点数学知识即可解答出来，其余的题目都非常简单。&lt;/p&gt;&lt;h2 id=&quot;5185-存在连续三个奇数的数组&quot;&gt;&lt;a href=&quot;#5185-存在连续三个奇数的数组&quot; class=&quot;headerlink&quot; title=&quot;5185. 存在连续三个奇数的数组&quot;&gt;&lt;/a&gt;5185. 存在连续三个奇数的数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt;，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：不存在连续三个元素都是奇数的情况。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：存在连续三个元素都是奇数的情况，即 [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 201周周赛</title>
    <link href="http://yoursite.com/2020/08/09/190/"/>
    <id>http://yoursite.com/2020/08/09/190/</id>
    <published>2020-08-09T08:21:04.153Z</published>
    <updated>2020-08-09T09:26:54.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="201周周赛"><a href="#201周周赛" class="headerlink" title="201周周赛"></a>201周周赛</h1><p>本周的周赛题目都比较简单，40分钟搞定前三道题目，后面有事就中途退场。回来后，最后一题5分钟搞定，好简单。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809162635.png" alt="1"><br>不过整体来说，感觉题目质量非常高，leetcode出题还是用心。</p><h2 id="5483-整理字符串"><a href="#5483-整理字符串" class="headerlink" title="5483. 整理字符串"></a>5483. 整理字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p><p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code>和 <code>s[i + 1]</code>不会同时满足下述条件：</p><a id="more"></a><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> 是小写字符，但 <code>s[i + 1]</code> 是相同的大写字符；反之亦然 。<br>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。<br>请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。<br>注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。</li></ul><p>示例 1：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leEeetcode"</span></span><br><span class="line">输出：<span class="string">"leetcode"</span></span><br><span class="line">解释：无论你第一次选的是 <span class="selector-tag">i</span> = <span class="number">1</span> 还是 <span class="selector-tag">i</span> = <span class="number">2</span>，都会使 <span class="string">"leEeetcode"</span> 缩减为 <span class="string">"leetcode"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abBAcC"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：</span><br><span class="line"><span class="string">"abBAcC"</span> --&gt; <span class="string">"aAcC"</span> --&gt; <span class="string">"cC"</span> --&gt; <span class="string">""</span></span><br><span class="line"><span class="string">"abBAcC"</span> --&gt; <span class="string">"abBA"</span> --&gt; <span class="string">"aA"</span> --&gt; <span class="string">""</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"s"</span></span><br><span class="line">输出：<span class="string">"s"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写和大写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-the-string-great" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-the-string-great</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  堆栈</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题感觉比较坑，简单的题目估计卡住不少人，感觉可以到达mid难度。</li><li>模拟堆栈即可，遍历字符串，如果当前字符串中的元素与栈顶的元素的绝对值之差为<code>32</code>，则出栈即可。最后返回栈中剩余的元素即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isgood = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        res.push_back(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.empty())&#123;</span><br><span class="line">                res.push_back(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(res.back()-s[i]) == <span class="number">32</span>)&#123;</span><br><span class="line">                    res.pop_back();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push_back(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5484-找出第-N-个二进制字符串中的第-K-位"><a href="#5484-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="5484. 找出第 N 个二进制字符串中的第 K 位"></a>5484. 找出第 N 个二进制字符串中的第 K 位</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串  <code>Sn</code> 的形成规则如下：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li>当 <code>i &gt; 1</code> 时，<code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code><br>其中 + 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转<code>x</code>中的每一位（<code>0</code>变为 <code>1</code>，而 <code>1</code> 变为 <code>0</code>）</li></ul><p>例如，符合上述描述的序列的前 4 个字符串依次是：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li><code>S2 = &quot;011&quot;</code></li><li><code>S3 = &quot;0111001&quot;</code></li><li><code>S4 = &quot;011100110110001&quot;</code><br>请你返回  Sn 的 第 k 位字符 ，题目数据保证 k 一定在 Sn 长度范围以内。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">解释：S3 为 <span class="string">"0111001"</span>，其第 <span class="number">1</span> 位为 <span class="string">"0"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">11</span></span><br><span class="line">输出：<span class="string">"1"</span></span><br><span class="line">解释：S4 为 <span class="string">"011100110110001"</span>，其第 <span class="number">11</span> 位为 <span class="string">"1"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= 2n - 1</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题 + 找规律</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>先找到规律，刚拿到题目感觉没法下手，直接去求解的话，感觉很难。</li><li>仔细发现一下找到规律即可，实际我们直到$S_{n}$与$S_{n+1}$之间的递推关系，实际我们就可以用递归求解即可。我们可以讲字符串滑下来。</li><li>我们可以举例<code>S4</code>：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809165248.png" alt="1">。<br>首先我们可以直到$S_{n}$的长度$len(S_{n}) = 2^{n}-1$.假如<code>k</code>刚好在当前字符串中间的话，则直接返回<code>1</code>,因为我们直到除<code>S1</code>以外的字符串，最中间的字符都为<code>1</code>,最中间的位置刚好为：$2^{n-1}$<br>所以我们分为三种情况来讨论：</li></ol><ul><li>当$K &lt; 2^{n-1}$时：则此时$S_{n}[k] = S_{n-1}[k]$</li><li>当$K = 2^{n-1}$时：则此时$S_{n}[K] = 1$</li><li>当$K &gt; 2^{n-1}$时：则此时稍微麻烦点，由于后半部分是$reverse(invert(S_{n-1}))$,则$S_{n}[K] = inverse(S_{n-1}[2^{n}-k])$.</li><li>当$n = 0$时，则返回<code>0</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; k == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n<span class="number">-1</span>,<span class="built_in">pow</span>(<span class="number">2</span>,n)-k) == <span class="string">'0'</span>?<span class="string">'1'</span>:<span class="string">'0'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5471-和为目标值的最大数目不重叠非空子数组数目"><a href="#5471-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="5471. 和为目标值的最大数目不重叠非空子数组数目"></a>5471. 和为目标值的最大数目不重叠非空子数组数目</h2><p>给你一个数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">2</span> 个不重叠子数组（加粗数字表示） [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] ，它们的和为目标值 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">-9</span>], target = <span class="number">6</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">3</span> 个子数组和为 <span class="number">6</span> 。</span><br><span class="line">([<span class="number">5</span>,<span class="number">1</span>], [<span class="number">4</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">-9</span>]) 但只有前 <span class="number">2</span> 个是不重叠的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>0 &lt;= target &lt;= 10^6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目有点意思，我们设<code>dp[i]</code>代表前<code>i</code>个元素中含有最多的非连续符合条件且不重合的子数组的数目。</li><li>我们每次从在索引<code>i</code>初找到由元素<code>a[i]</code>作为符合条件的子数组的最后一个元素。我们利用前缀和，每次找到<code>prefixsum[i]-tagret</code>的索引<code>j</code>处。则可以得到以下递推公式.<script type="math/tex; mode=display">ans = max(ans,dp[j] + 1)</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            curr += nums[i<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt.count(curr-target))&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cnt[curr-target];</span><br><span class="line">                dp[i] = max(dp[i],dp[x] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,dp[i]);</span><br><span class="line">            cnt[curr] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5486-切棍子的最小成本"><a href="#5486-切棍子的最小成本" class="headerlink" title="5486. 切棍子的最小成本"></a>5486. 切棍子的最小成本</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一根长度为<code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <code>6</code> 的棍子可以标记如下：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809171755.png" alt="1"><br>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。<br>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p><p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p><p>返回切棍子的 最小总成本 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, cuts = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：按 [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] 的顺序切割的情况如下所示：</span><br><span class="line"></span><br><span class="line">第一次切割长度为 <span class="number">7</span> 的棍子，成本为 <span class="number">7</span> 。第二次切割长度为 <span class="number">6</span> 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 <span class="number">4</span> 的棍子，最后切割长度为 <span class="number">3</span> 的棍子。总成本为 <span class="number">7</span> + <span class="number">6</span> + <span class="number">4</span> + <span class="number">3</span> = <span class="number">20</span> 。</span><br><span class="line">而将切割顺序重新排列为 [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>] 后，总成本 = <span class="number">16</span>（如示例图中 <span class="number">7</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">2</span> = <span class="number">16</span>）。</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809171815.png" alt="2"><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, cuts = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：如果按给定的顺序切割，则总成本为 <span class="number">25</span> 。总成本 &lt;= <span class="number">25</span> 的切割顺序很多，例如，[<span class="number">4</span>，<span class="number">6</span>，<span class="number">5</span>，<span class="number">2</span>，<span class="number">1</span>] 的总成本 = <span class="number">22</span>，是所有可能方案中成本最小的。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 10^6</code></li><li><code>1 &lt;= cuts.length &lt;= min(n - 1, 100)</code></li><li><code>1 &lt;= cuts[i] &lt;= n - 1</code></li><li><code>cuts</code> 数组中的所有整数都 互不相同</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的dp，这种类型的题目已经见了很多了。</li><li>为了方便计算，我们首先讲头和尾加入<code>cuts</code>.我们用<code>dp[i][j]</code>代表<code>cuts[i]</code>到<code>cuts[j]</code>之间的切割最小成本。我们可以直到<code>dp[i][i] = 0</code>和 <code>dp[i][i+1]</code>，因为不需要切割。</li><li>我们很容易得出递推公式：<script type="math/tex; mode=display">dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j] + cuts[j] - cuts[i]) \qquad ( i \le k \le j</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;        </span><br><span class="line">        cuts.push_back(<span class="number">0</span>);</span><br><span class="line">        cuts.push_back(n);</span><br><span class="line">        <span class="keyword">int</span> m = cuts.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        </span><br><span class="line">        sort(cuts.begin(),cuts.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[m<span class="number">-1</span>][m<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j+i &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; j+i; ++k)&#123;</span><br><span class="line">                    dp[j][j+i] = min(dp[j][j+i],dp[j][k] + dp[k][j+i] + cuts[j+i] - cuts[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;201周周赛&quot;&gt;&lt;a href=&quot;#201周周赛&quot; class=&quot;headerlink&quot; title=&quot;201周周赛&quot;&gt;&lt;/a&gt;201周周赛&lt;/h1&gt;&lt;p&gt;本周的周赛题目都比较简单，40分钟搞定前三道题目，后面有事就中途退场。回来后，最后一题5分钟搞定，好简单。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200809162635.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;不过整体来说，感觉题目质量非常高，leetcode出题还是用心。&lt;/p&gt;&lt;h2 id=&quot;5483-整理字符串&quot;&gt;&lt;a href=&quot;#5483-整理字符串&quot; class=&quot;headerlink&quot; title=&quot;5483. 整理字符串&quot;&gt;&lt;/a&gt;5483. 整理字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由大小写英文字母组成的字符串 &lt;code&gt;s&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;一个整理好的字符串中，两个相邻字符 &lt;code&gt;s[i]&lt;/code&gt;和 &lt;code&gt;s[i + 1]&lt;/code&gt;不会同时满足下述条件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
