<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-22T13:48:25.348Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【生活】记一次失败的面试总结</title>
    <link href="http://yoursite.com/2021/05/19/285/"/>
    <id>http://yoursite.com/2021/05/19/285/</id>
    <published>2021-05-19T02:54:51.735Z</published>
    <updated>2021-05-22T13:48:25.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次失败的面试经历"><a href="#记一次失败的面试经历" class="headerlink" title="记一次失败的面试经历"></a>记一次失败的面试经历</h1><p>最近一直比较忙，每天忙于家里和工作，好久都没有时间来更新日志了，今天刚趁着有时间来好好更新一篇日志，主要想谈谈最近一直影响比较深刻的某外企的面试经历，虽然没有通过，但是我觉得把这段经历去复盘一下，总结其中的不足之处，也是对自己的一种成长，提醒自己在哪方面准备的还不足。</p><h2 id="1-接到通知"><a href="#1-接到通知" class="headerlink" title="1. 接到通知"></a>1. 接到通知</h2><a id="more"></a><p>某日正在上班期间，突然接到一个陌生的上海的电话，告知我因为在某次力扣双周赛排名比较靠前，问我有没有兴趣参加他们公司的面试。当时接到电话的那一刻确实比较诧异，因为很多公司都会介意我目前是在职公务员的经历，然后我跟她反复确认了一下，是否介意我目前是在职公务员的身份，被告知不是很介意，然后就发了面试确认。<br>实话实说我目前是在职公务员，并且已经从工程师的职业生涯已经<code>GAP</code>了好几年了，很多公司基本上看到简历都会直接丢弃的那种状态。不过只是业余爱好，平时工作之余时间也非常多，非常喜欢刷力扣算法题和计算机的四大的公开课。平时工作之余因为时间确实较多，心想反正闲着也是闲着，不能把这些时间浪费掉，纯粹是出于兴趣的目的来刷算法题目和学习这些专业课程的，一方面是把这些时间花在学习上总比浪费在抖音和游戏上强的多；另一方面，说句实话这些课程真的是非常非常有意思，纯粹是激起了我这种有两娃的中年男人的学习兴趣。</p><h2 id="2-笔试过程"><a href="#2-笔试过程" class="headerlink" title="2. 笔试过程"></a>2. 笔试过程</h2><p>跟<code>HR</code>确认邮件后，很快就收到了<code>first step</code>的<code>online assignment</code>.查看了一下，题目是在<code>hackrank</code>上，用<code>c++</code>设计一道系统设计题目，需要通过所有的测试用例。平时周一到周五确实没有时间，只能乘着周末来完成这个题目。大概在周日的时候，到旁边大学的自习室，打开了题目，从开始构思系统设计，到通过全部测试用例差不多花费了2个多小时，虽然最终的代码量再精简一下，估计也就不到<code>200</code>行就能完成。虽然花费了精力，但是完成提交<code>online assignment</code>，我觉得题目本身来说非常有意思，这个系统设计题目出的还是相当有水平的。题目大意如下：</p><blockquote><p>要求设计一个由多个<code>unit</code>连接组成的系统，该系统有多个输入，只有一个输出，通过每次输入不同的<code>input</code>来给出系统的最终输出。每个<code>unit</code>也可能有多个输入<code>input</code>，但是只有一个输出<code>output</code>，每个<code>unit</code>会执行某种运算，运算操作可能是<code>+，-，/，*，异或，与，或，非</code>等等,运算操作的数即为该<code>unit</code>的输入<code>input</code>，最终运算的结果即通过输出<code>output</code>获取。关键的一点在于，必须所有的<code>unit</code>的输入上<code>input</code>上都有合法的输入参数时，<code>unit</code>的<code>output</code>才会有输出。需要提示的是系统的<code>input</code>可能会连接多个<code>unit</code>的输入，一个<code>unit</code>的<code>output</code>可能会连接多个<code>unit</code>的<code>input</code>。题目给出了给出了所有解析输入的函数，要求利用这些函数来解析输入的参数。</p></blockquote><p>解题思路如下：</p><ul><li>本题实际就是一个有向图的遍历的问题，我们将每个的<code>unit</code>都看作为图中一个特殊的节点。图中的不同的<code>unit</code>的输出与<code>unit</code>的输入的连接即可看作为两个节点之间的边。我们每次遇到系统不同的<code>input</code>输入时，则我们会对相连接的<code>unit</code>的进行运算，并将运算的结果向后传递给下一个<code>unit</code>，如果我们检查传递后的<code>unit</code>的所有的<code>input</code>的输入状态是否都是合法，如果合法，则我们进行该<code>unit</code>的运算，并将输出结果再继续向下一个节点进行传递，直到最终由系统的<code>output</code>有输出，此时我们打印出系统的输出即可。</li><li><p>系统中特别需要注意的一点是一个<code>unit</code>的某个<code>input</code>只能连接一个<code>unit</code>的输出,但是一个<code>unit</code>的输出<code>output</code>,可以连接到多个<code>unit</code>的输入端口<code>input</code>。此时我们就需要记载每个<code>unit</code>的输出<code>output</code>连接了哪些<code>unit</code>的<code>input</code>;但是我们不需要记载每个<code>unit</code>的输入连接了哪个<code>unit</code>的输出。每个<code>unit</code>定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*unit define*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unit</span>&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// unit name</span></span><br><span class="line">  UNIT_TYPE type;   <span class="comment">// unit type</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; valid; <span class="comment">// every input port state</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input;  <span class="comment">// every input value</span></span><br><span class="line">  <span class="keyword">int</span> output;         <span class="comment">// output</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;Edge&gt; out;   <span class="comment">// output link to the input of the next unit</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*edge link*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> us; <span class="comment">// the next unit name</span></span><br><span class="line">    <span class="keyword">int</span> in;         <span class="comment">// input port of the unit   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>同时我们需要对整个系统的<code>input</code>和<code>output</code>也做抽象成为特殊的<code>unit</code>，每个<code>input</code>端口表示为只有一个输入和输出的<code>unit</code>，它的运算即为输出等于输入，系统的<code>output</code>端口表示为只有一个输入和输出的<code>unit</code>，它的运算也为输出等于输入，这样我们即可把整个系统全部抽象为<code>unit</code>，不同的<code>input</code>进入时，相当于有向图中的部分节点的值向它的相邻节点进行值传递，我们依次即可计算出图中中所有的<code>unit</code>的输出，最终能够计算出系统的<code>output</code>.实际即是一个非常简单的<code>bfs</code>即可完成，时间复杂度也即为<code>O(n)</code>即可。按照这个思路很快就完成了代码的编写，不过期间<code>debug</code>花了不少时间才完成。</p><h2 id="2-准备电话面试"><a href="#2-准备电话面试" class="headerlink" title="2. 准备电话面试"></a>2. 准备电话面试</h2><p>笔试很快就完成了，然后就给<code>HR</code>发了<code>email</code>确认了笔试已经完成，后面<code>HR</code>告知<code>online assignment</code>已经通过了，就需要进入<code>second step</code>的<code>phone interview</code>了，并且明确告知需要用英文进行，想想自己刚刚过六级的水平，口语搓的一比，并且在体制内也不会有用口语的地方，那也只能硬着头皮硬上了。办法总比困难多，那就开始练习口语了，不过确实不太好练习，因为周围也没有几个口语特别好的；另一方面即使口语非常好的，但是也没有时间来陪我模拟面试，大家基本上都有家庭了。<br>我想办法总比困难多，这就需要发挥自己的主观能动性了，分别从四个方面着手来准备面试：</p></li><li>从该公司的官方网站上查找一下相关公司的信息，大概需要了解一下公司的<code>backgroud</code>和<code>interview detail</code>，<code>job description</code>,大概对公司的基本信息和招聘职位的信息做一下基本的了解，同时也在<code>linked in</code>上找了该公司的员工的部分个人背景简介和工作内容的详细介绍，以上这些都是对基本信息的搜集，能够快速的对公司的基本信息和职位信息做一个基本的了解。</li><li>从<code>youtube</code>上快速的找一些<code>software engineer interview tips</code>诸如此类的视频，以及一些部分<code>up</code>主的<code>online mock coding interview</code>的面试视频来学习观看，一方面通过这些视频的学习了解<code>phone technical interview</code>的基本流程，另一方面能够顺便对部分专有的专业英语术语能够熟悉下，毕竟<code>CS</code>专业的英语专业术语非常多，同时自己也在默默的模仿一下。</li><li>在网上找了一个口语较好的<code>师弟</code>来进行练习，大概练习了有两三次，可惜期间<code>师弟parterner</code>有事中途退场了，我只能自己找了，在网上搜了几个还不错的<code>APP</code>，都能够付费进行口语练习。第一次拨通跟老外进行口语练习，还是蛮紧张的，不过想想就是要脸皮厚点，不过大部分国外人还是非常热心的，反正大部分口语说错了，他们大概也能懂，并且跟其中一个叫<code>ALEX</code>的老外还混熟了，基本上都找他瞎聊，感觉蛮开心的。不过其中<code>HR</code>问我要了一份英文简历，我也只能硬着头皮把我那个本身就写的非常烂的简历又用<code>tex</code>重新弄了一份英文版本的，不过写作英语时，发现国外的<code>Grammarly</code>的软件真心好用，如果需要写书面英语的话强烈推荐。</li><li>其余就是针对<code>whitepaper coding</code>和<code>C++ concept detail</code>的学习了，这个是本次面试中最大的失误，太注重在线<code>coding</code>能力了，反而忽视了对<code>c++ basic concept</code>的学习了，在<code>binary search</code>平台上练习了大量的算法题，感觉如果是靠算法题的话，我基本上可以百分之九十的题目都能秒杀。不过也是因为干公务员太长时间了，没有过多去关注实际工程中需要应用的技术细节和语言的语法细节方面了，另一方面也确实没有多少可以实践的地方。虽然自己尝试在<code>hackrank</code>上面去练习<code>c++</code>的专题训练，同时通过网上的部分面经来学习一些常见的<code>C++</code>的问题了，这方面是此次面试的最大失误，毕竟实际工程中算法其实并没有那么重要，实际工程中可能更加关注技术细节和代码落地，比如最基本的现程同步之类的，结果就是在这些细节的<code>concept</code>上失败了。<h2 id="3-电话面试过程"><a href="#3-电话面试过程" class="headerlink" title="3. 电话面试过程"></a>3. 电话面试过程</h2>电话面试邮件通知的时间大概是在周五的下午四点钟，于是早早的提前周五下午请好假，回家打开电脑，打开<code>hackerRank</code>,因为之前<code>HR</code>通知是在<code>hackerRank</code>上面进行白板面试，所有的题目都会在<code>hackerRank codepair</code>上出现，早早打开<code>hr</code>通知的链接，然后等在电脑前，四点到了，发现怎么还没有电话进来，后来又等了<code>10</code>分钟，还米有电话进来，以为面试取消了，都准备去洗洗睡了。结果差不多到了<code>4</code>点<code>15</code>了，手机显示上海的陌生号码打过来了，接听后，一位很轻的小哥告诉我是本次的面试官，说抱歉刚才因为有会议所以才迟到了，耳测小哥年龄应该在25~30岁之间。<br>我以为会有简单的自我介绍或者基本的关于过往的项目经历的简介之类的，没想到面试官上来就说开始吧，然后就开始了一堆关于<code>C++</code>的基础知识的细节和系统基础知识的考问，感觉之前准备的部分<code>behavior problem</code>都白准备了。下面是对部分详细问题的描述<h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">what<span class="symbol">'s</span>  the difference <span class="keyword">of</span> stack memory <span class="keyword">and</span> heap memory ?</span><br></pre></td></tr></table></figure></li><li>这个问题用中文还是蛮简单，用英文确实有点麻烦了，就用用举例的方法简单说了一下。定义静态数组的空间都是使用栈内存的，每次进行函数调用的时候，也是需要将参数压入栈，利用<code>stackmachine</code>,实际上如果要利用栈空间，大都是由在编译阶段编译器会直接定义好栈空间的分配；定义动态数组时则使用的是<code>heap memory</code>,比如我们常见的<code>malloc</code>,<code>new</code>的操作，则是在<code>heap</code>中进行申请。目前的操作系统中，每一个线程都会分配一个独立的<code>stack</code>,<code>stack</code>的大小则可以由现程初始化时进行指定，而<code>heap</code>则是由操作系统统一进行管理，每次申请动态内存时，操作系统则会在空余的<code>heap</code>中分配一块，常见的<code>heap</code>分配的算法有<code>first fit</code>,<code>best fit</code>等常见的分配算法。<h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">what<span class="symbol">'s</span> the usage <span class="keyword">of</span> memory pool?</span><br></pre></td></tr></table></figure></li><li><code>memory pool</code>常用内作为缓存，由于我们需要一些缓存来存储一些关键信息，如果我们每次需要使用内存时，都直接用<code>malloc,new</code>之类得动态内存申请，必然会造成很大一部分时间得开销，因为在实际得操作系统中<code>malloc</code>之类得开销非常耗费时间得，因为我们可以在系统初始化化即申请一大块动态内存，然后后面如果需要用到存储时，则从这一大块<code>memory pool</code>中取出一小块即可，避免了系统过多次得<code>malloc</code>操作，从而造成系统不必要得开销。<h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C++ smart pointer:</span><br><span class="line">what<span class="symbol">'s</span> the difference <span class="keyword">of</span> unique_ptr <span class="keyword">and</span> shared_ptr?</span><br><span class="line">why we <span class="keyword">use</span> make_shared ?</span><br></pre></td></tr></table></figure></li><li>常见的C++智能指针得问题。<code>unique_ptr</code>和<code>shared_ptr</code>主要关注内部实现即可知道他们的内部的原理和不同，这个基本上可以通过阅读智能指针的源代码即可了解其中的不同。<h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++ <span class="keyword">template</span>:</span><br></pre></td></tr></table></figure></li><li>这个问题直接卒掉，C++的模板编程非常方便，这个也是C++的高级特性的一个核心，说实话已经很长时间没有用模板编程了，还是好好的去学习学习<code>haskell</code>之类的语言，好好的学习一下<code>lisp</code>之类的高级语言，或者学习学习<code>SCIP</code>从而对这些语言的高级特性能够一劳永逸的去解决。<h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">what<span class="symbol">'s</span> the useage <span class="keyword">of</span> conditional variables ?</span><br></pre></td></tr></table></figure></li><li>C++的<code>conditional variables</code>主要用来作为线程同步和并发。<h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> oriented question:</span><br><span class="line">c++ <span class="function"><span class="keyword">constructor</span> &amp; <span class="title">destructor</span>?</span></span><br><span class="line"><span class="function"><span class="title">c</span>++ <span class="title">Base</span> <span class="title">Object</span>?</span></span><br></pre></td></tr></table></figure></li><li>题目中定义了函数的构造函数和析构函数，但是并没有对函数进行构造函数和虚构函数进行实例化，最终会导致我们在进行初始化一个类的变量时，就会报错<code>undefined reference</code>。问了一个关于C++基类的问题，这个问题确实已经很长时间没有关注过C++基类的用法。<h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coding:</span><br><span class="line"><span class="built_in">write</span> <span class="keyword">a</span> <span class="keyword">string</span> <span class="built_in">split</span> <span class="function"><span class="keyword">function</span> <span class="title">using</span> <span class="title">c</span>++.</span></span><br></pre></td></tr></table></figure></li><li>给了一个超级简单的<code>coding</code>题目，就是用<code>c++</code>写出<code>split</code>函数，感觉可能面试官不想再继续面了，可能就随便给了一个题目打发人的意思。刚开始明显看他还准备问我<code>dynamic programming</code>的题目，后面可能发现对我不敢兴趣了，就想快点结束面试的意思。差不多不到2分钟就写出了一个无<code>bug</code>的代码，反正是非常的简单。<h2 id="4-面试总结"><a href="#4-面试总结" class="headerlink" title="4. 面试总结"></a>4. 面试总结</h2>总得来说面试得不是非常好，许多基础知识都忘记得差不多了，但是我觉得通过自己练习算法题，还是得到了不少的面试机会，至少这样能感受到自己的努力有一些回报。还是需要多加努力学习，因为我知道像我这种没有背景没有关系得人什么都需要靠自己，在这个社会上立足，只有越努力才能越自由。<br>努力挣扎，虽然中年人生活不易，但是一定不要放弃自己得努力，依次诫勉，来告诫一个不敢轻易松懈得中年人。俗话说，“君子不立于危墙之下”，如果自己对周围的环境不爽，那么要么尝试着去改变这个环境，要么就努力脱离这个让你变得糟糕得环境，不要一味的抱怨环境和抱怨人生，尽快让自己进入一个上升的正循环的通道。</li><li>下一步的计划，是需要对基础知识进行恶补，虽然<code>C++</code>的不是一门特别容易上手的语言，但是里面非常多的语言特性是非常值得学习的，还是自己的基础不够扎实。学习的书单目前基本如下：</li><li>《the little scheme》</li><li>《MIT SCIP》</li><li>《C++ 深度探索内存模型》</li><li>《C++ 模板元编程》</li><li>《C++ 多线程编程》</li><li>《C++ 智能指针的实现》</li><li>《C++ 对象池的实现》<h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;记一次失败的面试经历&quot;&gt;&lt;a href=&quot;#记一次失败的面试经历&quot; class=&quot;headerlink&quot; title=&quot;记一次失败的面试经历&quot;&gt;&lt;/a&gt;记一次失败的面试经历&lt;/h1&gt;&lt;p&gt;最近一直比较忙，每天忙于家里和工作，好久都没有时间来更新日志了，今天刚趁着有时间来好好更新一篇日志，主要想谈谈最近一直影响比较深刻的某外企的面试经历，虽然没有通过，但是我觉得把这段经历去复盘一下，总结其中的不足之处，也是对自己的一种成长，提醒自己在哪方面准备的还不足。&lt;/p&gt;&lt;h2 id=&quot;1-接到通知&quot;&gt;&lt;a href=&quot;#1-接到通知&quot; class=&quot;headerlink&quot; title=&quot;1. 接到通知&quot;&gt;&lt;/a&gt;1. 接到通知&lt;/h2&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="职场" scheme="http://yoursite.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly Contest 241</title>
    <link href="http://yoursite.com/2021/05/16/284/"/>
    <id>http://yoursite.com/2021/05/16/284/</id>
    <published>2021-05-16T05:18:56.989Z</published>
    <updated>2021-05-20T12:18:41.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-weekly-contest-241"><a href="#leetcode-weekly-contest-241" class="headerlink" title="leetcode  weekly contest 241"></a>leetcode  weekly contest 241</h1><p>最后一题也没有时间想了，还是三道题的节奏，前三题确实没啥难度的题目。<br><img src="https://i.loli.net/2021/05/16/f51inxEeqLoQ7TN.png" alt></p><h2 id="5759-找出所有子集的异或总和再求和"><a href="#5759-找出所有子集的异或总和再求和" class="headerlink" title="5759. 找出所有子集的异或总和再求和"></a>5759. 找出所有子集的异或总和再求和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个数组的 异或总和 定义为数组中所有元素按位 <code>XOR</code>的结果；如果数组为 空 ，则异或总和为 0 。</p><p>例如，数组 <code>[2,5,6]</code> 的 异或总和 为 <code>2 XOR 5 XOR 6 = 1</code> 。<br>给你一个数组 nums ，请你求出 <code>nums</code>中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p><a id="more"></a><p>注意：在本题中，元素 相同 的不同子集应 多次 计数。</p><p>数组 <code>a</code> 是数组 <code>b</code> 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">3</span>] 共有 <span class="number">4</span> 个子集：</span><br><span class="line">- 空子集的异或总和是 <span class="number">0</span> 。</span><br><span class="line">- [<span class="number">1</span>] 的异或总和为 <span class="number">1</span> 。</span><br><span class="line">- [<span class="number">3</span>] 的异或总和为 <span class="number">3</span> 。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">3</span>] 的异或总和为 <span class="number">1</span> XOR <span class="number">3</span> = <span class="number">2</span> 。</span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">2</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">解释：[<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>] 共有 <span class="number">8</span> 个子集：</span><br><span class="line">- 空子集的异或总和是 <span class="number">0</span> 。</span><br><span class="line">- [<span class="number">5</span>] 的异或总和为 <span class="number">5</span> 。</span><br><span class="line">- [<span class="number">1</span>] 的异或总和为 <span class="number">1</span> 。</span><br><span class="line">- [<span class="number">6</span>] 的异或总和为 <span class="number">6</span> 。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">1</span>] 的异或总和为 <span class="number">5</span> XOR <span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">6</span>] 的异或总和为 <span class="number">5</span> XOR <span class="number">6</span> = <span class="number">3</span> 。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">6</span>] 的异或总和为 <span class="number">1</span> XOR <span class="number">6</span> = <span class="number">7</span> 。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>] 的异或总和为 <span class="number">5</span> XOR <span class="number">1</span> XOR <span class="number">6</span> = <span class="number">2</span> 。</span><br><span class="line"><span class="number">0</span> + <span class="number">5</span> + <span class="number">1</span> + <span class="number">6</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">7</span> + <span class="number">2</span> = <span class="number">28</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">480</span></span><br><span class="line">解释：每个子集的全部异或总和值之和为 <span class="number">480</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 12</code></li><li><code>1 &lt;= nums[i] &lt;= 20</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力遍历所有子集即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>用二进制编码，遍历所有可能的子集即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i)&#123;</span><br><span class="line">                    curr = curr^nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5760-构成交替字符串需要的最小交换次数"><a href="#5760-构成交替字符串需要的最小交换次数" class="headerlink" title="5760. 构成交替字符串需要的最小交换次数"></a>5760. 构成交替字符串需要的最小交换次数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 <code>s</code>，现需要将其转化为一个 交替字符串 。请你计算并返回转化所需的 最小 字符交换次数，如果无法完成转化，返回 -1 。</p><p>交替字符串 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 <code>&quot;010&quot;</code> 和 <code>&quot;1010&quot;</code>属于交替字符串，但 <code>&quot;0100&quot;</code>不是。</p><p>任意两个字符都可以进行交换，不必相邻 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"111000"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：交换位置 <span class="number">1</span> 和 <span class="number">4</span>：<span class="string">"111000"</span> -&gt; <span class="string">"101010"</span> ，字符串变为交替字符串。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"010"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串已经是交替字符串了，不需要交换。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1110"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i] 的值为 &#39;0&#39; 或 &#39;1&#39;</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力统计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们判断是否可以交换构成交替，如果字符串的长度为偶数，则我们判断字符中<code>1</code>的个数和<code>0</code>的个数是否相等，如果不相等则不可能构成交替，直接返回<code>-1</code>;如果字符串的长度为奇数，则我们判断字符串中<code>1</code>的个数和<code>0</code>的个数的差的绝对值是否为<code>1</code>，如果不为<code>1</code>，则直接返回<code>-1</code>。</li><li>我们在可以满足交换的条件下，则去求最小的交换次数，如果为字符串的长度为偶数，则我们考虑是将奇数位全部置为<code>1</code>的代价最小还是将奇数位全部置为<code>0</code>的代价最小，此时我们可以求出奇数位中<code>0</code>的个数为$cnt0$，则此时最小的交换值应该为$min(cnt0,n/2-cnt0)$;如果字符串中<code>1</code>的个数大于<code>0</code>的个数，则此时我们考虑的是将奇数位中的<code>0</code>全部替换为<code>1</code>，此时应该返回$cnt0$；如果字符串中<code>0</code>的个数大于<code>1</code>的个数，则此时我们考虑的是将奇数位中的<code>1</code>全部替换为<code>0</code>，此时我们应该返回$(n+1)/2 - cnt0$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) zero++;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) one++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="built_in">abs</span>(one-zero)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) cnt0++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zero == one)&#123;</span><br><span class="line">            ans = min(cnt0,n/<span class="number">2</span>-cnt0);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(one &gt; zero)&#123;</span><br><span class="line">                ans = cnt0;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = (n+<span class="number">1</span>)/<span class="number">2</span> - cnt0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5761-找出和为指定值的下标对"><a href="#5761-找出和为指定值的下标对" class="headerlink" title="5761. 找出和为指定值的下标对"></a>5761. 找出和为指定值的下标对</h2><p>给你两个整数数组 nums1 和 nums2 ，请你实现一个支持下述两类查询的数据结构：</p><p>累加 ，将一个正整数加到 nums2 中指定下标对应元素上。<br>计数 ，统计满足 <code>nums1[i] + nums2[j]</code>等于指定值的下标对 <code>(i, j)</code>数目<code>（0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length）</code>。<br>实现 FindSumPairs 类：<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FindSumPairs(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) 使用整数数组 nums1 和 nums2 初始化 FindSumPairs 对象。</span><br><span class="line"><span class="type">void</span> <span class="keyword">add</span>(<span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> val) 将 val 加到 nums2[<span class="keyword">index</span>] 上，即，执行 nums2[<span class="keyword">index</span>] += val 。</span><br><span class="line"><span class="type">int</span> count(<span class="type">int</span> tot) 返回满足 nums1[i] + nums2[j] == tot 的下标对 (i, j) 数目。</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"FindSumPairs"</span>, <span class="string">"count"</span>, <span class="string">"add"</span>, <span class="string">"count"</span>, <span class="string">"count"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"count"</span>]</span><br><span class="line">[[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]], [<span class="number">7</span>], [<span class="number">3</span>, <span class="number">2</span>], [<span class="number">8</span>], [<span class="number">4</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">7</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">8</span>, null, <span class="number">2</span>, <span class="number">1</span>, null, null, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">FindSumPairs findSumPairs = new FindSumPairs([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]);</span><br><span class="line">findSumPairs.count(<span class="number">7</span>);  <span class="comment">// 返回 8 ; 下标对 (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) 满足 2 + 5 = 7 ，下标对 (5,1), (5,5) 满足 3 + 4 = 7</span></span><br><span class="line">findSumPairs.add(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 此时 nums2 = [1,4,5,4,5,4]</span></span><br><span class="line">findSumPairs.count(<span class="number">8</span>);  <span class="comment">// 返回 2 ；下标对 (5,2), (5,4) 满足 3 + 5 = 8</span></span><br><span class="line">findSumPairs.count(<span class="number">4</span>);  <span class="comment">// 返回 1 ；下标对 (5,0) 满足 3 + 1 = 4</span></span><br><span class="line">findSumPairs.add(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 此时 nums2 = [2,4,5,4,5,4]</span></span><br><span class="line">findSumPairs.add(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 此时 nums2 = [2,5,5,4,5,4]</span></span><br><span class="line">findSumPairs.count(<span class="number">7</span>);  <span class="comment">// 返回 11 ；下标对 (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) 满足 2 + 5 = 7 ，下标对 (5,3), (5,5) 满足 3 + 4 = 7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length &lt;= 1000</code></li><li><code>1 &lt;= nums2.length &lt;= 105</code></li><li><code>1 &lt;= nums1[i] &lt;= 109</code></li><li><code>1 &lt;= nums2[i] &lt;= 105</code></li><li><code>0 &lt;= index &lt; nums2.length</code></li><li><code>1 &lt;= val &lt;= 105</code></li><li><code>1 &lt;= tot &lt;= 109</code></li><li>最多调用 <code>add</code>和 <code>count</code> 函数各 <code>1000</code>次</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-pairs-with-a-certain-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-pairs-with-a-certain-sum</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接模拟 + hash</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目的关键在于看到一个点，<code>nums1</code>的长度为<code>1000</code>以下，此时我们即可使用暴力<code>hash</code>.每次用<code>hash table</code>统计<code>nums2</code>数组中每个元素的个数，每次进行查询下，我们遍历<code>nums1</code>中的所有元素，然后在<code>hashtable</code>中查询$tot-nums1[i]$的个数，就是暴力<code>hash</code>即可，不需要用任何技巧。</li><li>每次对<code>nums2</code>中的元素进行更新时，我们直接更新<code>hash table</code>即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindSumPairs</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FindSumPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        arr1 = nums1;</span><br><span class="line">        arr2 = nums2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.size(); ++i) cnt[nums2[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cnt[arr2[index]]--;</span><br><span class="line">        arr2[index] += val;</span><br><span class="line">        cnt[arr2[index]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(tot-arr1[i]))&#123;</span><br><span class="line">                ans += cnt[tot-arr1[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindSumPairs object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindSumPairs* obj = new FindSumPairs(nums1, nums2);</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;count(tot);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5762-恰有-K-根木棍可以看到的排列数目"><a href="#5762-恰有-K-根木棍可以看到的排列数目" class="headerlink" title="5762. 恰有 K 根木棍可以看到的排列数目"></a>5762. 恰有 K 根木棍可以看到的排列数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有 n 根长度互不相同的木棍，长度为从 <code>1</code> 到 <code>n</code>的整数。请你将这些木棍排成一排，并满足从左侧 可以看到 恰好<code>k</code> 根木棍。从左侧 可以看到 木棍的前提是这个木棍的 左侧 不存在比它 更长的 木棍。</p><ul><li>例如，如果木棍排列为 <code>[1,3,2,5,4]</code>，那么从左侧可以看到的就是长度分别为 <code>1、3 、5</code>的木棍。<br>给你 <code>n</code> 和 <code>k</code> ，返回符合题目要求的排列 数目 。由于答案可能很大，请返回对 <code>109 + 7</code> 取余 的结果。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 和 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 是仅有的能满足恰好 <span class="number">2</span> 根木棍可以看到的排列。</span><br><span class="line">可以看到的木棍已经用粗体+斜体标识。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 是唯一一种能满足全部 <span class="number">5</span> 根木棍可以看到的排列。</span><br><span class="line">可以看到的木棍已经用粗体+斜体标识。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">20</span>, k = <span class="number">11</span></span><br><span class="line">输出：<span class="number">647427950</span></span><br><span class="line">解释：总共有 <span class="number">647427950</span> (mod <span class="number">109</span> + <span class="number">7</span>) 种能满足恰好有 <span class="number">11</span> 根木棍可以看到的排列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目的动态规划有点意思，因为一直想着从小往大进行增长元素，却发现很难推出递推公式。我们设<code>dp[i][j]</code>表示从后<code>i</code>个元素$[n-i+1,n-i+2,n-i+3,…,n]$中选出组成能够看到<code>j</code>个棍子的方案数目。此时我们如果假如一个更小的元素$n-i$，如果我们将$[n-i]$放在序列中的第一个元素，则此时我们再从$[n-i+1,n-i+2,n-i+3,…,n]$选出<code>j-1</code>个元素，满足能够看到<code>j-1</code>个棍子即可，因为此时$n-i$为序列中的最小元素，$n-i$一定会被看到，则此时:<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1]</script>如果我们第一个元素不为$n-i$,则我们可以将$n-i$放到后面的<code>i-1</code>个元素中的任意一个元素后面，它都不可见，则此时的方案数应该为:<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j]*(i-1)</script>综上我们可以得到如下推论:<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1] + dp[i-1][j]*(i-1)</script></li><li>仔细查了以下考斯林数的定义，基本上就是等于第一类斯特林数的推论应用，可以直接看到该公式是利用数学归纳法来证明出来的。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rearrangeSticks</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]*(i<span class="number">-1</span>))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-weekly-contest-241&quot;&gt;&lt;a href=&quot;#leetcode-weekly-contest-241&quot; class=&quot;headerlink&quot; title=&quot;leetcode  weekly contest 241&quot;&gt;&lt;/a&gt;leetcode  weekly contest 241&lt;/h1&gt;&lt;p&gt;最后一题也没有时间想了，还是三道题的节奏，前三题确实没啥难度的题目。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/05/16/f51inxEeqLoQ7TN.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5759-找出所有子集的异或总和再求和&quot;&gt;&lt;a href=&quot;#5759-找出所有子集的异或总和再求和&quot; class=&quot;headerlink&quot; title=&quot;5759. 找出所有子集的异或总和再求和&quot;&gt;&lt;/a&gt;5759. 找出所有子集的异或总和再求和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个数组的 异或总和 定义为数组中所有元素按位 &lt;code&gt;XOR&lt;/code&gt;的结果；如果数组为 空 ，则异或总和为 0 。&lt;/p&gt;&lt;p&gt;例如，数组 &lt;code&gt;[2,5,6]&lt;/code&gt; 的 异或总和 为 &lt;code&gt;2 XOR 5 XOR 6 = 1&lt;/code&gt; 。&lt;br&gt;给你一个数组 nums ，请你求出 &lt;code&gt;nums&lt;/code&gt;中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 52</title>
    <link href="http://yoursite.com/2021/05/15/283/"/>
    <id>http://yoursite.com/2021/05/15/283/</id>
    <published>2021-05-15T15:47:09.226Z</published>
    <updated>2021-05-22T12:58:15.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-52"><a href="#leetcode-biweekly-contest-52" class="headerlink" title="leetcode  biweekly contest 52"></a>leetcode  biweekly contest 52</h1><p>最近周赛题目质量越来越不稳定了，最后一题就是稍微麻烦一点的数学题目。<br><img src="https://i.loli.net/2021/05/16/TQS2JViKeLsdtoI.png" alt></p><h2 id="5742-将句子排序"><a href="#5742-将句子排序" class="headerlink" title="5742. 将句子排序"></a>5742. 将句子排序</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个 句子 指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。<br>我们可以给一个句子添加 从 1 开始的单词位置索引 ，并且将句子中所有单词 打乱顺序 。<br>比方说，句子 <code>&quot;This is a sentence&quot;</code> 可以被打乱顺序得到<code>&quot;sentence4 a3 is2 This1&quot; 或者 &quot;is2 sentence4 This1 a3&quot;</code> 。<br>给你一个 打乱顺序 的句子 s ，它包含的单词不超过 9 个，请你重新构造并得到原本顺序的句子。</p><a id="more"></a><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"is2 sentence4 This1 a3"</span></span><br><span class="line">输出：<span class="string">"This is a sentence"</span></span><br><span class="line">解释：将 s 中的单词按照初始位置排序，得到 <span class="string">"This1 is2 a3 sentence4"</span> ，然后删除数字。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"Myself2 Me1 I4 and3"</span></span><br><span class="line">输出：<span class="string">"Me Myself and I"</span></span><br><span class="line">解释：将 s 中的单词按照初始位置排序，得到 <span class="string">"Me1 Myself2 and3 I4"</span> ，然后删除数字。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= s.length &lt;= <span class="number">200</span>`</span><br><span class="line">+ s 只包含小写和大写英文字母、空格以及从 <span class="number">1</span> 到 <span class="number">9</span> 的数字。</span><br><span class="line">+ s 中单词数目为 <span class="number">1</span> 到 <span class="number">9</span> 个。</span><br><span class="line">+ s 中的单词由单个空格分隔。</span><br><span class="line">+ s 不包含任何前导或者后缀空格。</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/sorting-the-sentence</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力拆分排序</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 先将每个单词拆分出来，然后按照序号进行排序即可。排序完成后，再进行恢复即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s,char c)&#123;</span><br><span class="line">        <span class="built_in">int</span> len = s.size();</span><br><span class="line">        <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len;)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len &amp;&amp; s[i] == c) i++;</span><br><span class="line">            <span class="built_in">int</span> curr = i;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len &amp;&amp; s[i] != c) i++;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; len) ans.push_back(s.substr(curr,i-curr));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> sortSentence(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        vector&lt;<span class="built_in">string</span>&gt; words = split(s,<span class="string">' '</span>);</span><br><span class="line">        sort(words.begin(),words.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">string</span> &amp; a, <span class="keyword">const</span> <span class="built_in">string</span> &amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.back() &lt; b.back();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; words.size() - <span class="number">1</span>)&#123;</span><br><span class="line">                ans += words[i].substr(<span class="number">0</span>,words[i].size()<span class="number">-1</span>) + <span class="string">" "</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += words[i].substr(<span class="number">0</span>,words[i].size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5743-增长的内存泄露"><a href="#5743-增长的内存泄露" class="headerlink" title="5743. 增长的内存泄露"></a>5743. 增长的内存泄露</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数 <code>memory1</code> 和 <code>memory2</code>分别表示两个内存条剩余可用内存的位数。现在有一个程序每秒递增的速度消耗着内存。</p><p>在第 <code>i</code> 秒（秒数从 1 开始），有 <code>i</code> 位内存被分配到 剩余内存较多 的内存条（如果两者一样多，则分配到第一个内存条）。如果两者剩余内存都不足 <code>i</code>位，那么程序将 意外退出 。</p><p>请你返回一个数组，包含 <code>[crashTime, memory1crash, memory2crash]</code> ，其中 crashTime是程序意外退出的时间（单位为秒）， <code>memory1crash</code> 和 <code>memory2crash</code>分别是两个内存条最后剩余内存的位数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：memory1 = <span class="number">2</span>, memory2 = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">解释：内存分配如下：</span><br><span class="line">- 第 <span class="number">1</span> 秒，内存条 <span class="number">1</span> 被占用 <span class="number">1</span> 位内存。内存条 <span class="number">1</span> 现在有 <span class="number">1</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">2</span> 秒，内存条 <span class="number">2</span> 被占用 <span class="number">2</span> 位内存。内存条 <span class="number">2</span> 现在有 <span class="number">0</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">3</span> 秒，程序意外退出，两个内存条分别有 <span class="number">1</span> 位和 <span class="number">0</span> 位剩余可用内存。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：memory1 = <span class="number">8</span>, memory2 = <span class="number">11</span></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">解释：内存分配如下：</span><br><span class="line">- 第 <span class="number">1</span> 秒，内存条 <span class="number">2</span> 被占用 <span class="number">1</span> 位内存，内存条 <span class="number">2</span> 现在有 <span class="number">10</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">2</span> 秒，内存条 <span class="number">2</span> 被占用 <span class="number">2</span> 位内存，内存条 <span class="number">2</span> 现在有 <span class="number">8</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">3</span> 秒，内存条 <span class="number">1</span> 被占用 <span class="number">3</span> 位内存，内存条 <span class="number">1</span> 现在有 <span class="number">5</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">4</span> 秒，内存条 <span class="number">2</span> 被占用 <span class="number">4</span> 位内存，内存条 <span class="number">2</span> 现在有 <span class="number">4</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">5</span> 秒，内存条 <span class="number">1</span> 被占用 <span class="number">5</span> 位内存，内存条 <span class="number">1</span> 现在有 <span class="number">0</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">6</span> 秒，程序意外退出，两个内存条分别有 <span class="number">0</span> 位和 <span class="number">4</span> 位剩余可用内存。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>0 &lt;= memory1, memory2 &lt;= 231 - 1</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/incremental-memory-leak" target="_blank" rel="noopener">https://leetcode-cn.com/problems/incremental-memory-leak</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接模拟即可满足题目要求，因为时间复杂度约为$O(lg(m+n))$,所有的都在时间的允许范围内。</li><li>我们直到最大的可能开销约为$\frac{k*(k+1)}{2} \le (m+n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memLeak(<span class="keyword">int</span> memory1, <span class="keyword">int</span> memory2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr &lt;= memory1 || curr &lt;= memory2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(memory1 &gt;= memory2)&#123;</span><br><span class="line">                memory1 -= curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                memory2 -= curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;curr,memory1,memory2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5744-旋转盒子"><a href="#5744-旋转盒子" class="headerlink" title="5744. 旋转盒子"></a>5744. 旋转盒子</h2><p>给你一个 <code>m x n</code> 的字符矩阵 <code>box</code>，它表示一个箱子的侧视图。箱子的每一个格子可能为：</p><ul><li><code>&#39;#&#39;</code> 表示石头</li><li><code>&#39;*&#39;</code> 表示固定的障碍物</li><li><code>&#39;.&#39;</code> 表示空位置<br>这个箱子被 顺时针旋转 90 度 ，由于重力原因，部分石头的位置会发生改变。每个石头会垂直掉落，直到它遇到障碍物，另一个石头或者箱子的底部。重力 不会 影响障碍物的位置，同时箱子旋转不会产生惯性 ，也就是说石头的水平位置不会发生改变。</li></ul><p>题目保证初始时 <code>box</code> 中的石头要么在一个障碍物上，要么在另一个石头上，要么在箱子的底部。</p><p>请你返回一个 <code>n x m</code>的矩阵，表示按照上述旋转后，箱子内的结果。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：box = [[<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"#"</span>]]</span><br><span class="line">输出：[[<span class="string">"."</span>],</span><br><span class="line">      [<span class="string">"#"</span>],</span><br><span class="line">      [<span class="string">"#"</span>]]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：box = [[<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"*"</span>,<span class="string">"."</span>],</span><br><span class="line">            [<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"*"</span>,<span class="string">"."</span>]]</span><br><span class="line">输出：[[<span class="string">"#"</span>,<span class="string">"."</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"#"</span>],</span><br><span class="line">      [<span class="string">"*"</span>,<span class="string">"*"</span>],</span><br><span class="line">      [<span class="string">"."</span>,<span class="string">"."</span>]]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：box = [[<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"*"</span>,<span class="string">"."</span>,<span class="string">"*"</span>,<span class="string">"."</span>],</span><br><span class="line">            [<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"*"</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">            [<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"#"</span>,<span class="string">"."</span>]]</span><br><span class="line">输出：[[<span class="string">"."</span>,<span class="string">"#"</span>,<span class="string">"#"</span>],</span><br><span class="line">      [<span class="string">"."</span>,<span class="string">"#"</span>,<span class="string">"#"</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"*"</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"*"</span>,<span class="string">"."</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"*"</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"."</span>]]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == box.length</code></li><li><code>n == box[i].length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>box[i][j]</code>只可能是 ‘#’ ，’*’ 或者 ‘.’ 。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/rotating-the-box" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotating-the-box</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接模拟</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接找到下一个可能的存放的单元格，然后将石头放入到此单元格，直接模拟即可，利用双指针，一个指针指向当前的单元格，另一个指针指向可以存放的单元格，每次进行尝试即可，感觉算是一个简单的题目。时间复杂度为$O(m*n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; rotateTheBox(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; box) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = box.size();</span><br><span class="line">        <span class="keyword">int</span> col = box[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; ans(col,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(row));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = col<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(box[i][j] == <span class="string">'#'</span>)&#123;</span><br><span class="line">                    box[i][curr] = <span class="string">'#'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(curr != j) box[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                    curr--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(box[i][j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    curr = j - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                ans[i][j] = box[row<span class="number">-1</span>-j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5212-向下取整数对和"><a href="#5212-向下取整数对和" class="headerlink" title="5212. 向下取整数对和"></a>5212. 向下取整数对和</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，请你返回所有下标对 <code>0 &lt;= i, j &lt; nums.length</code> 的 <code>floor(nums[i] / nums[j])</code> 结果之和。由于答案可能会很大，请你返回答案对<code>109 + 7</code>取余 的结果。<br>函数 <code>floor()</code>返回输入数字的整数部分。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：</span><br><span class="line">floor(<span class="number">2</span> / <span class="number">5</span>) = floor(<span class="number">2</span> / <span class="number">9</span>) = floor(<span class="number">5</span> / <span class="number">9</span>) = <span class="number">0</span></span><br><span class="line">floor(<span class="number">2</span> / <span class="number">2</span>) = floor(<span class="number">5</span> / <span class="number">5</span>) = floor(<span class="number">9</span> / <span class="number">9</span>) = <span class="number">1</span></span><br><span class="line">floor(<span class="number">5</span> / <span class="number">2</span>) = <span class="number">2</span></span><br><span class="line">floor(<span class="number">9</span> / <span class="number">2</span>) = <span class="number">4</span></span><br><span class="line">floor(<span class="number">9</span> / <span class="number">5</span>) = <span class="number">1</span></span><br><span class="line">我们计算每一个数对商向下取整的结果并求和得到 <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/sum-of-floored-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-floored-pairs</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 素数筛查法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote></li></ul><ol><li>我们首先利用前缀和统计元素个数，比如$sum(n)$则表示当前小于等于<code>n</code>的元素的个数，然后我们就可以很快的利用前缀和求出区间$[i,j]$之间的元素的个数,$cnt(i,j) = sum[j] - sum[i-1]$.</li><li>我们依次枚举每个元素<code>x</code>的倍数，比如枚举如下:<script type="math/tex; mode=display">[x,2x,3x,4x,....,nx]</script>则我们很容易的知道处在区间$[ax,(a+1)x-1]$的数对于<code>x</code>取<code>floor</code>的结果为$a$,则我们依次枚举所有可能的区间即可。在处在区间$[ax,(a+1)x-1]$的数对<code>a</code>求<code>floor</code>的值为$a$.</li><li>感觉这个题目就是类似于素数筛查的方法，时间复杂度接近于<code>n</code>倍的调和级数，已经知道结论如下：<script type="math/tex; mode=display">1+1/2+1/3+1/4+...1/n = ln(n+1) + r</script>则本题的算法复杂度约为$n\sum_{i=1}^n\frac{1}{i}$,时间复杂度近似于$nlgn$.</li><li>比较坑爹得是，平台中的测试用例变换了，所以之前的代码可能有问题，特别是对于数组中所有元素都为<code>1</code>的情况下，此时则代码就会出现超时的问题，所以还是将代码进行了更新，本质的方法是一样的，不过是不是枚举数组中的元素，而是枚举数组中所有元素的最大值。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfFlooredPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxNum = *max_element(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; freq(maxNum+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(maxNum+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) freq[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; freq.size(); ++i) sum[i] = sum[i<span class="number">-1</span>] + freq[i]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxNum; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(freq[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j*i &lt;= maxNum; ++j)&#123;</span><br><span class="line">                ans = (ans + (<span class="keyword">long</span> <span class="keyword">long</span>)freq[i]*j*(sum[min(maxNum,(j+<span class="number">1</span>)*i<span class="number">-1</span>)] - sum[j*i<span class="number">-1</span>]))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-52&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-52&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 52&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 52&lt;/h1&gt;&lt;p&gt;最近周赛题目质量越来越不稳定了，最后一题就是稍微麻烦一点的数学题目。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/05/16/TQS2JViKeLsdtoI.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5742-将句子排序&quot;&gt;&lt;a href=&quot;#5742-将句子排序&quot; class=&quot;headerlink&quot; title=&quot;5742. 将句子排序&quot;&gt;&lt;/a&gt;5742. 将句子排序&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个 句子 指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。&lt;br&gt;我们可以给一个句子添加 从 1 开始的单词位置索引 ，并且将句子中所有单词 打乱顺序 。&lt;br&gt;比方说，句子 &lt;code&gt;&amp;quot;This is a sentence&amp;quot;&lt;/code&gt; 可以被打乱顺序得到&lt;code&gt;&amp;quot;sentence4 a3 is2 This1&amp;quot; 或者 &amp;quot;is2 sentence4 This1 a3&amp;quot;&lt;/code&gt; 。&lt;br&gt;给你一个 打乱顺序 的句子 s ，它包含的单词不超过 9 个，请你重新构造并得到原本顺序的句子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 二叉树的非递归遍历</title>
    <link href="http://yoursite.com/2021/05/11/282/"/>
    <id>http://yoursite.com/2021/05/11/282/</id>
    <published>2021-05-11T13:13:00.092Z</published>
    <updated>2021-05-15T15:01:20.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binary-tree-非递归遍历"><a href="#binary-tree-非递归遍历" class="headerlink" title="binary tree 非递归遍历"></a>binary tree 非递归遍历</h1><p>最近在练习题目的时候经常遇到二叉树的非递归遍历，感觉有许多非常有意思和思考的题目，其中二叉树的几个非递归遍历的几个小的观点。</p><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><ol><li><code>preorder traverse</code>：对于递归来说非常容易处理，我们先访问根节点，然后访问左子树，再次访问右子树，所以如果利用栈的话，则我们先将右子树入栈，然后再将左子树入栈，然后访问根节点。对于递归来说访问的核心代码为:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visit(root);</span><br><span class="line">dfs(root-&gt;left);</span><br><span class="line">dfs(root-&gt;right);</span><br></pre></td></tr></table></figure>源代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode * &gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode * node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            ans.emplace_back(node-&gt;val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)  st.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>inorder traverse</code>: 对于中序遍历则麻烦许多，首先我们会访问根节点的左子树，直到没有左子数节点时，则从栈中弹出一个数据，并进行访问，然后将其右子树节点压入到栈中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">        TreeNode * node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node||!st.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(node)&#123;</span><br><span class="line">                    st.push(node);</span><br><span class="line">                    node = node-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    ans.emplace_back(node-&gt;val);</span><br><span class="line">                    node = node-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>postorder traverse</code>: 后续遍历感觉最难搞了，需要两个栈来配合才能完成，感觉还是偏难的题目。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; st1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; st2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        TreeNode * node = root;</span><br><span class="line"></span><br><span class="line">        st1.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st1.empty())&#123;</span><br><span class="line">            TreeNode * node = st1.top();</span><br><span class="line">            st1.pop();</span><br><span class="line">            st2.push(node);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                st1.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                st1.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st2.empty())&#123;</span><br><span class="line">            ans.push_back(st2.top()-&gt;val);</span><br><span class="line">            st2.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;binary-tree-非递归遍历&quot;&gt;&lt;a href=&quot;#binary-tree-非递归遍历&quot; class=&quot;headerlink&quot; title=&quot;binary tree 非递归遍历&quot;&gt;&lt;/a&gt;binary tree 非递归遍历&lt;/h1&gt;&lt;p&gt;最近在练习题目的时候经常遇到二叉树的非递归遍历，感觉有许多非常有意思和思考的题目，其中二叉树的几个非递归遍历的几个小的观点。&lt;/p&gt;&lt;h2 id=&quot;非递归遍历&quot;&gt;&lt;a href=&quot;#非递归遍历&quot; class=&quot;headerlink&quot; title=&quot;非递归遍历&quot;&gt;&lt;/a&gt;非递归遍历&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;preorder traverse&lt;/code&gt;：对于递归来说非常容易处理，我们先访问根节点，然后访问左子树，再次访问右子树，所以如果利用栈的话，则我们先将右子树入栈，然后再将左子树入栈，然后访问根节点。对于递归来说访问的核心代码为:&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;visit(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dfs(root-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dfs(root-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
源代码：&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct TreeNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *left;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *right;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode() : val(0), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; preorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;TreeNode * &amp;gt; st;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!root) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        st.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!st.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            TreeNode * node = st.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            st.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans.emplace_back(node-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node-&amp;gt;right) st.push(node-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node-&amp;gt;left)  st.push(node-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inorder traverse&lt;/code&gt;: 对于中序遍历则麻烦许多，首先我们会访问根节点的左子树，直到没有左子数节点时，则从栈中弹出一个数据，并进行访问，然后将其右子树节点压入到栈中。&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct TreeNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *left;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *right;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode() : val(0), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; inorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;TreeNode *&amp;gt; st;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TreeNode * node = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(node||!st.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    st.push(node);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    node = node-&amp;gt;left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    node = st.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    st.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    ans.emplace_back(node-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    node = node-&amp;gt;right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postorder traverse&lt;/code&gt;: 后续遍历感觉最难搞了，需要两个栈来配合才能完成，感觉还是偏难的题目。&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct TreeNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *left;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *right;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode() : val(0), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; postorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;TreeNode *&amp;gt; st1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;TreeNode *&amp;gt; st2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!root) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TreeNode * node = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        st1.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!st1.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            TreeNode * node = st1.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            st1.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            st2.push(node);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node-&amp;gt;left)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                st1.push(node-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node-&amp;gt;right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                st1.push(node-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!st2.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans.push_back(st2.top()-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            st2.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 Mono Stack</title>
    <link href="http://yoursite.com/2021/05/11/281/"/>
    <id>http://yoursite.com/2021/05/11/281/</id>
    <published>2021-05-11T12:49:12.496Z</published>
    <updated>2021-05-11T13:56:36.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mono-stack"><a href="#mono-stack" class="headerlink" title="mono stack"></a>mono stack</h1><p>最近在练习题目的时候经常遇到<code>mono stack</code>的题目，总的来说题目还是非常非常的有意思，单调栈真心是个利器。可以解决非常多的复杂的问题。可以利用单调栈求出以当前值为最大值或者最小值的连续子数组的最大长度。</p><h2 id="单调栈的原理"><a href="#单调栈的原理" class="headerlink" title="单调栈的原理"></a>单调栈的原理</h2><p>单调栈中的数据需要遵循两个原则：</p><ul><li>栈中的数据会是严格递增或者递减，则我们可以知道，假如单调栈中的数据为递减，则可以知道栈顶的数据一定为当前序列中最大的数据;假如单调栈中的数据为递增，则可以知道栈顶的数据一定为当前序列中最小的数据。一般情况下我们都会用<code>dequeue</code>来处理单调栈的数据，则可以知道队列的头部一定为当前序列中所求的最大值或者最小值。</li><li>为了保持单调性，则每当加入一个新的元素时，则会将栈中所有比当前元素小或者大的数据全部进行出栈，则由此我们可以判断如下，假设当前的栈为递减：<br><img src="https://i.loli.net/2021/05/11/xJKB3lbXmrjCZ6q.png" alt="1"><br>从图中可以看出我们可以在$O(1)$的时间复杂度内求出当前序列的极值。栈中任意相邻的两个元素比如$(arr[i],arr[j])$,则表示所有处于$(i,j)$之间的元素均小于$arr[j]$,有了这个重要的推论，则许多问题都可以利用这个特性来求解，比如我们知道假设某个元素<code>x</code>大于$arr[j]$,则表示<code>x</code>一定大于所有位于$[i+1,j]$之间的元素。下面有几个非常有代表性的题目需要讨论下：</li></ul><a id="more"></a><ol><li><a href="https://www.hackerrank.com/challenges/deque-stl/problem" target="_blank" rel="noopener">找到子数组长度为k的最大值</a></li><li><a href="https://binarysearch.com/problems/Longest-Sublist-with-Value-Range-Condition" target="_blank" rel="noopener">Longest Sublist with Value Range Condition</a></li><li><a href="https://leetcode-cn.com/problems/maximum-subarray-min-product/" target="_blank" rel="noopener">子数组最小乘积的最大值</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">下一个更大元素 I</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">下一个更大元素 II</a></li></ol><h2 id="下一个更大元素-II"><a href="#下一个更大元素-II" class="headerlink" title="下一个更大元素 II"></a>下一个更大元素 II</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-ii</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  classical problem</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>首先题目中要求循环处理，这个很简单我们只需要在数组后面对数组本身再进行重复复制一遍即可，这样我们即可完成循环处理。</li><li>最经典的处理莫过于如何求第一个比其小或者大的数的处理，我们利用单调栈，所有小于当前的数全部从栈中弹出，因为我们知道一个推论为，栈中任意相邻的两个元素比如$(arr[i],arr[j])$,则表示所有处于$(i,j)$之间的元素均小于$arr[j]$,此时我们即可利用单调性很快求出所有的值。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            nums.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dq.back() &lt; n)&#123;</span><br><span class="line">                    ans[dq.back()] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Longest-Sublist-with-Value-Range-Condition"><a href="#Longest-Sublist-with-Value-Range-Condition" class="headerlink" title="Longest Sublist with Value Range Condition"></a>Longest Sublist with Value Range Condition</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a list of integers nums, return the length of the longest sublist where 2 * min(sublist) &gt; max(sublist).</p><p>Constraints</p><p>n ≤ 100,000 where n is the length of nums<br>Example 1<br>Input<br>nums = [9, 1, 5, 5, 3, 3]<br>Output<br>4<br>Explanation<br>The sublist [5, 5, 3, 3] is the longest sublist that meet the criteria since 2 * 3 &gt; 5.</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://binarysearch.com/problems/Longest-Sublist-with-Value-Range-Condition" target="_blank" rel="noopener">https://binarysearch.com/problems/Longest-Sublist-with-Value-Range-Condition</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  双指针加单调栈</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目更加经典，需要同时利用单调栈和双指针。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; minq;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxq;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">// we remove all the element is more than nums[i]</span></span><br><span class="line">        <span class="keyword">while</span>(!minq.empty() &amp;&amp; nums[minq.back()] &gt; nums[i]) minq.pop_back();</span><br><span class="line">        minq.push_back(i);</span><br><span class="line">        <span class="comment">// we remove all the element is less than nums[i]</span></span><br><span class="line">        <span class="keyword">while</span>(!maxq.empty() &amp;&amp; nums[maxq.back()] &lt; nums[i]) maxq.pop_back();</span><br><span class="line">        maxq.push_back(i);</span><br><span class="line">        <span class="keyword">while</span>(!minq.empty() &amp;&amp; !maxq.empty() &amp;&amp; nums[maxq.front()] &gt;= <span class="number">2</span>*nums[minq.front()])&#123;</span><br><span class="line">            <span class="keyword">while</span>(!minq.empty() &amp;&amp; minq.front() &lt;= j) minq.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!maxq.empty() &amp;&amp; maxq.front() &lt;= j) maxq.pop_front();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="qiu"><a href="#qiu" class="headerlink" title="qiu"></a>qiu</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given a set of arrays of size  and an integer , you have to find the maximum integer for each and every contiguous subarray of size  for each of the given arrays.<br>nput Format</p><p>First line of input will contain the number of test cases T. For each test case, you will be given the size of array N and the size of subarray to be used K. This will be followed by the elements of the array Ai.</p><p>Constraints, where  is the  element in the array .</p><p>Output Format</p><p>For each of the contiguous subarrays of size  of each array, you have to print the maximum integer.</p><p>Sample Input<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">6</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">1</span> <span class="number">4</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><br>Sample Output<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">6</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">8</span> <span class="number">8</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.hackerrank.com/challenges/deque-stl/problem" target="_blank" rel="noopener">https://www.hackerrank.com/challenges/deque-stl/problem</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  单调栈 + 滑动窗口</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目更加经典，需要同时利用单调栈和双指针。利用单调性，单调栈中的栈头一定保存的是当前序列的最大值。同时利用滑动窗口，一旦窗口超过队头的元素，则将队头的元素进行删除即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printKMax</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty() &amp;&amp; arr[i] &gt; arr[dq.back()])&#123;</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.push_back(i);</span><br><span class="line">        <span class="keyword">while</span>((i-j+<span class="number">1</span>) &gt; k)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front() &lt;= j) dq.pop_front();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[dq.front()]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    printKMax(arr, n, k);</span><br><span class="line">    t--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mono-stack&quot;&gt;&lt;a href=&quot;#mono-stack&quot; class=&quot;headerlink&quot; title=&quot;mono stack&quot;&gt;&lt;/a&gt;mono stack&lt;/h1&gt;&lt;p&gt;最近在练习题目的时候经常遇到&lt;code&gt;mono stack&lt;/code&gt;的题目，总的来说题目还是非常非常的有意思，单调栈真心是个利器。可以解决非常多的复杂的问题。可以利用单调栈求出以当前值为最大值或者最小值的连续子数组的最大长度。&lt;/p&gt;&lt;h2 id=&quot;单调栈的原理&quot;&gt;&lt;a href=&quot;#单调栈的原理&quot; class=&quot;headerlink&quot; title=&quot;单调栈的原理&quot;&gt;&lt;/a&gt;单调栈的原理&lt;/h2&gt;&lt;p&gt;单调栈中的数据需要遵循两个原则：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;栈中的数据会是严格递增或者递减，则我们可以知道，假如单调栈中的数据为递减，则可以知道栈顶的数据一定为当前序列中最大的数据;假如单调栈中的数据为递增，则可以知道栈顶的数据一定为当前序列中最小的数据。一般情况下我们都会用&lt;code&gt;dequeue&lt;/code&gt;来处理单调栈的数据，则可以知道队列的头部一定为当前序列中所求的最大值或者最小值。&lt;/li&gt;
&lt;li&gt;为了保持单调性，则每当加入一个新的元素时，则会将栈中所有比当前元素小或者大的数据全部进行出栈，则由此我们可以判断如下，假设当前的栈为递减：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/05/11/xJKB3lbXmrjCZ6q.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;从图中可以看出我们可以在$O(1)$的时间复杂度内求出当前序列的极值。栈中任意相邻的两个元素比如$(arr[i],arr[j])$,则表示所有处于$(i,j)$之间的元素均小于$arr[j]$,有了这个重要的推论，则许多问题都可以利用这个特性来求解，比如我们知道假设某个元素&lt;code&gt;x&lt;/code&gt;大于$arr[j]$,则表示&lt;code&gt;x&lt;/code&gt;一定大于所有位于$[i+1,j]$之间的元素。下面有几个非常有代表性的题目需要讨论下：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 240</title>
    <link href="http://yoursite.com/2021/05/09/280/"/>
    <id>http://yoursite.com/2021/05/09/280/</id>
    <published>2021-05-09T09:05:42.330Z</published>
    <updated>2021-05-11T12:50:00.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-240"><a href="#leetcode-contest-240" class="headerlink" title="leetcode  contest 240"></a>leetcode  contest 240</h1><p>本周的题目质量还算真心不错，印象最深的应该是第三题，单调栈的应用，最后一题反而感觉不是太难。已经经历过许多次单调栈了，还是对单调栈的理解不够透彻，刚刚复习了<code>tarjan</code>和<code>heap</code>的应用，印象非常深刻。</p><h2 id="5750-人口最多的年份"><a href="#5750-人口最多的年份" class="headerlink" title="5750. 人口最多的年份"></a>5750. 人口最多的年份</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>logs</code> ，其中每个 <code>logs[i] = [birthi, deathi]</code> 表示第 <code>i</code> 个人的出生和死亡年份。</p><a id="more"></a><p>年份 x 的 人口 定义为这一年期间活着的人的数目。第 <code>i</code> 个人被计入年份 x 的人口需要满足：x 在闭区间<code>[birthi, deathi - 1]</code> 内。注意，人不应当计入他们死亡当年的人口中。</p><p>返回 人口最多 且 最早 的年份。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">1993</span>,<span class="number">1999</span>],[<span class="number">2000</span>,<span class="number">2010</span>]]</span><br><span class="line">输出：<span class="number">1993</span></span><br><span class="line">解释：人口最多为 <span class="number">1</span> ，而 <span class="number">1993</span> 是人口为 <span class="number">1</span> 的最早年份。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">1950</span>,<span class="number">1961</span>],[<span class="number">1960</span>,<span class="number">1971</span>],[<span class="number">1970</span>,<span class="number">1981</span>]]</span><br><span class="line">输出：<span class="number">1960</span></span><br><span class="line">解释： </span><br><span class="line">人口最多为 <span class="number">2</span> ，分别出现在 <span class="number">1960</span> 和 <span class="number">1970</span> 。</span><br><span class="line">其中最早年份是 <span class="number">1960</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= logs.length &lt;= 100</code></li><li><code>1950 &lt;= birthi &lt; deathi &lt;= 2050</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-population-year" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-population-year</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  差分数组暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的直接暴力排序统计即可，时间复杂度为$O(n)$,稍微高级点的我们可以用点技巧的我们可以用查分数组。</li><li>我们每次在出身的年份将人数进行加<code>1</code>，在死亡的年份将人数减<code>1</code>，统计当年年份中人数最多的一年即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumPopulation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(<span class="number">2051</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; logs.size(); ++i)&#123;</span><br><span class="line">            arr[logs[i][<span class="number">0</span>]]++;</span><br><span class="line">            arr[logs[i][<span class="number">1</span>]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> year = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1950</span>; i &lt;= <span class="number">2050</span>; ++i)&#123;</span><br><span class="line">            curr += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; maxP)&#123;</span><br><span class="line">                maxP = curr;</span><br><span class="line">                year = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> year;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5751-下标对中的最大距离"><a href="#5751-下标对中的最大距离" class="headerlink" title="5751. 下标对中的最大距离"></a>5751. 下标对中的最大距离</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个 非递增 的整数数组 <code>nums1</code>​​​​​​ 和 <code>nums2</code>​​​​​​ ，数组下标均 从 0 开始 计数。<br>下标对 <code>(i, j)</code> 中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code> 。如果该下标对同时满足 <code>i &lt;= j</code> 且 <code>nums1[i] &lt;= nums2[j]</code> ，则称之为 有效 下标对，该下标对的 距离 为 <code>j - i</code>​​ 。​​</p><p>返回所有 有效 下标对 <code>(i, j)</code> 中的 最大距离 。如果不存在有效下标对，返回 0 。</p><p>一个数组 <code>arr</code> ，如果每个 <code>1 &lt;= i &lt; arr.length</code> 均有 <code>arr[i-1] &gt;= arr[i]</code> 成立，那么该数组是一个 非递增 数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">55</span>,<span class="number">30</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>], nums2 = [<span class="number">100</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有效下标对是 (<span class="number">0</span>,<span class="number">0</span>), (<span class="number">2</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">3</span>), (<span class="number">3</span>,<span class="number">4</span>) 和 (<span class="number">4</span>,<span class="number">4</span>) 。</span><br><span class="line">最大距离是 <span class="number">2</span> ，对应下标对 (<span class="number">2</span>,<span class="number">4</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">10</span>,<span class="number">10</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：有效下标对是 (<span class="number">0</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">1</span>) 和 (<span class="number">1</span>,<span class="number">1</span>) 。</span><br><span class="line">最大距离是 <span class="number">1</span> ，对应下标对 (<span class="number">0</span>,<span class="number">1</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">30</span>,<span class="number">29</span>,<span class="number">19</span>,<span class="number">5</span>], nums2 = [<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有效下标对是 (<span class="number">2</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">3</span>) 和 (<span class="number">3</span>,<span class="number">4</span>) 。</span><br><span class="line">最大距离是 <span class="number">2</span> ，对应下标对 (<span class="number">2</span>,<span class="number">4</span>) 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">5</span>,<span class="number">4</span>], nums2 = [<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在有效下标对，所以返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length &lt;= 105</code></li><li><code>1 &lt;= nums2.length &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[j] &lt;= 105</code></li><li><code>nums1</code> 和 <code>nums2</code> 都是 非递增 数组</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 双指针或者二分查找</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的二分查找或者双指针问题，对于二分查找就比较简单，我们每次固定<code>nums1[i]</code>,然后利用二分查找法，在<code>nums2</code>中找到最小且比<code>nums1[i]</code>的大的数的索引，即可很快得到结论，算法时间复杂度为$O(nlg(n))$.</li><li>双指针法，由于两个数组都是已经排好序了，我们遍历一个元素时<code>nums1[i]</code>时，用一个指针指向当且大于等于且最小的数的索引，此时如果我们将<code>nums1[i]</code>移动到<code>nums1[i+1]</code>时，则我们将<code>nums2[j]</code>往后移动直到满足题目要求。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &lt;= nums2[mid])&#123;</span><br><span class="line">                    curr = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,curr-i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>双指针<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; nums2[j] &gt;= nums1[i]) j++;</span><br><span class="line">            ans = max(ans,j-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5752-子数组最小乘积的最大值"><a href="#5752-子数组最小乘积的最大值" class="headerlink" title="5752. 子数组最小乘积的最大值"></a>5752. 子数组最小乘积的最大值</h2><p>一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。</p><p>比方说，数组<code>[3,2,5]</code>（最小值是 2）的最小乘积为<code>2 * (3+2+5) = 2 * 10 = 20</code>。<br>给你一个正整数数组 <code>nums</code> ，请你返回 <code>nums</code>任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对  <code>109 + 7</code>取余 的结果。</p><p>请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 <code>64</code> 位有符号整数 保存。</p><p>子数组 定义为一个数组的 连续 部分。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">解释：最小乘积的最大值由子数组 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>] （最小值是 <span class="number">2</span>）得到。</span><br><span class="line"><span class="number">2</span> * (<span class="number">2</span>+<span class="number">3</span>+<span class="number">2</span>) = <span class="number">2</span> * <span class="number">7</span> = <span class="number">14</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：最小乘积的最大值由子数组 [<span class="number">3</span>,<span class="number">3</span>] （最小值是 <span class="number">3</span>）得到。</span><br><span class="line"><span class="number">3</span> * (<span class="number">3</span>+<span class="number">3</span>) = <span class="number">3</span> * <span class="number">6</span> = <span class="number">18</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">60</span></span><br><span class="line">解释：最小乘积的最大值由子数组 [<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] （最小值是 <span class="number">4</span>）得到。</span><br><span class="line"><span class="number">4</span> * (<span class="number">5</span>+<span class="number">6</span>+<span class="number">4</span>) = <span class="number">4</span> * <span class="number">15</span> = <span class="number">60</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 107</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 单调栈</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们直接暴力的话，双层循环，时间复杂度为$O(n^{2}$.</li><li>我们可以利用单调栈，对每一个元素求出以作为最小元素最长连续子数组，我们即可求该元素的两边距离该元素最近且比该元素小的数组的索引，我们可以利用单调栈；</li></ol><ul><li>左边严格小于<code>nums[i]</code>的元素，且距离<code>nums[i]</code>最近，我们记该元素的索引为<code>left[i]</code>；</li><li>右边严格小于<code>nums[i]</code>的元素，且距离<code>nums[i]</code>最近，我们记该元素的索引为<code>right[i]</code>；<br>则我们可以直到以<code>nums[i]</code>为最小元素的最长连续子数组的索引为$[left[i]+1,right[i]-1]$，此时我们即可利用前缀和很快即可求出数组的最小乘积，我们枚举所有可能的最小乘积即可求出所有可能的元素；</li></ul><ol><li>我们每次将比当前元素大的元素从栈内弹出，并将弹出元素的最近小于等于的元素即等于当前的元素。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumMinProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n,n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sum[i+<span class="number">1</span>] = nums[i] + sum[i];</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; curr1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!curr1.empty() &amp;&amp; nums[i] &lt; nums[curr1.top()])&#123;</span><br><span class="line">                right[curr1.top()] = i;</span><br><span class="line">                curr1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            curr1.push(i);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; curr2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!curr2.empty() &amp;&amp; nums[i] &lt; nums[curr2.top()])&#123;</span><br><span class="line">                left[curr2.top()] = i;</span><br><span class="line">                curr2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            curr2.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> prod = nums[i] *(sum[right[i]]-sum[left[i]+<span class="number">1</span>]);</span><br><span class="line">            ans = max(ans,prod);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5753-有向图中最大颜色值"><a href="#5753-有向图中最大颜色值" class="headerlink" title="5753. 有向图中最大颜色值"></a>5753. 有向图中最大颜色值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 有向图 ，它含有 <code>n</code> 个节点和 <code>m</code>条边。节点编号从 0 到 <code>n - 1</code>。</p><p>给你一个字符串 <code>colors</code> ，其中 <code>colors[i]</code> 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 <code>edges</code> ，其中 <code>edges[j] = [aj, bj]</code>表示从节点 <code>aj</code>到节点<code>bj</code> 有一条 有向边 。</p><p>图中一条有效 路径 是一个点序列 <code>x1 -&gt; x2 -&gt; x3 -&gt; ... -&gt; xk</code>，对于所有 <code>1 &lt;= i &lt; k</code>，从 <code>xi</code>到 <code>xi+1</code> 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。</p><p>请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = <span class="string">"abaca"</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：路径 <span class="number">0</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> 含有 <span class="number">3</span> 个颜色为 <span class="string">"a"</span> 的节点（上图中的红色节点）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = <span class="string">"a"</span>, edges = [[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：从 <span class="number">0</span> 到 <span class="number">0</span> 有一个环。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == colors.length</code></li><li><code>m == edges.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= m &lt;= 105</code></li><li><code>colors</code> 只含有小写英文字母。</li><li><code>0 &lt;= aj, bj &lt; n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>拓扑排序</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>感觉这个题目反而没有太多亮点，常规的题目，因为题目中不需要处理环的特殊情况，所以就非常简单，我们首先判断图中是否有环，如果有环我们直接返回<code>-1</code>即可。</li><li>我们设<code>dp[i][c]</code>表示经过节点的<code>i</code>且颜色为<code>c</code>的节点最多的个数，则我们利用拓扑排序，每一条新的路径达到某个顶点，则我们对该顶点的每种颜色的最大个数都进行跟新比较即可，感觉中规中距的题目。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestPathValue</span><span class="params">(<span class="built_in">string</span> colors, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = colors.size();</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                qu.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            dp[curr][colors[curr]-<span class="string">'a'</span>]++;</span><br><span class="line">            ans = max(ans,dp[curr][colors[curr]-<span class="string">'a'</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">                indegree[v]--;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">                    dp[v][i] = max(dp[v][i],dp[curr][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(indegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-240&quot;&gt;&lt;a href=&quot;#leetcode-contest-240&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 240&quot;&gt;&lt;/a&gt;leetcode  contest 240&lt;/h1&gt;&lt;p&gt;本周的题目质量还算真心不错，印象最深的应该是第三题，单调栈的应用，最后一题反而感觉不是太难。已经经历过许多次单调栈了，还是对单调栈的理解不够透彻，刚刚复习了&lt;code&gt;tarjan&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;的应用，印象非常深刻。&lt;/p&gt;&lt;h2 id=&quot;5750-人口最多的年份&quot;&gt;&lt;a href=&quot;#5750-人口最多的年份&quot; class=&quot;headerlink&quot; title=&quot;5750. 人口最多的年份&quot;&gt;&lt;/a&gt;5750. 人口最多的年份&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个二维整数数组 &lt;code&gt;logs&lt;/code&gt; ，其中每个 &lt;code&gt;logs[i] = [birthi, deathi]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个人的出生和死亡年份。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 239</title>
    <link href="http://yoursite.com/2021/05/03/279/"/>
    <id>http://yoursite.com/2021/05/03/279/</id>
    <published>2021-05-03T08:33:32.332Z</published>
    <updated>2021-05-09T09:06:20.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-239"><a href="#leetcode-contest-239" class="headerlink" title="leetcode  contest 239"></a>leetcode  contest 239</h1><p>感觉周赛的题目还算是稍微好看点，不过最后一题确实不太难，基本上都是暴力加一定的技巧就能做出来。题目比双周赛要难一点，但是不是特别难，感觉至少三题的节奏。</p><h2 id="1848-到目标元素的最小距离"><a href="#1848-到目标元素的最小距离" class="headerlink" title="1848. 到目标元素的最小距离"></a>1848. 到目标元素的最小距离</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> （下标 从 0 开始 计数）以及两个整数 <code>target</code> 和 <code>start</code> ，请你找出一个下标 i ，满足 <code>nums[i] == target</code> 且 <code>abs(i - start)</code>最小化 。注意：<code>abs(x)</code>表示 x 的绝对值。</p><a id="more"></a><p>返回 <code>abs(i - start)</code> 。</p><p>题目数据保证 <code>target</code> 存在于 <code>nums</code> 中。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], target = <span class="number">5</span>, start = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：nums[<span class="number">4</span>] = <span class="number">5</span> 是唯一一个等于 target 的值，所以答案是 abs(<span class="number">4</span> - <span class="number">3</span>) = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], target = <span class="number">1</span>, start = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums[<span class="number">0</span>] = <span class="number">1</span> 是唯一一个等于 target 的值，所以答案是 abs(<span class="number">0</span> - <span class="number">0</span>) = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">1</span>, start = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums 中的每个值都是 <span class="number">1</span> ，但 nums[<span class="number">0</span>] 使 abs(i - start) 的结果得以最小化，所以答案是 abs(<span class="number">0</span> - <span class="number">0</span>) = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li><li><code>0 &lt;= start &lt; nums.length</code></li><li><code>target 存在于 nums 中</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-to-the-target-element</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力统计就可，题目有点奇怪，不是中规中矩的题目<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(ans-start) &gt; <span class="built_in">abs</span>(i-start))&#123;</span><br><span class="line">                        ans = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(ans-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1849-将字符串拆分为递减的连续值"><a href="#1849-将字符串拆分为递减的连续值" class="headerlink" title="1849. 将字符串拆分为递减的连续值"></a>1849. 将字符串拆分为递减的连续值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个仅由数字组成的字符串 <code>s</code>。</p><p>请你判断能否将 <code>s</code>拆分成两个或者多个 非空子字符串 ，使子字符串的 数值 按 降序 排列，且每两个 相邻子字符串 的数值之 差 等于 1 。</p><p>例如，字符串 <code>s = &quot;0090089&quot;</code>可以拆分成 [“0090”, “089”] ，数值为 [90,89] 。这些数值满足按降序排列，且相邻值相差 1 ，这种拆分方法可行。<br>另一个例子中，字符串 s = “001” 可以拆分成 [“0”, “01”]、[“00”, “1”] 或 [“0”, “0”, “1”] 。然而，所有这些拆分方法都不可行，因为对应数值分别是 [0,1]、[0,1] 和 [0,0,1] ，都不满足按降序排列的要求。<br>如果可以按要求拆分 <code>s</code>，返回<code>true</code>；否则，返回 <code>false</code> 。</p><p>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1234"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：不存在拆分 s 的可行方法。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"050043"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：s 可以拆分为 [<span class="string">"05"</span>, <span class="string">"004"</span>, <span class="string">"3"</span>] ，对应数值为 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>] 。</span><br><span class="line">满足按降序排列，且相邻值相差 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"9080701"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：不存在拆分 s 的可行方法。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"10009998"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：s 可以拆分为 [<span class="string">"100"</span>, <span class="string">"099"</span>, <span class="string">"98"</span>] ，对应数值为 [<span class="number">100</span>,<span class="number">99</span>,<span class="number">98</span>] 。</span><br><span class="line">满足按降序排列，且相邻值相差 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values" target="_blank" rel="noopener">https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力<code>dfs</code></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>上来就知道这个题目可以暴力<code>dfs</code>加剪枝就可以搞定。但是一般不喜欢用<code>dfs</code>，想来想去没有想到好的解法，最后还算老老实实的用<code>dfs</code>。</li><li>每次进行<code>dfs</code>递归时，需要记录前一个已经分割后的值以及当前已经进行分割的次数。关键一点需要提示，当前值如果大于$10^{10}$,则我们可以直接进行中止，因为后面的字符无论如何都不可能构成比当前数小<code>1</code>的值，这样即可放置<code>long long</code>溢出的问题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> prev,<span class="keyword">int</span> curr,<span class="keyword">int</span> cnt,<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> max = <span class="number">1e10</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span> &amp;&amp; curr == s.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = curr; i &lt; s.size(); ++i)&#123;</span><br><span class="line">                x = x*<span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(dfs(x,i+<span class="number">1</span>,cnt+<span class="number">1</span>,s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = curr; i &lt; s.size(); ++i)&#123;</span><br><span class="line">                x = x*<span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(x == prev<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(x,i+<span class="number">1</span>,cnt+<span class="number">1</span>,s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; prev<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="1850-邻位交换的最小次数"><a href="#1850-邻位交换的最小次数" class="headerlink" title="1850. 邻位交换的最小次数"></a>1850. 邻位交换的最小次数</h2><p>给你一个表示大整数的字符串 <code>num</code> ，和一个整数 <code>k</code> 。</p><p>如果某个整数是 <code>num</code> 中各位数字的一个 排列 且它的 值大于 <code>num</code>，则称这个整数为 妙数 。可能存在很多妙数，但是只需要关注 值最小 的那些。</p><ul><li>例如，num = “5489355142” ：<ul><li>第 1 个最小妙数是 “5489355214”</li><li>第 2 个最小妙数是 “5489355241”</li><li>第 3 个最小妙数是 “5489355412”</li><li>第 4 个最小妙数是 “5489355421”<br>返回要得到第 k 个 最小妙数 需要对 num 执行的 相邻位数字交换的最小次数 。</li></ul></li></ul><p>测试用例是按存在第 k 个最小妙数而生成的。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"5489355142"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：第 <span class="number">4</span> 个最小妙数是 <span class="string">"5489355421"</span> ，要想得到这个数字：</span><br><span class="line">- 交换下标 <span class="number">7</span> 和下标 <span class="number">8</span> 对应的位：<span class="string">"5489355142"</span> -&gt; <span class="string">"5489355412"</span></span><br><span class="line">- 交换下标 <span class="number">8</span> 和下标 <span class="number">9</span> 对应的位：<span class="string">"5489355412"</span> -&gt; <span class="string">"5489355421"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"11112"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：第 <span class="number">4</span> 个最小妙数是 <span class="string">"21111"</span> ，要想得到这个数字：</span><br><span class="line">- 交换下标 <span class="number">3</span> 和下标 <span class="number">4</span> 对应的位：<span class="string">"11112"</span> -&gt; <span class="string">"11121"</span></span><br><span class="line">- 交换下标 <span class="number">2</span> 和下标 <span class="number">3</span> 对应的位：<span class="string">"11121"</span> -&gt; <span class="string">"11211"</span></span><br><span class="line">- 交换下标 <span class="number">1</span> 和下标 <span class="number">2</span> 对应的位：<span class="string">"11211"</span> -&gt; <span class="string">"12111"</span></span><br><span class="line">- 交换下标 <span class="number">0</span> 和下标 <span class="number">1</span> 对应的位：<span class="string">"12111"</span> -&gt; <span class="string">"21111"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"00123"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第 <span class="number">1</span> 个最小妙数是 <span class="string">"00132"</span> ，要想得到这个数字：</span><br><span class="line">- 交换下标 <span class="number">3</span> 和下标 <span class="number">4</span> 对应的位：<span class="string">"00123"</span> -&gt; <span class="string">"00132"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= num.length &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 1000</code></li><li><code>num</code> 仅由数字组成</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>第一步我们需要求出第<code>k</code>个<code>next_permutation</code>，即下一个的有序序列和，当然我们可以很快的利用<code>c++</code>的库函数$next_permutation$,如果不知道库如何解决，我们从<code>n-1</code>个字符开始倒序遍历，并记录已经访问过的字符，如果发现已经访问过的字符列表中存在比当前字符$s[i]$大的字符时，此时我们则从已经访问过的字符列表中找到第最小且严格大于$s[i]$的字符，并且进行交换，然后对字符串$s[i+1…n-1]$按照从小到大的顺序进行排列即可，这个就是严格的规律。</li><li>第二部我们需要找到最小的相邻字符的交换次数，此时我们仔细观察，队员元素字符串$src$和原始字符串$dst$我们则进行逐个比较，如果当前字符相等则我们跳过，如果$src[i] != dst[i]$时，则我们从$src[i+1…n-1]$中找到第一个跟$dst[i]$相等的字符$src[j]$，然后我们进行相邻的字符交换，此时我们需要交换的次数为$j-i$。</li><li>继续下一个字符比较，重复<code>2</code>的步骤，知道两个字符串相等，则此时我们得到交换次数即为最小的交换次数。本质题目不是特别难，但是还算需要一点严格的数学证明过程。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinSwaps</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> s = num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr.empty())&#123;</span><br><span class="line">                    curr[s[j]] = j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[j] &lt; curr.rbegin()-&gt;first)&#123;</span><br><span class="line">                        <span class="keyword">auto</span> it = curr.upper_bound(s[j]);</span><br><span class="line">                        <span class="keyword">int</span> x = it-&gt;second;</span><br><span class="line">                        swap(s[j],s[x]);</span><br><span class="line">                        sort(s.begin()+j+<span class="number">1</span>,s.end());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        curr[s[j]] = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == num[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n ; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] == s[i])&#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt; i; --j)&#123;</span><br><span class="line">                num[j] = num[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans += k - i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1851-包含每个查询的最小区间"><a href="#1851-包含每个查询的最小区间" class="headerlink" title="1851. 包含每个查询的最小区间"></a>1851. 包含每个查询的最小区间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [lefti, righti]</code>表示第<code>i</code>个区间开始于 <code>lefti</code> 、结束于 <code>righti</code>（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 <code>righti - lefti + 1</code>。</p><p>再给你一个整数数组 <code>queries</code>。第 j 个查询的答案是满足 <code>lefti &lt;= queries[j] &lt;= righti</code>的 长度最小区间 <code>i</code> 的长度 。如果不存在这样的区间，那么答案是 -1 。</p><p>以数组形式返回对应查询的所有答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">4</span>]], queries = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">解释：查询处理如下：</span><br><span class="line">- Query = <span class="number">2</span> ：区间 [<span class="number">2</span>,<span class="number">4</span>] 是包含 <span class="number">2</span> 的最小区间，答案为 <span class="number">4</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> 。</span><br><span class="line">- Query = <span class="number">3</span> ：区间 [<span class="number">2</span>,<span class="number">4</span>] 是包含 <span class="number">3</span> 的最小区间，答案为 <span class="number">4</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> 。</span><br><span class="line">- Query = <span class="number">4</span> ：区间 [<span class="number">4</span>,<span class="number">4</span>] 是包含 <span class="number">4</span> 的最小区间，答案为 <span class="number">4</span> - <span class="number">4</span> + <span class="number">1</span> = <span class="number">1</span> 。</span><br><span class="line">- Query = <span class="number">5</span> ：区间 [<span class="number">3</span>,<span class="number">6</span>] 是包含 <span class="number">5</span> 的最小区间，答案为 <span class="number">6</span> - <span class="number">3</span> + <span class="number">1</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">8</span>],[<span class="number">20</span>,<span class="number">25</span>]], queries = [<span class="number">2</span>,<span class="number">19</span>,<span class="number">5</span>,<span class="number">22</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">解释：查询处理如下：</span><br><span class="line">- Query = <span class="number">2</span> ：区间 [<span class="number">2</span>,<span class="number">3</span>] 是包含 <span class="number">2</span> 的最小区间，答案为 <span class="number">3</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span> 。</span><br><span class="line">- Query = <span class="number">19</span>：不存在包含 <span class="number">19</span> 的区间，答案为 <span class="number">-1</span> 。</span><br><span class="line">- Query = <span class="number">5</span> ：区间 [<span class="number">2</span>,<span class="number">5</span>] 是包含 <span class="number">5</span> 的最小区间，答案为 <span class="number">5</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">- Query = <span class="number">22</span>：区间 [<span class="number">20</span>,<span class="number">25</span>] 是包含 <span class="number">22</span> 的最小区间，答案为 <span class="number">25</span> - <span class="number">20</span> + <span class="number">1</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= intervals.length &lt;= 105</code></li><li><code>1 &lt;= queries.length &lt;= 105</code></li><li><code>queries[i].length == 2</code></li><li><code>1 &lt;= lefti &lt;= righti &lt;= 107</code></li><li><code>1 &lt;= queries[j] &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-interval-to-include-each-query</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>优先级队列或者离线二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目跟<code>1847</code>很像，都是利用类似的离线查询加贪心的算法，我们首先按照区间的大小进行排序，然后我们对按照区间的长短从小到大遍历每个区间，每次去查询区间中包含有多少个查询的点，然后将查询的点进行赋值，然后将已经查询到的点进行移除，每次只需依次遍历一遍即可完成该操作。时间复杂度为$O(n<em>lg(n) + m</em>lg(m) + 2n*lg(m))$</li><li>利用优先级队列，我们首先还算将区间按照区间的左端点进行排序，将所有的查询点也按照从小到大进行排序，然后我们依次遍历每一个查询点，我们每次进行遍历时，将所有左起点小于等于$query_{i}$的端点进行入优先级队列。优先级队列中按照区间的长度进行排序，每次我们将所有右端点小于$query_{i}$的区间从队列中去掉，剩余的队列中的第一个元素即为最小的满足的区间。依次遍历即可完成所有的查询。时间复杂度为$O(nlg + mlgm + mlgn)$,其中<code>n</code>为区间的长度，<code>m</code>为查询数组的长度。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>解法1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minInterval(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; itv, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) st.emplace(q[i], i);</span><br><span class="line">        sort(itv.begin(), itv.end(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] &lt; b[<span class="number">1</span>] - b[<span class="number">0</span>];&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : itv)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = st.lower_bound(&#123;v[<span class="number">0</span>], <span class="number">-1</span>&#125;);</span><br><span class="line">            <span class="keyword">while</span>(it != st.end() &amp;&amp; it-&gt;first &lt;= v[<span class="number">1</span>])&#123;</span><br><span class="line">                ans[it-&gt;second] = v[<span class="number">1</span>] - v[<span class="number">0</span>] + <span class="number">1</span>, st.erase(it++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>解法2<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    Node(<span class="keyword">int</span> len,<span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = len;</span><br><span class="line">        <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a, <span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.len &gt; b.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minInterval(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">        sort(intervals.begin(),intervals.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) arr.push_back(&#123;queries[i],i&#125;);</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: arr)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= v[<span class="number">0</span>])&#123;</span><br><span class="line">                pq.push(Node(intervals[i][<span class="number">1</span>]-intervals[i][<span class="number">0</span>]+<span class="number">1</span>,intervals[i][<span class="number">1</span>]));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!pq.empty() &amp;&amp; pq.top().end &lt; v[<span class="number">0</span>])&#123;</span><br><span class="line">                pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!pq.empty())&#123;</span><br><span class="line">                ans[v[<span class="number">1</span>]] = pq.top().len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-239&quot;&gt;&lt;a href=&quot;#leetcode-contest-239&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 239&quot;&gt;&lt;/a&gt;leetcode  contest 239&lt;/h1&gt;&lt;p&gt;感觉周赛的题目还算是稍微好看点，不过最后一题确实不太难，基本上都是暴力加一定的技巧就能做出来。题目比双周赛要难一点，但是不是特别难，感觉至少三题的节奏。&lt;/p&gt;&lt;h2 id=&quot;1848-到目标元素的最小距离&quot;&gt;&lt;a href=&quot;#1848-到目标元素的最小距离&quot; class=&quot;headerlink&quot; title=&quot;1848. 到目标元素的最小距离&quot;&gt;&lt;/a&gt;1848. 到目标元素的最小距离&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; （下标 从 0 开始 计数）以及两个整数 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;start&lt;/code&gt; ，请你找出一个下标 i ，满足 &lt;code&gt;nums[i] == target&lt;/code&gt; 且 &lt;code&gt;abs(i - start)&lt;/code&gt;最小化 。注意：&lt;code&gt;abs(x)&lt;/code&gt;表示 x 的绝对值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 51</title>
    <link href="http://yoursite.com/2021/05/01/278/"/>
    <id>http://yoursite.com/2021/05/01/278/</id>
    <published>2021-05-01T15:36:32.799Z</published>
    <updated>2021-05-04T02:23:27.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-51"><a href="#leetcode-biweekly-contest-51" class="headerlink" title="leetcode biweekly contest 51"></a>leetcode biweekly contest 51</h1><p>双周赛的题目质量感觉一直不太稳定，要么太难，要么太容易，本周前三题都是简单题目，最后一题也不需要太多的技巧，高级的数据结构也基本上用不上。本周的题目还是比较见简单，基本上就是手速题。<br><img src="https://i.loli.net/2021/05/03/Z7iYD5UrKXMAF3Q.png" alt></p><h2 id="1844-将所有数字用字符替换"><a href="#1844-将所有数字用字符替换" class="headerlink" title="1844. 将所有数字用字符替换"></a>1844. 将所有数字用字符替换</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的字符串 <code>s</code>，它的 偶数 下标处为小写英文字母，奇数 下标处为数字。</p><a id="more"></a><p>定义一个函数 <code>shift(c, x)</code> ，其中 c 是一个字符且 x 是一个数字，函数返回字母表中 c 后面第 x 个字符。</p><p>比方说，<code>shift(&#39;a&#39;, 5) = &#39;f&#39;</code>和 <code>shift(&#39;x&#39;, 0) = &#39;x&#39;</code> 。<br>对于每个 奇数 下标 i ，你需要将数字 <code>s[i]</code>用 <code>shift(s[i-1], s[i])</code>替换。</p><p>请你替换所有数字以后，将字符串 s 返回。题目 保证 <code>shift(s[i-1], s[i])</code> 不会超过 <code>&#39;z&#39;</code> 。</p><p>示例 1：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"a1c1e1"</span></span><br><span class="line">输出：<span class="string">"abcdef"</span></span><br><span class="line">解释：数字被替换结果如下：</span><br><span class="line">- <span class="function"><span class="title">s</span>[1] -&gt;</span> shift(<span class="string">'a'</span>,<span class="number">1</span>) = <span class="string">'b'</span></span><br><span class="line">- <span class="function"><span class="title">s</span>[3] -&gt;</span> shift(<span class="string">'c'</span>,<span class="number">1</span>) = <span class="string">'d'</span></span><br><span class="line">- <span class="function"><span class="title">s</span>[5] -&gt;</span> shift(<span class="string">'e'</span>,<span class="number">1</span>) = <span class="string">'f'</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"a1b2c3d4e"</span></span><br><span class="line">输出：<span class="string">"abbdcfdhe"</span></span><br><span class="line">解释：数字被替换结果如下：</span><br><span class="line">- <span class="function"><span class="title">s</span>[1] -&gt;</span> shift(<span class="string">'a'</span>,<span class="number">1</span>) = <span class="string">'b'</span></span><br><span class="line">- <span class="function"><span class="title">s</span>[3] -&gt;</span> shift(<span class="string">'b'</span>,<span class="number">2</span>) = <span class="string">'d'</span></span><br><span class="line">- <span class="function"><span class="title">s</span>[5] -&gt;</span> shift(<span class="string">'c'</span>,<span class="number">3</span>) = <span class="string">'f'</span></span><br><span class="line">- <span class="function"><span class="title">s</span>[7] -&gt;</span> shift(<span class="string">'d'</span>,<span class="number">4</span>) = <span class="string">'h'</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写英文字母和数字。</li><li>对所有 奇数 下标处的 <code>i</code> ，满足 <code>shift(s[i-1], s[i]) &lt;= &#39;z&#39;</code> 。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-digits-in-base-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-digits-in-base-k</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单暴力即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceDigits</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i = i + <span class="number">2</span>)&#123;</span><br><span class="line">            s[i] = s[i<span class="number">-1</span>] + s[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1845-座位预约管理系统"><a href="#1845-座位预约管理系统" class="headerlink" title="1845. 座位预约管理系统"></a>1845. 座位预约管理系统</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>请你设计一个管理 n 个座位预约的系统，座位编号从 <code>1</code> 到<code>n</code>。</p><p>请你实现 <code>SeatManager</code> 类：</p><p>SeatManager(int n) 初始化一个 SeatManager 对象，它管理从 1 到 n 编号的 n 个座位。所有座位初始都是可预约的。<br>int reserve() 返回可以预约座位的 最小编号 ，此座位变为不可预约。<br>void unreserve(int seatNumber) 将给定编号 seatNumber 对应的座位变成可以预约。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"SeatManager"</span>, <span class="string">"reserve"</span>, <span class="string">"reserve"</span>, <span class="string">"unreserve"</span>, <span class="string">"reserve"</span>, <span class="string">"reserve"</span>, <span class="string">"reserve"</span>, <span class="string">"reserve"</span>, <span class="string">"unreserve"</span>]</span><br><span class="line">[[<span class="number">5</span>], [], [], [<span class="number">2</span>], [], [], [], [], [<span class="number">5</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">1</span>, <span class="number">2</span>, null, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, null]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">SeatManager seatManager = new SeatManager(<span class="number">5</span>); <span class="comment">// 初始化 SeatManager ，有 5 个座位。</span></span><br><span class="line">seatManager.reserve();    <span class="comment">// 所有座位都可以预约，所以返回最小编号的座位，也就是 1 。</span></span><br><span class="line">seatManager.reserve();    <span class="comment">// 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。</span></span><br><span class="line">seatManager.unreserve(<span class="number">2</span>); <span class="comment">// 将座位 2 变为可以预约，现在可预约的座位为 [2,3,4,5] 。</span></span><br><span class="line">seatManager.reserve();    <span class="comment">// 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。</span></span><br><span class="line">seatManager.reserve();    <span class="comment">// 可以预约的座位为 [3,4,5] ，返回最小编号的座位，也就是 3 。</span></span><br><span class="line">seatManager.reserve();    <span class="comment">// 可以预约的座位为 [4,5] ，返回最小编号的座位，也就是 4 。</span></span><br><span class="line">seatManager.reserve();    <span class="comment">// 唯一可以预约的是座位 5 ，所以返回 5 。</span></span><br><span class="line">seatManager.unreserve(<span class="number">5</span>); <span class="comment">// 将座位 5 变为可以预约，现在可预约的座位为 [5] 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= seatNumber &lt;= n</code></li><li>每一次对 <code>reserve</code> 的调用，题目保证至少存在一个可以预约的座位。</li><li>每一次对 <code>unreserve</code> 的调用，题目保证 <code>seatNumber</code> 在调用函数前都是被预约状态。</li><li>对 <code>reserve</code> 和 <code>unreserve</code> 的调用 总共 不超过 105 次。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/seat-reservation-manager" target="_blank" rel="noopener">https://leetcode-cn.com/problems/seat-reservation-manager</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 平衡二叉查找树</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们利用二叉平衡查找树的特性，即可在$O(lgn)$的时间复杂度内找到最小的节点，然后取出即可。</li><li>释放时我们直接把元素从集合中删除即可，时间复杂度为$O(nlgn)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeatManager</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SeatManager(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            seat.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reserve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = *seat.begin();</span><br><span class="line">        used.insert(ans);</span><br><span class="line">        seat.erase(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unreserve</span><span class="params">(<span class="keyword">int</span> seatNumber)</span> </span>&#123;</span><br><span class="line">        used.erase(seatNumber);</span><br><span class="line">        seat.insert(seatNumber);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; seat;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; used;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SeatManager object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SeatManager* obj = new SeatManager(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;reserve();</span></span><br><span class="line"><span class="comment"> * obj-&gt;unreserve(seatNumber);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="1846-减小和重新排列数组后的最大元素"><a href="#1846-减小和重新排列数组后的最大元素" class="headerlink" title="1846. 减小和重新排列数组后的最大元素"></a>1846. 减小和重新排列数组后的最大元素</h2><p>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p><ul><li><code>arr</code> 中 第一个 元素必须为 1 。</li><li>任意相邻两个元素的差的绝对值 小于等于<code>1</code> ，也就是说，对于任意的 <code>1 &lt;= i &lt; arr.length</code> （数组下标从 0 开始），都满足 <code>abs(arr[i] - arr[i - 1]) &lt;= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。<br>你可以执行以下 2 种操作任意次：</li><li>减小 arr 中任意元素的值，使其变为一个 更小的正整数 。</li><li>重新排列 arr 中的元素，你可以以任意顺序重新排列。<br>请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">我们可以重新排列 arr 得到 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>] ，该数组满足所有条件。</span><br><span class="line">arr 中最大元素为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">100</span>,<span class="number">1</span>,<span class="number">1000</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">一个可行的方案如下：</span><br><span class="line"><span class="number">1.</span> 重新排列 arr 得到 [<span class="number">1</span>,<span class="number">100</span>,<span class="number">1000</span>] 。</span><br><span class="line"><span class="number">2.</span> 将第二个元素减小为 <span class="number">2</span> 。</span><br><span class="line"><span class="number">3.</span> 将第三个元素减小为 <span class="number">3</span> 。</span><br><span class="line">现在 arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，满足所有条件。</span><br><span class="line">arr 中最大元素为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：数组已经满足所有条件，最大元素为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 105</code></li><li><code>1 &lt;= arr[i] &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>因为题目中给定的要求，改变元素只能往变小的方向改，所以首先我们想到的解法即是将元素按照从小到大进行排列。</li><li>由于相邻间隔的绝对值之差不能大于<code>1</code>，所以<code>arr[i]</code>最多也就只能等于<code>arr[i-1] + 1</code>，由此我们可以得到约束条件如下：<script type="math/tex; mode=display">1 \le (arr[1] -1) \\arr[1] \le (arr[2]-1) \\arr[n-2] \le (arr[n-1]-1)</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumElementAfterDecrementingAndRearranging</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] - arr[i<span class="number">-1</span>] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                arr[i] = arr[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1847-最近的房间"><a href="#1847-最近的房间" class="headerlink" title="1847. 最近的房间"></a>1847. 最近的房间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个酒店里有 <code>n</code> 个房间，这些房间用二维整数数组 <code>rooms</code> 表示，其中 <code>rooms[i] = [roomIdi, sizei]</code> 表示有一个房间号为 <code>roomIdi</code>的房间且它的面积为<code>sizei</code>。每一个房间号 <code>roomIdi</code>保证是 独一无二 的。</p><p>同时给你 k 个查询，用二维数组 <code>queries</code> 表示，其中 <code>queries[j] = [preferredj, minSizej]</code> `。第 j 个查询的答案是满足如下条件的房间 id ：</p><ul><li>房间的面积 至少 为 <code>minSizej</code> ，且</li><li><code>abs(id - preferredj)</code> 的值 最小 ，其中 <code>abs(x)</code>是 x 的绝对值。<br>如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。</li></ul><p>请你返回长度为 k 的数组 <code>answer</code>，其中 <code>answer[j]</code>为第 j 个查询的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：rooms = [[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>]], queries = [[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">-1</span>,<span class="number">3</span>]</span><br><span class="line">解释：查询的答案如下：</span><br><span class="line">查询 [<span class="number">3</span>,<span class="number">1</span>] ：房间 <span class="number">3</span> 的面积为 <span class="number">2</span> ，大于等于 <span class="number">1</span> ，且号码是最接近 <span class="number">3</span> 的，为 abs(<span class="number">3</span> - <span class="number">3</span>) = <span class="number">0</span> ，所以答案为 <span class="number">3</span> 。</span><br><span class="line">查询 [<span class="number">3</span>,<span class="number">3</span>] ：没有房间的面积至少为 <span class="number">3</span> ，所以答案为 <span class="number">-1</span> 。</span><br><span class="line">查询 [<span class="number">5</span>,<span class="number">2</span>] ：房间 <span class="number">3</span> 的面积为 <span class="number">2</span> ，大于等于 <span class="number">2</span> ，且号码是最接近 <span class="number">5</span> 的，为 abs(<span class="number">3</span> - <span class="number">5</span>) = <span class="number">2</span> ，所以答案为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：rooms = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>]], queries = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：查询的答案如下：</span><br><span class="line">查询 [<span class="number">2</span>,<span class="number">3</span>] ：房间 <span class="number">2</span> 的面积为 <span class="number">3</span> ，大于等于 <span class="number">3</span> ，且号码是最接近的，为 abs(<span class="number">2</span> - <span class="number">2</span>) = <span class="number">0</span> ，所以答案为 <span class="number">2</span> 。</span><br><span class="line">查询 [<span class="number">2</span>,<span class="number">4</span>] ：房间 <span class="number">1</span> 和 <span class="number">3</span> 的面积都至少为 <span class="number">4</span> ，答案为 <span class="number">1</span> 因为它房间编号更小。</span><br><span class="line">查询 [<span class="number">2</span>,<span class="number">5</span>] ：房间 <span class="number">3</span> 是唯一面积大于等于 <span class="number">5</span> 的，所以答案为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == rooms.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>k == queries.length</code></li><li><code>1 &lt;= k &lt;= 104</code></li><li><code>1 &lt;= roomIdi, preferredj &lt;= 107</code></li><li><code>1 &lt;= sizei, minSizej &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/closest-room" target="_blank" rel="noopener">https://leetcode-cn.com/problems/closest-room</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>排序 + 离线查询</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们按照房间的大小对所有的房间进行排序，然后将所有的查询也按照每次房间查询的大小进行排序。我们依次从较大的房间进行查询。每次查询$(preferred, minSize)$时，将所有房间面积大于等于$(minSize)$的房间号都加入到$treeset$集合中。</li><li>接下来我们进行关键的一步查询，距离$preferred$的最近的房间号应该要么为最大且小于等于$preferred$的房间号，要么为最小且大于等于$preferred$的房间号，我们可以快速的利用二分查找即可。</li><li>时间复杂度为$O(mlgn)$,离线查询的这个工具非常有用，最后一题也不用高大上的线段树之类的数据结构。看了线段树的做法，感觉太复杂了。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; closestRoom(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = rooms.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            queries[i].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(rooms.begin(),rooms.end(),[&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        sort(queries.begin(),queries.end(),[&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = queries[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; rooms[j][<span class="number">1</span>] &gt;= queries[i][<span class="number">1</span>])&#123;</span><br><span class="line">                pre.insert(rooms[j][<span class="number">0</span>]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre.empty())&#123;</span><br><span class="line">                ans[queries[i][<span class="number">2</span>]] = <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> it = pre.lower_bound(queries[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span>(it == pre.end())&#123;</span><br><span class="line">                    it--;</span><br><span class="line">                    ans[queries[i][<span class="number">2</span>]] = *it;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == pre.begin())&#123;</span><br><span class="line">                    ans[queries[i][<span class="number">2</span>]] = *pre.begin();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> r = *it;</span><br><span class="line">                    it--;</span><br><span class="line">                    <span class="keyword">int</span> l = *it;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(curr-l) &lt; <span class="built_in">abs</span>(curr-r))&#123;</span><br><span class="line">                        ans[queries[i][<span class="number">2</span>]] = l;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(curr-l) &gt; <span class="built_in">abs</span>(curr-r))&#123;</span><br><span class="line">                        ans[queries[i][<span class="number">2</span>]] = r;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ans[queries[i][<span class="number">2</span>]] = l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-51&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-51&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 51&quot;&gt;&lt;/a&gt;leetcode biweekly contest 51&lt;/h1&gt;&lt;p&gt;双周赛的题目质量感觉一直不太稳定，要么太难，要么太容易，本周前三题都是简单题目，最后一题也不需要太多的技巧，高级的数据结构也基本上用不上。本周的题目还是比较见简单，基本上就是手速题。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/05/03/Z7iYD5UrKXMAF3Q.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;1844-将所有数字用字符替换&quot;&gt;&lt;a href=&quot;#1844-将所有数字用字符替换&quot; class=&quot;headerlink&quot; title=&quot;1844. 将所有数字用字符替换&quot;&gt;&lt;/a&gt;1844. 将所有数字用字符替换&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的字符串 &lt;code&gt;s&lt;/code&gt;，它的 偶数 下标处为小写英文字母，奇数 下标处为数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 238</title>
    <link href="http://yoursite.com/2021/04/25/277/"/>
    <id>http://yoursite.com/2021/04/25/277/</id>
    <published>2021-04-25T04:37:23.010Z</published>
    <updated>2021-04-25T11:52:22.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-238"><a href="#leetcode-contest-238" class="headerlink" title="leetcode  contest 238"></a>leetcode  contest 238</h1><p>本周周赛的题目质量非常高，非常喜欢第<code>2</code>题与第<code>4</code>题，还是三道题的节奏。</p><h2 id="5738-K-进制表示下的各位数字总和"><a href="#5738-K-进制表示下的各位数字总和" class="headerlink" title="5738. K 进制表示下的各位数字总和"></a>5738. K 进制表示下的各位数字总和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>（<code>10</code> 进制）和一个基数 <code>k</code> ，请你将 <code>n</code> 从 <code>10</code> 进制表示转换为 <code>k</code> 进制表示，计算并返回转换后各位数字的 总和 。</p><p>转换后，各位数字应当视作是 <code>10</code> 进制数字，且它们的总和也应当按 <code>10</code>进制表示返回。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">34</span>, k = <span class="number">6</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：<span class="number">34</span> (<span class="number">10</span> 进制) 在 <span class="number">6</span> 进制下表示为 <span class="number">54</span> 。<span class="number">5</span> + <span class="number">4</span> = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：n 本身就是 <span class="number">10</span> 进制。 <span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>2 &lt;= k &lt;= 10</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-digits-in-base-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-digits-in-base-k</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单暴力即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumBase</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            ans += (n%k);</span><br><span class="line">            n = n/k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5739-最高频元素的频数"><a href="#5739-最高频元素的频数" class="headerlink" title="5739. 最高频元素的频数"></a>5739. 最高频元素的频数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>元素的 频数 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。在一步操作中，你可以选择<code>nums</code>的一个下标，并将该下标对应元素的值增加 <code>1</code>。</p><p>执行最多 <code>k</code> 次操作后，返回数组中最高频元素的 最大可能频数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：对第一个元素执行 <span class="number">3</span> 次递增操作，对第二个元素执 <span class="number">2</span> 次递增操作，此时 nums = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>] 。</span><br><span class="line"><span class="number">4</span> 是数组中最高频元素，频数是 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">13</span>], k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：存在多种最优解决方案：</span><br><span class="line">- 对第一个元素执行 <span class="number">3</span> 次递增操作，此时 nums = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">13</span>] 。<span class="number">4</span> 是数组中最高频元素，频数是 <span class="number">2</span> 。</span><br><span class="line">- 对第二个元素执行 <span class="number">4</span> 次递增操作，此时 nums = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">13</span>] 。<span class="number">8</span> 是数组中最高频元素，频数是 <span class="number">2</span> 。</span><br><span class="line">- 对第三个元素执行 <span class="number">5</span> 次递增操作，此时 nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">13</span>] 。<span class="number">13</span> 是数组中最高频元素，频数是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">6</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找或者双指针</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>首先需要按照元素的大小进行排序，我们每次遍历到第<code>i</code>个元素时，我们需要计算将<code>i-1</code>个元素中在<code>k</code>的限制条件下，最多可以变换多少元素变换为<code>nums[i]</code>，此时我们可以利用前缀和即可，假设我们可以将第<code>i</code>个元素之前的<code>m</code>个元素变换为<code>nums[i]</code>，则约束条件为:<script type="math/tex; mode=display">\sum_{i=1}^{m} (nums[i] - nums[i-k]) \le k \\f(m) = m*nums[i] - \sum_{i=1}^{m}(nums[i-k]) \le k</script>满足上述条件即可，我们可以看到上述函数<code>f</code>是根据<code>m</code>的大小是递增的，由此我们即可利用二分查找，每次测试合适的<code>m</code>的值满足<code>k</code>的限制条件即可。</li><li>第二种解法则是利用双指针滑动窗口，由于利用递增的特性每次对当前的窗口的值进行尝试即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; presum(n,<span class="number">0</span>);</span><br><span class="line">        presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(mid == <span class="number">0</span>)&#123;</span><br><span class="line">                    curr = presum[i<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    curr = presum[i<span class="number">-1</span>] - presum[mid<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(((<span class="keyword">long</span> <span class="keyword">long</span>)(i-mid)*nums[i] - curr) &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>)k)&#123;</span><br><span class="line">                    cnt = i - mid;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,cnt+<span class="number">1</span>);</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>滑动窗口<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            tot += nums[i];</span><br><span class="line">            <span class="keyword">while</span>((tot + k) &lt; (<span class="keyword">long</span> <span class="keyword">long</span>)nums[i]*(i-j+<span class="number">1</span>))&#123;</span><br><span class="line">                tot -= nums[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5740-所有元音按顺序排布的最长子字符串"><a href="#5740-所有元音按顺序排布的最长子字符串" class="headerlink" title="5740. 所有元音按顺序排布的最长子字符串"></a>5740. 所有元音按顺序排布的最长子字符串</h2><p>当一个字符串满足如下条件时，我们称它是 美丽的 ：</p><p>所有 5 个英文元音字母<code>（&#39;a&#39; ，&#39;e&#39; ，&#39;i&#39; ，&#39;o&#39; ，&#39;u&#39;）</code>都必须 至少 出现一次。<br>这些元音字母的顺序都必须按照 字典序 升序排布（也就是说所有的 ‘a’ 都在 ‘e’ 前面，所有的 ‘e’ 都在 ‘i’ 前面，以此类推）<br>比方说，字符串 <code>&quot;aeiou&quot;</code>和 <code>&quot;aaaaaaeiiiioou&quot;</code> 都是 美丽的 ，但是<code>&quot;uaeio&quot;</code> ，<code>&quot;aeoiu&quot;</code> 和 <code>&quot;aaaeeeooo&quot;</code> 不是美丽的 。</p><p>给你一个只包含英文元音字母的字符串<code>word</code>，请你返回<code>word</code> 中 最长美丽子字符串的长度 。如果不存在这样的子字符串，请返回 0 。</p><p>子字符串 是字符串中一个连续的字符序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"aeiaaioaaaaeiiiiouuuooaauuaeiu"</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：最长子字符串是 <span class="string">"aaaaeiiiiouuu"</span> ，长度为 <span class="number">13</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"aeeeiiiioooauuuaeiou"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：最长子字符串是 <span class="string">"aeiou"</span> ，长度为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"a"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有美丽子字符串，所以返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-xor-for-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-xor-for-each-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划，我们设<code>dp[i]</code>代表以<code>i</code>的元音字母为结尾且满足从<code>a</code>开始且递增<code>1</code>的连续字符串的长度。</li><li>我们每次需要判断两个条件：</li></ol><ul><li>当前字符串是否严格连续递增<code>1</code>或者与前一个字符相等；</li><li>当前子字符串的起始字符是否为<code>a</code>；<br>本质来说还算是非常简单的<code>dp</code>实现，感觉比第二题简单多了。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestBeautifulSubstring</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; order;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; arr = &#123;<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) order[arr[i]] = i;</span><br><span class="line">        <span class="keyword">if</span>(word[<span class="number">0</span>] == <span class="string">'a'</span>) dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>] == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>(word[i] == <span class="string">'a'</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(order[word[i]] == order[word[i<span class="number">-1</span>]] || (order[word[i]] - order[word[i<span class="number">-1</span>]]) == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(word[i] == <span class="string">'a'</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; <span class="number">0</span> &amp;&amp; word[i] == <span class="string">'u'</span>)&#123;</span><br><span class="line">                ans = max(ans,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5741-最高建筑高度"><a href="#5741-最高建筑高度" class="headerlink" title="5741. 最高建筑高度"></a>5741. 最高建筑高度</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在一座城市里，你需要建 <code>n</code>栋新的建筑。这些新的建筑会从 <code>1</code>到 <code>n</code>编号排成一列。</p><p>这座城市对这些新建筑有一些规定：</p><p>每栋建筑的高度必须是一个非负整数。<br>第一栋建筑的高度 必须 是 <code>0</code>。<br>任意两栋相邻建筑的高度差 不能超过  <code>1</code>。<br>除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组 <code>restrictions</code> 的形式给出，其中 <code>restrictions[i] = [idi, maxHeighti]</code> ，表示建筑 <code>idi</code>的高度 不能超过 <code>maxHeighti</code> 。</p><p>题目保证每栋建筑在 <code>restrictions</code>中 至多出现一次 ，同时建筑 1 不会 出现在 <code>restrictions</code> 中。</p><p>请你返回 最高 建筑能达到的 最高高度 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, restrictions = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>] ，最高建筑的高度为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, restrictions = []</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，最高建筑的高度为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, restrictions = [[<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>] ，最高建筑的高度为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 109</code></li><li><code>0 &lt;= restrictions.length &lt;= min(n - 1, 105)</code></li><li><code>2 &lt;= idi &lt;= n</code></li><li><code>idi</code> 是 唯一的 。</li><li><code>0 &lt;= maxHeighti &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-building-height" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-building-height</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>奥数</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目确实出的很好，根据题目中的要求，由于相邻的楼层的高度差为<code>1</code>，则我们可以知道位于位置<code>i</code>处的楼层为$h[i]$,则我们可以知道位于位置<code>j</code>处的楼层的高度最高一定不能高于$h[i] + abs(i-j)$，我们按照位置的先后来排序，然后利用传递性，对楼层的高度进行限制，刚好能够符合要求。</li><li>对于$(i,h[i])$与$(j,h[j])$两点坐标所能构成的楼层的最大高度有公式为$\frac{abs(i-j)+h[i] + h[j]}{2}$.</li><li>参考官方题解，确实是个非常不错的面试题目。<a href="https://leetcode-cn.com/problems/maximum-building-height/solution/zui-gao-jian-zhu-gao-du-by-leetcode-solu-axbb/" target="_blank" rel="noopener">题解</a>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxBuilding</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        arr.push_back(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        arr.push_back(&#123;n,n<span class="number">-1</span>&#125;);</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">int</span> m = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            arr[i][<span class="number">1</span>] = min(arr[i][<span class="number">1</span>],arr[i<span class="number">-1</span>][<span class="number">1</span>] + arr[i][<span class="number">0</span>] - arr[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            arr[i][<span class="number">1</span>] = min(arr[i][<span class="number">1</span>],arr[i+<span class="number">1</span>][<span class="number">1</span>] + arr[i+<span class="number">1</span>][<span class="number">0</span>] - arr[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            ans = max(ans,(arr[i+<span class="number">1</span>][<span class="number">0</span>] - arr[i][<span class="number">0</span>] + arr[i][<span class="number">1</span>] + arr[i+<span class="number">1</span>][<span class="number">1</span>])/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-238&quot;&gt;&lt;a href=&quot;#leetcode-contest-238&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 238&quot;&gt;&lt;/a&gt;leetcode  contest 238&lt;/h1&gt;&lt;p&gt;本周周赛的题目质量非常高，非常喜欢第&lt;code&gt;2&lt;/code&gt;题与第&lt;code&gt;4&lt;/code&gt;题，还是三道题的节奏。&lt;/p&gt;&lt;h2 id=&quot;5738-K-进制表示下的各位数字总和&quot;&gt;&lt;a href=&quot;#5738-K-进制表示下的各位数字总和&quot; class=&quot;headerlink&quot; title=&quot;5738. K 进制表示下的各位数字总和&quot;&gt;&lt;/a&gt;5738. K 进制表示下的各位数字总和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;（&lt;code&gt;10&lt;/code&gt; 进制）和一个基数 &lt;code&gt;k&lt;/code&gt; ，请你将 &lt;code&gt;n&lt;/code&gt; 从 &lt;code&gt;10&lt;/code&gt; 进制表示转换为 &lt;code&gt;k&lt;/code&gt; 进制表示，计算并返回转换后各位数字的 总和 。&lt;/p&gt;&lt;p&gt;转换后，各位数字应当视作是 &lt;code&gt;10&lt;/code&gt; 进制数字，且它们的总和也应当按 &lt;code&gt;10&lt;/code&gt;进制表示返回。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Google Kickstart】 Google Kick Start 2021 roundB</title>
    <link href="http://yoursite.com/2021/04/19/276/"/>
    <id>http://yoursite.com/2021/04/19/276/</id>
    <published>2021-04-19T09:09:34.045Z</published>
    <updated>2021-04-21T13:41:34.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-kick-start-2021-roundB"><a href="#google-kick-start-2021-roundB" class="headerlink" title="google kick start 2021 roundB"></a>google kick start 2021 roundB</h1><p><code>google kickstart</code>的题目质量很高，虽然比不上竞赛的难度，但是都是非常有思考的题目。<br>还是把题解仔细的写一遍，非常喜欢这类型的题目。</p><h2 id="Increasing-Substring"><a href="#Increasing-Substring" class="headerlink" title="Increasing Substring"></a>Increasing Substring</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/04/21/2z4NiBxDXLouK5W.png" alt></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882</a></p><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>判断当前字符为结尾的最长递增连续字符串的长度。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt; s[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans[i] = ans[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Longest-Progression"><a href="#Longest-Progression" class="headerlink" title="Longest Progression"></a>Longest Progression</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/04/21/r1f43nB5j2SHFYo.png" alt></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a3a5" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a3a5</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>在最多只能改变一个元素的情况下，求连续最长的等差序列的长度。典型的滑动窗口，跟力扣的某个题目非常像。我们设<code>left[i]</code>为以第<code>i</code>个元素为结尾的最长连续等差序列的长度，<code>right[i]</code>为以第<code>i</code>个元素为开始的最长连续等差序列的长度，所以我们每次尝试改变第<code>i</code>个元素，然后进行前后可能的元素进行相连即可尝试得到最长的长度。</li><li>时间复杂度为$O(n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*left*/</span></span><br><span class="line">    left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    left[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] - arr[i<span class="number">-1</span>] == arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>])&#123;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    right[n<span class="number">-2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-3</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] - arr[i+<span class="number">1</span>] == arr[i+<span class="number">1</span>] - arr[i+<span class="number">2</span>])&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = max(ans, <span class="number">1</span> + right[<span class="number">1</span>]);</span><br><span class="line">    ans = max(ans,<span class="number">1</span> + left[n<span class="number">-2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        ans = n;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i+<span class="number">2</span>] - arr[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                    ans = max(ans,right[i+<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = max(ans,right[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n<span class="number">-2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i+<span class="number">2</span>] - arr[i+<span class="number">1</span>]) &amp;&amp; \</span><br><span class="line">                   arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + right[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i+<span class="number">2</span>] - arr[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                    ans = max(ans,right[i+<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = max(ans,right[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    ans = max(ans,left[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Consecutive-Primes"><a href="#Consecutive-Primes" class="headerlink" title="Consecutive Primes"></a>Consecutive Primes</h2><p>给定数字<code>num</code>,求小等于<code>num</code>且刚好能够被分解为两个连续的质数的乘积的最大元素。</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a8e6" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a8e6</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先因为题目中限定了元素的大小，我们仔细推算一下，肯定只能由这三个连续的质数的组合，$p_{1} &lt; p_{2} &lt; \sqrt{num} &lt; p_{3}$,最终的结果要么为$p_{1}<em>p_{2}$,要么为$p_{2}</em>p_{3}$.</li><li>如果数据量非常小的话，我们直接用素数筛查法，即可求出所有的素数，但是因为本题中的数据量非常大，所以我们需要另辟蹊径。仔细查看一下数学知识，<a href="https://en.wikipedia.org/wiki/Prime_gap" target="_blank" rel="noopener">素数最大间隔</a>，根据题目中的判断，我们可以猜测两个素数之间的最大间隔也就在几百，所以我们此时就可以用暴力求解，然后同时可以利用素因子快速检测一个数是否为素数因为我们只需要检测$lg(lg(num))$范围的素因子即可。</li><li>时间复杂度计算还是太麻烦了，大概在$O(k*lg(lg(num)))$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">100006</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> h = <span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.size() &amp;&amp; prime[i] &lt;= h; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%prime[i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="comment">/*upper*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x+<span class="number">1</span>; i &lt; num ;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(i))&#123;</span><br><span class="line">            arr.push_back(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*lower*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt;= <span class="number">2</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(i))&#123;</span><br><span class="line">            arr.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(arr.size() &gt;= <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">0</span>]*arr[<span class="number">1</span>] &lt;= num)&#123;</span><br><span class="line">        ans = max(ans,arr[<span class="number">0</span>]*arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">1</span>]*arr[<span class="number">2</span>] &lt;= num)&#123;</span><br><span class="line">        ans = max(ans,arr[<span class="number">1</span>]*arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*find all prime*/</span></span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100005</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">        prime.push_back(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= <span class="number">100005</span>; j = j + i)&#123;</span><br><span class="line">            visit[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Truck-Delivery"><a href="#Truck-Delivery" class="headerlink" title="Truck Delivery"></a>Truck Delivery</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/04/21/TbHgtyqCvL2SI7M.png" alt></p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a885#problem" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a885#problem</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>线段树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>对于<code>test1</code>的数据集感觉一般人都能拿到分，无非是每次遇到查询，进行暴力检测路劲即可，即可得到所有可能的$GCD$的值，这个13分感觉很好难，时间复杂度为$O(N*Q)$.</li><li>对于第二个测试集则需要进行深入思考的深度，仔细发现一下，如果我们采用<code>dfs</code>遍历每一条路径时，如果所经历的路径已经按照<code>limit</code>进行排序好了，则我们可以很容易的利用二分查找即可在$O(lg(MAX(L)))$的时间复杂度内完成一次查询，如果需要这样进行查询的话则我们需要构造一种数据结构在$O(lg(MAX(L)))$的时间复杂度内完成这个查询。仔细思索一下我们可以构造线段树，线段树的长度为$(1,MAX(L))$,线段树的<code>key</code>为$L_{i}$,值为$V_{i}$,初始时设置$V_{i} = 0$.每次遇到查询$(C_{i},W_{i})$时，我们只需要查询$(1,W_{i})$范围的$gcd$即可。我们在遍历到某个节点时，则我们需要对线段树进行更新，每次更新$(L_{i},gcd(V_{i},C_{i}))$，每当我们从第$i$个节点退出时，则我们需要更新线段树的节点，需要将其节点的值从$gcd(V_{i},C_{i})$恢复到$V_{i}$.</li><li>时间复杂度为$O((2<em>N+Q)</em>lg(MAX(L)))$,空间复杂度为$O(MAX(L))$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>暴力解法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; graph(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; edgs(n,<span class="built_in">vector</span>&lt;pii&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x,y,l,a;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;l&gt;&gt;a;</span><br><span class="line">        x--;</span><br><span class="line">        y--;</span><br><span class="line">        graph[x].push_back(y);</span><br><span class="line">        graph[y].push_back(x);</span><br><span class="line">        edgs[x][y] = &#123;l,a&#125;;</span><br><span class="line">        edgs[y][x] = &#123;l,a&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; fa = <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bfs*/</span></span><br><span class="line">    qu.push(<span class="number">0</span>);</span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*neg*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">            visit[v] = <span class="literal">true</span>;</span><br><span class="line">            fa[v] = curr;</span><br><span class="line">            qu.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> c,w;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        c--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(c != <span class="number">0</span>)&#123;</span><br><span class="line">            pii curr = edgs[c][fa[c]];</span><br><span class="line">            <span class="keyword">if</span>(w &gt;= curr.first)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">0</span>) num = curr.second;</span><br><span class="line">                <span class="keyword">else</span> num = __gcd(num,curr.second);</span><br><span class="line">            &#125;</span><br><span class="line">            c = fa[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>线段树解法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> int32;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; gcd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> city;</span><br><span class="line">    <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> charge;</span><br><span class="line">    Edge(<span class="keyword">int</span> city,<span class="keyword">int</span> limit,<span class="keyword">long</span> <span class="keyword">long</span> charge)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;city = city;</span><br><span class="line">        <span class="keyword">this</span>-&gt;limit = limit;</span><br><span class="line">        <span class="keyword">this</span>-&gt;charge = charge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">200005</span>;</span><br><span class="line">SegTreeNode tree[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2 + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left = tree[CHL(idx)].gcd.back();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> right = tree[CHR(idx)].gcd.back();</span><br><span class="line">    tree[idx].gcd[<span class="number">0</span>] = __gcd(left,right);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].gcd.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(l,mid,CHL(idx));</span><br><span class="line">    buildTree(mid+<span class="number">1</span>,r,CHR(idx));</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">long</span> <span class="keyword">long</span> charge,<span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; tree[idx].l || x &gt; tree[idx].r ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == tree[idx].r &amp;&amp; tree[idx].l == x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(add == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//向当前节点加入一个新值</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val = tree[idx].gcd.back();</span><br><span class="line">            tree[idx].gcd.push_back(__gcd(val,charge));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(add == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//弹出最后一个值</span></span><br><span class="line">            tree[idx].gcd.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        updateTree(CHL(idx),x,charge,add);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        updateTree(CHR(idx),x,charge,add);</span><br><span class="line">    &#125;</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w &lt; tree[idx].l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == tree[idx].r &amp;&amp; tree[idx].r &lt;= w)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].gcd.back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w &gt;= tree[idx].r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].gcd.back();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(w &lt;= mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> queryTree(CHL(idx),w);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(w &gt; mid)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> left = queryTree(CHL(idx),w);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> right = queryTree(CHR(idx),w);</span><br><span class="line">            <span class="keyword">return</span> __gcd(left,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp; res,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; &amp; graph,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; query)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[curr].size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = graph[curr][i].city;</span><br><span class="line">        <span class="keyword">int</span> limit = graph[curr][i].limit;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> charge = graph[curr][i].charge;</span><br><span class="line">        <span class="keyword">if</span>(visit[nx]) <span class="keyword">continue</span>;</span><br><span class="line">        visit[nx] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新当前的（L,C）</span></span><br><span class="line">        updateTree(<span class="number">1</span>,limit,charge,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : query[nx])&#123;</span><br><span class="line">            <span class="keyword">int</span> weight = v.first;</span><br><span class="line">            <span class="keyword">int</span> idx = v.second;</span><br><span class="line">            res[idx] = queryTree(<span class="number">1</span>,weight);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nx,visit,res,graph,query);</span><br><span class="line">        <span class="comment">//删除当前的边</span></span><br><span class="line">        updateTree(<span class="number">1</span>,limit,charge,<span class="number">-1</span>);</span><br><span class="line">        visit[nx] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;    </span><br><span class="line">    <span class="comment">/*input the value*/</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&gt;&gt; graph(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; query(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        int64 x,y,l,a;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;l&gt;&gt;a;</span><br><span class="line">        x--;</span><br><span class="line">        y--;</span><br><span class="line">        graph[x].push_back(Edge(y,l,a));</span><br><span class="line">        graph[y].push_back(Edge(x,l,a));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> c,w;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        c--;</span><br><span class="line">        <span class="comment">//按照城市将所有的查询进行分类</span></span><br><span class="line">        query[c].push_back(&#123;w,i&#125;);     </span><br><span class="line">    &#125;</span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*dfs every node*/</span></span><br><span class="line">    dfs(<span class="number">0</span>,visit,ans,graph,query);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    buildTree(<span class="number">0</span>,<span class="number">200001</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;google-kick-start-2021-roundB&quot;&gt;&lt;a href=&quot;#google-kick-start-2021-roundB&quot; class=&quot;headerlink&quot; title=&quot;google kick start 2021 roundB&quot;&gt;&lt;/a&gt;google kick start 2021 roundB&lt;/h1&gt;&lt;p&gt;&lt;code&gt;google kickstart&lt;/code&gt;的题目质量很高，虽然比不上竞赛的难度，但是都是非常有思考的题目。&lt;br&gt;还是把题解仔细的写一遍，非常喜欢这类型的题目。&lt;/p&gt;&lt;h2 id=&quot;Increasing-Substring&quot;&gt;&lt;a href=&quot;#Increasing-Substring&quot; class=&quot;headerlink&quot; title=&quot;Increasing Substring&quot;&gt;&lt;/a&gt;Increasing Substring&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/04/21/2z4NiBxDXLouK5W.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="kickstart" scheme="http://yoursite.com/tags/kickstart/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly  Contest 50</title>
    <link href="http://yoursite.com/2021/04/18/274/"/>
    <id>http://yoursite.com/2021/04/18/274/</id>
    <published>2021-04-18T03:36:35.107Z</published>
    <updated>2021-04-18T04:56:44.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-50"><a href="#leetcode-biweekly-contest-50" class="headerlink" title="leetcode  biweekly  contest 50"></a>leetcode  biweekly  contest 50</h1><p>还是三道题的节奏，前三题基本上都是简单题，不到15分钟搞定前三题，最后一题又难度特别高，感觉就是比手速。<br><img src="https://i.loli.net/2021/04/18/zubn7aMx1DEXHos.png" alt></p><h2 id="5717-最少操作使数组递增"><a href="#5717-最少操作使数组递增" class="headerlink" title="5717. 最少操作使数组递增"></a>5717. 最少操作使数组递增</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>（下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。</p><a id="more"></a><p>比方说，如果 <code>nums = [1,2,3]</code> ，你可以选择增加 <code>nums[1]</code> 得到 <code>nums = [1,3,3]</code>。<br>请你返回使 <code>nums</code> 严格递增 的 最少 操作次数。</p><p>我们称数组 <code>nums</code> 是 严格递增的 ，当它满足对于所有的 <code>0 &lt;= i &lt; nums.length - 1</code> 都有 <code>nums[i] &lt; nums[i+1]</code> 。一个长度为 1 的数组是严格递增的一种特殊情况。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以进行如下操作：</span><br><span class="line"><span class="number">1</span>) 增加 nums[<span class="number">2</span>] ，数组变为 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] 。</span><br><span class="line"><span class="number">2</span>) 增加 nums[<span class="number">1</span>] ，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line"><span class="number">3</span>) 增加 nums[<span class="number">2</span>] ，数组变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-increasing" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-increasing</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  贪心算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>每次最多递增到前一个数字加1即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = max(nums[i],nums[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">            ans += x - nums[i];</span><br><span class="line">            nums[i] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5718-统计一个圆中点的数目"><a href="#5718-统计一个圆中点的数目" class="headerlink" title="5718. 统计一个圆中点的数目"></a>5718. 统计一个圆中点的数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> ，表示第 i 个点在二维平面上的坐标。多个点可能会有 相同 的坐标。</p><p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [xj, yj, rj]</code> ，表示一个圆心在<code>(xj, yj)</code>且半径为 rj 的圆。</p><p>对于每一个查询 <code>queries[j]</code> ，计算在第 j 个圆 内 点的数目。如果一个点在圆的 边界上 ，我们同样认为它在圆 内 。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[j]</code>是第 j 个查询的答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">2</span>]], queries = [[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：所有的点和圆如上图所示。</span><br><span class="line">queries[<span class="number">0</span>] 是绿色的圆，queries[<span class="number">1</span>] 是红色的圆，queries[<span class="number">2</span>] 是蓝色的圆。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>]], queries = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：所有的点和圆如上图所示。</span><br><span class="line">queries[<span class="number">0</span>] 是绿色的圆，queries[<span class="number">1</span>] 是红色的圆，queries[<span class="number">2</span>] 是蓝色的圆，queries[<span class="number">3</span>] 是紫色的圆。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= points.length &lt;= 500</code></li><li><code>points[i].length == 2</code></li><li><code>0 &lt;= x​​​​​​i, y​​​​​​i &lt;= 500</code></li><li><code>1 &lt;= queries.length &lt;= 500</code></li><li><code>queries[j].length == 3</code></li><li><code>0 &lt;= xj, yj &lt;= 500</code></li><li><code>1 &lt;= rj &lt;= 500</code></li><li>所有的坐标都是整数。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/queries-on-number-of-points-inside-a-circle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queries-on-number-of-points-inside-a-circle</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力解决即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>检查每一个点是否都在园内即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countPoints(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="built_in">abs</span>(points[j][<span class="number">0</span>] - queries[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> y = <span class="built_in">abs</span>(points[j][<span class="number">1</span>] - queries[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> r = queries[i][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>((x*x + y*y) &lt;= (r*r))&#123;</span><br><span class="line">                    ans[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5719-每个查询的最大异或值"><a href="#5719-每个查询的最大异或值" class="headerlink" title="5719. 每个查询的最大异或值"></a>5719. 每个查询的最大异或值</h2><p>给你一个 有序 数组 <code>nums</code> ，它由 n 个非负整数组成，同时给你一个整数 <code>maximumBit</code> 。你需要执行以下查询 n 次：</p><p>找到一个非负整数<code>k &lt; 2maximumBit</code> ，使得<code>nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k</code> 的结果 最大化 。k 是第 i 个查询的答案。<br>从当前数组 <code>nums</code> 删除 最后 一个元素。<br>请你返回一个数组 <code>answer</code>，其中 <code>answer[i]</code>是第 i 个查询的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>], maximumBit = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：查询的答案如下：</span><br><span class="line">第一个查询：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]，k = <span class="number">0</span>，因为 <span class="number">0</span> XOR <span class="number">1</span> XOR <span class="number">1</span> XOR <span class="number">3</span> XOR <span class="number">0</span> = <span class="number">3</span> 。</span><br><span class="line">第二个查询：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]，k = <span class="number">3</span>，因为 <span class="number">0</span> XOR <span class="number">1</span> XOR <span class="number">1</span> XOR <span class="number">3</span> = <span class="number">3</span> 。</span><br><span class="line">第三个查询：nums = [<span class="number">0</span>,<span class="number">1</span>]，k = <span class="number">2</span>，因为 <span class="number">0</span> XOR <span class="number">1</span> XOR <span class="number">2</span> = <span class="number">3</span> 。</span><br><span class="line">第四个查询：nums = [<span class="number">0</span>]，k = <span class="number">3</span>，因为 <span class="number">0</span> XOR <span class="number">3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], maximumBit = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">解释：查询的答案如下：</span><br><span class="line">第一个查询：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]，k = <span class="number">5</span>，因为 <span class="number">2</span> XOR <span class="number">3</span> XOR <span class="number">4</span> XOR <span class="number">7</span> XOR <span class="number">5</span> = <span class="number">7</span>。</span><br><span class="line">第二个查询：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，k = <span class="number">2</span>，因为 <span class="number">2</span> XOR <span class="number">3</span> XOR <span class="number">4</span> XOR <span class="number">2</span> = <span class="number">7</span> 。</span><br><span class="line">第三个查询：nums = [<span class="number">2</span>,<span class="number">3</span>]，k = <span class="number">6</span>，因为 <span class="number">2</span> XOR <span class="number">3</span> XOR <span class="number">6</span> = <span class="number">7</span> 。</span><br><span class="line">第四个查询：nums = [<span class="number">2</span>]，k = <span class="number">5</span>，因为 <span class="number">2</span> XOR <span class="number">5</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>], maximumBit = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>nums.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= maximumBit &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt; 2maximumBit</code></li><li><code>nums​​​</code> 中的数字已经按 升序 排好序。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-xor-for-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-xor-for-each-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们计算出当前数组异或的结果<code>x</code>，然后根据贪心法，如果<code>x</code>的第<code>i</code>位为<code>0</code>，我们则在符合<code>maximumBit</code>的范围内将第<code>i</code>位的值取为<code>1</code>即可，贪心原则取即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getMaximumXor(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> maximumBit) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) curr = curr^nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = maximumBit<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr&amp;(<span class="number">1</span>&lt;&lt;j)) <span class="keyword">continue</span>;</span><br><span class="line">                x += (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(x);</span><br><span class="line">            curr = curr^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5720-使字符串有序的最少操作次数"><a href="#5720-使字符串有序的最少操作次数" class="headerlink" title="5720. 使字符串有序的最少操作次数"></a>5720. 使字符串有序的最少操作次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>s</code>（下标从<code>0</code>开始）。你需要对 <code>s</code>执行以下操作直到它变为一个有序字符串：</p><ul><li>找到 最大下标 <code>i</code> ，使得 <code>1 &lt;= i &lt; s.length</code> 且 <code>s[i] &lt; s[i - 1]</code> 。</li><li>找到 最大下标 <code>j</code> ，使得 <code>i &lt;= j &lt; s.length</code> 且对于所有在闭区间 <code>[i, j]</code> 之间的 <code>k</code> 都有 <code>s[k] &lt; s[i - 1]</code> 。<br>交换下标为 <code>i - 1</code>​​​​ 和 <code>j</code>​​​​ 处的两个字符。<br>将下标 i 开始的字符串后缀反转。<br>请你返回将字符串变成有序的最少操作次数。由于答案可能会很大，请返回它对 <code>109 + 7</code> 取余 的结果。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"cba"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：模拟过程如下所示：</span><br><span class="line">操作 <span class="number">1</span>：i=<span class="number">2</span>，j=<span class="number">2</span>。交换 s[<span class="number">1</span>] 和 s[<span class="number">2</span>] 得到 s=<span class="string">"cab"</span> ，然后反转下标从 <span class="number">2</span> 开始的后缀字符串，得到 s=<span class="string">"cab"</span> 。</span><br><span class="line">操作 <span class="number">2</span>：i=<span class="number">1</span>，j=<span class="number">2</span>。交换 s[<span class="number">0</span>] 和 s[<span class="number">2</span>] 得到 s=<span class="string">"bac"</span> ，然后反转下标从 <span class="number">1</span> 开始的后缀字符串，得到 s=<span class="string">"bca"</span> 。</span><br><span class="line">操作 <span class="number">3</span>：i=<span class="number">2</span>，j=<span class="number">2</span>。交换 s[<span class="number">1</span>] 和 s[<span class="number">2</span>] 得到 s=<span class="string">"bac"</span> ，然后反转下标从 <span class="number">2</span> 开始的后缀字符串，得到 s=<span class="string">"bac"</span> 。</span><br><span class="line">操作 <span class="number">4</span>：i=<span class="number">1</span>，j=<span class="number">1</span>。交换 s[<span class="number">0</span>] 和 s[<span class="number">1</span>] 得到 s=<span class="string">"abc"</span> ，然后反转下标从 <span class="number">1</span> 开始的后缀字符串，得到 s=<span class="string">"acb"</span> 。</span><br><span class="line">操作 <span class="number">5</span>：i=<span class="number">2</span>，j=<span class="number">2</span>。交换 s[<span class="number">1</span>] 和 s[<span class="number">2</span>] 得到 s=<span class="string">"abc"</span> ，然后反转下标从 <span class="number">2</span> 开始的后缀字符串，得到 s=<span class="string">"abc"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabaa"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：模拟过程如下所示：</span><br><span class="line">操作 <span class="number">1</span>：i=<span class="number">3</span>，j=<span class="number">4</span>。交换 s[<span class="number">2</span>] 和 s[<span class="number">4</span>] 得到 s=<span class="string">"aaaab"</span> ，然后反转下标从 <span class="number">3</span> 开始的后缀字符串，得到 s=<span class="string">"aaaba"</span> 。</span><br><span class="line">操作 <span class="number">2</span>：i=<span class="number">4</span>，j=<span class="number">4</span>。交换 s[<span class="number">3</span>] 和 s[<span class="number">4</span>] 得到 s=<span class="string">"aaaab"</span> ，然后反转下标从 <span class="number">4</span> 开始的后缀字符串，得到 s=<span class="string">"aaaab"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"cdbea"</span></span><br><span class="line">输出：<span class="number">63</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcodeleetcodeleetcode"</span></span><br><span class="line">输出：<span class="number">982157772</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 3000</code></li><li><code>s</code>​ 只包含小写英文字母。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-string-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-string-sorted</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目非常考验思考的深度，仔细思考如果满足在某处最大值使得$s[i-1] &gt; s[i]….s[j]$，则我们肯定可以得到以下推论：</li></ol><ul><li>首先字符是从<code>i</code>后满足递增：<script type="math/tex; mode=display">s[i] \le s[i+1] \le s[i+2] ...s[j-1] \le s[j] \le s[j+1] ... s[n-2] \le s[n-1]</script></li><li>我们将$s[i]$与$s[j]$进行交换后，从<code>i</code>以后的序列仍然满足递增：<script type="math/tex; mode=display">s[i] \le s[i+1] \le s[i+2] ...s[j-1] \le s[i-1] \le s[j+1] ... s[n-2] \le s[n-1]</script></li></ul><ol><li>我们需要仔细分析一下，反转后的序列，<script type="math/tex; mode=display">s[n-1] \ge s[n-2] ... \ge s[j+1] \ge s[i-1] \ge s[j-1] ... s[i+2] \ge s[i+1] \ge s[i]</script>仔细思考一下，序列:<script type="math/tex; mode=display">t = (s[i-1],s[i],s[i+1] ,s[i+2] ...s[j-1],s[i-1],s[j+1] ... s[n-2],s[n-1]) \\s = (s[j],s[i+1],s[i+2],s[j-1],s[j],s[j+1],s[n-2],s[n-1]) \\</script>经过一变换后的序列$s$刚好是原字符串序列$t$按照字典序从大到小排列的下一个更小的序列，我们最终需要将整个字符串变换为字典序最小的序列。此时我们只需要计算从最小的序列递增到当前的序列需要经过多少步即可。但是实际这个变换还是非常难计算的，中间如果不涉及到重复的字符串，则非常容易计算，但是涉及到重复的字符串则稍微复杂许多，我们需要经过去重的操作。<br>题目的解答参考官方的解答，题目还是非常难的题目<a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-string-sorted/solution/shi-zi-fu-chuan-you-xu-de-zui-shao-cao-z-qgra/" target="_blank" rel="noopener">官方解答</a></li><li>乘法逆元的基本知识，证明过程还是非常复杂，但是记住两个重要的结论：</li></ol><ul><li>$a$在质数$m$的乘法逆元为：<script type="math/tex; mode=display">a \quad mod \quad m \neq 0 \\(a*a^{-1}) \quad mod \quad m = 1 \\a^{-1} = a^{m-2}</script></li><li>$(\frac{a}{b})\quad mod \quad m$可以利用乘法逆元进行等价变换为：<script type="math/tex; mode=display">(\frac{a}{b})\quad mod \quad m = (a*b^{-1})\quad mod \quad m \\= (a*b^{m-2})\quad mod \quad m \\\frac{a}{\prod_{i=1}^{n}b_{i}}\quad mod \quad m = (a*\prod_{i=1}^{n}b_{i}^{-1}) \quad mod \quad m\\= (a*\prod_{i=1}^{n}b_{i}^{m-2})\quad mod \quad m</script></li></ul></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 快速幂，用来计算 x^y mod m</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickmul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>, mul = x;</span><br><span class="line">        <span class="keyword">while</span> (y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ret = (LL)ret * mul % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            mul = (LL)mul * mul % mod;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeStringSorted</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fac[i] 表示 i! mod m</span></span><br><span class="line">        <span class="comment">// facinv[i] 表示 i! 在 mod m 意义下的乘法逆元</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fac(n + <span class="number">1</span>), facinv(n + <span class="number">1</span>);</span><br><span class="line">        fac[<span class="number">0</span>] = facinv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fac[i] = (LL)fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">            <span class="comment">// 使用费马小定理 + 快速幂计算乘法逆元</span></span><br><span class="line">            facinv[i] = quickmul(fac[i], mod - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// freq 存储每个字符出现的次数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; freq(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">            ++freq[ch - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// rank 求出比 s[i] 小的字符数量</span></span><br><span class="line">            <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i] - <span class="string">'a'</span>; ++j) &#123;</span><br><span class="line">                rank += freq[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 排列个数的分子</span></span><br><span class="line">            <span class="keyword">int</span> cur = (LL)rank * fac[n - i - <span class="number">1</span>] % mod;</span><br><span class="line">            <span class="comment">// 依次乘分母每一项阶乘的乘法逆元</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                cur = (LL)cur * facinv[freq[j]] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + cur) % mod;</span><br><span class="line">            --freq[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-50&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-50&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly  contest 50&quot;&gt;&lt;/a&gt;leetcode  biweekly  contest 50&lt;/h1&gt;&lt;p&gt;还是三道题的节奏，前三题基本上都是简单题，不到15分钟搞定前三题，最后一题又难度特别高，感觉就是比手速。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/04/18/zubn7aMx1DEXHos.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5717-最少操作使数组递增&quot;&gt;&lt;a href=&quot;#5717-最少操作使数组递增&quot; class=&quot;headerlink&quot; title=&quot;5717. 最少操作使数组递增&quot;&gt;&lt;/a&gt;5717. 最少操作使数组递增&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;（下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 237</title>
    <link href="http://yoursite.com/2021/04/18/275/"/>
    <id>http://yoursite.com/2021/04/18/275/</id>
    <published>2021-04-18T02:20:45.849Z</published>
    <updated>2021-04-18T11:45:12.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-237"><a href="#leetcode-contest-237" class="headerlink" title="leetcode  contest 237"></a>leetcode  contest 237</h1><p>本周周赛的题目都是考验手速，最后一道<code>hard</code>题目可以算是中等难度,感觉就是拼手速。<br><img src="https://i.loli.net/2021/04/18/n9wsAmVWiE6TNKr.png" alt></p><h2 id="5734-判断句子是否为全字母句"><a href="#5734-判断句子是否为全字母句" class="headerlink" title="5734. 判断句子是否为全字母句"></a>5734. 判断句子是否为全字母句</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>全字母句 指包含英语字母表中每个字母至少一次的句子。</p><p>给你一个仅由小写英文字母组成的字符串 <code>sentence</code> ，请你判断 <code>sentence</code> 是否为 全字母句 。</p><a id="more"></a><p>如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"thequickbrownfoxjumpsoverthelazydog"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="keyword">sentence</span> 包含英语字母表中每个字母至少一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 1000</code></li><li><code>sentence</code> 由小写英语字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-237/problems/check-if-the-sentence-is-pangram/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-237/problems/check-if-the-sentence-is-pangram/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>统计<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfPangram</span><span class="params">(<span class="built_in">string</span> A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : A) cnt.insert(c);</span><br><span class="line">        <span class="keyword">return</span> cnt.size() == <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5735-雪糕的最大数量"><a href="#5735-雪糕的最大数量" class="headerlink" title="5735. 雪糕的最大数量"></a>5735. 雪糕的最大数量</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>夏日炎炎，小男孩 <code>Tony</code> 想买一些雪糕消消暑。</p><p>商店中新到 <code>n</code> 支雪糕，用长度为 n 的数组 <code>costs</code> 表示雪糕的定价，其中 <code>costs[i]</code> 表示第 i 支雪糕的现金价格。<code>Tony</code> 一共有 <code>coins</code> 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 <code>costs</code> 和现金量 <code>coins</code> ，请你计算并返回 <code>Tony</code> 用 <code>coins</code> 现金能够买到的雪糕的 最大数量 。</p><p>注意：<code>Tony</code> 可以按任意顺序购买雪糕。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：costs = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>], coins = <span class="number">7</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：Tony 可以买下标为 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">4</span> 的雪糕，总价为 <span class="number">1</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：costs = [<span class="number">10</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>], coins = <span class="number">5</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：Tony 没有足够的钱买任何一支雪糕。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：costs = [<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>], coins = <span class="number">20</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：Tony 可以买下所有的雪糕，总价为 <span class="number">1</span> + <span class="number">6</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">5</span> = <span class="number">18</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>costs.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= costs[i] &lt;= 105</code></li><li><code>1 &lt;= coins &lt;= 108</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-237/problems/maximum-ice-cream-bars/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-237/problems/maximum-ice-cream-bars/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>按照价格从高到底排列即可，依次购买所能达到的最大数量。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = costs.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(costs.begin(),costs.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coins &gt;= costs[i])&#123;</span><br><span class="line">                coins -= costs[i];</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5736-单线程-CPU"><a href="#5736-单线程-CPU" class="headerlink" title="5736. 单线程 CPU"></a>5736. 单线程 CPU</h2><p>给你一个二维数组 <code>tasks</code> ，用于表示 n​​​​​​ 项从 0 到 n - 1 编号的任务。其中 <code>tasks[i] = [enqueueTimei, processingTimei]</code>意味着第 i​​​​​​​​​​ 项任务将会于 <code>enqueueTimei</code> 时进入任务队列，需要 <code>processingTimei</code> 的时长完成执行。</p><p>现有一个单线程 <code>CPU</code>，同一时间只能执行 最多一项 任务，该 <code>CPU</code>将会按照下述方式运行：</p><ul><li>如果 <code>CPU</code> 空闲，且任务队列中没有需要执行的任务，则 <code>CPU</code> 保持空闲状态。</li><li>如果 <code>CPU</code> 空闲，但任务队列中有需要执行的任务，则 <code>CPU</code> 将会选择 执行时间最短 的任务开始执行。</li><li>如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li><li>一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。</li><li><code>CPU</code> 可以在完成一项任务后，立即开始执行一项新任务。<br>返回 CPU 处理任务的顺序。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：事件按下述流程运行： </span><br><span class="line">- time = <span class="number">1</span> ，任务 <span class="number">0</span> 进入任务队列，可执行任务项 = &#123;<span class="number">0</span>&#125;</span><br><span class="line">- 同样在 time = <span class="number">1</span> ，空闲状态的 CPU 开始执行任务 <span class="number">0</span> ，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = <span class="number">2</span> ，任务 <span class="number">1</span> 进入任务队列，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">3</span> ，任务 <span class="number">2</span> 进入任务队列，可执行任务项 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">- 同样在 time = <span class="number">3</span> ，CPU 完成任务 <span class="number">0</span> 并开始执行队列中用时最短的任务 <span class="number">2</span> ，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">4</span> ，任务 <span class="number">3</span> 进入任务队列，可执行任务项 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">- time = <span class="number">5</span> ，CPU 完成任务 <span class="number">2</span> 并开始执行队列中用时最短的任务 <span class="number">3</span> ，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">6</span> ，CPU 完成任务 <span class="number">3</span> 并开始执行任务 <span class="number">1</span> ，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = <span class="number">10</span> ，CPU 完成任务 <span class="number">1</span> 并进入空闲状态</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">7</span>,<span class="number">10</span>],[<span class="number">7</span>,<span class="number">12</span>],[<span class="number">7</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：事件按下述流程运行： </span><br><span class="line">- time = <span class="number">7</span> ，所有任务同时进入任务队列，可执行任务项  = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">- 同样在 time = <span class="number">7</span> ，空闲状态的 CPU 开始执行任务 <span class="number">4</span> ，可执行任务项 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">- time = <span class="number">9</span> ，CPU 完成任务 <span class="number">4</span> 并开始执行任务 <span class="number">3</span> ，可执行任务项 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">- time = <span class="number">13</span> ，CPU 完成任务 <span class="number">3</span> 并开始执行任务 <span class="number">2</span> ，可执行任务项 = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">18</span> ，CPU 完成任务 <span class="number">2</span> 并开始执行任务 <span class="number">0</span> ，可执行任务项 = &#123;<span class="number">1</span>&#125;</span><br><span class="line">- time = <span class="number">28</span> ，CPU 完成任务 <span class="number">0</span> 并开始执行任务 <span class="number">1</span> ，可执行任务项 = &#123;&#125;</span><br><span class="line">- time = <span class="number">40</span> ，CPU 完成任务 <span class="number">1</span> 并进入空闲状态</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>tasks.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= enqueueTimei, processingTimei &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-xor-for-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-xor-for-each-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的优先级队列解法；</li><li>首先我们将队列按照入队时间进行排列。我们设置一个时间轴<code>enter</code>表示当前任务处理的起始时间，当前如果队列为空，或者当前任务的入队时间小于等于<code>CPU</code>的处理起始时间，我们则将任务进行入队等待操作；如果当前的任务的起始时间大于<code>CPU</code>的处理任务时间，则我们必须将任务从已有队列中移出，直到<code>CPU</code>的处理任务的起始时间大于等于当前任务的入队时间。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> start,<span class="keyword">int</span> cost)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;idx = idx;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a,Node &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.cost == b.cost)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.idx &gt; b.idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = tasks.size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; arr;</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); ++i)&#123;</span><br><span class="line">            arr.push_back(Node(i,tasks[i][<span class="number">0</span>],tasks[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](Node &amp; a,Node &amp; b)&#123;</span><br><span class="line">           <span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> enter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(enter &lt; arr[i].start &amp;&amp; !pq.empty())&#123;</span><br><span class="line">                Node curr = pq.top();</span><br><span class="line">                pq.pop();</span><br><span class="line">                ans.push_back(curr.idx);</span><br><span class="line">                enter += curr.cost;</span><br><span class="line">            &#125;</span><br><span class="line">            enter = max(enter,arr[i].start);</span><br><span class="line">            pq.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            ans.push_back(curr.idx);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5737-所有数对按位与结果的异或和"><a href="#5737-所有数对按位与结果的异或和" class="headerlink" title="5737. 所有数对按位与结果的异或和"></a>5737. 所有数对按位与结果的异或和</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>列表的 异或和<code>（XOR sum）</code>指对所有元素进行按位 <code>XOR</code> 运算的结果。如果列表中仅有一个元素，那么其 异或和 就等于该元素。</p><p>例如，<code>[1,2,3,4]</code> 的 异或和 等于<code>1 XOR 2 XOR 3 XOR 4 = 4</code>，而 <code>[3]</code> 的 异或和 等于 3 。<br>给你两个下标 从 0 开始 计数的数组 arr1 和 arr2 ，两数组均由非负整数组成。</p><p>根据每个 <code>(i, j)</code>数对，构造一个由 <code>arr1[i] AND arr2[j]</code>（按位 AND 运算）结果组成的列表。其中 <code>0 &lt;= i &lt; arr1.length</code> 且 <code>0 &lt;= j &lt; arr2.length</code> 。</p><p>返回上述列表的 异或和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], arr2 = [<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：列表 = [<span class="number">1</span> AND <span class="number">6</span>, <span class="number">1</span> AND <span class="number">5</span>, <span class="number">2</span> AND <span class="number">6</span>, <span class="number">2</span> AND <span class="number">5</span>, <span class="number">3</span> AND <span class="number">6</span>, <span class="number">3</span> AND <span class="number">5</span>] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>] ，</span><br><span class="line">异或和 = <span class="number">0</span> XOR <span class="number">1</span> XOR <span class="number">2</span> XOR <span class="number">0</span> XOR <span class="number">2</span> XOR <span class="number">1</span> = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 = [<span class="number">12</span>], arr2 = [<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：列表 = [<span class="number">12</span> AND <span class="number">4</span>] = [<span class="number">4</span>] ，异或和 = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr1.length, arr2.length &lt;= 105</code></li><li><code>0 &lt;= arr1[i], arr2[j] &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-237/problems/find-xor-sum-of-all-pairs-bitwise-and/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-237/problems/find-xor-sum-of-all-pairs-bitwise-and/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目可以算是中等难度，我们仔细的需要思考如下某个数<code>num</code>：</li></ol><ul><li>如果$num$的第$i$位为<code>0</code>,则第<code>i</code>位<code>and</code>任何数的结果则都为<code>0</code>;</li><li>如果$num$的第$i$位为<code>1</code>,则第<code>i</code>位<code>and 1</code>的结果则都为<code>1</code>;</li><li>奇数个<code>1</code>的异或的结果为<code>1</code>，偶数个<code>1</code>异或的结果则为<code>0</code>;</li><li>我们可以求所出数组<code>arr1</code>的某个数$arr1[i]$的每一位与<code>arr2</code>的每一位进行<code>AND</code>之后再进行异或后的结果。</li></ul><ol><li>实际可以更简单的利用公式：<script type="math/tex; mode=display">(a\&b)\oplus (a\&c) = a\&(b\oplus c)</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = arr1.size();</span><br><span class="line">        <span class="keyword">int</span> l2 = arr2.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; ++i) x = x^arr1[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l2; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr2[i]&amp;(<span class="number">1</span>&lt;&lt;j)&amp;(x)) ans ^=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-237&quot;&gt;&lt;a href=&quot;#leetcode-contest-237&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 237&quot;&gt;&lt;/a&gt;leetcode  contest 237&lt;/h1&gt;&lt;p&gt;本周周赛的题目都是考验手速，最后一道&lt;code&gt;hard&lt;/code&gt;题目可以算是中等难度,感觉就是拼手速。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/04/18/n9wsAmVWiE6TNKr.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5734-判断句子是否为全字母句&quot;&gt;&lt;a href=&quot;#5734-判断句子是否为全字母句&quot; class=&quot;headerlink&quot; title=&quot;5734. 判断句子是否为全字母句&quot;&gt;&lt;/a&gt;5734. 判断句子是否为全字母句&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;全字母句 指包含英语字母表中每个字母至少一次的句子。&lt;/p&gt;&lt;p&gt;给你一个仅由小写英文字母组成的字符串 &lt;code&gt;sentence&lt;/code&gt; ，请你判断 &lt;code&gt;sentence&lt;/code&gt; 是否为 全字母句 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly  Contest 236</title>
    <link href="http://yoursite.com/2021/04/11/273/"/>
    <id>http://yoursite.com/2021/04/11/273/</id>
    <published>2021-04-11T05:38:01.505Z</published>
    <updated>2021-04-18T04:15:17.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-weekly-contest-236"><a href="#leetcode-weekly-contest-236" class="headerlink" title="leetcode weekly contest 236"></a>leetcode weekly contest 236</h1><p>还是三道题的节奏，周赛题目比季度赛的题目简单多了，最后一题实际可以用<code>bst</code>或者<code>set</code>均可。</p><h2 id="5726-数组元素积的符号"><a href="#5726-数组元素积的符号" class="headerlink" title="5726. 数组元素积的符号"></a>5726. 数组元素积的符号</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>已知函数 <code>signFunc(x)</code> 将会根据 x 的正负返回特定值：</p><ul><li>如果 <code>x</code> 是正数，返回 <code>1</code>。</li><li>如果 <code>x</code> 是负数，返回 <code>-1</code> 。</li><li>如果 <code>x</code> 是等于 <code>0</code> ，返回 <code>0</code> 。<br>给你一个整数数组 <code>nums</code> 。令 <code>product</code> 为数组 <code>nums</code> 中所有元素值的乘积。</li></ul><a id="more"></a><p>返回 <code>signFunc(product)</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：数组中所有值的乘积是 <span class="number">144</span> ，且 signFunc(<span class="number">144</span>) = <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：数组中所有值的乘积是 <span class="number">0</span> ，且 signFunc(<span class="number">0</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：数组中所有值的乘积是 <span class="number">-1</span> ，且 signFunc(<span class="number">-1</span>) = <span class="number">-1</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">-100</span> &lt;= nums[i] &lt;= <span class="number">100</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/sign-of-the-product-of-an-array</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   计算符号的个数即可</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 遇到第`k`个空格则推出即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">array</span>Sign(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        long long curr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; <span class="number">0</span>) curr = curr*(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">0</span>) curr = curr*<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5727-找出游戏的获胜者"><a href="#5727-找出游戏的获胜者" class="headerlink" title="5727. 找出游戏的获胜者"></a>5727. 找出游戏的获胜者</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第<code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code>，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。</p><p>游戏遵循如下规则：</p><ul><li>从第 1 名小伙伴所在位置 开始 。</li><li>沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li><li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li><li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。</li><li>否则，圈子中最后一名小伙伴赢得游戏。<br>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</li></ul><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：游戏运行步骤如下：</span><br><span class="line"><span class="number">1</span>) 从小伙伴 <span class="number">1</span> 开始。</span><br><span class="line"><span class="number">2</span>) 顺时针数 <span class="number">2</span> 名小伙伴，也就是小伙伴 <span class="number">1</span> 和 <span class="number">2</span> 。</span><br><span class="line"><span class="number">3</span>) 小伙伴 <span class="number">2</span> 离开圈子。下一次从小伙伴 <span class="number">3</span> 开始。</span><br><span class="line"><span class="number">4</span>) 顺时针数 <span class="number">2</span> 名小伙伴，也就是小伙伴 <span class="number">3</span> 和 <span class="number">4</span> 。</span><br><span class="line"><span class="number">5</span>) 小伙伴 <span class="number">4</span> 离开圈子。下一次从小伙伴 <span class="number">5</span> 开始。</span><br><span class="line"><span class="number">6</span>) 顺时针数 <span class="number">2</span> 名小伙伴，也就是小伙伴 <span class="number">5</span> 和 <span class="number">1</span> 。</span><br><span class="line"><span class="number">7</span>) 小伙伴 <span class="number">1</span> 离开圈子。下一次从小伙伴 <span class="number">3</span> 开始。</span><br><span class="line"><span class="number">8</span>) 顺时针数 <span class="number">2</span> 名小伙伴，也就是小伙伴 <span class="number">3</span> 和 <span class="number">5</span> 。</span><br><span class="line"><span class="number">9</span>) 小伙伴 <span class="number">5</span> 离开圈子。只剩下小伙伴 <span class="number">3</span> 。所以小伙伴 <span class="number">3</span> 是游戏的获胜者。</span><br></pre></td></tr></table></figure><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：小伙伴离开圈子的顺序：<span class="number">5</span>、<span class="number">4</span>、<span class="number">6</span>、<span class="number">2</span>、<span class="number">3</span> 。小伙伴 <span class="number">1</span> 是游戏的获胜者。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= n &lt;= 500</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 经典的约瑟夫环问题，可以利用公式或者直接模拟即可，因为本题数据量非常小，直接模拟即可，时间复杂度$O(n^{2})$即可解决。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheWinner</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p=(p+k)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5728-最少侧跳次数"><a href="#5728-最少侧跳次数" class="headerlink" title="5728. 最少侧跳次数"></a>5728. 最少侧跳次数</h2><p>给你一个长度为 <code>n</code> 的 <code>3</code>跑道道路 ，它总共包含<code>n + 1</code>个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。</p><p>给你一个长度为 <code>n + 1</code> 的数组 <code>obstacles</code>，其中 <code>obstacles[i]</code> （取值范围从 0 到 3）表示在点 i 处的 <code>obstacles[i]</code>跑道上有一个障碍。如果 <code>obstacles[i] == 0</code>，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。</p><p>比方说，如果 <code>obstacles[2] == 1</code> ，那么说明在点 2 处跑道 1 有障碍。<br>这只青蛙从点 i 跳到点 <code>i + 1</code>且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p><p>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。<br>这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。</p><p>注意：点 0 处和点 n 处的任一跑道都不会有障碍。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：最优方案如上图箭头所示。总共有 <span class="number">2</span> 次侧跳（红色箭头）。</span><br><span class="line">注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 <span class="number">2</span> 处所示）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：跑道 <span class="number">2</span> 没有任何障碍，所以不需要任何侧跳。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最优方案如上图所示。总共有 <span class="number">2</span> 次侧跳。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>obstacles.length == n + 1</code></li><li><code>1 &lt;= n &lt;= 5 * 105</code></li><li><code>0 &lt;= obstacles[i] &lt;= 3</code></li><li><code>obstacles[0] == obstacles[n] == 0</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-sideway-jumps" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-sideway-jumps</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的<code>dp</code>即可解决该问题，<code>dp[i][j]</code>表示到达第<code>i</code>跳第<code>j</code>个赛道时花费的最少跳数。<script type="math/tex; mode=display">dp[i][j] = min(dp[i-1][j],dp[i][j+1] + 1,dp[i][j+2] + 1)</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSideJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = obstacles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>,n+<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*initial*/</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(obstacles[i] != j) dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j)&#123;</span><br><span class="line">               <span class="keyword">if</span>(obstacles[i] != j)&#123;</span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">3</span>; ++k)&#123;</span><br><span class="line">                       dp[i][j] = min(dp[i][j],dp[i][k] + <span class="number">1</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *min_element(dp[n<span class="number">-1</span>].begin(),dp[n<span class="number">-1</span>].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5729-求出-MK-平均值"><a href="#5729-求出-MK-平均值" class="headerlink" title="5729. 求出 MK 平均值"></a>5729. 求出 MK 平均值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数 <code>m</code> 和 <code>k</code> ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 <code>MK</code> 平均值 。</p><p>MK 平均值 按照如下步骤计算：</p><p>如果数据流中的整数少于 <code>m</code> 个，<code>MK</code> 平均值 为 <code>-1</code> ，否则将数据流中最后 <code>m</code>个元素拷贝到一个独立的容器中。<br>从这个容器中删除最小的 k 个数和最大的 k 个数。<br>计算剩余元素的平均值，并 向下取整到最近的整数 。<br>请你实现 <code>MKAverage</code> 类：</p><ul><li><code>MKAverage(int m, int k)</code> 用一个空的数据流和两个整数 m 和 k 初始化 MKAverage 对象。</li><li><code>void addElement(int num)</code> 往数据流中插入一个新的元素 num 。</li><li><code>int calculateMKAverage()</code> 对当前的数据流计算并返回 MK 平均数 ，结果需 向下取整到最近的整数 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MKAverage"</span>, <span class="string">"addElement"</span>, <span class="string">"addElement"</span>, <span class="string">"calculateMKAverage"</span>, <span class="string">"addElement"</span>, <span class="string">"calculateMKAverage"</span>, <span class="string">"addElement"</span>, <span class="string">"addElement"</span>, <span class="string">"addElement"</span>, <span class="string">"calculateMKAverage"</span>]</span><br><span class="line">[[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>], [<span class="number">1</span>], [], [<span class="number">10</span>], [], [<span class="number">5</span>], [<span class="number">5</span>], [<span class="number">5</span>], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">-1</span>, null, <span class="number">3</span>, null, null, null, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MKAverage obj = new MKAverage(<span class="number">3</span>, <span class="number">1</span>); </span><br><span class="line">obj.addElement(<span class="number">3</span>);        <span class="comment">// 当前元素为 [3]</span></span><br><span class="line">obj.addElement(<span class="number">1</span>);        <span class="comment">// 当前元素为 [3,1]</span></span><br><span class="line">obj.calculateMKAverage(); <span class="comment">// 返回 -1 ，因为 m = 3 ，但数据流中只有 2 个元素</span></span><br><span class="line">obj.addElement(<span class="number">10</span>);       <span class="comment">// 当前元素为 [3,1,10]</span></span><br><span class="line">obj.calculateMKAverage(); <span class="comment">// 最后 3 个元素为 [3,1,10]</span></span><br><span class="line">                          <span class="comment">// 删除最小以及最大的 1 个元素后，容器为 [3]</span></span><br><span class="line">                          <span class="comment">// [3] 的平均值等于 3/1 = 3 ，故返回 3</span></span><br><span class="line">obj.addElement(<span class="number">5</span>);        <span class="comment">// 当前元素为 [3,1,10,5]</span></span><br><span class="line">obj.addElement(<span class="number">5</span>);        <span class="comment">// 当前元素为 [3,1,10,5,5]</span></span><br><span class="line">obj.addElement(<span class="number">5</span>);        <span class="comment">// 当前元素为 [3,1,10,5,5,5]</span></span><br><span class="line">obj.calculateMKAverage(); <span class="comment">// 最后 3 个元素为 [5,5,5]</span></span><br><span class="line">                          <span class="comment">// 删除最小以及最大的 1 个元素后，容器为 [5]</span></span><br><span class="line">                          <span class="comment">// [5] 的平均值等于 5/1 = 5 ，故返回 5</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>3 &lt;= m &lt;= 105</code></li><li><code>1 &lt;= k*2 &lt; m</code></li><li><code>1 &lt;= num &lt;= 105</code></li><li><code>addElement</code> 与 <code>calculateMKAverage</code> 总操作次数不超过 105 次。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-mk-average" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-mk-average</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p><code>BST</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>最简单直接的方法就是利用三个有序的<code>set</code>，分别存储最小的<code>k</code>个数，中间的<code>m-2*k</code>个数，最大的<code>k</code>个数，比赛时想到了用这种方法，但是没有写对。</li><li>每次更新时将最后一个元素删除，并同时加入新的元素，然后分别调整三个<code>set</code>使得其数量和大小关系达成符合条件要求即可。最大的收获时关于<code>multiset</code>的几种基本操作。</li></ol><ul><li><code>erase</code>的几种基本操作:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator position)</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function">iterator  <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>但是关键一点<code>erase</code>不支持<code>reverse_iterator</code>,这个是我第一次知道。<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position</span><br><span class="line">Iterator pointing <span class="built_in">to</span> <span class="keyword">a</span> single <span class="keyword">element</span> <span class="built_in">to</span> be removed <span class="built_in">from</span> <span class="keyword">the</span> multiset.</span><br><span class="line">Member types iterator <span class="keyword">and</span> const_iterator are bidirectional iterator types that point <span class="built_in">to</span> elements.</span><br><span class="line">erase postion支持对multiset中单个元素的删除</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val</span><br><span class="line">Value <span class="keyword">to</span> be removed <span class="keyword">from</span> the multiset. All elements with a value equivalent <span class="keyword">to</span> this are removed <span class="keyword">from</span> the container.</span><br><span class="line">Member<span class="built_in"> type </span>value_type is the<span class="built_in"> type </span>of the elements <span class="keyword">in</span> the container, defined <span class="keyword">in</span> multiset as an alias of its first template parameter (T).</span><br><span class="line">erase val则会将集合中所有等于val的元素全部删除</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">first</span>, <span class="keyword">last</span></span><br><span class="line">Iterators specifying <span class="keyword">a</span> range <span class="keyword">within</span> <span class="keyword">the</span> multiset container <span class="built_in">to</span> be removed: [<span class="keyword">first</span>,<span class="keyword">last</span>). i.e., <span class="keyword">the</span> range includes all <span class="keyword">the</span> elements between <span class="keyword">first</span> <span class="keyword">and</span> <span class="keyword">last</span>, including <span class="keyword">the</span> <span class="keyword">element</span> pointed <span class="keyword">by</span> <span class="keyword">first</span> but <span class="keyword">not</span> <span class="keyword">the</span> <span class="literal">one</span> pointed <span class="keyword">by</span> <span class="keyword">last</span>.</span><br><span class="line">Member types iterator <span class="keyword">and</span> const_iterator are bidirectional iterator types that point <span class="built_in">to</span> elements.</span><br><span class="line">erase val则会将集合中[<span class="keyword">first</span>, <span class="keyword">last</span>]的元素全部删除，支持范围删除</span><br></pre></td></tr></table></figure></li></ul><ol><li>线段树的版本最后花了点时间参考树状数组的解法写了出来，收获不少，可以将数组中的元素离散化，全部转换成对元素的统计，通过二分查找，我们找到从小到大排序中第<code>k</code>个元素$num_{k}$和第<code>m-k</code>个元素$num_{m-k}$，然后利用线段树求所有小于等于$num_{k}$的元素的和与所有小于等于$num_{m-k}$的元素和，然后求差即可得到第<code>k+1</code>个元素到第<code>m-k</code>个元素的和。解法非常巧妙，但是非常值得学习的解法。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MKAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m, k, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; lower, middle, upper;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    </span><br><span class="line">    MKAverage(<span class="keyword">int</span> m, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftLeft</span><span class="params">(<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&amp; l, <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        l.insert(*r.begin());</span><br><span class="line">        r.erase(r.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftRight</span><span class="params">(<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&amp; l, <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        r.insert(*l.rbegin());</span><br><span class="line">        l.erase(--l.end());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        nums.push(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lower.size() &amp;&amp; *lower.rbegin() &gt;= num) lower.insert(num);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(upper.size() &amp;&amp; *upper.begin() &lt;= num) upper.insert(num);</span><br><span class="line">        <span class="keyword">else</span> middle.insert(num), sum += num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(lower.size() &gt; k)&#123;</span><br><span class="line">            sum += *lower.rbegin();</span><br><span class="line">            shiftRight(lower, middle);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span>(upper.size() &gt; k)&#123;</span><br><span class="line">            sum += *upper.begin();</span><br><span class="line">            shiftLeft(middle, upper);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*erase the first element*/</span></span><br><span class="line">        <span class="keyword">if</span>(nums.size() &gt; m) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = nums.front(); </span><br><span class="line">            nums.pop();</span><br><span class="line">            <span class="keyword">if</span>(lower.find(d) != lower.end()) lower.erase(lower.find(d));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(middle.find(d) != middle.end()) middle.erase(middle.find(d)), sum -= d;</span><br><span class="line">            <span class="keyword">else</span> upper.erase(upper.find(d));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">while</span>(lower.size() &lt; k)&#123;</span><br><span class="line">                sum -= *middle.begin();</span><br><span class="line">                shiftLeft(lower, middle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(upper.size() &lt; k)&#123;</span><br><span class="line">                sum -= *middle.rbegin();</span><br><span class="line">                shiftRight(middle, upper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMKAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> sum / (m - <span class="number">2</span>*k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2 + 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line">segTreeNode tree[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    tree[idx].count = tree[CHL(idx)].count + tree[CHR(idx)].count;</span><br><span class="line">    tree[idx].sum = tree[CHL(idx)].sum + tree[CHR(idx)].sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[idx].count = arr[l];</span><br><span class="line">        tree[idx].sum = l*arr[l];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(l,mid,arr,CHL(idx));</span><br><span class="line">    buildTree(mid+<span class="number">1</span>,r,arr,CHR(idx));</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryCount</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt;= x) <span class="keyword">return</span> tree[idx].count;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryCount(l,mid,CHL(idx),x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryCount(l,mid,CHL(idx),x) + queryCount(mid+<span class="number">1</span>,r,CHR(idx),x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queryKth</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> kth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].count &lt; kth) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == tree[idx].r) <span class="keyword">return</span> tree[idx].l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = tree[CHL(idx)].count;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= kth)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryKth(CHL(idx),kth);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryKth(CHR(idx),kth -left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt;= x) <span class="keyword">return</span> tree[idx].sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> querySum(l,mid,CHL(idx),x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> querySum(l,mid,CHL(idx),x) + querySum(mid+<span class="number">1</span>,r,CHR(idx),x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">addTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt; x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == x &amp;&amp; tree[idx].r == x)&#123;</span><br><span class="line">        tree[idx].count += val;</span><br><span class="line">        tree[idx].sum += val*x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        addTree(CHL(idx),x,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        addTree(CHR(idx),x,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MKAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MKAverage(<span class="keyword">int</span> m, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">100001</span>);</span><br><span class="line">        buildTree(<span class="number">0</span>,<span class="number">100000</span>,arr,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        qu.push(num);</span><br><span class="line">        addTree(<span class="number">1</span>,num,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(qu.size() &gt; m)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            addTree(<span class="number">1</span>,x,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMKAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(qu.size() &lt; m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> lower = queryKth(<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">int</span> upper = queryKth(<span class="number">1</span>,m-k);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lsum = querySum(<span class="number">0</span>,<span class="number">100000</span>,<span class="number">1</span>,lower);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rsum = querySum(<span class="number">0</span>,<span class="number">100000</span>,<span class="number">1</span>,upper);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lcnt = queryCount(<span class="number">0</span>,<span class="number">100000</span>,<span class="number">1</span>,lower);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rcnt = queryCount(<span class="number">0</span>,<span class="number">100000</span>,<span class="number">1</span>,upper);</span><br><span class="line">        <span class="keyword">if</span>(lcnt &gt; k) lsum -= (lcnt-k)*lower;</span><br><span class="line">        <span class="keyword">if</span>(rcnt &gt; m-k) rsum -= (rcnt - (m-k))*upper;</span><br><span class="line">        <span class="keyword">return</span> (rsum-lsum)/(m<span class="number">-2</span>*k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MKAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MKAverage* obj = new MKAverage(m, k);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addElement(num);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;calculateMKAverage();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-weekly-contest-236&quot;&gt;&lt;a href=&quot;#leetcode-weekly-contest-236&quot; class=&quot;headerlink&quot; title=&quot;leetcode weekly contest 236&quot;&gt;&lt;/a&gt;leetcode weekly contest 236&lt;/h1&gt;&lt;p&gt;还是三道题的节奏，周赛题目比季度赛的题目简单多了，最后一题实际可以用&lt;code&gt;bst&lt;/code&gt;或者&lt;code&gt;set&lt;/code&gt;均可。&lt;/p&gt;&lt;h2 id=&quot;5726-数组元素积的符号&quot;&gt;&lt;a href=&quot;#5726-数组元素积的符号&quot; class=&quot;headerlink&quot; title=&quot;5726. 数组元素积的符号&quot;&gt;&lt;/a&gt;5726. 数组元素积的符号&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;已知函数 &lt;code&gt;signFunc(x)&lt;/code&gt; 将会根据 x 的正负返回特定值：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 是正数，返回 &lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 是负数，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;x&lt;/code&gt; 是等于 &lt;code&gt;0&lt;/code&gt; ，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;br&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。令 &lt;code&gt;product&lt;/code&gt; 为数组 &lt;code&gt;nums&lt;/code&gt; 中所有元素值的乘积。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  LCCUP 2021 团队赛</title>
    <link href="http://yoursite.com/2021/04/08/272/"/>
    <id>http://yoursite.com/2021/04/08/272/</id>
    <published>2021-04-08T14:22:38.256Z</published>
    <updated>2021-04-13T01:42:47.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-LCCUP-2021-团队赛"><a href="#leetcode-LCCUP-2021-团队赛" class="headerlink" title="leetcode  LCCUP 2021 团队赛"></a>leetcode  LCCUP 2021 团队赛</h1><h2 id="LCP-33-蓄水"><a href="#LCP-33-蓄水" class="headerlink" title="LCP 33. 蓄水"></a>LCP 33. 蓄水</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 <code>N</code>个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 <code>bucket[i]</code>。小扣有以下两种操作：</p><ul><li>升级水桶：选择任意一个水桶，使其容量增加为 <code>bucket[i]+1</code></li><li>蓄水：将全部水桶接满水，倒入各自对应的水缸<br>每个水缸对应最低蓄水量记作 <code>vat[i]</code>，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。</li></ul><a id="more"></a><p>注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bucket = [<span class="number">1</span>,<span class="number">3</span>], vat = [<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 次操作升级 bucket[<span class="number">0</span>]；</span><br><span class="line">第 <span class="number">2</span> ~ <span class="number">4</span> 次操作均选择蓄水，即可完成蓄水要求。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：bucket = [<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>], vat = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>输出：3<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 次操作均选择升级 bucket[<span class="number">1</span>]</span><br><span class="line">第 <span class="number">2</span>~<span class="number">3</span> 次操作选择蓄水，即可完成蓄水要求。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= bucket.length == vat.length &lt;= 100</code></li><li><code>0 &lt;= bucket[i], vat[i] &lt;= 10^4</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/o8SXZn" target="_blank" rel="noopener">https://leetcode-cn.com/problems/o8SXZn</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  贪心算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>最优策略肯定是我们将每个水桶升级到一定的重量，然后一起进行蓄水<code>n</code>次即可。</li><li>难点在于如何求得最终蓄水的次数，好在我们可以进行暴力，遍历所有可能的蓄水次数，在蓄水之前同时要升级水桶，如何求得升级的水桶：设总容量为$v$,蓄水次数为$n$,则我们知道桶的重量肯定最少需要为<script type="math/tex; mode=display">b \ge ⌈\frac{v}{n}⌉</script>依次我们需要升级桶的次数为$⌈\frac{v}{n}⌉ - b$，求出所有的升级次数即可再加上升级次数。</li><li>唯一需要注意的一点，需要剔除到容量为$0$的水池。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">storeWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bucket, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = vat.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> maxn = *max_element(vat.begin(),vat.end());</span><br><span class="line">        <span class="keyword">if</span>(maxn == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                curr += max(<span class="number">0</span>,(vat[j] + i <span class="number">-1</span>)/i - bucket[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans,curr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-34-二叉树染色"><a href="#LCP-34-二叉树染色" class="headerlink" title="LCP 34. 二叉树染色"></a>LCP 34. 二叉树染色</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>小扣有一个根结点为 <code>root</code> 的二叉树模型，初始所有结点均为白色，可以用蓝色染料给模型结点染色，模型的每个结点有一个 <code>val</code>价值。小扣出于美观考虑，希望最后二叉树上每个蓝色相连部分的结点个数不能超过<code>k</code>个，求所有染成蓝色的结点价值总和最大是多少？</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line"></span><br><span class="line">解释：结点 <span class="number">5</span>、<span class="number">3</span>、<span class="number">4</span> 染成蓝色，获得最大的价值 <span class="number">5</span>+<span class="number">3</span>+<span class="number">4</span>=<span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line"></span><br><span class="line">解释：结点 <span class="number">4</span>、<span class="number">3</span>、<span class="number">9</span> 染成蓝色，获得最大的价值 <span class="number">4</span>+<span class="number">3</span>+<span class="number">9</span>=<span class="number">16</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= k &lt;= 10</li><li>1 &lt;= val &lt;= 10000</li><li>1 &lt;= 结点数量 &lt;= 10000</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/er-cha-shu-ran-se-UGC" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-ran-se-UGC</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dfs</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的非常好，非常适合于面试题目，难度刚好始终，非常适合思考，写代码的难度不是很难。</li><li>设<code>dp(root,i)</code>表示以当前<code>root</code>为根节点，且包含根节点在内被染色的节点的个数为<code>i</code>的最大价值，我们即可传递下去：<script type="math/tex; mode=display">dp[root][i] = max(dp[root][i],dp[left][j] + 1 + dp[right][i-j])</script></li><li>还是非常有深度思考的<code>dfs</code>方案。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfs(TreeNode * root,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vl = dfs(root-&gt;left,k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vr = dfs(root-&gt;right,k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; k; ++j)&#123;</span><br><span class="line">                ans[i+j+<span class="number">1</span>] = max(ans[i+j+<span class="number">1</span>],root-&gt;val + vl[i] + vr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = max(ans[<span class="number">0</span>],vl[i] + vr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret = dfs(root,k);</span><br><span class="line">        <span class="keyword">return</span> *max_element(ret.begin(),ret.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-35-电动车游城市"><a href="#LCP-35-电动车游城市" class="headerlink" title="LCP 35. 电动车游城市"></a>LCP 35. 电动车游城市</h2><p>小明的电动车电量充满时可行驶距离为 <code>cnt</code>，每行驶 <code>1</code> 单位距离消耗 <code>1</code> 单位电量，且花费 <code>1</code> 单位时间。小明想选择电动车作为代步工具。地图上共有 <code>N</code> 个景点，景点编号为<code>0 ~ N-1</code>。他将地图信息以 [城市 <code>A</code>编号,城市 <code>B</code> 编号,两城市间距离] 格式整理在在二维数组<code>paths</code>，表示城市<code>A、B</code>间存在双向通路。初始状态，电动车电量为 <code>0</code>。每个城市都设有充电桩，<code>charge[i]</code> 表示第 <code>i</code>个城市每充 <code>1</code> 单位电量需要花费的单位时间。请返回小明最少需要花费多少单位时间从起点城市 <code>start</code> 抵达终点城市 <code>end</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>]], cnt = <span class="number">6</span>, start = <span class="number">1</span>, end = <span class="number">0</span>, charge = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">43</span></span><br><span class="line"></span><br><span class="line">解释：最佳路线为：<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">0</span>。</span><br><span class="line">在城市 <span class="number">1</span> 仅充 <span class="number">3</span> 单位电至城市 <span class="number">3</span>，然后在城市 <span class="number">3</span> 充 <span class="number">5</span> 单位电，行驶至城市 <span class="number">5</span>。</span><br><span class="line">充电用时共 <span class="number">3</span>*<span class="number">10</span> + <span class="number">5</span>*<span class="number">1</span>= <span class="number">35</span></span><br><span class="line">行驶用时 <span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span>，此时总用时最短 <span class="number">43</span>。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>]], cnt = <span class="number">8</span>, start = <span class="number">0</span>, end = <span class="number">2</span>, charge = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">38</span></span><br><span class="line"></span><br><span class="line">解释：最佳路线为：<span class="number">0</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>。</span><br><span class="line">城市 <span class="number">0</span> 充电 <span class="number">2</span> 单位，行驶至城市 <span class="number">4</span> 充电 <span class="number">8</span> 单位，行驶至城市 <span class="number">3</span> 充电 <span class="number">1</span> 单位，最终行驶至城市 <span class="number">2</span>。</span><br><span class="line">充电用时 <span class="number">4</span>*<span class="number">2</span>+<span class="number">2</span>*<span class="number">8</span>+<span class="number">3</span>*<span class="number">1</span> = <span class="number">27</span></span><br><span class="line">行驶用时 <span class="number">2</span>+<span class="number">5</span>+<span class="number">4</span> = <span class="number">11</span>，总用时最短 <span class="number">38</span>。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= paths.length &lt;= 200</code></li><li><code>paths[i].length == 3</code></li><li><code>2 &lt;= charge.length == n &lt;= 100</code></li><li><code>0 &lt;= path[i][0],path[i][1],start,end &lt; n</code></li><li><code>1 &lt;= cnt &lt;= 100</code></li><li><code>1 &lt;= path[i][2] &lt;= cnt</code></li><li><code>1 &lt;= charge[i] &lt;= 100</code></li><li>题目保证所有城市相互可以到达</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/DFPeFJ" target="_blank" rel="noopener">https://leetcode-cn.com/problems/DFPeFJ</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>dijistra</code>算法，我们设置<code>dp[i][x]</code>表示我们到达第<code>i</code>个城市后，剩余的电量为<code>x</code>时所花费的最小时间。</li><li>状态转移：当我们达到一个城市<code>i</code>且当前剩余电量为<code>x</code>时，次时我们需要计算下一个的状态转移：</li></ol><ul><li>要么我们继续停留在当前城市进行充电,我们可以遍历所有的可能，每充电<code>1</code>单位则记录一个状态；</li><li>要么我们选择开到另一个城市<code>j</code>，则此时存有的电量值应该能够满足开到另一个城市，$x \ge cost[i][j]$；</li></ul><ol><li>根据计算本程序的时间复杂度为$O(n<em>(C+m))$,空间复杂度为$O(n</em>m)$<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> e,<span class="keyword">int</span> cost)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;e = e;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a,Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">electricCarPlan</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths, <span class="keyword">int</span> cnt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; charge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = charge.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INF;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cnt+<span class="number">1</span>,INF));</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : paths)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(&#123;v[<span class="number">0</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pq.push(Node(start,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        dp[start][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*we find it reach to the end*/</span></span><br><span class="line">            <span class="keyword">if</span>(curr.x == end) <span class="keyword">return</span> curr.cost;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.x])&#123;</span><br><span class="line">                <span class="keyword">int</span> nx = v.first;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = v.second; i &lt;= cnt; ++i)&#123;</span><br><span class="line">                    <span class="keyword">int</span> add = max(<span class="number">0</span>,i-curr.e);</span><br><span class="line">                    <span class="keyword">int</span> cost = curr.cost + v.second + add*charge[curr.x];</span><br><span class="line">                    <span class="keyword">if</span>(dp[nx][i-v.second] &gt; cost)&#123;</span><br><span class="line">                        pq.push(Node(nx,i-v.second,cost));</span><br><span class="line">                        dp[nx][i-v.second] = cost;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-36-最多牌组数"><a href="#LCP-36-最多牌组数" class="headerlink" title="LCP 36. 最多牌组数"></a>LCP 36. 最多牌组数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>麻将的游戏规则中，共有两种方式凑成「一组牌」：</p><ul><li>顺子：三张牌面数字连续的麻将，例如 [4,5,6]</li><li>刻子：三张牌面数字相同的麻将，例如 [10,10,10]<br>给定若干数字作为麻将牌的数值（记作一维数组 <code>tiles</code>），请返回所给 <code>tiles</code> 最多可组成的牌组数。<br>注意：凑成牌组时，每张牌仅能使用一次。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：tiles = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：最多可以组合出 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 或者 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 其中一组牌。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：tiles = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：最多可以组合出 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 与 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 两组牌。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= tiles.length &lt;= 10^5</code></li><li><code>1 &lt;= tiles[i] &lt;= 10^9</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/Up5XYM" target="_blank" rel="noopener">https://leetcode-cn.com/problems/Up5XYM</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LCP-37-最小矩形面积"><a href="#LCP-37-最小矩形面积" class="headerlink" title="LCP 37. 最小矩形面积"></a>LCP 37. 最小矩形面积</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>二维平面上有 NN 条直线，形式为 <code>y = kx + b</code>，其中 <code>k、b</code>为整数 且 <code>k &gt; 0</code>。所有直线以 <code>[k,b]</code> 的形式存于二维数组 <code>lines</code> 中，不存在重合的两条直线。两两直线之间可能存在一个交点，最多会有$C^{2}n$个交点。我们用一个平行于坐标轴的矩形覆盖所有的交点，请问这个矩形最小面积是多少。若直线之间无交点、仅有一个交点或所有交点均在同一条平行坐标轴的直线上，则返回0。</p><p>注意：返回结果是浮点数，与标准答案 绝对误差或相对误差 在 10^-4 以内的结果都被视为正确结果</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：lines = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">48.00000</span></span><br><span class="line"></span><br><span class="line">解释：三条直线的三个交点为 (<span class="number">3</span>, <span class="number">9</span>) (<span class="number">1</span>, <span class="number">5</span>) 和 (<span class="number">-1</span>, <span class="number">-3</span>)。最小覆盖矩形左下角为 (<span class="number">-1</span>, <span class="number">-3</span>) 右上角为 (<span class="number">3</span>,<span class="number">9</span>)，面积为 <span class="number">48</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：lines = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0.00000</span></span><br><span class="line"></span><br><span class="line">解释：仅有一个交点 (<span class="number">-2</span>，<span class="number">-1</span>）</span><br></pre></td></tr></table></figure></p><p>限制：</p><ul><li><code>1 &lt;= lines.length &lt;= 10^5 且 lines[i].length == 2</code></li><li><code>1 &lt;= lines[0] &lt;= 10000</code></li><li><code>-10000 &lt;= lines[1] &lt;= 10000</code></li><li>与标准答案绝对误差或相对误差在 <code>10^-4</code> 以内的结果都被视为正确结果</li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-ju-xing-mian-ji" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-ju-xing-mian-ji</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>二分查找</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LCP-38-守卫城堡"><a href="#LCP-38-守卫城堡" class="headerlink" title="LCP 38. 守卫城堡"></a>LCP 38. 守卫城堡</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>城堡守卫游戏的胜利条件为使恶魔无法从出生点到达城堡。游戏地图可视作 <code>2*N</code>的方格图，记作字符串数组 <code>grid</code>，其中：</p><ul><li>“.” 表示恶魔可随意通行的平地；</li><li>“#” 表示恶魔不可通过的障碍物，玩家可通过在 平地 上设置障碍物，即将 “.” 变为 “#” 以阻挡恶魔前进；</li><li>“S” 表示恶魔出生点，将有大量的恶魔该点生成，恶魔可向上/向下/向左/向右移动，且无法移动至地图外；</li><li>“P” 表示瞬移点，移动到 “P” 点的恶魔可被传送至任意一个 “P” 点，也可选择不传送；</li><li>“C” 表示城堡。<br>然而在游戏中用于建造障碍物的金钱是有限的，请返回玩家最少需要放置几个障碍物才能获得胜利。若无论怎样放置障碍物均无法获胜，请返回 -1。</li></ul><p>注意：</p><p>地图上可能有一个或多个出生点<br>地图上有且只有一个城堡<br>示例 1<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [<span class="string">"S.C.P<span class="subst">#P</span>."</span>, <span class="string">".....#.S"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：至少需要放置三个障碍物</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [<span class="string">"SP<span class="subst">#P</span>..P<span class="subst">#PC</span>#.S"</span>, <span class="string">"..<span class="subst">#P</span>..P####.#"</span>]</span><br><span class="line"></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：无论怎样修筑障碍物，均无法阻挡最左侧出生的恶魔到达城堡位置</span><br></pre></td></tr></table></figure></p><p>示例 3：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [<span class="string">"SP#.C.<span class="subst">#PS</span>"</span>, <span class="string">"P.#...#.P"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：无需放置障碍物即可获得胜利</span><br></pre></td></tr></table></figure></p><p>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [<span class="string">"CP.#.P."</span>, <span class="string">"...S..S"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：至少需要放置 <span class="number">4</span> 个障碍物，示意图为放置方法之一</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>grid.length == 2</code></li><li><code>2 &lt;= grid[0].length == grid[1].length &lt;= 10^4</code></li><li><code>grid[i][j]</code> 仅包含字符 <code>&quot;.&quot;、&quot;#&quot;、&quot;C&quot;、&quot;P&quot;、&quot;S&quot;</code></li></ul><h3 id="地址-5"><a href="#地址-5" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/7rLGCR" target="_blank" rel="noopener">https://leetcode-cn.com/problems/7rLGCR</a></p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp或者最大流</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-LCCUP-2021-团队赛&quot;&gt;&lt;a href=&quot;#leetcode-LCCUP-2021-团队赛&quot; class=&quot;headerlink&quot; title=&quot;leetcode  LCCUP 2021 团队赛&quot;&gt;&lt;/a&gt;leetcode  LCCUP 2021 团队赛&lt;/h1&gt;&lt;h2 id=&quot;LCP-33-蓄水&quot;&gt;&lt;a href=&quot;#LCP-33-蓄水&quot; class=&quot;headerlink&quot; title=&quot;LCP 33. 蓄水&quot;&gt;&lt;/a&gt;LCP 33. 蓄水&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定 &lt;code&gt;N&lt;/code&gt;个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 &lt;code&gt;bucket[i]&lt;/code&gt;。小扣有以下两种操作：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;升级水桶：选择任意一个水桶，使其容量增加为 &lt;code&gt;bucket[i]+1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;蓄水：将全部水桶接满水，倒入各自对应的水缸&lt;br&gt;每个水缸对应最低蓄水量记作 &lt;code&gt;vat[i]&lt;/code&gt;，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Google】 Google</title>
    <link href="http://yoursite.com/2021/04/06/271/"/>
    <id>http://yoursite.com/2021/04/06/271/</id>
    <published>2021-04-06T05:05:05.749Z</published>
    <updated>2021-04-08T14:22:41.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-mock-view"><a href="#Google-mock-view" class="headerlink" title="Google mock view"></a>Google mock view</h1><p>前段时间做了一下<code>google</code>的<code>mock interview</code>,其中有道题目印象深刻。</p><h2 id="1-区间查询"><a href="#1-区间查询" class="headerlink" title="1. 区间查询"></a>1. 区间查询</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定长度为<code>n</code>的数组<code>A</code>，给定组数$[i,j]$，求以下结果:</p><script type="math/tex; mode=display">query(i,j) = \prod_{k=1}^{j-i+1}(A_{i+k-1}^{k})</script><p>所求结果对$10^{9} + 7$取模, 其中满足以下：</p><a id="more"></a><ul><li>$i \le j$</li><li>$1 \le n \le 10^{5}$</li><li>$0 \le A[i] \le 10^{9}$ <h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/truncate-sentence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/truncate-sentence</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>线段树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote></li></ul><ol><li>首先看到类似的求区间的数列我们首先想到的就是用线段树。我们首先用数学分解的方法来将公式进行分解和变换：<script type="math/tex; mode=display">A[i,j] = \prod_{k=i}^{j}(A_{k}^{k-i+1}) \\= \prod_{m=i}^{s-1}(A_{m}^{m+1-i}) * \prod_{n=s}^{j}(A_{n}^{n+1-i}) \\= \prod_{m=i}^{s-1}(A_{m}^{m+1-i}) * \prod_{n=s}^{j}(A_{n}^{n+1-s})*(\prod_{n=s}^{j}A_{n})^{s-i} \\</script>由上述变换我们就可以知道如何通过线段树对其进行分解，我们设线段树的每个非叶子节点，包含的范围为$(i,j)$,且包含两个值：<script type="math/tex; mode=display">prod_{(i,j)} = \prod_{k=i}^{j}A_{k}\\val_{(i,j)} = \prod_{k=i}^{j}A_{k}^{k+1-i}\\</script>有了上述变换以后我们可以知道线段树的变化，假如本次我们需要查询的区间为$(i,j)$,假设线段从$mid$处断开分为两个子节点，则我们可以知道如下的求和公式：<script type="math/tex; mode=display">prod_{(i,j)} = \prod_{k=i}^{j}A_{k} = \prod_{k=i}^{mid}A_{k}*\prod_{k=mid+1}^{j}A_{k} \\= prod_{(i,mid)}*prod_{(mid+1,j)} \\</script>而$val$可以变换如下：<script type="math/tex; mode=display">val_{(i,j)} = \prod_{k=i}^{j}A_{k}^{k+1-i} =  \prod_{k=i}^{mid}(A_{k}^{k+1-i}) * \prod_{k=mid+1}^{j}(A_{k}^{k+1-i}) \\=  \prod_{k=i}^{mid}(A_{k}^{k+1-i}) * \prod_{k=mid+1}^{j}(A_{k}^{k+1-(mid+1)})*(\prod_{k=mid+1}^{j}A_{k})^{mid+1-i} \\= val_{(i,mid)}*val_{(mid+1,j)}*(prod_{(mid+1,j)})^{mid+1-i}</script>根据以上变换，我们则可以轻易的用线段树可以在$lg(n)$的时间复杂度内求出所有的查询。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">2000000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> prod;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2+1)</span></span><br><span class="line">segTreeNode tree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i != <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ret = (ret*x)%mod;</span><br><span class="line">        x = (x*x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> d = mid - tree[idx].l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pl = tree[CHL(idx)].prod;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pr = tree[CHR(idx)].prod;</span><br><span class="line">    tree[idx].prod = pl*pr%MOD;</span><br><span class="line">    tree[idx].val = tree[CHL(idx)].val*tree[CHR(idx)].val*fastpow(pr,d,MOD)%MOD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].val = <span class="number">1</span>;</span><br><span class="line">    tree[idx].prod = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[idx].val = arr[l];</span><br><span class="line">        tree[idx].prod = arr[l];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(l,mid,arr,CHL(idx));</span><br><span class="line">    buildTree(mid+<span class="number">1</span>,r,arr,CHR(idx));</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; l || tree[idx].l &gt; r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tree[idx].l &amp;&amp;  tree[idx].r &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d = tree[idx].l - l;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].val*fastpow(tree[idx].prod,d,MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(l,r,CHR(idx));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(l,r,CHL(idx));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lval = queryTree(l,r,CHL(idx));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rval = queryTree(l,r,CHR(idx));</span><br><span class="line">        <span class="keyword">return</span> lval*rval%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    buildTree(<span class="number">0</span>,n<span class="number">-1</span>,arr,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l--;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;queryTree(l,r,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Google-mock-view&quot;&gt;&lt;a href=&quot;#Google-mock-view&quot; class=&quot;headerlink&quot; title=&quot;Google mock view&quot;&gt;&lt;/a&gt;Google mock view&lt;/h1&gt;&lt;p&gt;前段时间做了一下&lt;code&gt;google&lt;/code&gt;的&lt;code&gt;mock interview&lt;/code&gt;,其中有道题目印象深刻。&lt;/p&gt;&lt;h2 id=&quot;1-区间查询&quot;&gt;&lt;a href=&quot;#1-区间查询&quot; class=&quot;headerlink&quot; title=&quot;1. 区间查询&quot;&gt;&lt;/a&gt;1. 区间查询&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定长度为&lt;code&gt;n&lt;/code&gt;的数组&lt;code&gt;A&lt;/code&gt;，给定组数$[i,j]$，求以下结果:&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
query(i,j) = \prod_{k=1}^{j-i+1}(A_{i+k-1}^{k})&lt;/script&gt;&lt;p&gt;所求结果对$10^{9} + 7$取模, 其中满足以下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  LCCUP 2021</title>
    <link href="http://yoursite.com/2021/04/06/270/"/>
    <id>http://yoursite.com/2021/04/06/270/</id>
    <published>2021-04-06T00:39:47.905Z</published>
    <updated>2021-04-08T09:58:12.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-LCCUP-2021"><a href="#leetcode-LCCUP-2021" class="headerlink" title="leetcode  LCCUP 2021"></a>leetcode  LCCUP 2021</h1><p>总共5道题目，还是依旧三道题，后面两道题思考量确实很大，前三题基本上都是<code>mid</code>难度的题目。</p><h2 id="1-采购方案"><a href="#1-采购方案" class="headerlink" title="1. 采购方案"></a>1. 采购方案</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小力将 N 个零件的报价存于数组 <code>nums</code>。小力预算为 <code>target</code>，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</p><p>注意：答案需要以 <code>1e9 + 7 (1000000007)</code>为底取模，如：计算初始结果为：<code>1000000008</code>，请返回 <code>1</code></p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：预算内仅能购买 nums[<span class="number">0</span>] 与 nums[<span class="number">2</span>]。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：符合预算的采购方案如下：</span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line">nums[<span class="number">0</span>] + nums[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">nums[<span class="number">1</span>] + nums[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">nums[<span class="number">2</span>] + nums[<span class="number">3</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i], target &lt;= 10^5</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/truncate-sentence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/truncate-sentence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  两数求和问题，双指针或者二分查找</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的两数求和问题，常见的就是用双指针或者二分查找，在这里比较简单的是用双指针问题，固定一个较大的数<code>x</code>，查找用多少个数满足$x+y &lt; target$.</li><li>算法时间复杂度$O(nlgn)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; i &amp;&amp; nums[i] + nums[l] &lt;= target) l++;</span><br><span class="line">            <span class="keyword">if</span>(l == i) l--;</span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; nums[i] + nums[l] &gt; target) l--;</span><br><span class="line">            <span class="keyword">if</span>(l &gt;= <span class="number">0</span>) ans = (ans + l + <span class="number">1</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="2-乐团站位"><a href="#2-乐团站位" class="headerlink" title="2. 乐团站位"></a>2. 乐团站位</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>某乐团的演出场地可视作 <code>num * num</code> 的二维矩阵 <code>grid</code>（左上角坐标为 <code>[0,0]</code>)，每个位置站有一位成员。乐团共有 <code>9</code> 种乐器，乐器编号为 <code>1~9</code>，每位成员持有 <code>1</code> 个乐器。</p><p>为保证声乐混合效果，成员站位规则为：自 <code>grid</code> 左上角开始顺时针螺旋形向内循环以 <code>1，2，...，9</code>循环重复排列。例如当 <code>num = 5</code>时，站位如图所示</p><p>请返回位于场地坐标<code>[Xpos,Ypos]</code>的成员所持乐器编号。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">3</span>, Xpos = <span class="number">0</span>, Ypos = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">4</span>, Xpos = <span class="number">1</span>, Ypos = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= num &lt;= 10^9</code></li><li><code>0 &lt;= Xpos, Ypos &lt; num</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-the-users-active-minutes</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>思路很简单，我们首先找到该坐标属于从外往里数第几个正方形，然后属于该正方形中的第几个元素即可。<br><img src="https://i.loli.net/2021/04/06/uoGFLZHMPvskAn7.jpg" alt></li><li>第几圈我们仔细观察一下可以知道$level = min(x,y,num-1-x,num-1-y)$,第$level$个正方形的边长为$ edge = num - 2<em>level$,此时我们知道<code>level</code>以外的所有正方形的周长的综合为$sum = num</em>num - edge<em>edge$,此时我们知道从第<code>level</code>层的正方形的起始点应该为$num</em>num - edge*edge + 1$,此时我们在分别判断$(x,y)$按照顺时针旋转属于该正方形的第几条边即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orchestraLayout</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> xPos, <span class="keyword">int</span> yPos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> level = min(min(xPos,yPos),min(num-xPos<span class="number">-1</span>,num<span class="number">-1</span>-yPos));</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> edge  = num - <span class="number">2</span>*level;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = (<span class="keyword">long</span> <span class="keyword">long</span>)(num)*num - (<span class="keyword">long</span> <span class="keyword">long</span>)(edge)*edge;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*move to (0,0)*/</span></span><br><span class="line">        xPos -= level;</span><br><span class="line">        yPos -= level;</span><br><span class="line">        <span class="keyword">if</span>(xPos == <span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            curr += yPos + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(yPos == edge - <span class="number">1</span>)&#123; <span class="comment">// 2</span></span><br><span class="line">            curr += (edge <span class="number">-1</span>) + xPos + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xPos == edge - <span class="number">1</span>)&#123; <span class="comment">// 3</span></span><br><span class="line">            curr += (edge <span class="number">-1</span>)*<span class="number">2</span> + edge - yPos;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(yPos == <span class="number">0</span>)&#123; <span class="comment">// 4</span></span><br><span class="line">            curr += (edge <span class="number">-1</span>)*<span class="number">3</span> + edge - xPos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (curr%<span class="number">9</span>) == <span class="number">0</span> ? <span class="number">9</span> : (curr%<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-30-魔塔游戏"><a href="#LCP-30-魔塔游戏" class="headerlink" title="LCP 30. 魔塔游戏"></a>LCP 30. 魔塔游戏</h2><p>小扣当前位于魔塔游戏第一层，共有 <code>N</code> 个房间，编号为 <code>0 ~ N-1</code>。每个房间的补血道具/怪物对于血量影响记于数组<code>nums</code>，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；<code>0</code> 表示房间对血量无影响。</p><p>小扣初始血量为<code>1</code>，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 <code>-1</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">-250</span>,<span class="number">-60</span>,<span class="number">-140</span>,<span class="number">-50</span>,<span class="number">-50</span>,<span class="number">100</span>,<span class="number">150</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：初始血量为 <span class="number">1</span>。至少需要将 nums[<span class="number">3</span>] 调整至访问顺序末尾以满足要求。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-200</span>,<span class="number">-300</span>,<span class="number">400</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">解释：调整访问顺序也无法完成全部房间的访问。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/p0NxJO" target="_blank" rel="noopener">https://leetcode-cn.com/problems/p0NxJO</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>思考一下，如何才能满足能够通过这一层，我们将所有的伤害和血量增加加起来的和满足大于<code>0</code>则表示一定可以通过这一层，否则则表示我们不能通过这一层。</li><li>假如我们当前遇到血量不足时，我们最优策略应该即把伤害值最大的房间往后移，根据这个贪心策略，我们利用优先级的特性，每次将所有的伤害均进入优先级队列，穿越房间时，如果发现当前血量不足，则我们从队列弹出最大的伤害值，并将当前的血量进行恢复，一直回到当前的持有的血量大于<code>0</code>为止。</li><li>算法的时间复杂度为$O(nlgn)$.空间复杂度为$O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicTower</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            sum += v;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.push(-v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!pq.empty() &amp;&amp; sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    sum += pq.top();</span><br><span class="line">                    pq.pop();</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-31-变换的迷宫"><a href="#LCP-31-变换的迷宫" class="headerlink" title="LCP 31. 变换的迷宫"></a>LCP 31. 变换的迷宫</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>某解密游戏中，有一个 <code>N*M</code> 的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于 <code>(n-1,m-1)</code>位置。迷宫变化规律记录于 <code>maze</code>中，<code>maze[i]</code>表示 <code>i</code>时刻迷宫的地形状态，<code>&quot;.&quot;</code>表示可通行空地，<code>&quot;#&quot;</code> 表示陷阱。</p><p>地形图初始状态记作 <code>maze[0]</code>，此时小力位于起点 <code>(0,0)</code>。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。</p><p>小力背包有以下两个魔法卷轴（卷轴使用一次后消失）：</p><ul><li>临时消除术：将指定位置在下一个时刻变为空地；</li><li>永久消除术：将指定位置永久变为空地。<br>请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？</li></ul><p>注意： 输入数据保证起点和终点在所有时刻均为空地。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">".#."</span>,<span class="string">"#.."</span>],[<span class="string">"..."</span>,<span class="string">".#."</span>],[<span class="string">".##"</span>,<span class="string">".#."</span>],[<span class="string">"..#"</span>,<span class="string">".#."</span>]]</span><br><span class="line"></span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">解释：</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">".#."</span>,<span class="string">"..."</span>],[<span class="string">"..."</span>,<span class="string">"..."</span>]]</span><br><span class="line"></span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">解释：由于时间不够，小力无法到达终点逃出迷宫。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">"..."</span>,<span class="string">"..."</span>,<span class="string">"..."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>],[<span class="string">".##"</span>,<span class="string">"###"</span>,<span class="string">"##."</span>]]</span><br><span class="line"></span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">解释：由于道路不通，小力无法到达终点逃出迷宫。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= maze.length &lt;= 100</code></li><li><code>1 &lt;= maze[i].length, maze[i][j].length &lt;= 50</code></li><li><code>maze[i][j]</code> 仅包含 <code>&quot;.&quot;、&quot;#&quot;</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/Db3wC1" target="_blank" rel="noopener">https://leetcode-cn.com/problems/Db3wC1</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p><code>dfs</code>记忆式搜索。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本题的思考难度还是非常大的，难点在于如何处理永久将某一位置变为空地，假如我们直接设遍历所有的状态，则可能会超时。难点在于如何思考和优化，参考了一下第二名的代码，非常简洁。</li></ol><ul><li>对于临时消除的这个问题，非常好处理，设立一个标志位，表示当前是否可以进行临时消除即可。</li><li>对于永久消除的这个问题，我们最难思考的是，假设我们在某一个时刻$t_{0}$对坐标$(x,y)$进行了消除，则我们经历了$t_{1},t_{2},t_{3}…,t_{i}$跳跃了坐标$(x_{1},y_{1})，(x_{2},y_{2})，(x_{3},y_{3})…(x_{i},y_{i})，$后，我们又回到了坐标$(x,y)$,则此时我们如何判断$(x,y)$已经被永久消除，这个是最难的思考点。题解中给出的假设我们在$t_{0}$时候已经对坐标$(x,y)$进行了消除，我们在$t_{i}$时候刻后经历了其他不同的坐标后又回到原始坐标$(x,y)$,我们完全可以可以在一直$t_{1},t_{2},t_{3}…,t_{i}$一直呆在原始坐标$(x,y)$处，因此我们可以判断，假如它从永久消除的坐标$(x,y)$跳出后，就不会再跳回原始坐标$(x,y)$.</li><li>因此我们需要增设一个状态$usedStay$,如果$usedStay = 1$，表示我们已经用了永久消除当前可以一直停留在原地，如果$usedStay = 0$则表示为未用永久消除术或者用了永久消除但已经跳出释放永久消除的格子。</li></ul><ol><li>我们设$dp[t][x][y][tmpuse][alluse][usedstay]$表示在<code>t</code>时候到达坐标$(x,y)$,且手中持有的临时消除的次数为$tmpuse$,手中持有的永久消除的次数为$alluse$,当前的是否使用永久消除术且可以停留在原地的状态为$usedstay$.</li><li>时间复杂度为$O(n<em>row</em>col<em>2</em>2<em>2</em>4)$,在我们当前的数值的允许范围内可以完成全部搜索。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">51</span>][<span class="number">51</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> n,row,col;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; matrix;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> tmp_use,<span class="keyword">int</span> all_use,<span class="keyword">int</span> used_stay)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[t][x][y][tmp_use][all_use][used_stay]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        dp[t][x][y][tmp_use][all_use][used_stay] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t == n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*check if we can stay at the same positon (x,y) in the next time t+1*/</span></span><br><span class="line">        <span class="keyword">if</span>(used_stay || matrix[t+<span class="number">1</span>][x][y] == <span class="string">'.'</span>) </span><br><span class="line">            dfs(t+<span class="number">1</span>,x,y,tmp_use,all_use,used_stay);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*check if we can move to other position in the next time*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = x + d[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y1 = y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x1 &lt; <span class="number">0</span> || y1 &lt; <span class="number">0</span> || x1 &gt;= row || y1 &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[t+<span class="number">1</span>][x1][y1] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="comment">/*we just move to other postion (x1,y1)*/</span></span><br><span class="line">                dfs(t+<span class="number">1</span>,x1,y1,tmp_use,all_use,<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/*we use temple erase (x1,y1) at this time,the next time it can move to (x1,y1)*/</span></span><br><span class="line">                <span class="keyword">if</span>(tmp_use &gt; <span class="number">0</span>) dfs(t+<span class="number">1</span>,x1,y1,<span class="number">0</span>,all_use,<span class="number">0</span>);</span><br><span class="line">                <span class="comment">/*we use all erase (x1,y1) at this time, the next time it can move to (x1,y1) and it can stay at (x1,y1) all over the life*/</span></span><br><span class="line">                <span class="keyword">if</span>(all_use &gt; <span class="number">0</span>) dfs(t+<span class="number">1</span>,x1,y1,tmp_use,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">escapeMaze</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; maze)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = maze.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;row = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;col = maze[<span class="number">0</span>][<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;matrix = maze;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; ++l)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i][row<span class="number">-1</span>][col<span class="number">-1</span>][j][k][l]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-32-批量处理任务"><a href="#LCP-32-批量处理任务" class="headerlink" title="LCP 32. 批量处理任务"></a>LCP 32. 批量处理任务</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>某实验室计算机待处理任务以<code>[start,end,period]</code>格式记于二维数组 <code>tasks</code>，表示完成该任务的时间范围为起始时间 <code>start</code> 至结束时间 <code>end</code>之间，需要计算机投入 <code>period</code> 的时长，注意：</p><ul><li><code>period</code> 可为不连续时间</li><li>首尾时间均包含在内</li><li>处于开机状态的计算机可同时处理任意多个任务，请返回电脑最少开机多久，可处理完所有任务。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">tasks[<span class="number">0</span>] 选择时间点 <span class="number">2</span>、<span class="number">3</span>；</span><br><span class="line">tasks[<span class="number">1</span>] 选择时间点 <span class="number">2</span>、<span class="number">3</span>、<span class="number">5</span>；</span><br><span class="line">tasks[<span class="number">2</span>] 选择时间点 <span class="number">5</span>、<span class="number">6</span>；</span><br><span class="line">因此计算机仅需在时间点 <span class="number">2</span>、<span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span> 四个时刻保持开机即可完成任务。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">tasks[<span class="number">0</span>] 选择时间点 <span class="number">2</span> 或 <span class="number">3</span>；</span><br><span class="line">tasks[<span class="number">1</span>] 选择时间点 <span class="number">5</span>；</span><br><span class="line">tasks[<span class="number">2</span>] 选择时间点 <span class="number">5</span>、<span class="number">6</span>；</span><br><span class="line">因此计算机仅需在时间点 <span class="number">2</span>、<span class="number">5</span>、<span class="number">6</span> 或 <span class="number">3</span>、<span class="number">5</span>、<span class="number">6</span> 三个时刻保持开机即可完成任务。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= tasks.length &lt;= 10^5</code></li><li><code>tasks[i].length == 3</code></li><li><code>0 &lt;= tasks[i][0] &lt;= tasks[i][1] &lt;= 10^9</code></li><li><code>1 &lt;= tasks[i][2] &lt;= tasks[i][1]-tasks[i][0] + 1</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/t3fKg1" target="_blank" rel="noopener">https://leetcode-cn.com/problems/t3fKg1</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>贪心算法，线段树</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们可以知道每一个任务对应着一个线段，所有的运行时间点我们也可以看作为离散的线段，所谓的开机时间满足要求，只需要在线段范围$[l,r]$内运行的时间点组成的离散的小线段的总长度大于等于$period$即可，仔细分析一下，我们可以利用类似于差分数组的方法，我们按照任务的结束时间的先后顺序进行排序，每遇到一个任务结束的右端点$r_{i}$时，我们首先查询当前任务运行时间范围$[l_{i},r_{i}]$内已经运行的开机时间是否满足$period_{i}$,如果不满足，则我们从右端$r_{i}$向左开始在空闲的时间内依次添加开机时间直到$[l_{i},r_{i}]$范围的开机时间满足$period_{i}$即可。</li><li>我们可以用数组表示当前已经开机时间点离散小线段，比如$arr[i] = {l_{i},r_{i}}$表示当前在$[l_{i},r_{i}]$设备已经在开机运行，则此时该时间段内连续的运行时间即为$r_{i}-l_{i} + 1$，我们用前缀和$pre[i]$表示前<code>i</code>个开机运行线段的运行时间的总和.我们每次固定当前的右端点，然后利用二分查找和前缀和可以快速查找在$[l_{i},r_{i}]$范围内已经开机运行的时间的总和，然后即可求出当前任务中我们还需要再开机运行多长时间，依次进行叠加即可求出所满足要求，这个算法是参考@cuiaoxiang的，不过算法时间复杂度较高，时间复杂度感觉应该是$o(n^{2})$因为其中涉及到线段的合并的问题，但是实际上我们可以进行优化，最终结果是可以过测试用例的。</li><li>线段树，线段树的解法就复杂的多了，可以参考@restant的解法，写的实在太复杂，不过原理应该差不多。<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">processTasks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tasks.size();</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : tasks) v[<span class="number">0</span>]--;</span><br><span class="line">        sort(tasks.begin(),tasks.end(),[&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; used;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; n; i = j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*we find the most running time from task[i][1] which we need to add*/</span></span><br><span class="line">            <span class="keyword">for</span>(j = i; j &lt; n &amp;&amp; tasks[j][<span class="number">1</span>] == tasks[i][<span class="number">1</span>]; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> s = tasks[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> t = tasks[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> p = tasks[j][<span class="number">2</span>];</span><br><span class="line">                <span class="comment">/*search last segment greater than x*/</span></span><br><span class="line">                <span class="keyword">int</span> k = lower_bound(used.begin(),used.end(),pii&#123;s,<span class="number">0</span>&#125;) - used.begin();</span><br><span class="line">                <span class="keyword">int</span> m = used.size();</span><br><span class="line">                <span class="keyword">int</span> curr = pre[m] - pre[k];</span><br><span class="line">                <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; used[k<span class="number">-1</span>].second &gt;= s) curr += used[k<span class="number">-1</span>].second - s;</span><br><span class="line">                <span class="keyword">if</span>(p &gt; curr)  mx = max(mx,p-curr);</span><br><span class="line">            &#125;</span><br><span class="line">            ret += mx;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;mx&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(mx &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = tasks[i][<span class="number">1</span>]-mx;</span><br><span class="line">                <span class="keyword">int</span> y = tasks[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span>(used.size() &amp;&amp; used.back().second &gt;= x)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> [u,v] = used.back();</span><br><span class="line">                    used.pop_back();</span><br><span class="line">                    pre.pop_back();</span><br><span class="line">                    x = u - (v-x);</span><br><span class="line">                &#125;</span><br><span class="line">                used.push_back(&#123;x,y&#125;);</span><br><span class="line">                pre.push_back(pre.back() + y - x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (t&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs ((t&lt;&lt;1)|1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, p;</span><br><span class="line">&#125;a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NMB</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> add ,sum, id;</span><br><span class="line">&#125;tree[<span class="number">100005</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[ls].add += tree[t].add;</span><br><span class="line">tree[ls].sum += tree[t].add;</span><br><span class="line">tree[rs].add += tree[t].add;</span><br><span class="line">tree[rs].sum += tree[t].add;</span><br><span class="line">tree[t].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tree[ls].sum &lt; tree[rs].sum)</span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = tree[ls].sum;</span><br><span class="line">tree[t].id = tree[ls].id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = tree[rs].sum;</span><br><span class="line">tree[t].id = tree[rs].id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[t].add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) </span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = a[l].r - a[l].p + <span class="number">1</span>;</span><br><span class="line">tree[t].id = l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build_tree(l,mid,ls);</span><br><span class="line">build_tree(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> tree[t].sum;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">down(t);</span><br><span class="line"><span class="keyword">if</span> (ll&lt;=mid) <span class="keyword">return</span> find(ll,l,mid,ls);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> find(ll,mid+<span class="number">1</span>,r,rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[t].sum = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">down(t);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ll&lt;=mid) modify(ll,c,l,mid,ls);</span><br><span class="line"><span class="keyword">else</span> modify(ll,c,mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(t); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> rr,<span class="keyword">int</span> c,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr)</span><br><span class="line">&#123;</span><br><span class="line">tree[t].add += c;</span><br><span class="line">tree[t].sum += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">down(t);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ll &lt;= mid) change(ll,rr,c,l,mid,ls);</span><br><span class="line"><span class="keyword">if</span> (rr&gt;mid)  change(ll,rr,c,mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = n + <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;</span><br><span class="line">ans += R - L + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> ((l + r) &gt;&gt; <span class="number">1</span> != mid)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid].l &gt;= L) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r; a[i].l &lt;= R &amp;&amp; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p = find(i, <span class="number">1</span>, n, <span class="number">1</span>) + (R - a[i].l + <span class="number">1</span>); </span><br><span class="line">modify(i, p, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">1</span>) change(<span class="number">1</span>, r - <span class="number">1</span>, R - L + <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">processTasks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">n = tasks.size();</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ;++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i].l = tasks[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">a[i].r = tasks[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">a[i].p = tasks[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">build_tree(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = tree[<span class="number">1</span>].id;</span><br><span class="line"><span class="keyword">int</span> L = find(x, <span class="number">1</span>, n ,<span class="number">1</span>), R = a[x].r;</span><br><span class="line">Work(L,R);</span><br><span class="line">modify(x,(<span class="keyword">int</span>)<span class="number">1e9</span>,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-LCCUP-2021&quot;&gt;&lt;a href=&quot;#leetcode-LCCUP-2021&quot; class=&quot;headerlink&quot; title=&quot;leetcode  LCCUP 2021&quot;&gt;&lt;/a&gt;leetcode  LCCUP 2021&lt;/h1&gt;&lt;p&gt;总共5道题目，还是依旧三道题，后面两道题思考量确实很大，前三题基本上都是&lt;code&gt;mid&lt;/code&gt;难度的题目。&lt;/p&gt;&lt;h2 id=&quot;1-采购方案&quot;&gt;&lt;a href=&quot;#1-采购方案&quot; class=&quot;headerlink&quot; title=&quot;1. 采购方案&quot;&gt;&lt;/a&gt;1. 采购方案&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;小力将 N 个零件的报价存于数组 &lt;code&gt;nums&lt;/code&gt;。小力预算为 &lt;code&gt;target&lt;/code&gt;，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。&lt;/p&gt;&lt;p&gt;注意：答案需要以 &lt;code&gt;1e9 + 7 (1000000007)&lt;/code&gt;为底取模，如：计算初始结果为：&lt;code&gt;1000000008&lt;/code&gt;，请返回 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 49</title>
    <link href="http://yoursite.com/2021/04/04/268/"/>
    <id>http://yoursite.com/2021/04/04/268/</id>
    <published>2021-04-04T12:18:32.818Z</published>
    <updated>2021-04-05T15:17:52.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-49"><a href="#leetcode-biweekly-contest-49" class="headerlink" title="leetcode biweekly contest 49"></a>leetcode biweekly contest 49</h1><p>还是依旧三道题，最后一题的状态压缩<code>dp</code>确实非常难以想到。前三题非常简单，最后一题比较难。</p><h2 id="5705-判断国际象棋棋盘中一个格子的颜色"><a href="#5705-判断国际象棋棋盘中一个格子的颜色" class="headerlink" title="5705. 判断国际象棋棋盘中一个格子的颜色"></a>5705. 判断国际象棋棋盘中一个格子的颜色</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个坐标<code>coordinates</code>，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。<br>如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 <code>false</code>。<br>给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。</p><a id="more"></a><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coordinates</span> = <span class="string">"a1"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：如上图棋盘所示，<span class="string">"a1"</span> 坐标的格子是黑色的，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coordinates</span> = <span class="string">"h3"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：如上图棋盘所示，<span class="string">"h3"</span> 坐标的格子是白色的，所以返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">coordinates</span> = <span class="string">"c7"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>coordinates.length == 2</code></li><li><code>&#39;a&#39; &lt;= coordinates[0] &lt;= &#39;h&#39;</code></li><li><code>&#39;1&#39; &lt;= coordinates[1] &lt;= &#39;8&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/determine-color-of-a-chessboard-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/determine-color-of-a-chessboard-square</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>行号与列号的奇偶性相同时，则为黑色，否则则为白色。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">squareIsWhite</span><span class="params">(<span class="built_in">string</span> coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = coordinates[<span class="number">0</span>] - <span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = coordinates[<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>((x&amp;<span class="number">1</span>)^(y&amp;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5706-句子相似性-III"><a href="#5706-句子相似性-III" class="headerlink" title="5706. 句子相似性 III"></a>5706. 句子相似性 III</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>&quot;Hello World&quot; ，&quot;HELLO&quot; ，&quot;hello world hello world&quot;</code> 都是句子。每个单词都 只 包含大写和小写英文字母。</p><p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 相似的 。比方说，<code>sentence1 = &quot;Hello my name is Jane&quot;</code>且 <code>sentence2 = &quot;Hello Jane&quot;</code> ，我们可以往 sentence2 中 “Hello” 和 “Jane” 之间插入 “my name is” 得到 sentence1 。<br><code>给你两个句子</code>sentence1 <code>和</code>sentence2<code>，如果</code>sentence1<code>和</code>sentence2` 是相似的，请你返回 true ，否则返回 false 。</p><p>示例 1：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：se<span class="symbol">ntence1</span> = <span class="string">"My name is Haley"</span>, se<span class="symbol">ntence2</span> = <span class="string">"My Haley"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：可以往 se<span class="symbol">ntence2</span> 中 <span class="string">"My"</span> 和 <span class="string">"Haley"</span> 之间插入 <span class="string">"name is"</span> ，得到 se<span class="symbol">ntence1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence1</span> = <span class="string">"of"</span>, <span class="attr">sentence2</span> = <span class="string">"A lot of words"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：se<span class="symbol">ntence1</span> = <span class="string">"Eating right now"</span>, se<span class="symbol">ntence2</span> = <span class="string">"Eating"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：可以往 se<span class="symbol">ntence2</span> 的结尾插入 <span class="string">"right now"</span> 得到 se<span class="symbol">ntence1</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence1</span> = <span class="string">"Luky"</span>, <span class="attr">sentence2</span> = <span class="string">"Lucccky"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li><li><code>sentence1</code> 和 <code>sentence2</code> 都只包含大小写英文字母和空格。</li><li><code>sentence1</code> 和 <code>sentence2</code> 中的单词都只由单个空格隔开。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sentence-similarity-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sentence-similarity-iii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的不好，没啥好说的，只需要判断两个句子的首尾相等的部分去掉即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areSentencesSimilar</span><span class="params">(<span class="built_in">string</span> sentence1, <span class="built_in">string</span> sentence2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = sentence1.size();</span><br><span class="line">        <span class="keyword">int</span> n = sentence2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sentence1.size();)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; sentence1[i] == <span class="string">' '</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; sentence1[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                curr.push_back(sentence1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt; <span class="number">0</span>) arr1.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sentence2.size();)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; sentence2[i] == <span class="string">' '</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; sentence2[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                curr.push_back(sentence2[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt; <span class="number">0</span>) arr2.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**/</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r1 = arr1.size();</span><br><span class="line">        <span class="keyword">int</span> r2 = arr2.size();</span><br><span class="line">        <span class="comment">/*left*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r1 &amp;&amp; i &lt; r2; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] == arr2[i]) l = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*right*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr1.size()<span class="number">-1</span>,j = arr2.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] == arr2[j])&#123;</span><br><span class="line">                r1 = i;</span><br><span class="line">                r2 = j;</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == (arr1.size()<span class="number">-1</span>) || l == (arr2.size()<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(r1 == <span class="number">0</span> || r2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((r1 - l) == <span class="number">1</span> || (r2-l) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5708-统计一个数组中好对子的数目"><a href="#5708-统计一个数组中好对子的数目" class="headerlink" title="5708. 统计一个数组中好对子的数目"></a>5708. 统计一个数组中好对子的数目</h2><p>给你一个数组 nums ，数组中只包含非负整数。定义<code>rev(x)</code>的值为将整数 x 各个数字位反转得到的结果。比方说 <code>rev(123) = 321</code> ， <code>rev(120) = 21</code> 。我们称满足下面条件的下标对 <code>(i, j)</code>是 好的 ：</p><ul><li><code>0 &lt;= i &lt; j &lt; nums.length</code></li><li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code><br>请你返回好下标对的数目。由于结果可能会很大，请将结果对 <code>109 + 7</code>取余 后返回。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">42</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">97</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：两个坐标对为：</span><br><span class="line"> - (<span class="number">0</span>,<span class="number">3</span>)：<span class="number">42</span> + rev(<span class="number">97</span>) = <span class="number">42</span> + <span class="number">79</span> = <span class="number">121</span>, <span class="number">97</span> + rev(<span class="number">42</span>) = <span class="number">97</span> + <span class="number">24</span> = <span class="number">121</span> 。</span><br><span class="line"> - (<span class="number">1</span>,<span class="number">2</span>)：<span class="number">11</span> + rev(<span class="number">1</span>) = <span class="number">11</span> + <span class="number">1</span> = <span class="number">12</span>, <span class="number">1</span> + rev(<span class="number">11</span>) = <span class="number">1</span> + <span class="number">11</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">13</span>,<span class="number">10</span>,<span class="number">35</span>,<span class="number">24</span>,<span class="number">76</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-nice-pairs-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-nice-pairs-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简单，题目中要求给定的公式为：<script type="math/tex; mode=display">nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</script>我们只需要将上述公式变换一下：<script type="math/tex; mode=display">nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])</script>因此我们统计数组中所有等式$nums[i] - rev(nums[i])$的值的个数，利用数学组合定理即可求出所有可能的数目。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNicePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curr = curr*<span class="number">10</span> + (x%<span class="number">10</span>);</span><br><span class="line">                x = x/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cnt[nums[i]-arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            ans = (ans + v.second*(v.second<span class="number">-1</span>)/<span class="number">2</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5707-得到新鲜甜甜圈的最多组数"><a href="#5707-得到新鲜甜甜圈的最多组数" class="headerlink" title="5707. 得到新鲜甜甜圈的最多组数"></a>5707. 得到新鲜甜甜圈的最多组数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一个甜甜圈商店，每批次都烤<code>batchSize</code> 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 所有 甜甜圈都必须已经全部销售完毕。给你一个整数 <code>batchSize</code> 和一个整数数组 <code>groups</code> ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 <code>groups[i]</code>表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。<br>当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。<br>你可以随意安排每批顾客到来的顺序。请你返回在此前提下，最多 有多少组人会感到开心。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：batchSize = <span class="number">3</span>, groups = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你可以将这些批次的顾客顺序安排为 [<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>] 。那么第 <span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">6</span> 组都会感到开心。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：batchSize = <span class="number">4</span>, groups = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= batchSize &lt;= 9</code></li><li><code>1 &lt;= groups.length &lt;= 30</code></li><li><code>1 &lt;= groups[i] &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-groups-getting-fresh-donuts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-groups-getting-fresh-donuts</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>状态压缩<code>dp</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目说的还是太复杂了，本质就是求将数组划分为能被<code>k</code>整除的非连续子数组的最大数目，以前见到过连续的子数组划分，遇到类似的题目确实不好想到。</li><li>我们可以看到假设只有<code>20</code>个元素时，则此时非常好解决，我们只需要利用二进制掩码解决所有可能的分组即可或者常规的<code>dfs</code>即可。</li><li>我们如何优化状态，减少所有可能的状态，即可对算法时间复杂度进行优化：</li></ol><ul><li>首先进行剪枝，我们知道如果当前的<code>group</code>刚好能被<code>batchSize</code>整除，或者刚好两个数相加能被<code>batchSize</code>整除的，我们优先将这两类数目去除掉。</li><li>我们对于状态如何定义，因为题目中并没有要求数字有序，数字可以为乱序，此时我们则看到题目中给定的条件为$1 &lt;= batchSize &lt;= 9$,则我们可以将数组按照对<code>batchSize</code>取模的结果进行分类，对其分类作为状态<code>dp</code>，则此时所有可能的最大状态为$3^{10}$，这个数字实际在可以接受的范围内，因此采用这个即可，看了所有的解答，基本上都在用各种方法对状态进行编码压缩，也可以直接用字符串对状态进行编码，也可以用类似于<code>K-R</code>的字符串的搜索方法对其进行编码，然后遍历所有可能的状态，各式各样的状态编码和压缩，当然最直接和最简单的就是直接暴力将用<code>treeMap</code>将数组作为状态，同时求出当前状态下所能够得到的最大可能分组以及剩余的余数，刚刚时间卡住可以过时间复杂度。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; dp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cnt, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = dp.find(cnt);</span><br><span class="line">        <span class="keyword">if</span>(it != end(dp)) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cnt[i] -= <span class="number">1</span>;</span><br><span class="line">            res = max(res,(left == <span class="number">0</span>) + dfs(cnt,(left + i)%cnt.size()));</span><br><span class="line">            cnt[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[cnt] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxHappyGroups</span><span class="params">(<span class="keyword">int</span> batchSize, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; groups)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(batchSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> group : groups)&#123;</span><br><span class="line">            ++cnt[group % batchSize];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = cnt[<span class="number">0</span>];</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (batchSize<span class="number">-1</span>)/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = min(cnt[i],cnt[batchSize-i]);</span><br><span class="line">            ans += m;</span><br><span class="line">            cnt[i] -= m;</span><br><span class="line">            cnt[batchSize-i] -= m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + dfs(cnt, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-49&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-49&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 49&quot;&gt;&lt;/a&gt;leetcode biweekly contest 49&lt;/h1&gt;&lt;p&gt;还是依旧三道题，最后一题的状态压缩&lt;code&gt;dp&lt;/code&gt;确实非常难以想到。前三题非常简单，最后一题比较难。&lt;/p&gt;&lt;h2 id=&quot;5705-判断国际象棋棋盘中一个格子的颜色&quot;&gt;&lt;a href=&quot;#5705-判断国际象棋棋盘中一个格子的颜色&quot; class=&quot;headerlink&quot; title=&quot;5705. 判断国际象棋棋盘中一个格子的颜色&quot;&gt;&lt;/a&gt;5705. 判断国际象棋棋盘中一个格子的颜色&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个坐标&lt;code&gt;coordinates&lt;/code&gt;，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。&lt;br&gt;如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 &lt;code&gt;false&lt;/code&gt;。&lt;br&gt;给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly  Contest 235</title>
    <link href="http://yoursite.com/2021/04/04/269/"/>
    <id>http://yoursite.com/2021/04/04/269/</id>
    <published>2021-04-04T01:30:40.110Z</published>
    <updated>2021-04-04T13:59:32.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-weekly-contest-235"><a href="#leetcode-weekly-contest-235" class="headerlink" title="leetcode weekly contest 235"></a>leetcode weekly contest 235</h1><p>还是依旧三道题，最后一题的思考确实比较难。</p><h2 id="5722-截断句子"><a href="#5722-截断句子" class="headerlink" title="5722. 截断句子"></a>5722. 截断句子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p><p>例如，<code>&quot;Hello World&quot;、&quot;HELLO&quot;</code> 和 <code>&quot;hello world hello world&quot;</code>都是句子。<br>给你一个句子 <code>s​​​​​​</code> 和一个整数<code>k​​​​​​</code> ，请你将 <code>s​​</code> 截断 ​，​​​使截断后的句子仅含 前 <code>k​​​​​​</code> 个单词。返回 截断 <code>s​​​​​​</code> 后得到的句子。</p><a id="more"></a><p>示例 1：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"Hello how are you Contestant"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="comment">"Hello how are you"</span></span><br><span class="line">解释：</span><br><span class="line">s 中的单词为 [<span class="comment">"Hello"</span>, <span class="comment">"how"</span> <span class="comment">"are"</span>, <span class="comment">"you"</span>, <span class="comment">"Contestant"</span>]</span><br><span class="line">前 <span class="number">4</span> 个单词为 [<span class="comment">"Hello"</span>, <span class="comment">"how"</span>, <span class="comment">"are"</span>, <span class="comment">"you"</span>]</span><br><span class="line">因此，应当返回 <span class="comment">"Hello how are you"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"What is the solution to this problem"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="comment">"What is the solution"</span></span><br><span class="line">解释：</span><br><span class="line">s 中的单词为 [<span class="comment">"What"</span>, <span class="comment">"is"</span> <span class="comment">"the"</span>, <span class="comment">"solution"</span>, <span class="comment">"to"</span>, <span class="comment">"this"</span>, <span class="comment">"problem"</span>]</span><br><span class="line">前 <span class="number">4</span> 个单词为 [<span class="comment">"What"</span>, <span class="comment">"is"</span>, <span class="comment">"the"</span>, <span class="comment">"solution"</span>]</span><br><span class="line">因此，应当返回 <span class="comment">"What is the solution"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "chopper <span class="keyword">is</span> <span class="keyword">not</span> a tanuki", k = 5</span><br><span class="line">输出："chopper <span class="keyword">is</span> <span class="keyword">not</span> a tanuki"</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>k</code> 的取值范围是 <code>[1,  s 中单词的数目]</code></li><li><code>s</code> 仅由大小写英文字母和空格组成</li><li><code>s</code> 中的单词之间由单个空格隔开</li><li>不存在前导或尾随空格</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/truncate-sentence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/truncate-sentence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>遇到第<code>k</code>个空格则推出即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">truncateSentence</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>) k--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> s.substr(<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5723-查找用户活跃分钟数"><a href="#5723-查找用户活跃分钟数" class="headerlink" title="5723. 查找用户活跃分钟数"></a>5723. 查找用户活跃分钟数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你用户在 <code>LeetCode</code>的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 <code>logs[i] = [IDi, timei]</code> 表示 ID 为 IDi 的用户在 timei 分钟时执行了某个操作。</p><p>多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。</p><p>指定用户的 用户活跃分钟数<code>（user active minutes，UAM）</code> 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p><p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 <code>answer</code> ，对于每个 <code>j（1 &lt;= j &lt;= k）</code>，<code>answer[j]</code>表示 用户活跃分钟数 等于 <code>j</code> 的用户数。</p><p>返回上面描述的答案数组 <code>answer</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>]], k = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">ID=<span class="number">0</span> 的用户执行操作的分钟分别是：<span class="number">5</span> 、<span class="number">2</span> 和 <span class="number">5</span> 。因此，该用户的用户活跃分钟数为 <span class="number">2</span>（分钟 <span class="number">5</span> 只计数一次）</span><br><span class="line">ID=<span class="number">1</span> 的用户执行操作的分钟分别是：<span class="number">2</span> 和 <span class="number">3</span> 。因此，该用户的用户活跃分钟数为 <span class="number">2</span></span><br><span class="line"><span class="number">2</span> 个用户的用户活跃分钟数都是 <span class="number">2</span> ，answer[<span class="number">2</span>] 为 <span class="number">2</span> ，其余 answer[j] 的值都是 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]], k = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">ID=<span class="number">1</span> 的用户仅在分钟 <span class="number">1</span> 执行单个操作。因此，该用户的用户活跃分钟数为 <span class="number">1</span></span><br><span class="line">ID=<span class="number">2</span> 的用户执行操作的分钟分别是：<span class="number">2</span> 和 <span class="number">3</span> 。因此，该用户的用户活跃分钟数为 <span class="number">2</span></span><br><span class="line"><span class="number">1</span> 个用户的用户活跃分钟数是 <span class="number">1</span> ，<span class="number">1</span> 个用户的用户活跃分钟数是 <span class="number">2</span> </span><br><span class="line">因此，answer[<span class="number">1</span>] = <span class="number">1</span> ，answer[<span class="number">2</span>] = <span class="number">1</span> ，其余的值都是 <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= logs.length &lt;= 104</code></li><li><code>0 &lt;= IDi &lt;= 109</code></li><li><code>1 &lt;= timei &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[用户的最大用户活跃分钟数, 105]</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-the-users-active-minutes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-the-users-active-minutes</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash统计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>利用<code>hash</code>统计每个用户活跃的分钟的计数，然后将每个用户的活跃分钟的次数返回到最终的统计结果中即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findingUsersActiveMinutes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; logs, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = logs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(k);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : logs)&#123;</span><br><span class="line">            cnt[v[<span class="number">0</span>]].insert(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: cnt)&#123;</span><br><span class="line">            ans[v.second.size()<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5724-绝对差值和"><a href="#5724-绝对差值和" class="headerlink" title="5724. 绝对差值和"></a>5724. 绝对差值和</h2><p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code>。</p><p>数组 <code>nums1</code> 和 <code>nums2</code> 的 绝对差值和 定义为所有 <code>|nums1[i] - nums2[i]|（0 &lt;= i &lt; n）</code>的 总和（下标从 0 开始）。</p><p>你可以选用 <code>nums1</code> 中的 任意一个 元素来替换 <code>nums1</code> 中的 至多 一个元素，以 最小化 绝对差值和。</p><p>在替换数组 <code>nums1</code> 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>109 + 7</code>取余 后返回。</p><p><code>|x|</code>定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，值为 <code>x</code> ，或者</li><li>如果 <code>x &lt;= 0</code> ，值为 <code>-x</code></li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：有两种可能的最优方案：</span><br><span class="line">- 将第二个元素替换为第一个元素：[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>] =&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>] ，或者</span><br><span class="line">- 将第二个元素替换为第三个元素：[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>] =&gt; [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">两种方案的绝对差值和都是 |<span class="number">1</span><span class="number">-2</span>| + (|<span class="number">1</span><span class="number">-3</span>| 或者 |<span class="number">5</span><span class="number">-3</span>|) + |<span class="number">5</span><span class="number">-5</span>| = <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>], nums2 = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：将第一个元素替换为第二个元素：[<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>] =&gt; [<span class="number">10</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">绝对差值和为 |<span class="number">10</span><span class="number">-9</span>| + |<span class="number">10</span><span class="number">-3</span>| + |<span class="number">4</span><span class="number">-5</span>| + |<span class="number">4</span><span class="number">-1</span>| + |<span class="number">2</span><span class="number">-7</span>| + |<span class="number">7</span><span class="number">-4</span>| = <span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-absolute-sum-difference</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>根据题目中的意思，我们只能进行一次替换，根据贪心原则则我们肯定将$|nums1[i]-nums2[i]|$最大的数对进行替换，才能使得返回值最小。因此首先我们找到所有的值$|nums1[i]-nums2[i]|$最大的所有数对，然后分别对其中的每一个数对尝试进行替换，是否能否取得最小值。</li><li>对于数对$nums1[i],nums2[i]$,如果要使的$|nums1[i]-nums2[i]|$的值，最小则我们应当尽量将$nums1[i]$替换为最接近$nums2[i]$的值，则此时我们可以利用二分查找，在数组<code>nums1</code>找到最小的大于等于$nums2[i]$的数和最大的小于等于$nums2[i]$的数，最接近的数肯定在这两个数中选一个即可，此时我们非常常见的可以利用二分查找即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsoluteSumDiff</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = nums1;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(nums1[i]-nums2[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums1[i]-nums2[i]) &gt; <span class="built_in">abs</span>(nums1[diff]-nums2[diff]))&#123;</span><br><span class="line">                diff = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums1[i]-nums2[i]) == <span class="built_in">abs</span>(nums1[diff]-nums2[diff]))&#123;</span><br><span class="line">                a.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr.begin(),arr.end(),nums2[a[i]]);</span><br><span class="line">            <span class="keyword">if</span>(it == arr.end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == arr.begin())&#123;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,curr-<span class="built_in">abs</span>(nums1[diff]-nums2[diff])+<span class="built_in">abs</span>(*it-nums2[a[i]]));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5725-序列中不同最大公约数的数目"><a href="#5725-序列中不同最大公约数的数目" class="headerlink" title="5725. 序列中不同最大公约数的数目"></a>5725. 序列中不同最大公约数的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个由正整数组成的数组 <code>nums</code>。</p><p>数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。<br>例如，序列 <code>[4,6,16]</code> 的最大公约数是 2 。<br>数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。<br>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,2,4,1,5,10]</code> 的一个子序列。<br>计算并返回 <code>nums</code> 的所有 非空 子序列中 不同 最大公约数的 数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">10</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：上图显示了所有的非空子序列与各自的最大公约数。</span><br><span class="line">不同的最大公约数为 <span class="number">6</span> 、<span class="number">10</span> 、<span class="number">3</span> 、<span class="number">2</span> 和 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">15</span>,<span class="number">40</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 105</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题，素数筛选法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先对于素数筛选法还是非常熟悉的，如果一个数<code>x</code>为素数，则<code>x</code>的倍数一定不是素数。我们知道可以在$O(n)$的时间复杂度内筛选出所有的从$[1,n]$的素数。</li><li>我们知道如果<code>x</code>为某个数组的最大公约数，则我们可以知道如下结论:</li></ol><ul><li>数组中的每个元素都能被$x$整除；</li><li>数组中的所有元素除以<code>x</code>以后组成的数组的最大公约数为<code>1</code>。</li><li>数组中所有元素都是$x$的倍数；</li></ul><ol><li>此时我们就可以参考素数筛选法，尝试从$[1,200000]$中所有的可能的最大公约数，则此时我们假设<code>x</code>为公约数，则我们测试所有的$x$的倍数是否存在于原数组中，如果存在我们则求最大公约数，最终我们测试所有可能的元素的最大公约数是否为$x$。</li><li>题目的算法时间复杂度计算公式为：<script type="math/tex; mode=display">O(n) = \frac{n}{1} + \frac{n}{2} + \frac{n}{3} + ... + \frac{n}{n} \\\approx n*lg(n)</script>非常喜欢这种思考类型的题目，但是感觉就是刷题而已。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) valid[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= <span class="number">200000</span>; j = j + i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="number">0</span>) curr = j;</span><br><span class="line">                    <span class="keyword">else</span> curr = __gcd(curr,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == i) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> valid[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) valid[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= <span class="number">200000</span>; j = j + i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">                        curr = j/i;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        curr = __gcd(curr,j/i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="number">1</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-weekly-contest-235&quot;&gt;&lt;a href=&quot;#leetcode-weekly-contest-235&quot; class=&quot;headerlink&quot; title=&quot;leetcode weekly contest 235&quot;&gt;&lt;/a&gt;leetcode weekly contest 235&lt;/h1&gt;&lt;p&gt;还是依旧三道题，最后一题的思考确实比较难。&lt;/p&gt;&lt;h2 id=&quot;5722-截断句子&quot;&gt;&lt;a href=&quot;#5722-截断句子&quot; class=&quot;headerlink&quot; title=&quot;5722. 截断句子&quot;&gt;&lt;/a&gt;5722. 截断句子&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。&lt;/p&gt;&lt;p&gt;例如，&lt;code&gt;&amp;quot;Hello World&amp;quot;、&amp;quot;HELLO&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;hello world hello world&amp;quot;&lt;/code&gt;都是句子。&lt;br&gt;给你一个句子 &lt;code&gt;s​​​​​​&lt;/code&gt; 和一个整数&lt;code&gt;k​​​​​​&lt;/code&gt; ，请你将 &lt;code&gt;s​​&lt;/code&gt; 截断 ​，​​​使截断后的句子仅含 前 &lt;code&gt;k​​​​​​&lt;/code&gt; 个单词。返回 截断 &lt;code&gt;s​​​​​​&lt;/code&gt; 后得到的句子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Atcoder】</title>
    <link href="http://yoursite.com/2021/03/29/267/"/>
    <id>http://yoursite.com/2021/03/29/267/</id>
    <published>2021-03-29T14:16:04.543Z</published>
    <updated>2021-03-31T11:43:29.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="atcoder-197"><a href="#atcoder-197" class="headerlink" title="atcoder 197"></a>atcoder 197</h1><p>atcoder的题目难度还是非常高的，非常适合ACM的比赛，难度还是不小的，仔细做了一下，发现自己也就3到4题的水平，<code>e</code>和<code>f</code>的难度还是非常大。</p><h2 id="e"><a href="#e" class="headerlink" title="e"></a>e</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/31/7ZVcTIYC9uWfrma.png" alt><br>给编号从<code>1</code>到<code>n</code>的球的坐标和颜色，要求按照颜色的升序进行进行遍历。其中球的颜色可以重复，从<code>0</code>点开始起遍历所有的球，并返回到<code>0</code>点的最短路径。</p><a id="more"></a><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc197/tasks/abc197_e" target="_blank" rel="noopener">https://atcoder.jp/contests/abc197/tasks/abc197_e</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  dp</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本题的<code>dp</code>还是非常值得思考的一个<code>dp</code>，我们假设不考虑球的颜色，我们按照球的坐标的大小进行排序<script type="math/tex; mode=display">x_{1} < x_{2} < x_{3} < x_{4} ... < x_{n}</script>按照所有球的坐标从小到大进行访问即可。但在实际的过程中因为要求必须按照球的颜色大小进行访问，此时我们首先必须按照球的颜色编号大小对所有的球进行排序。我们仔细观察一下，假设对于第<code>i</code>种颜色的球总共有<code>m</code>个，它的所有的坐标按照从小到大分布如下：<script type="math/tex; mode=display">x^{i}_{1} < x^{i}_{2} < x^{i}_{3} < x^{i}_{4}< x^{i}_{5}...< x^{i}_{m}</script>我们仔细思索一下，假设我们从坐标$x^{i}_{k}$开始访问第<code>i</code>种颜色的球，无论访问顺序如何，最小的访问路径的终点一定是要么是$x^{i}_{1}$,要么是$x^{i}_{m}$,相当于要么是第<code>i</code>种颜色的球中坐标最小的球，要么是第<code>i</code>种颜色的球中坐标最大的球。<br>2.基于此种情况下，我们可以推到出<code>dp</code>的递推公式，我们设：</li></ol><ul><li><code>dp[i][0]</code>表示已经遍历了前<code>i</code>种颜色的球，且最后访问的球位于第<code>i</code>种颜色的球的坐标的首位。</li><li><code>dp[i][1]</code>表示已经遍历了前<code>i</code>种颜色的球，且最后访问的球位于第<code>i</code>种颜色的球的坐标的末位。</li></ul><ol><li>基于上述的推断，我们设<code>arr[i][0]</code>表示第<code>i</code>种球的坐标的首位，<code>arr[i][1]</code>表示第<code>i</code>种球的坐标的末位,我们可以得到递推公式如下：<script type="math/tex; mode=display">dp[i][0] = min(dp[i][0],dp[i-1][0] + abs(arr[i-1][0] - arr[i][1]) + arr[i][1] - arr[i][0); \\dp[i][0] = min(dp[i][0],dp[i-1][1] + abs(arr[i-1][1] - arr[i][1]) + arr[i][1] - arr[i][0); \\dp[i][1] = min(dp[i][1],dp[i-1][0] + abs(arr[i-1][0] - arr[i][0]) + arr[i][1] - arr[i][0); \\dp[i][1] = min(dp[i][1],dp[i-1][1] + abs(arr[i-1][1] - arr[i][0]) + arr[i][1] - arr[i][0); \\</script></li><li>此题的重点在于如何理解跨越时最小的移动轨迹，从某一点到某一点的最小的移动轨迹一般都是确定的。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;sz[find(x)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; y1) swap(x1,y1);</span><br><span class="line">        parent[y1] = x1;</span><br><span class="line">        sz[x1] += sz[y1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x,c;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        cnt[c].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        sort(cnt[v.first].begin(),cnt[v.first].end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        arr.push_back(&#123;v.second[<span class="number">0</span>],v.second.back()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push_back(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> m = arr.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>,LONG_MAX));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = arr[i][<span class="number">1</span>] - arr[i][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">0</span>] = min(dp[i][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">0</span>] - arr[i][<span class="number">1</span>]) + l);</span><br><span class="line">        dp[i][<span class="number">0</span>] = min(dp[i][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">1</span>] - arr[i][<span class="number">1</span>]) + l);</span><br><span class="line">        dp[i][<span class="number">1</span>] = min(dp[i][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">0</span>] - arr[i][<span class="number">0</span>]) + l);</span><br><span class="line">        dp[i][<span class="number">1</span>] = min(dp[i][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="built_in">abs</span>(arr[i<span class="number">-1</span>][<span class="number">1</span>] - arr[i][<span class="number">0</span>]) + l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(dp[m<span class="number">-1</span>][<span class="number">0</span>],dp[m<span class="number">-1</span>][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;atcoder-197&quot;&gt;&lt;a href=&quot;#atcoder-197&quot; class=&quot;headerlink&quot; title=&quot;atcoder 197&quot;&gt;&lt;/a&gt;atcoder 197&lt;/h1&gt;&lt;p&gt;atcoder的题目难度还是非常高的，非常适合ACM的比赛，难度还是不小的，仔细做了一下，发现自己也就3到4题的水平，&lt;code&gt;e&lt;/code&gt;和&lt;code&gt;f&lt;/code&gt;的难度还是非常大。&lt;/p&gt;&lt;h2 id=&quot;e&quot;&gt;&lt;a href=&quot;#e&quot; class=&quot;headerlink&quot; title=&quot;e&quot;&gt;&lt;/a&gt;e&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/7ZVcTIYC9uWfrma.png&quot; alt&gt;&lt;br&gt;给编号从&lt;code&gt;1&lt;/code&gt;到&lt;code&gt;n&lt;/code&gt;的球的坐标和颜色，要求按照颜色的升序进行进行遍历。其中球的颜色可以重复，从&lt;code&gt;0&lt;/code&gt;点开始起遍历所有的球，并返回到&lt;code&gt;0&lt;/code&gt;点的最短路径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="atcoder" scheme="http://yoursite.com/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 234</title>
    <link href="http://yoursite.com/2021/03/28/266/"/>
    <id>http://yoursite.com/2021/03/28/266/</id>
    <published>2021-03-28T05:22:16.985Z</published>
    <updated>2021-03-31T02:57:22.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-234"><a href="#leetcode-contest-234" class="headerlink" title="leetcode contest 234"></a>leetcode contest 234</h1><p>本周的题目质量太差了，没有特别需要思考的地方，除了第二题是个数学题以外，本周的题目感觉基本上都是数学问题，最有意思和思考的题目竟然是第二题。</p><h2 id="5713-字符串中不同整数的数目"><a href="#5713-字符串中不同整数的数目" class="headerlink" title="5713. 字符串中不同整数的数目"></a>5713. 字符串中不同整数的数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p><p>请你用空格替换每个不是数字的字符。例如，<code>&quot;a123bc34d8ef34&quot;</code> 将会变成 <code>&quot; 123  34 8  34&quot;</code> 。注意，剩下的这些整数间至少要用一个空格隔开：<code>&quot;123&quot;、&quot;34&quot;、&quot;8&quot; 和 &quot;34&quot;</code>。</p><a id="more"></a><p>返回对 <code>word</code> 完成替换后形成的 不同 整数的数目。</p><p>如果两个整数的 不含前导零 的十进制表示不同，则认为这两个整数也不同。</p><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"a123bc34d8ef34"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：不同的整数有 <span class="string">"123"</span>、<span class="string">"34"</span> 和 <span class="string">"8"</span> 。注意，<span class="string">"34"</span> 只计数一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"leet1234code234"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"a1b01c001"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="string">"1"</span>、<span class="string">"01"</span> 和 <span class="string">"001"</span> 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 1000</code></li><li><code>word</code> 由数字和小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-different-integers-in-a-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>取出字符串中连续的数字的字符串放入到集合中。对于字符串需要处理去掉前导<code>0</code>，然后将剩余的数字作为一个完整的字符串放入到集合中。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDifferentIntegers</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'a'</span> &amp;&amp; s[i] &lt;= <span class="string">'z'</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> curr;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] == <span class="string">'0'</span>) i++;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                    curr.push_back(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.size() == <span class="number">0</span>) curr.push_back(<span class="string">'0'</span>);</span><br><span class="line">                cnt.insert(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5715-还原排列的最少操作步数"><a href="#5715-还原排列的最少操作步数" class="headerlink" title="5715. 还原排列的最少操作步数"></a>5715. 还原排列的最少操作步数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个偶数 <code>n</code>​​​​​​ ，已知存在一个长度为 <code>n</code> 的排列 <code>perm</code>，其中 <code>perm[i] == i​</code>（下标 从 0 开始 计数）。</p><p>一步操作中，你将创建一个新数组 <code>arr</code>，对于每个 <code>i</code> ：</p><ul><li>如果 <code>i % 2 == 0</code>，那么 <code>arr[i] = perm[i / 2]</code></li><li>如果 <code>i % 2 == 1</code>，那么 <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code><br>然后将 <code>arr</code>​​ 赋值​​给<code>perm</code> 。</li></ul><p>要想使 <code>perm</code> 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">所以，仅需执行 <span class="number">1</span> 步操作</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">2</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">所以，仅需执行 <span class="number">2</span> 步操作</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>n</code>​​​​​​ 是一个偶数</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题，暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>如果不知道如何解决，我们可以建设最终变换的次数肯定不会多于<code>n</code>，则此时我们直接用暴力变换，知道变换出来的数组的每个元素满足<code>arr[i] == i</code>即回到初始值。<br>2.首先我们可以尝试进行变换一下题目中的变换规则：</li></ol><ul><li>如果 <code>i &lt; n/2</code>，那么 <code>arr[2*i] = perm[i]</code></li><li>如果 <code>i &gt;= n/2</code>，那么 <code>arr[2*i-n] = perm[i]</code><br>如果用数学问题来分析，我们可以看到第一次变换的情况如下，最开始的数组为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...,n<span class="number">-1</span></span><br></pre></td></tr></table></figure>经过第一次变换后，假设<code>n=10</code>，我们可以仔细观察它的变化规则，我们可以知道变换后的数组元素为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span>：<span class="number">0</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> </span><br><span class="line"><span class="number">2</span>：<span class="number">0</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">9</span> </span><br><span class="line"><span class="number">3</span>: <span class="number">0</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">9</span> </span><br><span class="line"><span class="number">4</span>: <span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">1</span> <span class="number">5</span> <span class="number">9</span> </span><br><span class="line"><span class="number">5</span>: <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> </span><br><span class="line"><span class="number">6</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>我们假设试着开始进行逆变换，即从上述的状态<code>6</code>向状态<code>5</code>开始变换，一直到变换出来状态<code>0</code>为止，如果为逆变换则我们应当遵循如下变换：</li><li>如果 <code>i &lt; n/2</code>，那么 <code>arr[i] = perm[2*i]</code></li><li>如果 <code>i &gt;= n/2</code>，那么 <code>arr[i] = perm[2*i-n]</code><br>则此时我们可以知道如下第一次变换时:</li><li>当$i &lt; \frac{n}{2}$时，此时我们可以知道$f(i) = 2*i$;</li><li>当$i \ge \frac{n}{2}$时，此时我们可以知道$f(i) = 2*i - (n-1)$;</li><li>$perm[0],perm[n-1]$这两个元素始终保持不变；<br>仔细观察其规律，我们可以得到结论得到结论，$f(i) = 2<em>i\quad mod (n-1)$，因为当$i &lt; \frac{n}{2}$时，此时我们可以知道$f(i) = 2</em>i$，此时$2*i &lt; (n-1)$.<br>根据上述得到的结论后，我们可以知道：<br>第<code>k</code>的结果与第<code>k-1</code>次的变换结果如下：<script type="math/tex; mode=display">f_{k}(i) = 2*f_{k-1}(i) \quad mod \quad (n-1)</script>则此时我们将$f_{1}(i)$代入到上述的公式中，可以得到：<script type="math/tex; mode=display">f_{k}(i) = 2^{k}*i \quad mod \quad(n-1)</script>因此我们只需要满足如下时，即表示我们当前的变换到了最终的结果：<script type="math/tex; mode=display">f_{k}(1) = 2^{k}*1 \quad mod \quad(n-1) = 1 \\ f_{k}(2) = 2^{k}*2 \quad mod \quad(n-1) = 2 \\f_{k}(3) = 2^{k}*3 \quad mod \quad(n-1) = 3 \\... \\f_{k}(n-1) = 2^{k}*(n-2) \quad mod \quad(n-1) = n-2</script>仔细观察一下，我们是需要满足$2^{k}<em>1 \quad mod \quad(n-1) = 1$这个等式，其余的等式都可以满足，所以我们求出最小的<code>k</code>满足$2^{k}</em>1 \quad mod \quad(n-1) = 1$即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reinitializePermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; perm(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) perm[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) arr[i] = perm[i/<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) arr[i] = perm[n/<span class="number">2</span> + (i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        perm = arr;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(perm[i] != i)&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) arr[i] = perm[i/<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>) arr[i] = perm[n/<span class="number">2</span> + (i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            perm = arr;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reinitializePermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pow2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (pow2 != <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            pow2 = pow2 * <span class="number">2</span> % (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5714-替换字符串中的括号内容"><a href="#5714-替换字符串中的括号内容" class="headerlink" title="5714. 替换字符串中的括号内容"></a>5714. 替换字符串中的括号内容</h2><p>给你一个字符串 <code>s</code>，它包含一些括号对，每个括号中包含一个 非空 的键。</p><p>比方说，字符串 <code>&quot;(name)is(age)yearsold&quot;</code> 中，有 两个 括号对，分别包含键 <code>&quot;name&quot;</code> 和 <code>&quot;age&quot;</code> 。<br>你知道许多键对应的值，这些关系由二维字符串数组<code>knowledge</code> 表示，其中 <code>knowledge[i] = [keyi, valuei]</code> ，表示键 <code>keyi</code>对应的值为 <code>valuei</code>。</p><p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p><ul><li>将<code>keyi</code>和括号用对应的值 <code>valuei</code> 替换。</li><li>如果从 <code>knowledge</code>中无法得知某个键对应的值，你需要将 <code>keyi</code>和括号用问号 “?” 替换（不需要引号）。</li><li><code>knowledge</code>中每个键最多只会出现一次。<code>s</code> 中不会有嵌套的括号。</li></ul><p>请你返回替换 所有 括号对后的结果字符串。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(name)is(age)yearsold"</span>, knowledge = [[<span class="string">"name"</span>,<span class="string">"bob"</span>],[<span class="string">"age"</span>,<span class="string">"two"</span>]]</span><br><span class="line">输出：<span class="string">"bobistwoyearsold"</span></span><br><span class="line">解释：</span><br><span class="line">键 <span class="string">"name"</span> 对应的值为 <span class="string">"bob"</span> ，所以将 <span class="string">"(name)"</span> 替换为 <span class="string">"bob"</span> 。</span><br><span class="line">键 <span class="string">"age"</span> 对应的值为 <span class="string">"two"</span> ，所以将 <span class="string">"(age)"</span> 替换为 <span class="string">"two"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"hi(name)"</span>, knowledge = <span class="string">[["a","b"]]</span></span><br><span class="line">输出：<span class="string">"hi?"</span></span><br><span class="line">解释：由于不知道键 <span class="string">"name"</span> 对应的值，所以用 <span class="string">"?"</span> 替换 <span class="string">"(name)"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">"(a)(a)(a)aaa"</span>, knowledge = [[<span class="comment">"a"</span>,<span class="comment">"yes"</span>]]</span><br><span class="line">输出：<span class="comment">"yesyesyesaaa"</span></span><br><span class="line">解释：相同的键在 s 中可能会出现多次。</span><br><span class="line">键 <span class="comment">"a"</span> 对应的值为 <span class="comment">"yes"</span> ，所以将所有的 <span class="comment">"(a)"</span> 替换为 <span class="comment">"yes"</span> 。</span><br><span class="line">注意，不在括号里的 <span class="comment">"a"</span> 不需要被替换。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(a)(b)"</span>, knowledge = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"a"</span>]]</span><br><span class="line">输出：<span class="string">"ba"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>0 &lt;= knowledge.length &lt;= 105</code></li><li><code>knowledge[i].length == 2</code></li><li><code>1 &lt;= keyi.length, valuei.length &lt;= 10</code></li><li>s 只包含小写英文字母和圆括号 ‘(‘ 和 ‘)’ 。</li><li>s 中每一个左圆括号 ‘(‘ 都有对应的右圆括号 ‘)’ 。</li><li>s 中每对括号内的键都不会为空。</li><li>s 中不会有嵌套括号对。</li><li><code>keyi</code>和 <code>valuei</code> 只包含小写英文字母。</li><li><code>knowledge</code> 中的 <code>keyi</code> 不会重复。<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>这个题目可以算是简单题目，只需要用<code>hashtable</code>保存<code>key</code>对应的<code>value</code>即可，取出括号中的<code>key</code>，然后用对应的<code>value</code>替换即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">evaluate</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; knowledge)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; dict;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : knowledge) dict[v[<span class="number">0</span>]] = v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); )&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">'('</span>)&#123;</span><br><span class="line">                ans.push_back(s[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) i++;</span><br><span class="line">                <span class="built_in">string</span> key;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] != <span class="string">')'</span>)&#123;</span><br><span class="line">                    key.push_back(s[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) i++;</span><br><span class="line">                <span class="keyword">if</span>(dict.count(key))&#123;</span><br><span class="line">                    ans += dict[key];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans.push_back(<span class="string">'?'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5716-好因子的最大数目"><a href="#5716-好因子的最大数目" class="headerlink" title="5716. 好因子的最大数目"></a>5716. 好因子的最大数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数 <code>primeFactors</code> 。你需要构造一个正整数 n ，它满足以下条件：</p><p>n 质因数（质因数需要考虑重复的情况）的数目 不超过 <code>primeFactors</code> 个。<br>n 好因子的数目最大化。如果 <code>n</code> 的一个因子可以被<code>n</code>的每一个质因数整除，我们称这个因子是 好因子 。比方说，如果 n = 12 ，那么它的质因数为 [2,2,3] ，那么 6 和 12 是好因子，但 3 和 4 不是。<br>请你返回 n 的好因子的数目。由于答案可能会很大，请返回答案对 <code>109 + 7</code>取余 的结果。</p><p>请注意，一个质数的定义是大于 1 ，且不能被分解为两个小于该数的自然数相乘。一个数 <code>n</code> 的质因子是将 <code>n</code> 分解为若干个质因子，且它们的乘积为 n 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：primeFactors = <span class="number">5</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="number">200</span> 是一个可行的 n 。</span><br><span class="line">它有 <span class="number">5</span> 个质因子：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>] ，且有 <span class="number">6</span> 个好因子：[<span class="number">10</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>] 。</span><br><span class="line">不存在别的 n 有至多 <span class="number">5</span> 个质因子，且同时有更多的好因子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：primeFactors = <span class="number">8</span></span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= primeFactors &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-233/problems/count-pairs-with-xor-in-a-range/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-233/problems/count-pairs-with-xor-in-a-range/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目弄得太啰嗦了，本质就是正整数分解使得乘积最大问题，如果转化为这个问题得话，本题就十分简单了，本质就变成了一个数学问题。<br><a href="https://blog.csdn.net/xiaoquantouer/article/details/70142739" target="_blank" rel="noopener">正整数分解使得乘积最大问题</a></li><li>按照题目中给定得意思，假设我们设<code>n</code>有<code>k</code>个不同的质因子，每个不同的质因子的数目分别为$p_{0},p_{1}，…,p_{k-1}$则我们可以知道如下：<script type="math/tex; mode=display">primeFactors = \sum_{i = 0}^{k-1}p_{i}</script>按照题目中要求好因子必须能够被所有的质因子整除，这就表示好因子必须包含每一个不同的质因子，根据组合定理可以知道，这样的好因子的数目即为:<script type="math/tex; mode=display">good = \prod_{i=0}^{k-1}p_{i}</script>题目中要求使得<code>good</code>的值最大，因此这就转为了正整数分解使得乘积最大问题。最大的分解的原则如下：</li></ol><ul><li>能被<code>3</code>除断，那么就分解为<code>3+3+...+3</code>的情况即可。例如<code>9=3+3+3</code>。</li><li>被<code>3</code>除余<code>1</code>，分解为<code>3+3+...+3+2+2</code>或者<code>3+3+...+3+4</code>的情况，例如<code>10=3+3+2+2</code></li><li>被<code>3</code>除余<code>2</code>，分解为<code>3+3+...+3+2</code>的情况，例如<code>11=3+3+3+2</code>。</li></ul><ol><li>我们根据<code>primeFactors</code>的大小按照上述规则进行分解即可，稍微麻烦点的我们可以利用二分法进行快速的求幂。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = fastpow(x,y/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(y%<span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (curr*curr)%mod;</span><br><span class="line">        <span class="keyword">return</span> (curr*curr*x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNiceDivisors</span><span class="params">(<span class="keyword">int</span> primeFactors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(primeFactors%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> fastpow(<span class="number">3</span>,primeFactors/<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primeFactors%<span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(primeFactors == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>*fastpow(<span class="number">3</span>,(primeFactors<span class="number">-4</span>)/<span class="number">3</span>)%mod; </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(primeFactors%<span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*fastpow(<span class="number">3</span>,(primeFactors<span class="number">-2</span>)/<span class="number">3</span>)%mod;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-234&quot;&gt;&lt;a href=&quot;#leetcode-contest-234&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 234&quot;&gt;&lt;/a&gt;leetcode contest 234&lt;/h1&gt;&lt;p&gt;本周的题目质量太差了，没有特别需要思考的地方，除了第二题是个数学题以外，本周的题目感觉基本上都是数学问题，最有意思和思考的题目竟然是第二题。&lt;/p&gt;&lt;h2 id=&quot;5713-字符串中不同整数的数目&quot;&gt;&lt;a href=&quot;#5713-字符串中不同整数的数目&quot; class=&quot;headerlink&quot; title=&quot;5713. 字符串中不同整数的数目&quot;&gt;&lt;/a&gt;5713. 字符串中不同整数的数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;word&lt;/code&gt; ，该字符串由数字和小写英文字母组成。&lt;/p&gt;&lt;p&gt;请你用空格替换每个不是数字的字符。例如，&lt;code&gt;&amp;quot;a123bc34d8ef34&amp;quot;&lt;/code&gt; 将会变成 &lt;code&gt;&amp;quot; 123  34 8  34&amp;quot;&lt;/code&gt; 。注意，剩下的这些整数间至少要用一个空格隔开：&lt;code&gt;&amp;quot;123&amp;quot;、&amp;quot;34&amp;quot;、&amp;quot;8&amp;quot; 和 &amp;quot;34&amp;quot;&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
