<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-05T10:28:05.202Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 270</title>
    <link href="http://yoursite.com/2021/12/05/350/"/>
    <id>http://yoursite.com/2021/12/05/350/</id>
    <published>2021-12-05T10:12:06.134Z</published>
    <updated>2021-12-05T10:28:05.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-270"><a href="#leetcode-contest-270" class="headerlink" title="leetcode  contest 270"></a>leetcode  contest 270</h1><p>最后一题欧拉回路,确实不会，其余的题目都是简单题目．</p><h3 id="5942-找出-3-位偶数"><a href="#5942-找出-3-位偶数" class="headerlink" title="5942. 找出 3 位偶数"></a>5942. 找出 3 位偶数</h3><p>给你一个整数数组 <code>digits</code> ，其中每个元素是一个数字<code>（0 - 9）</code>。数组中可能存在重复元素。</p><p>你需要找出 所有 满足下述条件且 互不相同 的整数：</p><ul><li>该整数由 digits 中的三个元素按 任意 顺序 依次连接 组成。</li><li>该整数不含 前导零</li><li>该整数是一个 偶数<br>例如，给定的 <code>digits</code> 是 <code>[1, 2, 3]</code> ，整数 <code>132</code> 和 <code>312</code> 满足上面列出的全部条件。</li></ul><a id="more"></a><p>将找出的所有互不相同的整数按 递增顺序 排列，并以数组形式返回。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-270/problems/finding-3-digit-even-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-270/problems/finding-3-digit-even-numbers/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>遍历所有的三位数，检测符合性条件即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(C)$, 其中 $C = 1000$ 为三位数的总数。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findEvenNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : digits)&#123;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">string</span> s = to_string(i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">                curr[c-<span class="string">'0'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr[j] &gt; cnt[j])&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5943-删除链表的中间节点"><a href="#5943-删除链表的中间节点" class="headerlink" title="5943. 删除链表的中间节点"></a>5943. 删除链表的中间节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 <code>head</code> 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 <code>head</code>。</p><p>长度为 n 链表的中间节点是从头数起第<code>⌊n / 2⌋</code>个节点（下标从 <code>0</code>开始），其中<code>⌊x⌋</code>表示小于或等于 x 的最大整数。</p><p>对于 <code>n = 1、2、3、4</code>和 <code>5</code> 的情况，中间节点的下标分别是 <code>0、1、1、2</code>和 <code>2</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">上图表示给出的链表。节点的下标分别标注在每个节点的下方。</span><br><span class="line">由于 n = <span class="number">7</span> ，值为 <span class="number">7</span> 的节点 <span class="number">3</span> 是中间节点，用红色标注。</span><br><span class="line">返回结果为移除节点后的新链表。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">上图表示给出的链表。</span><br><span class="line">对于 n = <span class="number">4</span> ，值为 <span class="number">3</span> 的节点 <span class="number">2</span> 是中间节点，用红色标注。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">2</span>]</span><br><span class="line">解释：</span><br><span class="line">上图表示给出的链表。</span><br><span class="line">对于 n = <span class="number">2</span> ，值为 <span class="number">1</span> 的节点 <span class="number">1</span> 是中间节点，用红色标注。</span><br><span class="line">值为 <span class="number">2</span> 的节点 <span class="number">0</span> 是移除节点 <span class="number">1</span> 后剩下的唯一一个节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表中节点的数目在范围 [1, 105] 内</li><li>1 &lt;= Node.val &lt;= 105</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-270/problems/delete-the-middle-node-of-a-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-270/problems/delete-the-middle-node-of-a-linked-list/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 快慢指针或者数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>好无聊的题目，找到目标删除节点的前一个节点，进行删除即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(n)$，其中 $n$ 为链表的长度.</li><li>空间复杂度为 $O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteMiddle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode * curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> m = n/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;next = curr-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5944-从二叉树一个节点到另一个节点每一步的方向"><a href="#5944-从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="5944. 从二叉树一个节点到另一个节点每一步的方向"></a>5944. 从二叉树一个节点到另一个节点每一步的方向</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一棵 二叉树 的根节点 root ，这棵二叉树总共有 <code>n</code> 个节点。每个节点的值为 <code>1</code> 到 <code>n</code> 中的一个整数，且互不相同。给你一个整数 <code>startValue</code> ，表示起点节点 s 的值，和另一个不同的整数 <code>destValue</code>，表示终点节点 <code>t</code> 的值。</p><p>请找到从节点 <code>s</code> 到节点 <code>t</code> 的 最短路径 ，并以字符串的形式返回每一步的方向。每一步用 大写 字母 ‘L’ ，’R’ 和 ‘U’ 分别表示一种方向：</p><ul><li>‘L’ 表示从一个节点前往它的 左孩子 节点。</li><li>‘R’ 表示从一个节点前往它的 右孩子 节点。</li><li>‘U’ 表示从一个节点前往它的 父 节点。<br>请你返回从 <code>s</code> 到 <code>t</code> 最短路径 每一步的方向。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">4</span>], startValue = <span class="number">3</span>, destValue = <span class="number">6</span></span><br><span class="line">输出：<span class="string">"UURL"</span></span><br><span class="line">解释：最短路径为：<span class="number">3</span> → <span class="number">1</span> → <span class="number">5</span> → <span class="number">2</span> → <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">1</span>], startValue = <span class="number">2</span>, destValue = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"L"</span></span><br><span class="line">解释：最短路径为：<span class="number">2</span> → <span class="number">1</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">+ 树中节点数目为 `n` 。</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= Node.val &lt;= n`</span><br><span class="line">+ 树中所有节点的值 互不相同 。</span><br><span class="line">+ `<span class="number">1</span> &lt;= startValue, destValue &lt;= n`</span><br><span class="line">+ `startValue != destValue`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-270/problems/step-by-step-directions-from-a-binary-tree-node-to-another/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt; DFS</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 感觉也是非常常见的题目,先利用 $lca$ 算法找到给定值的最低的公共父节点 $fa$ ,可以参考原题关于 $lca$ 的求法. 然后再利用 `dfs` 找到从 $fa$ 到每个起点 $start$ 和 终点 $dest$ 的路径. 知道路径以后我们可以知道从起点 $start$ 到 $fa$ 的方向应该都是 $U$, 从$fa$ 到 </span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度：$O(N)$ 其中 $n$ 为二叉树中节点的个数。</span><br><span class="line">+ 空间复杂度分析: $O(N)$,其中 $n$ 为二叉树中节点的个数.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode * lca(TreeNode * root, <span class="built_in">int</span> startValue, <span class="built_in">int</span> destValue) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>ptr;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == startValue) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == destValue) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode * left = lca(root-&gt;left,startValue,destValue);</span><br><span class="line">        TreeNode * right = lca(root-&gt;right,startValue,destValue);</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; !right)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bool</span> dfs(TreeNode * root, <span class="built_in">int</span> val,vector&lt;<span class="built_in">int</span>&gt; &amp; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        res.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dfs(root-&gt;left,val,res))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.pop_back();</span><br><span class="line">        res.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(dfs(root-&gt;right,val,res))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> getDirections(TreeNode* root, <span class="built_in">int</span> startValue, <span class="built_in">int</span> destValue) &#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        TreeNode * p = lca(root,startValue,destValue);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; paths;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; patht;</span><br><span class="line">        dfs(p,startValue,paths);</span><br><span class="line">        dfs(p,destValue,patht);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; paths.size(); ++i)&#123;</span><br><span class="line">            ans.push_back(<span class="string">'U'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; patht.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(patht[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.push_back(<span class="string">'L'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="string">'R'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5932-合法重新排列数对"><a href="#5932-合法重新排列数对" class="headerlink" title="5932. 合法重新排列数对"></a>5932. 合法重新排列数对</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的二维整数数组 <code>pairs</code> ，其中 <code>pairs[i] = [starti, endi]</code> 。如果 <code>pairs</code> 的一个重新排列，满足对每一个下标<code>i （ 1 &lt;= i &lt; pairs.length ）</code>都有 <code>endi-1 == starti</code>，那么我们就认为这个重新排列是 <code>pairs</code> 的一个 合法重新排列 。</p><p>请你返回 任意一个 <code>pairs</code> 的合法重新排列。</p><p>注意：数据保证至少存在一个 <code>pairs</code> 的合法重新排列。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：pairs = [[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">11</span>,<span class="number">9</span>],[<span class="number">9</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[[<span class="number">11</span>,<span class="number">9</span>],[<span class="number">9</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">1</span>]]</span><br><span class="line">解释：</span><br><span class="line">输出的是一个合法重新排列，因为每一个 endi<span class="number">-1</span> 都等于 starti 。</span><br><span class="line">end0 = <span class="number">9</span> == <span class="number">9</span> = start1 </span><br><span class="line">end1 = <span class="number">4</span> == <span class="number">4</span> = start2</span><br><span class="line">end2 = <span class="number">5</span> == <span class="number">5</span> = start3</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：pairs = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">解释：</span><br><span class="line">输出的是一个合法重新排列，因为每一个 endi<span class="number">-1</span> 都等于 starti 。</span><br><span class="line">end0 = <span class="number">3</span> == <span class="number">3</span> = start1</span><br><span class="line">end1 = <span class="number">2</span> == <span class="number">2</span> = start2</span><br><span class="line">重新排列后的数组 [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>]] 和 [[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>]] 都是合法的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：pairs = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">输出的是一个合法重新排列，因为每一个 endi<span class="number">-1</span> 都等于 starti 。</span><br><span class="line">end0 = <span class="number">2</span> == <span class="number">2</span> = start1</span><br><span class="line">end1 = <span class="number">1</span> == <span class="number">1</span> = start2</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= pairs.length &lt;= 105</code></li><li><code>pairs[i].length == 2</code></li><li><code>0 &lt;= starti, endi &lt;= 109</code></li><li><code>starti != endi</code></li><li><code>pairs</code> 中不存在一模一样的数对。</li><li>至少 存在 一个合法的 <code>pairs</code> 重新排列。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-270/problems/valid-arrangement-of-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-270/problems/valid-arrangement-of-pairs/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>欧拉回路</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li></li><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(N)$ 其中 $n$ 为二叉树中节点的个数。</li><li>空间复杂度分析: $O(N)$,其中 $n$ 为二叉树中节点的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><code>c++</code></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-270&quot;&gt;&lt;a href=&quot;#leetcode-contest-270&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 270&quot;&gt;&lt;/a&gt;leetcode  contest 270&lt;/h1&gt;&lt;p&gt;最后一题欧拉回路,确实不会，其余的题目都是简单题目．&lt;/p&gt;&lt;h3 id=&quot;5942-找出-3-位偶数&quot;&gt;&lt;a href=&quot;#5942-找出-3-位偶数&quot; class=&quot;headerlink&quot; title=&quot;5942. 找出 3 位偶数&quot;&gt;&lt;/a&gt;5942. 找出 3 位偶数&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;digits&lt;/code&gt; ，其中每个元素是一个数字&lt;code&gt;（0 - 9）&lt;/code&gt;。数组中可能存在重复元素。&lt;/p&gt;&lt;p&gt;你需要找出 所有 满足下述条件且 互不相同 的整数：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;该整数由 digits 中的三个元素按 任意 顺序 依次连接 组成。&lt;/li&gt;
&lt;li&gt;该整数不含 前导零&lt;/li&gt;
&lt;li&gt;该整数是一个 偶数&lt;br&gt;例如，给定的 &lt;code&gt;digits&lt;/code&gt; 是 &lt;code&gt;[1, 2, 3]&lt;/code&gt; ，整数 &lt;code&gt;132&lt;/code&gt; 和 &lt;code&gt;312&lt;/code&gt; 满足上面列出的全部条件。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 269</title>
    <link href="http://yoursite.com/2021/11/28/349/"/>
    <id>http://yoursite.com/2021/11/28/349/</id>
    <published>2021-11-28T14:42:07.015Z</published>
    <updated>2021-11-28T16:10:15.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-269"><a href="#leetcode-contest-269" class="headerlink" title="leetcode  contest 269"></a>leetcode  contest 269</h1><p>本周最后一题竟然基本上都过了，最后模拟了一把暴力 $BFS$ 过了最后一题.<br><img src="https://i.loli.net/2021/11/28/5mDFS3qcyM7a8QI.png" alt></p><h3 id="5938-找出数组排序后的目标下标"><a href="#5938-找出数组排序后的目标下标" class="headerlink" title="5938. 找出数组排序后的目标下标"></a>5938. 找出数组排序后的目标下标</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> 以及一个目标元素 <code>target</code> 。</p><p>目标下标 是一个满足 <code>nums[i] == target</code>的下标 <code>i</code> 。</p><a id="more"></a><p>将 <code>nums</code> 按 非递减 顺序排序后，返回由 <code>nums</code> 中目标下标组成的列表。如果不存在目标下标，返回一个 空 列表。返回的列表必须按 递增 顺序排列。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：排序后，nums 变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">满足 nums[i] == <span class="number">2</span> 的下标是 <span class="number">1</span> 和 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">3</span>]</span><br><span class="line">解释：排序后，nums 变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">满足 nums[i] == <span class="number">3</span> 的下标是 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>]</span><br><span class="line">解释：排序后，nums 变为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">满足 nums[i] == <span class="number">5</span> 的下标是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>], target = <span class="number">4</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：nums 中不含值为 <span class="number">4</span> 的元素。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i], target &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-269/problems/find-target-indices-after-sorting-array/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序后遍历．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N \log N)$,其中 $N$ 为数组的长度。</li><li>空间复杂度: $O(N)$, 其中 $N$ 为数组的长度。。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; targetIndices(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;ｓ</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5939-半径为-k-的子数组平均值"><a href="#5939-半径为-k-的子数组平均值" class="headerlink" title="5939. 半径为 k 的子数组平均值"></a>5939. 半径为 k 的子数组平均值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的数组 <code>nums</code> ，数组中有 <code>n</code> 个整数，另给你一个整数 <code>k</code> 。</p><p>半径为 <code>k</code> 的子数组平均值 是指：<code>nums</code> 中一个以下标 <code>i</code> 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 <code>i - k</code> 和<code>i + k</code>范围（含 <code>i - k</code> 和<code>i + k</code>）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。</p><p>构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。</p><p>x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。</p><p>例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 3.75，截断后得到 3 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：</span><br><span class="line">- avg[<span class="number">0</span>]、avg[<span class="number">1</span>] 和 avg[<span class="number">2</span>] 是 <span class="number">-1</span> ，因为在这几个下标前的元素数量都不足 k 个。</span><br><span class="line">- 中心为下标 <span class="number">3</span> 且半径为 <span class="number">3</span> 的子数组的元素总和是：<span class="number">7</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">9</span> + <span class="number">1</span> + <span class="number">8</span> + <span class="number">5</span> = <span class="number">37</span> 。</span><br><span class="line">  使用截断式 整数除法，avg[<span class="number">3</span>] = <span class="number">37</span> / <span class="number">7</span> = <span class="number">5</span> 。</span><br><span class="line">- 中心为下标 <span class="number">4</span> 的子数组，avg[<span class="number">4</span>] = (<span class="number">4</span> + <span class="number">3</span> + <span class="number">9</span> + <span class="number">1</span> + <span class="number">8</span> + <span class="number">5</span> + <span class="number">2</span>) / <span class="number">7</span> = <span class="number">4</span> 。</span><br><span class="line">- 中心为下标 <span class="number">5</span> 的子数组，avg[<span class="number">5</span>] = (<span class="number">3</span> + <span class="number">9</span> + <span class="number">1</span> + <span class="number">8</span> + <span class="number">5</span> + <span class="number">2</span> + <span class="number">6</span>) / <span class="number">7</span> = <span class="number">4</span> 。</span><br><span class="line">- avg[<span class="number">6</span>]、avg[<span class="number">7</span>] 和 avg[<span class="number">8</span>] 是 <span class="number">-1</span> ，因为在这几个下标后的元素数量都不足 k 个。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">100000</span>], k = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">100000</span>]</span><br><span class="line">解释：</span><br><span class="line">- 中心为下标 <span class="number">0</span> 且半径 <span class="number">0</span> 的子数组的元素总和是：<span class="number">100000</span> 。</span><br><span class="line">  avg[<span class="number">0</span>] = <span class="number">100000</span> / <span class="number">1</span> = <span class="number">100000</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">8</span>], k = <span class="number">100000</span></span><br><span class="line">输出：[<span class="number">-1</span>]</span><br><span class="line">解释：</span><br><span class="line">- avg[<span class="number">0</span>] 是 <span class="number">-1</span> ，因为在下标 <span class="number">0</span> 前后的元素数量均不足 k 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == nums.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= nums[i], k &lt;= <span class="number">105</span>。`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-269/problems/k-radius-subarray-averages/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 滑动窗口大小为 $<span class="number">2</span> \times k + <span class="number">1</span>$, 我们依次求出连续长度为 $<span class="number">2</span> \times k + <span class="number">1</span>$ 的连续子数组的和.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度分析: 时间复杂度为 $O(N)$, 其中 $N$ 为数组的长度。</span><br><span class="line">+ 空间复杂度分析: 空间复杂度为 $O(N)$, 其中 $N$ 为数组的长度。。</span><br><span class="line"></span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; getAverages(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">int</span> sz = k*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n,<span class="number">-1</span>);</span><br><span class="line">        long long curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz &amp;&amp; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = k; i &lt; n-k; ++i)&#123;</span><br><span class="line">            ans[i] = curr/sz;</span><br><span class="line">            curr -= nums[i-k];</span><br><span class="line">            <span class="keyword">if</span>(i + k + <span class="number">1</span> &lt; n)&#123;</span><br><span class="line">                curr += nums[i+k+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5940-从数组中移除最大值和最小值"><a href="#5940-从数组中移除最大值和最小值" class="headerlink" title="5940. 从数组中移除最大值和最小值"></a>5940. 从数组中移除最大值和最小值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的数组 <code>nums</code> ，数组由若干 互不相同 的整数组成。</p><p><code>nums</code> 中有一个值最小的元素和一个值最大的元素。分别称为 最小值 和 最大值 。你的目标是从数组中移除这两个元素。</p><p>一次 删除 操作定义为从数组的 前面 移除一个元素或从数组的 后面 移除一个元素。</p><p>返回将数组中最小值和最大值 都 移除需要的最小删除次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">数组中的最小元素是 nums[<span class="number">5</span>] ，值为 <span class="number">1</span> 。</span><br><span class="line">数组中的最大元素是 nums[<span class="number">1</span>] ，值为 <span class="number">10</span> 。</span><br><span class="line">将最大值和最小值都移除需要从数组前面移除 <span class="number">2</span> 个元素，从数组后面移除 <span class="number">3</span> 个元素。</span><br><span class="line">结果是 <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span> ，这是所有可能情况中的最小删除次数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">-4</span>,<span class="number">19</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">数组中的最小元素是 nums[<span class="number">1</span>] ，值为 <span class="number">-4</span> 。</span><br><span class="line">数组中的最大元素是 nums[<span class="number">2</span>] ，值为 <span class="number">19</span> 。</span><br><span class="line">将最大值和最小值都移除需要从数组前面移除 <span class="number">3</span> 个元素。</span><br><span class="line">结果是 <span class="number">3</span> ，这是所有可能情况中的最小删除次数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">101</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。</span><br><span class="line">移除它只需要 <span class="number">1</span> 次删除操作。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">-105</span> &lt;= nums[i] &lt;= <span class="number">105</span>`</span><br><span class="line">+ `nums` 中的整数 互不相同</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-269/problems/removing-minimum-and-maximum-from-array/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学问题</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 感觉这个题目可以算是一个简单题目，因为一个数要么从前取，要么从后取，因此不同的数的组合取法最多有 $<span class="number">4</span>$ 种:</span><br><span class="line">+ 要么两个数都从数组的开头取;</span><br><span class="line">+ 要么两个数都从数组的结尾取;</span><br><span class="line">+ 要么一个数从数组的开头取,另一个数从数组的结尾取.</span><br><span class="line">以上几种组合的全部求一遍即可得到最小的移除步骤.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度度为 $O(n)$.</span><br><span class="line">+ 空间复杂度为 $O(<span class="number">1</span>)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minimumDeletions(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> minVal = INT_MAX;</span><br><span class="line">        <span class="built_in">int</span> maxVal = INT_MIN;</span><br><span class="line">        <span class="built_in">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">int</span> ans = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; minVal)&#123;</span><br><span class="line">                minVal = nums[i];</span><br><span class="line">                minIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxVal)&#123;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans = min(ans,max(minIdx,maxIdx) + <span class="number">1</span>);</span><br><span class="line">        ans = min(ans,max(n - maxIdx, n - minIdx));</span><br><span class="line">        ans = min(ans,maxIdx + <span class="number">1</span> + n - minIdx);</span><br><span class="line">        ans = min(ans,minIdx + <span class="number">1</span> + n - maxIdx);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5941-找出知晓秘密的所有专家"><a href="#5941-找出知晓秘密的所有专家" class="headerlink" title="5941. 找出知晓秘密的所有专家"></a>5941. 找出知晓秘密的所有专家</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code> ，表示有 <code>n</code> 个专家从 <code>0</code> 到 <code>n - 1</code>编号。另外给你一个下标从 <code>0</code> 开始的二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [xi, yi, timei]</code> 表示专家 <code>xi</code>和专家 <code>yi</code> 在时间 <code>timei</code>要开一场会。一个专家可以同时参加 多场会议 。最后，给你一个整数 <code>firstPerson</code> 。</p><p>专家<code>0</code> 有一个 秘密 ，最初，他在时间 <code>0</code> 将这个秘密分享给了专家 <code>firstPerson</code> 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 <code>xi</code> 在时间 <code>timei</code> 时知晓这个秘密，那么他将会与专家 yi 分享这个秘密，反之亦然。</p><p>秘密共享是 瞬时发生 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p><p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 任何顺序 返回答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, meetings = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>]], firstPerson = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">解释：</span><br><span class="line">时间 <span class="number">0</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">1</span> 共享。</span><br><span class="line">时间 <span class="number">5</span> ，专家 <span class="number">1</span> 将秘密与专家 <span class="number">2</span> 共享。</span><br><span class="line">时间 <span class="number">8</span> ，专家 <span class="number">2</span> 将秘密与专家 <span class="number">3</span> 共享。</span><br><span class="line">时间 <span class="number">10</span> ，专家 <span class="number">1</span> 将秘密与专家 <span class="number">5</span> 共享。</span><br><span class="line">因此，在所有会议结束后，专家 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span> 和 <span class="number">5</span> 都将知晓这个秘密。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, meetings = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>]], firstPerson = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">时间 <span class="number">0</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">3</span> 共享。</span><br><span class="line">时间 <span class="number">2</span> ，专家 <span class="number">1</span> 与专家 <span class="number">2</span> 都不知晓这个秘密。</span><br><span class="line">时间 <span class="number">3</span> ，专家 <span class="number">3</span> 将秘密与专家 <span class="number">0</span> 和专家 <span class="number">1</span> 共享。</span><br><span class="line">因此，在所有会议结束后，专家 <span class="number">0</span>、<span class="number">1</span> 和 <span class="number">3</span> 都将知晓这个秘密。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, meetings = [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]], firstPerson = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">时间 <span class="number">0</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">1</span> 共享。</span><br><span class="line">时间 <span class="number">1</span> ，专家 <span class="number">1</span> 将秘密与专家 <span class="number">2</span> 共享，专家 <span class="number">2</span> 将秘密与专家 <span class="number">3</span> 共享。</span><br><span class="line">注意，专家 <span class="number">2</span> 可以在收到秘密的同一时间分享此秘密。</span><br><span class="line">时间 <span class="number">2</span> ，专家 <span class="number">3</span> 将秘密与专家 <span class="number">4</span> 共享。</span><br><span class="line">因此，在所有会议结束后，专家 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span> 和 <span class="number">4</span> 都将知晓这个秘密。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, meetings = [[<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>]], firstPerson = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">时间 <span class="number">0</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">1</span> 共享。</span><br><span class="line">时间 <span class="number">1</span> ，专家 <span class="number">0</span> 将秘密与专家 <span class="number">2</span> 共享，专家 <span class="number">1</span> 将秘密与专家 <span class="number">3</span> 共享。</span><br><span class="line">因此，在所有会议结束后，专家 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span> 和 <span class="number">3</span> 都将知晓这个秘密。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= meetings.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `meetings[i].length == <span class="number">3</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= xi, yi &lt;= n - <span class="number">1</span>`</span><br><span class="line">+ `xi != yi`</span><br><span class="line">+ `<span class="number">1</span> &lt;= timei &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= firstPerson &lt;= n - <span class="number">1</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-269/problems/find-all-people-with-secret/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt; BFS或者集合</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 我们首先将所有的会议按照时间大小进行排序,题目最难的地方在于如何处理像同时间下的会议间的关系的传递, 可以通过 $BFS$ 或者集合来处理.</span><br><span class="line"><span class="number">2.</span> $BFS$ : 我们首先利用优先队列, 队列里面存储的为某个专家 $x$ 在 $t$ 时间开会, 我们按照时间的先后顺序来依次访问每个节点, 每个节点弹出时, 我们会依次将该专家 $x$ 所有与其他专家开过的会议时间全部压入到优先队列中, 记录下节点 $x$ 最早知道秘密的时间为 $cost[x]$, 当我们如果发现当前参加会议且知道秘密的时间小于 $cost[x]$, 则我们需要重新进行迭代一次.减枝技巧如下:</span><br><span class="line">+ 我们设 $x$ 的最早知道秘密的时间为 $cost[x]$, 并同时用 $visit[x]$ 记录他是否已经遍历过该节点, 如果遍历过该节点我们不再对该节点的邻居进行迭代.</span><br><span class="line">+ 初始时我们将 $(<span class="number">0</span>,firsperson)$ 的 $cost$ 都设置为 $<span class="number">0</span>$.</span><br><span class="line">+ 如果节点的相邻节点的会议时间小于当前的节点的会议时间, 则我们直接应该跳过, 我们只访问比当前节点晚的会议时间, 因为是向后传递.</span><br><span class="line"><span class="number">3.</span> 题目的难点在于如何处理相同时间下的会议传递, 我们自然而然的想到利用集合,我们处理如下:</span><br><span class="line">+ 首先我们对 $<span class="number">0</span>, firstperson$ 进行合并, 且设置父节点为 $<span class="number">0</span>$;</span><br><span class="line">+ 我们首先对连续相同的起始时间的会议中专家的传递关系进行合并, 两个集合合并时更新父节点为较小的父节点, 然后我们再次遍历一遍相同时间的会议, 对父节点不为 $<span class="number">0</span>$ 的集合进行删除, 这样我们每次就只保证了父节点为 $<span class="number">0</span>$ 的元素进行合并.</span><br><span class="line">+ 我们最终检测父节点为 $<span class="number">0</span>$ 的集合中的元素即为所求.</span><br><span class="line"><span class="number">4.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度：$BFS$ 的时间复杂度为 $O(m\log n)$,其中 $m$ 为会议的个数, $n$ 为专家的个数, 集合方法的时间复杂度为 $O(m \alpha)$。</span><br><span class="line">+ 空间复杂度分析: $O(n + m)$,其中 $m$ 为会议的个数, $n$ 为专家的个数,.</span><br><span class="line">### 代码</span><br><span class="line">+ $BFS$:</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; findAllPeople(<span class="built_in">int</span> n, vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; meetings, <span class="built_in">int</span> firstPerson) &#123;</span><br><span class="line">        <span class="built_in">int</span> m = meetings.size();</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; cost(n,INT_MAX);</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; graph(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans;</span><br><span class="line">        cost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cost[firstPerson] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        sort(meetings.begin(),meetings.end(),[&amp;](<span class="keyword">const</span> vector&lt;<span class="built_in">int</span>&gt; &amp; a, <span class="keyword">const</span> vector&lt;<span class="built_in">int</span>&gt; &amp; b)&#123;</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : meetings)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(&#123;v[<span class="number">2</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(&#123;v[<span class="number">2</span>],v[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">        pq.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        pq.push(&#123;<span class="number">0</span>,firstPerson&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            <span class="comment">/*当前节点*/</span></span><br><span class="line">            pii curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(visit[curr.second]) <span class="keyword">continue</span>;</span><br><span class="line">            visit[curr.second] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">auto</span> [t, v] : graph[curr.second])&#123;</span><br><span class="line">                <span class="comment">/* 所有早于当前会议的会议全部跳过*/</span></span><br><span class="line">                <span class="keyword">if</span>(t &lt; curr.first) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">/* 如果当前的时间小于它知道秘密的时间, 则将其加入到队列中重新迭代*/</span></span><br><span class="line">                <span class="keyword">if</span>(t &lt; cost[v])&#123;</span><br><span class="line">                    pq.push(&#123;t, v&#125;);</span><br><span class="line">                    cost[v] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i])&#123;</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>集合:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x]) &#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(f, x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(f, y);</span><br><span class="line">        <span class="keyword">if</span>(x1 == y1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; y1) &#123;</span><br><span class="line">            f[x1] = y1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            f[y1] = x1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAllPeople(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; meetings, <span class="keyword">int</span> firstPerson) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = meetings.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(meetings.begin(),meetings.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        uni(f, <span class="number">0</span> ,firstPerson);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = i;</span><br><span class="line">            <span class="keyword">int</span> time = meetings[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; meetings[i][<span class="number">2</span>] == time) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = curr; j &lt; i; ++j) &#123;</span><br><span class="line">                uni(f, meetings[j][<span class="number">0</span>], meetings[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = curr; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(find(f,meetings[j][<span class="number">0</span>]) != <span class="number">0</span>) &#123;</span><br><span class="line">                    f[meetings[j][<span class="number">0</span>]] = meetings[j][<span class="number">0</span>];</span><br><span class="line">                    f[meetings[j][<span class="number">1</span>]] = meetings[j][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(f, i) == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-269&quot;&gt;&lt;a href=&quot;#leetcode-contest-269&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 269&quot;&gt;&lt;/a&gt;leetcode  contest 269&lt;/h1&gt;&lt;p&gt;本周最后一题竟然基本上都过了，最后模拟了一把暴力 $BFS$ 过了最后一题.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/11/28/5mDFS3qcyM7a8QI.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5938-找出数组排序后的目标下标&quot;&gt;&lt;a href=&quot;#5938-找出数组排序后的目标下标&quot; class=&quot;headerlink&quot; title=&quot;5938. 找出数组排序后的目标下标&quot;&gt;&lt;/a&gt;5938. 找出数组排序后的目标下标&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; 以及一个目标元素 &lt;code&gt;target&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;目标下标 是一个满足 &lt;code&gt;nums[i] == target&lt;/code&gt;的下标 &lt;code&gt;i&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 66</title>
    <link href="http://yoursite.com/2021/11/28/348/"/>
    <id>http://yoursite.com/2021/11/28/348/</id>
    <published>2021-11-27T16:21:13.005Z</published>
    <updated>2021-11-28T01:50:48.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-66"><a href="#leetcode-biweekly-contest-66" class="headerlink" title="leetcode biweekly contest 66"></a>leetcode biweekly contest 66</h1><p>本周的双周赛的题目不是很高，总体感觉难度不是很大.<br><img src="https://i.loli.net/2021/11/28/yKFfbsrYiGI43CR.png" alt></p><h3 id="5922-统计出现过一次的公共字符串"><a href="#5922-统计出现过一次的公共字符串" class="headerlink" title="5922. 统计出现过一次的公共字符串"></a>5922. 统计出现过一次的公共字符串</h3><p>给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：words1 = [<span class="string">"leetcode"</span>,<span class="string">"is"</span>,<span class="string">"amazing"</span>,<span class="string">"as"</span>,<span class="string">"is"</span>], words2 = [<span class="string">"amazing"</span>,<span class="string">"leetcode"</span>,<span class="string">"is"</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- <span class="string">"leetcode"</span> 在两个数组中都恰好出现一次，计入答案。</span><br><span class="line">- <span class="string">"amazing"</span> 在两个数组中都恰好出现一次，计入答案。</span><br><span class="line">- <span class="string">"is"</span> 在两个数组中都出现过，但在 words1 中出现了 <span class="number">2</span> 次，不计入答案。</span><br><span class="line">- <span class="string">"as"</span> 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。</span><br><span class="line">所以，有 <span class="number">2</span> 个字符串在两个数组中都恰好出现了一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">words1</span> = [<span class="string">"b"</span>,<span class="string">"bb"</span>,<span class="string">"bbb"</span>], <span class="attr">words2</span> = [<span class="string">"a"</span>,<span class="string">"aa"</span>,<span class="string">"aaa"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有字符串在两个数组中都恰好出现一次。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words1 = [<span class="comment">"a"</span>,<span class="comment">"ab"</span>], words2 = [<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"ab"</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一在两个数组中都出现一次的字符串是 <span class="comment">"ab"</span> 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= words1.length, words2.length &lt;= 1000</code></li><li><code>1 &lt;= words1[i].length, words2[j].length &lt;= 30</code></li><li><code>words1[i] 和 words2[j] 都只包含小写英文字母。</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-common-words-with-one-occurrence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-common-words-with-one-occurrence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测统计字符串中字符的次数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>分别检测两个字符串中的字符串的次数,找到次数都为$1$ 的字符串．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串数组的长度。</li><li>空间复杂度: $O(N)$,其中 $N$ 为字符串数组的长度。。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cnt1;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cnt2;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words1) cnt1[word]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words2) cnt2[word]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt1) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt2.count(v.first) &amp;&amp; cnt2[v.first] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5923-从房屋收集雨水需要的最少水桶数"><a href="#5923-从房屋收集雨水需要的最少水桶数" class="headerlink" title="5923. 从房屋收集雨水需要的最少水桶数"></a>5923. 从房屋收集雨水需要的最少水桶数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的字符串 <code>street</code> 。<code>street</code> 中每个字符要么是表示房屋的 <code>&#39;H&#39;</code> ，要么是表示空位的 <code>&#39;.&#39;</code> 。</p><p>你可以在 空位 放置水桶，从相邻的房屋收集雨水。位置在 <code>i - 1</code> 或者 <code>i + 1</code> 的水桶可以收集位置为 <code>i</code> 处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 两个 房屋的雨水。</p><p>在确保 每个 房屋旁边都 至少 有一个水桶的前提下，请你返回需要的 最少 水桶数。如果无解请返回 <code>-1</code>。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：street = <span class="string">"H..H"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">我们可以在下标为 <span class="number">1</span> 和 <span class="number">2</span> 处放水桶。</span><br><span class="line"><span class="string">"H..H"</span> -&gt; <span class="string">"HBBH"</span>（'B' 表示放置水桶）。</span><br><span class="line">下标为 <span class="number">0</span> 处的房屋右边有水桶，下标为 <span class="number">3</span> 处的房屋左边有水桶。</span><br><span class="line">所以每个房屋旁边都至少有一个水桶收集雨水。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：street = <span class="string">".H.H."</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">我们可以在下标为 <span class="number">2</span> 处放置一个水桶。</span><br><span class="line"><span class="string">".H.H."</span> -&gt; <span class="string">".HBH."</span>（'B' 表示放置水桶）。</span><br><span class="line">下标为 <span class="number">1</span> 处的房屋右边有水桶，下标为 <span class="number">3</span> 处的房屋左边有水桶。</span><br><span class="line">所以每个房屋旁边都至少有一个水桶收集雨水。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：street = <span class="string">".HHH."</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">没有空位可以放置水桶收集下标为 <span class="number">2</span> 处的雨水。</span><br><span class="line">所以没有办法收集所有房屋的雨水。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">street </span>= <span class="string">"H"</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">没有空位放置水桶。</span><br><span class="line">所以没有办法收集所有房屋的雨水。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：street = <span class="string">"."</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">没有房屋需要收集雨水。</span><br><span class="line">所以需要 <span class="number">0</span> 个水桶。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= street.length &lt;= 105</code></li><li><code>street[i] 要么是 &#39;H&#39; ，要么是 &#39;.&#39;</code> 。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-66/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-66/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目本身确实想复杂了，就是一个简单的贪心算法，我们遍历到第 $i$ 个位置的房屋时,我们放置桶时优先放到第 $i+1$ 个位置, 因为这样有可能相邻的房屋可以共享桶; 其次我们再尝试在 $i-1$ 个位置放置桶,如果两个位置都无法放置,则表示无法完成.。无法完成的条件实际有以下几种情况:</li></ol><ul><li>字符串长度为 $1$ 且只有一个房屋.</li><li>字符串的开头或者结尾为两个连续的房屋.</li><li>字符串中存在三个连续的房屋.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$, 其中 $N$ 为字符串的长度。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumBuckets</span><span class="params">(<span class="built_in">string</span> street)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = street.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(street[i] == <span class="string">'H'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; street[i<span class="number">-1</span>] == <span class="string">'B'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; street[i+<span class="number">1</span>] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    street[i+<span class="number">1</span>] = <span class="string">'B'</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; street[i<span class="number">-1</span>] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    street[i<span class="number">-1</span>] = <span class="string">'B'</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5924-网格图中机器人回家的最小代价"><a href="#5924-网格图中机器人回家的最小代价" class="headerlink" title="5924. 网格图中机器人回家的最小代价"></a>5924. 网格图中机器人回家的最小代价</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>m x n</code> 的网格图，其中 <code>(0, 0)</code> 是最左上角的格子，<code>(m - 1, n - 1)</code> 是最右下角的格子。给你一个整数数组 <code>startPos ，startPos = [startrow, startcol]</code> 表示 初始 有一个 机器人 在格子 <code>(startrow, startcol)</code> 处。同时给你一个整数数组 <code>homePos ，homePos = [homerow, homecol]</code> 表示机器人的 家 在格子 <code>(homerow, homecol)</code> 处。</p><p>机器人需要回家。每一步它可以往四个方向移动：上，下，左，右，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从 <code>0</code> 开始的额整数数组：长度为 <code>m</code> 的数组 <code>rowCosts</code>  和长度为 <code>n</code> 的数组 <code>colCosts</code> 。</p><p>如果机器人往 上 或者往 下 移动到第 <code>r</code> 行 的格子，那么代价为 <code>rowCosts[r]</code>。<br>如果机器人往 左 或者往 右 移动到第 <code>c</code> 列 的格子，那么代价为 <code>colCosts[c]</code> 。<br>请你返回机器人回家需要的 最小总代价 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：startPos = [<span class="number">1</span>, <span class="number">0</span>], homePos = [<span class="number">2</span>, <span class="number">3</span>], rowCosts = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>], colCosts = [<span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：一个最优路径为：</span><br><span class="line">从 (<span class="number">1</span>, <span class="number">0</span>) 开始</span><br><span class="line">-&gt; 往下走到 (<span class="number">2</span>, <span class="number">0</span>) 。代价为 rowCosts[<span class="number">2</span>] = <span class="number">3</span> 。</span><br><span class="line">-&gt; 往右走到 (<span class="number">2</span>, <span class="number">1</span>) 。代价为 colCosts[<span class="number">1</span>] = <span class="number">2</span> 。</span><br><span class="line">-&gt; 往右走到 (<span class="number">2</span>, <span class="number">2</span>) 。代价为 colCosts[<span class="number">2</span>] = <span class="number">6</span> 。</span><br><span class="line">-&gt; 往右走到 (<span class="number">2</span>, <span class="number">3</span>) 。代价为 colCosts[<span class="number">3</span>] = <span class="number">7</span> 。</span><br><span class="line">总代价为 <span class="number">3</span> + <span class="number">2</span> + <span class="number">6</span> + <span class="number">7</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：startPos = [<span class="number">0</span>, <span class="number">0</span>], homePos = [<span class="number">0</span>, <span class="number">0</span>], rowCosts = [<span class="number">5</span>], colCosts = [<span class="number">26</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：机器人已经在家了，所以不需要移动。总代价为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == rowCosts.length</code></li><li><code>n == colCosts.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>0 &lt;= rowCosts[r], colCosts[c] &lt;= 104</code></li><li><code>startPos.length == 2</code></li><li><code>homePos.length == 2</code></li><li><code>0 &lt;= startrow, homerow &lt; m</code></li><li><code>0 &lt;= startcol, homecol &lt; n</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 曼哈顿距离</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们仔细思考一下相关情况.实际最小的行代价与列代价类似于求曼哈顿距离，只有起始和终点坐标有关系，与路径无关．由于每个格子的 $cost$ 都是大于 $0$ 的,最小的距离肯定是没有回头路的距离，所以我们直接求出两点之间的经过的行的代价和列的代价之和即可.如果本题改为格子的 $cost$ 可能小于 $0$ 那么情况就负责许多.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度度为 $O(m \times n)$.</li><li>空间复杂度为 $O(1)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startPos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; homePos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rowCosts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; colCosts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = rowCosts.size();</span><br><span class="line">        <span class="keyword">int</span> col = colCosts.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(startPos[<span class="number">0</span>] &lt; homePos[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = startPos[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= homePos[<span class="number">0</span>]; ++i)&#123;</span><br><span class="line">                ans += rowCosts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = startPos[<span class="number">0</span>] - <span class="number">1</span>; i &gt;= homePos[<span class="number">0</span>]; --i)&#123;</span><br><span class="line">                ans += rowCosts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(startPos[<span class="number">1</span>] &lt; homePos[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = startPos[<span class="number">1</span>] + <span class="number">1</span>; i &lt;= homePos[<span class="number">1</span>]; ++i)&#123;</span><br><span class="line">                ans += colCosts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = startPos[<span class="number">1</span>] - <span class="number">1</span>; i &gt;= homePos[<span class="number">1</span>]; --i)&#123;</span><br><span class="line">                ans += colCosts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5925-统计农场中肥沃金字塔的数目"><a href="#5925-统计农场中肥沃金字塔的数目" class="headerlink" title="5925. 统计农场中肥沃金字塔的数目"></a>5925. 统计农场中肥沃金字塔的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一个 矩形网格 状的农场，划分为 <code>m</code> 行 <code>n</code> 列的单元格。每个格子要么是 肥沃的 （用 <code>1</code> 表示），要么是 贫瘠 的（用 <code>0</code> 表示）。网格图以外的所有与格子都视为贫瘠的。</p><p>农场中的 金字塔 区域定义如下：</p><ul><li>区域内格子数目 大于 <code>1</code> 且所有格子都是 肥沃的 。<br>金字塔 顶端 是这个金字塔 最上方 的格子。金字塔的高度是它所覆盖的行数。令 <code>(r, c)</code> 为金字塔的顶端且高度为<code>h</code> ，那么金字塔区域内包含的任一格子 <code>(i, j)</code> 需满足<code>r &lt;= i &lt;= r + h - 1</code>且 <code>c - (i - r) &lt;= j &lt;= c + (i - r)</code> 。<br>一个 倒金字塔 类似定义如下：</li><li>区域内格子数目 大于 <code>1</code> 且所有格子都是 肥沃的 。<br>倒金字塔的 顶端 是这个倒金字塔 最下方 的格子。倒金字塔的高度是它所覆盖的行数。令 <code>(r, c)</code> 为金字塔的顶端且高度为 <code>h</code> ，那么金字塔区域内包含的任一格子 <code>(i, j)</code> 需满足 <code>r - h + 1 &lt;= i &lt;= r</code> 且 <code>c - (r - i) &lt;= j &lt;= c + (r - i)</code> 。<br>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。</li></ul><p>给你一个下标从 <code>0</code> 开始且大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，它表示农场，请你返回 <code>grid</code> 中金字塔和倒金字塔的 总数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">2</span> 个可能的金字塔区域分别如上图蓝色和红色区域所示。</span><br><span class="line">这个网格图中没有倒金字塔区域。</span><br><span class="line">所以金字塔区域总数为 <span class="number">2</span> + <span class="number">0</span> = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">金字塔区域如上图蓝色区域所示，倒金字塔如上图红色区域所示。</span><br><span class="line">所以金字塔区域总数目为 <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">网格图中没有任何金字塔或倒金字塔区域。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">7</span> 个金字塔区域。上图第二和第三张图中展示了它们中的 <span class="number">3</span> 个。</span><br><span class="line">有 <span class="number">6</span> 个倒金字塔区域。上图中最后一张图展示了它们中的 <span class="number">2</span> 个。</span><br><span class="line">所以金字塔区域总数目为 <span class="number">7</span> + <span class="number">6</span> = <span class="number">13.</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>grid[i][j]</code>要么是 <code>0</code> ，要么是 <code>1</code> 。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测或者dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>暴力检测:　我们利用前缀和的方法可以求出以第 $(i,j)$ 个格子为中心,向左右进行同时扩张的最长连续的为$1$ 的格子的数目为 $dp[i][j]$. 我们每次检测以 $(i,j)$ 为金字塔的顶点，向下衍生的金字塔的最大次数,此时我们只需要满足以下条件即可一直往下衍生:<script type="math/tex; mode=display">dp[i][j] >= 1 \\dp[i][j + 1] >= 1*2 + 1 \\\cdots \\dp[i][j + k] >= k*2 + 1 \\</script>我们检测$(i,j)$ 为顶点的最大层数为 $cnt$ ,则此时我们可以得到的金字塔的数目为 $cnt-1$.同理倒金字塔的检测方法也类似．</li><li>动态规划: 我们可以设 $(i,j)$ 为顶点的构成金字塔的层数为 $dp[i][j]$ ,则我们可以知道递推公式如下:<script type="math/tex; mode=display">dp[i][j] = \left\{\begin{array}{lr}\min(\min(dp[i+1][j-1],dp[i+1][j+1]),dp[i+1][j]) + 1 \qquad (grid[i][j] = 0)\\0 \qquad (grid[i][j] = 1) \\\end{array}\right.</script>已经知道递推公式,上述检测方法并不是很难.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度：动态规划的时间复杂度为 $O(m \times n)$, 暴力检测的时间复杂度为 $(m \times n) \times \min(m,n)$。</li><li>空间复杂度分析: $O(m \times n)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>暴力检测:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPyramids</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(col);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix(col);</span><br><span class="line">            prefix[<span class="number">0</span>] = grid[i][<span class="number">0</span>];</span><br><span class="line">            suffix[col<span class="number">-1</span>] = grid[i][col<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    prefix[j] = prefix[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    prefix[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-2</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    suffix[j] = suffix[j+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    suffix[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">2</span>*min(prefix[j],suffix[j]) - <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> k = i;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; row &amp;&amp; dp[k][j] &gt;= cnt*<span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += cnt - <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                k = i;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; dp[k][j] &gt;= cnt*<span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += cnt - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>动态规划:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m + <span class="number">2</span>); <span class="comment">// 在首尾各增加了一个哨兵位，以避免对边界情况的讨论。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ndp(m + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                ndp[j + <span class="number">1</span>] = min(dp[j], min(dp[j + <span class="number">1</span>], dp[j + <span class="number">2</span>])) + <span class="number">1</span>;</span><br><span class="line">                ans += ndp[j + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = move(ndp); <span class="comment">// 滚动数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPyramids</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = count(grid);</span><br><span class="line">        reverse(grid.begin(), grid.end());</span><br><span class="line">        ans += count(grid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-66&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-66&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 66&quot;&gt;&lt;/a&gt;leetcode biweekly contest 66&lt;/h1&gt;&lt;p&gt;本周的双周赛的题目不是很高，总体感觉难度不是很大.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/11/28/yKFfbsrYiGI43CR.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5922-统计出现过一次的公共字符串&quot;&gt;&lt;a href=&quot;#5922-统计出现过一次的公共字符串&quot; class=&quot;headerlink&quot; title=&quot;5922. 统计出现过一次的公共字符串&quot;&gt;&lt;/a&gt;5922. 统计出现过一次的公共字符串&lt;/h3&gt;&lt;p&gt;给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：words1 = [&lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;is&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;amazing&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;as&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;is&quot;&lt;/span&gt;], words2 = [&lt;span class=&quot;string&quot;&gt;&quot;amazing&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;is&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt; 在两个数组中都恰好出现一次，计入答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;string&quot;&gt;&quot;amazing&quot;&lt;/span&gt; 在两个数组中都恰好出现一次，计入答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;string&quot;&gt;&quot;is&quot;&lt;/span&gt; 在两个数组中都出现过，但在 words1 中出现了 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 次，不计入答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;string&quot;&gt;&quot;as&quot;&lt;/span&gt; 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以，有 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 个字符串在两个数组中都恰好出现了一次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight nix&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;attr&quot;&gt;words1&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;bb&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;bbb&quot;&lt;/span&gt;], &lt;span class=&quot;attr&quot;&gt;words2&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;aa&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;aaa&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：没有字符串在两个数组中都恰好出现一次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight smalltalk&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：words1 = [&lt;span class=&quot;comment&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;&quot;ab&quot;&lt;/span&gt;], words2 = [&lt;span class=&quot;comment&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;&quot;ab&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：唯一在两个数组中都出现一次的字符串是 &lt;span class=&quot;comment&quot;&gt;&quot;ab&quot;&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Weekly Contest 268</title>
    <link href="http://yoursite.com/2021/11/17/347/"/>
    <id>http://yoursite.com/2021/11/17/347/</id>
    <published>2021-11-17T00:57:29.873Z</published>
    <updated>2021-11-21T08:28:34.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-268"><a href="#leetcode-contest-268" class="headerlink" title="leetcode contest 268"></a>leetcode contest 268</h1><p>最后一题确实不太友好,虽然做出来了,但是感觉就是纯暴力破解.<br><img src="https://i.loli.net/2021/11/21/d6ZYRPT2FqaOMGQ.png" alt></p><h3 id="5930-两栋颜色不同且距离最远的房子"><a href="#5930-两栋颜色不同且距离最远的房子" class="headerlink" title="5930. 两栋颜色不同且距离最远的房子"></a>5930. 两栋颜色不同且距离最远的房子</h3><p>街上有 <code>n</code> 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 <code>0</code> 开始且长度为 <code>n</code> 的整数数组 <code>colors</code> ，其中 <code>colors[i]</code> 表示第 <code>i</code>栋房子的颜色。</p><a id="more"></a><p>返回 两栋 颜色 不同 房子之间的 最大 距离。</p><p>第 <code>i</code> 栋房子和第 <code>j</code> 栋房子之间的距离是 <code>abs(i - j)</code> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：上图中，颜色 <span class="number">1</span> 标识成蓝色，颜色 <span class="number">6</span> 标识成红色。</span><br><span class="line">两栋颜色不同且距离最远的房子是房子 <span class="number">0</span> 和房子 <span class="number">3</span> 。</span><br><span class="line">房子 <span class="number">0</span> 的颜色是颜色 <span class="number">1</span> ，房子 <span class="number">3</span> 的颜色是颜色 <span class="number">6</span> 。两栋房子之间的距离是 abs(<span class="number">0</span> - <span class="number">3</span>) = <span class="number">3</span> 。</span><br><span class="line">注意，房子 <span class="number">3</span> 和房子 <span class="number">6</span> 也可以产生最佳答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：上图中，颜色 <span class="number">1</span> 标识成蓝色，颜色 <span class="number">8</span> 标识成黄色，颜色 <span class="number">3</span> 标识成绿色。</span><br><span class="line">两栋颜色不同且距离最远的房子是房子 <span class="number">0</span> 和房子 <span class="number">4</span> 。</span><br><span class="line">房子 <span class="number">0</span> 的颜色是颜色 <span class="number">1</span> ，房子 <span class="number">4</span> 的颜色是颜色 <span class="number">3</span> 。两栋房子之间的距离是 abs(<span class="number">0</span> - <span class="number">4</span>) = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：两栋颜色不同且距离最远的房子是房子 <span class="number">0</span> 和房子 <span class="number">1</span> 。</span><br><span class="line">房子 <span class="number">0</span> 的颜色是颜色 <span class="number">0</span> ，房子 <span class="number">1</span> 的颜色是颜色 <span class="number">1</span> 。两栋房子之间的距离是 abs(<span class="number">0</span> - <span class="number">1</span>) = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == colors.length</code></li><li><code>2 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= colors[i] &lt;= 100</code></li><li>生成的测试数据满足至少存在 <code>2</code> 栋颜色不同的房子</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接从数组中暴力检测即可，遍历所有的不同颜色的房子．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N^2)$,其中 $N$ 为数组的长度。</li><li>空间复杂度: $O(1)$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; colors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = colors.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[i] != colors[j])&#123;</span><br><span class="line">                    ans = max(ans,j - i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5201-给植物浇水"><a href="#5201-给植物浇水" class="headerlink" title="5201. 给植物浇水"></a>5201. 给植物浇水</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你打算用一个水罐给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。<code>x = -1</code> 处有一条河，你可以在那里重新灌满你的水罐。</p><p>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p><ul><li>按从左到右的顺序给植物浇水。</li><li>在给当前植物浇完水之后，如果你没有足够的水 完全 浇灌下一株植物，那么你就需要返回河边重新装满水罐。</li><li>你 不能 提前重新灌满水罐。</li><li>最初，你在河边（也就是，<code>x = -1</code>），在 <code>x</code> 轴上每移动 一个单位 都需要 一步 。</li></ul><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有一个整数 <code>capacity</code> 表示水罐的容量，返回浇灌所有植物需要的 步数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：plants = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>], capacity = <span class="number">5</span></span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">解释：从河边开始，此时水罐是装满的：</span><br><span class="line">- 走到植物 <span class="number">0</span> (<span class="number">1</span> 步) ，浇水。水罐中还有 <span class="number">3</span> 单位的水。</span><br><span class="line">- 走到植物 <span class="number">1</span> (<span class="number">1</span> 步) ，浇水。水罐中还有 <span class="number">1</span> 单位的水。</span><br><span class="line">- 由于不能完全浇灌植物 <span class="number">2</span> ，回到河边取水 (<span class="number">2</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">2</span> (<span class="number">3</span> 步) ，浇水。水罐中还有 <span class="number">2</span> 单位的水。</span><br><span class="line">- 由于不能完全浇灌植物 <span class="number">3</span> ，回到河边取水 (<span class="number">3</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">3</span> (<span class="number">4</span> 步) ，浇水。</span><br><span class="line">需要的步数是 = <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">14</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：plants = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], capacity = <span class="number">4</span></span><br><span class="line">输出：<span class="number">30</span></span><br><span class="line">解释：从河边开始，此时水罐是装满的：</span><br><span class="line">- 走到植物 <span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span> (<span class="number">3</span> 步) ，浇水。回到河边取水 (<span class="number">3</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">3</span> (<span class="number">4</span> 步) ，浇水。回到河边取水 (<span class="number">4</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">4</span> (<span class="number">5</span> 步) ，浇水。回到河边取水 (<span class="number">5</span> 步)。</span><br><span class="line">- 走到植物 <span class="number">5</span> (<span class="number">6</span> 步) ，浇水。</span><br><span class="line">需要的步数是 = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">6</span> = <span class="number">30</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：plants = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>], capacity = <span class="number">8</span></span><br><span class="line">输出：<span class="number">49</span></span><br><span class="line">解释：每次浇水都需要重新灌满水罐。</span><br><span class="line">需要的步数是 = <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">6</span> + <span class="number">7</span> = <span class="number">49</span> 。</span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-268/problems/watering-plants/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-268/problems/watering-plants/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 枚举和模拟</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们每次记录上一次灌溉能够达到的最远位置为 $last$, 则我们返回起始位置后装满水,需要耗费的步数为 $2 \times (last + 1)$, 下一次灌溉尝试则从位置 $last + 1$ 开始尝试, 直到我们到达最后一株植物即可。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$, 其中 $N$ 为数组的长度,我们只需要遍历一遍数组即可。</li><li>空间复杂度分析: 空间复杂度为 $O(1)$。</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wateringPlants</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; plants, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = plants.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(last &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = last; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr + plants[i] &lt;= capacity)&#123;</span><br><span class="line">                    last = i;</span><br><span class="line">                    curr += plants[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += last + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(last &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                ans += last + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2075-解码斜向换位密码"><a href="#2075-解码斜向换位密码" class="headerlink" title="2075. 解码斜向换位密码"></a>2075. 解码斜向换位密码</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。</p><p>子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。</p><p>请你实现 <code>RangeFreqQuery</code> 类：</p><ul><li><code>RangeFreqQuery(int[] arr)</code> 用下标从 <code>0</code>开始的整数数组 <code>arr</code> 构造一个类的实例。</li><li><code>int query(int left, int right, int value)</code> 返回子数组 <code>arr[left...right]</code> 中 <code>value</code> 的 频率 。</li><li>一个 子数组 指的是数组中一段连续的元素。<code>arr[left...right]</code> 指的是 <code>nums</code> 中包含下标 <code>left</code> 和 <code>right</code> 在内 的中间一段连续元素。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"RangeFreqQuery"</span>, <span class="string">"query"</span>, <span class="string">"query"</span>]</span><br><span class="line">[[[<span class="number">12</span>, <span class="number">33</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>]], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">11</span>, <span class="number">33</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([<span class="number">12</span>, <span class="number">33</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>]);</span><br><span class="line">rangeFreqQuery.query(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 返回 1 。4 在子数组 [33, 4] 中出现 1 次。</span></span><br><span class="line">rangeFreqQuery.query(<span class="number">0</span>, <span class="number">11</span>, <span class="number">33</span>); <span class="comment">// 返回 2 。33 在整个子数组中出现 2 次。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 105</code></li><li><code>1 &lt;= arr[i], value &lt;= 104</code></li><li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li><li>调用 <code>query</code> 不超过 <code>105</code> 次。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-268/problems/range-frequency-queries/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-268/problems/range-frequency-queries/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 哈希存储 + 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>刚拿到挺难的样子,实际我们用哈希表存储每个元素在数组中的所以,此时如果我们需要查询某个元素 $val$ 在区间 $[left,right]$ 中的频率, 则此时我们只需要利用二分查找,查找该元素在数组中索引的集合中有多少处在区间 $[left,right]$ 中即可.</li><li>复杂度分析:</li></ol><ul><li><code>query</code>的时间复杂度为 $O(2\log n)$,其中 $n$ 为数组的长度, 对于每个查询我们需要两次二分查找．<code>RangeFreqQuery</code>需要 $O(n)$ 的时间复杂度.</li><li>空间复杂度为 $O(n)$,其中 $n$ 为数组的长度, 我们只需要存储每个元素在数组中的索引即可.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeFreqQuery</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RangeFreqQuery(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            cnt[arr[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cnt.count(value)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it1 = lower_bound(cnt[value].begin(),cnt[value].end(),left);</span><br><span class="line">        <span class="keyword">auto</span> it2 = upper_bound(cnt[value].begin(),cnt[value].end(),right);</span><br><span class="line">        <span class="keyword">return</span> it2 - it1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5933-k-镜像数字的和"><a href="#5933-k-镜像数字的和" class="headerlink" title="5933. k 镜像数字的和"></a>5933. k 镜像数字的和</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个 <code>k</code> 镜像数字 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 没有前导 <code>0</code> 的 正 整数。</p><p>比方说，<code>9</code>是一个 <code>2</code> 镜像数字。<code>9</code> 在十进制下为<code>9</code> ，二进制下为 <code>1001</code> ，两者从前往后读和从后往前读都一样。<br>相反地，<code>4</code> 不是一个 <code>2</code> 镜像数字。<code>4</code> 在二进制下为 100 ，从前往后和从后往前读不相同。<br>给你进制 <code>k</code> 和一个数字<code>n</code> ，请你返回 k 镜像数字中 最小 的 <code>n</code> 个数 之和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">2</span>, n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">最小的 <span class="number">5</span> 个 <span class="number">2</span> 镜像数字和它们的二进制表示如下：</span><br><span class="line">  十进制       二进制</span><br><span class="line">    <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">    <span class="number">3</span>          <span class="number">11</span></span><br><span class="line">    <span class="number">5</span>          <span class="number">101</span></span><br><span class="line">    <span class="number">7</span>          <span class="number">111</span></span><br><span class="line">    <span class="number">9</span>          <span class="number">1001</span></span><br><span class="line">它们的和为 <span class="number">1</span> + <span class="number">3</span> + <span class="number">5</span> + <span class="number">7</span> + <span class="number">9</span> = <span class="number">25</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">499</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">7</span> 个最小的 <span class="number">3</span> 镜像数字和它们的三进制表示如下：</span><br><span class="line">  十进制       三进制</span><br><span class="line">    <span class="number">1</span>          <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>          <span class="number">2</span></span><br><span class="line">    <span class="number">4</span>          <span class="number">11</span></span><br><span class="line">    <span class="number">8</span>          <span class="number">22</span></span><br><span class="line">    <span class="number">121</span>        <span class="number">11111</span></span><br><span class="line">    <span class="number">151</span>        <span class="number">12121</span></span><br><span class="line">    <span class="number">212</span>        <span class="number">21212</span></span><br><span class="line">它们的和为 <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">121</span> + <span class="number">151</span> + <span class="number">212</span> = <span class="number">499</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">7</span>, n = <span class="number">17</span></span><br><span class="line">输出：<span class="number">20379000</span></span><br><span class="line">解释：<span class="number">17</span> 个最小的 <span class="number">7</span> 镜像数字分别为：</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">121</span>, <span class="number">171</span>, <span class="number">242</span>, <span class="number">292</span>, <span class="number">16561</span>, <span class="number">65656</span>, <span class="number">2137312</span>, <span class="number">4602064</span>, <span class="number">6597956</span>, <span class="number">6958596</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 30</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-268/problems/sum-of-k-mirror-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-268/problems/sum-of-k-mirror-numbers/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 模拟 + 枚举</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目挺奇怪的，拿到之后确实没有非常好的方法, 只能按照题目要求生成所有 $k$ 进制的镜像数 $x$,同时我们检测 $x$ 是否也属于 $10$ 进制的镜像数, 知道满足 $n$ 个即可.</li><li>题目的难点在于如何生成镜像数, 其实这个有规律可循的, 假设我们生成 $k$ 进制且长度为 $bit$ 的所有镜像数集合(且满足从小到大)为 $cnt$.  则我们生成每个长度为 $bit + 1$ 的 $k$ 进制镜像数时,生成规则如下:</li></ol><ul><li>如果 $bit$ 为偶数, 则我们可以知道 $bit + 1$ 肯定为奇数, 此时生成规则为 我们依次在每个 $bit$ 位的 $k$ 进制镜像数的中间依次插入 $(0-9)$即可,比如当前 $4$ 进制镜像数为 $1111$, 则此时我们可以生成的镜像数为 $11011,11111,11211,11311$,每个$bit$ 位镜像数 $x$ 可以生成 $k$ 个 $bit + 1$ 位镜像数.</li><li>如果 $bit$ 为奇数数, 则我们可以知道 $bit + 1$ 肯定为偶数, 此时生成规则为我们依次在每个 $\frac{bit-1}{2}$ 与 $\frac{bit+1}{2}$ 中间插入一个 $s[\frac{bit-1}{2}]$,比如当前 $3$ 进制镜像数为 $121$, 则此时我们可以生成的镜像数为 $1221$,每个$bit$ 位镜像数 $x$ 可以生成 $1$ 个 $bit + 1$ 位镜像数.</li><li>感觉数据量很小,可以直接暴力计算出来所有可能的值,然后打表查找即可.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(n \times k \times 10)$。</li><li>空间复杂度分析: $O(n \times k)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp; str, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)&#123;</span><br><span class="line">            curr = curr*k + c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(curr);</span><br><span class="line">        <span class="built_in">string</span> t = s;</span><br><span class="line">        reverse(t.begin(),t.end());</span><br><span class="line">        <span class="keyword">if</span>(t == s)&#123;</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> bit,<span class="keyword">int</span> count,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; cnt, <span class="keyword">long</span> <span class="keyword">long</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : cnt)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = bit/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> curr = s.substr(<span class="number">0</span>,mid) + s[mid<span class="number">-1</span>] + s.substr(mid);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = check(curr, k);</span><br><span class="line">                <span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += x;</span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                next.push_back(curr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">                    <span class="built_in">string</span> curr = s.substr(<span class="number">0</span>,mid) + to_string(i) + s.substr(mid);</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> x = check(curr, k);</span><br><span class="line">                    <span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        res += x;</span><br><span class="line">                        count--;</span><br><span class="line">                        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next.push_back(curr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(k,bit+<span class="number">1</span>,count,next,res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kMirror</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            cnt.push_back(to_string(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">                res += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            res += i;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(k,<span class="number">2</span>,n - (k<span class="number">-1</span>),cnt,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-268&quot;&gt;&lt;a href=&quot;#leetcode-contest-268&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 268&quot;&gt;&lt;/a&gt;leetcode contest 268&lt;/h1&gt;&lt;p&gt;最后一题确实不太友好,虽然做出来了,但是感觉就是纯暴力破解.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/11/21/d6ZYRPT2FqaOMGQ.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5930-两栋颜色不同且距离最远的房子&quot;&gt;&lt;a href=&quot;#5930-两栋颜色不同且距离最远的房子&quot; class=&quot;headerlink&quot; title=&quot;5930. 两栋颜色不同且距离最远的房子&quot;&gt;&lt;/a&gt;5930. 两栋颜色不同且距离最远的房子&lt;/h3&gt;&lt;p&gt;街上有 &lt;code&gt;n&lt;/code&gt; 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始且长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;colors&lt;/code&gt; ，其中 &lt;code&gt;colors[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt;栋房子的颜色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab8 Thread</title>
    <link href="http://yoursite.com/2021/11/15/346/"/>
    <id>http://yoursite.com/2021/11/15/346/</id>
    <published>2021-11-15T05:21:58.779Z</published>
    <updated>2021-11-15T05:22:33.651Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>Kickstart Kickstart 2021 Round  H</title>
    <link href="http://yoursite.com/2021/11/15/345/"/>
    <id>http://yoursite.com/2021/11/15/345/</id>
    <published>2021-11-15T05:19:31.766Z</published>
    <updated>2021-12-05T10:29:28.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kickstart-2021-round-H"><a href="#kickstart-2021-round-H" class="headerlink" title="kickstart 2021 round  H"></a>kickstart 2021 round  H</h1><p><code>kickstart</code>的题目一向质量高,并且难度非常大，感觉基本上是校招面试题中难度最大的题目了，感觉力扣的难度弱爆了. 前三题感觉基本上只需要基本的数学技巧和数据结构的基本知识就可以做出来，最后一题真心是达到<code>ACM</code>的入门难度，还是挺难的题目。第四题花了好长时间才能弄懂题解.</p><a id="more"></a><h3 id="Transform-the-String"><a href="#Transform-the-String" class="headerlink" title="Transform the String"></a>Transform the String</h3><p>Problem<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You are given a string S which denotes a padlock consisting of lower case English letters. You are also given a string F consisting of <span class="keyword">set</span> <span class="keyword">of</span> favorite <span class="keyword">lower</span> <span class="keyword">case</span> English letters. You <span class="keyword">are</span> allowed <span class="keyword">to</span> perform several <span class="keyword">operations</span> <span class="keyword">on</span> the padlock. <span class="keyword">In</span> <span class="keyword">each</span> operation, you can <span class="keyword">change</span> one letter <span class="keyword">of</span> the <span class="keyword">string</span> <span class="keyword">to</span> the one <span class="keyword">following</span> it <span class="keyword">or</span> <span class="keyword">preceding</span> it <span class="keyword">in</span> the alphabetical order. <span class="keyword">For</span> example: <span class="keyword">for</span> the letter c, you <span class="keyword">are</span> allowed <span class="keyword">to</span> <span class="keyword">change</span> it <span class="keyword">to</span> either b <span class="keyword">or</span> d <span class="keyword">in</span> an operation. The letters can be considered <span class="keyword">in</span> a cyclic <span class="keyword">order</span>, i.e., the <span class="keyword">preceding</span> letter <span class="keyword">for</span> letter a would be letter z. Similarly, the <span class="keyword">following</span> letter <span class="keyword">for</span> letter z would be letter a.</span><br><span class="line"></span><br><span class="line">Your aim <span class="keyword">is</span> <span class="keyword">to</span> find the <span class="keyword">minimum</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">operations</span> that <span class="keyword">are</span> <span class="keyword">required</span> such that <span class="keyword">each</span> letter <span class="keyword">in</span> <span class="keyword">string</span> S <span class="keyword">after</span> applying the <span class="keyword">operations</span>, <span class="keyword">is</span> <span class="keyword">present</span> <span class="keyword">in</span> <span class="keyword">string</span> F.</span><br></pre></td></tr></table></figure></p><p>Input<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The <span class="keyword">first</span> <span class="built_in">line</span> <span class="keyword">of</span> <span class="keyword">the</span> input gives <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> test cases, T. T test cases follow.</span><br><span class="line"></span><br><span class="line">Each test <span class="keyword">case</span> consists <span class="keyword">of</span> <span class="literal">two</span> <span class="keyword">lines</span>.</span><br><span class="line">The <span class="keyword">first</span> <span class="built_in">line</span> <span class="keyword">of</span> <span class="keyword">each</span> test <span class="keyword">case</span> <span class="keyword">contains</span> <span class="keyword">the</span> <span class="keyword">string</span> S.</span><br><span class="line">The <span class="keyword">second</span> <span class="built_in">line</span> <span class="keyword">of</span> <span class="keyword">each</span> test <span class="keyword">case</span> <span class="keyword">contains</span> <span class="keyword">the</span> <span class="keyword">string</span> F.</span><br></pre></td></tr></table></figure></p><p>Output<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> <span class="keyword">each</span> test <span class="keyword">case</span>, output one <span class="type">line</span> containing <span class="keyword">Case</span> #x: y, <span class="keyword">where</span> x <span class="keyword">is</span> the test <span class="keyword">case</span> number (starting <span class="keyword">from</span> <span class="number">1</span>) <span class="keyword">and</span> y <span class="keyword">is</span> the minimum number <span class="keyword">of</span> operations that are required such that <span class="keyword">each</span> letter <span class="keyword">in</span> string S <span class="keyword">after</span> applying the operations, <span class="keyword">is</span> one <span class="keyword">of</span> the characters <span class="keyword">in</span> string F.</span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008da461#problem" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008da461#problem</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 遍历</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一题就是灌水题，非常简单.　要求找到将字符串中的字符全部变为给定的字符集中字符，求最小的变换次数，字符 <code>a</code> 转换到字符 <code>b</code> 有两种转换方法, 要么递增,要么递减翻转. $minstep = \min(|a-b|,26 - |a-b|)$,我们首先统计字符串 $s$ 中每种字符的个数, 然后对 $s$ 中的每种字符在字符集中找到最小的变换步数的目标字符 $c$ 即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(CN)$,其中 $M$ 为字符集中字符的个数。</li><li>空间复杂度: $O(C)$,其中 $C = 26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> src;</span><br><span class="line">    <span class="built_in">string</span> target;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;src;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;target;  </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : src) cnt[c - <span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : target) &#123;</span><br><span class="line">            curr = min(curr, <span class="built_in">abs</span>(<span class="string">'a'</span> + i - c));</span><br><span class="line">            curr = min(curr, <span class="number">26</span> - <span class="built_in">abs</span>(<span class="string">'a'</span> + i - c));</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="keyword">long</span> <span class="keyword">long</span>)curr * cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="Painter"><a href="#Painter" class="headerlink" title="Painter"></a>Painter</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/12/01/CoIOBGxR7zY4P3U.png" alt></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9a88" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9a88</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法或者<code>dfs</code></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常有趣,感觉跟某个力扣的某个题非常像,题意是说每种颜色可能有红黄蓝三种基本颜色组合, 每次涂画时可以选择一个区间　$[L,R]$ 涂上一种基本色, 给定的区间颜色分布,找到最少的涂画次数.</li><li>贪心算法, 我们设 $dp[i]$ 表示涂画前 $i$ 个颜色时所需要的涂画的最小步数, 我们在画 第 $i+1$ 个颜色时我们应该如何选择呢:</li></ol><ul><li>按照贪心算法进行选择颜色, 假设第 $i$ 个颜色的基色包括 $i+1$ 个颜色使用的所有基色, 那么我们可以知道在画第 $i$ 个颜色时的基色时 我们肯定可以将 $i+1$ 个颜色的基色也包含进去,因此 $dp[i+1] = dp[i]$, 我们举例如下:<ul><li>我们假设第 $i$ 个颜色为 $G$, 第 $i+1$ 个颜色为 $P$, 则此时我们假设 $i$ 中的三种基色最后涂画时的区间分布分别为 $[L_r,i],[L_g,i],[L_b,i]$, 我们可以知道按照贪心原则我们可以将以上 $red$, $blue$ 的区间向由扩展一个位置,则此时三种基色的区间分别为 $[L_r,i+1],[L_g,i],[L_b,i+1]$, 此时即可同时满足第 $i$ 个颜色与 第 $i+1$ 个颜色.</li></ul></li><li>假设第 $i$ 个颜色的基色不能包含第 $i+1$ 个颜色使用的所有基色时,则此时我们只需要找到第 $i+1$ 个颜色使用了与第 $i$ 个颜色有哪些不同的基色.此时递推公式为 $dp[i+1] = dp[i] + diff(i,i+1)$<br>实际处理中我们对每种颜色进行二进制编码, 我们用 $mask[i]$ 表示第 $i$ 个颜色的二进制编码, $mask[i+1]$ 表示第 $i+1$ 个颜色的二进制编码,则此时我们可以知道递推公式为 $dp[i+1] = dp[i] + count((mask[i]|mask[i]) \oplus maks[i])$</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$,其中 $N$ 为字符串的长度.</li><li>空间复杂度分析: 空间复杂度为 $O(N)$,其中 $N$ 为字符串的长度.</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Red + Yellow = Orange 110</span></span><br><span class="line"><span class="comment">Red + Blue = Purple   101</span></span><br><span class="line"><span class="comment">Yellow + Blue = Green 011</span></span><br><span class="line"><span class="comment">Red + Yellow + Blue = Gray 111</span></span><br><span class="line"><span class="comment">U = Uncolored 000</span></span><br><span class="line"><span class="comment">R = Red       100</span></span><br><span class="line"><span class="comment">Y = Yellow    010</span></span><br><span class="line"><span class="comment">B = Blue      001</span></span><br><span class="line"><span class="comment">O = Orange    110</span></span><br><span class="line"><span class="comment">P = Purple    101</span></span><br><span class="line"><span class="comment">G = Green     011</span></span><br><span class="line"><span class="comment">A = Gray      111</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*ROAOR 3</span></span><br><span class="line"><span class="comment">  12331 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        x = x&amp;(x<span class="number">-1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; dict = &#123;<span class="string">'U'</span>,<span class="string">'R'</span>,<span class="string">'Y'</span>,<span class="string">'B'</span>,<span class="string">'O'</span>,<span class="string">'P'</span>,<span class="string">'G'</span>,<span class="string">'A'</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">        cnt[dict[i]] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = count(cnt[s[<span class="number">0</span>]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = cnt[s[i]];</span><br><span class="line">        <span class="keyword">int</span> prev = cnt[s[i - <span class="number">1</span>]];</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + count(curr|prev) - count(prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Silly-Substitutions"><a href="#Silly-Substitutions" class="headerlink" title="Silly Substitutions"></a>Silly Substitutions</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>You are given a string S of length N which consists of digits 0-9. You do the following operations on the string in the order given.<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Find all <span class="keyword">the</span> substrings <span class="number">01</span> <span class="keyword">and</span> <span class="built_in">replace</span> <span class="keyword">each</span> <span class="keyword">of</span> them <span class="keyword">with</span> <span class="number">2.</span></span><br><span class="line">Find all <span class="keyword">the</span> substrings <span class="number">12</span> <span class="keyword">and</span> <span class="built_in">replace</span> <span class="keyword">each</span> <span class="keyword">of</span> them <span class="keyword">with</span> <span class="number">3.</span></span><br><span class="line">Find all <span class="keyword">the</span> substrings <span class="number">23</span> <span class="keyword">and</span> <span class="built_in">replace</span> <span class="keyword">each</span> <span class="keyword">of</span> them <span class="keyword">with</span> <span class="number">4.</span></span><br><span class="line">Find all <span class="keyword">the</span> substrings <span class="number">34</span> <span class="keyword">and</span> <span class="built_in">replace</span> <span class="keyword">each</span> <span class="keyword">of</span> them <span class="keyword">with</span> <span class="number">5.</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><br>Find all the substrings 89 and replace each of them with 0.<br>Find all the substrings 90 and replace each of them with 1.<br>You repeat this process in the same given order until none of the above operations change the string. For example, if S is 12 then we do not stop at operation 1 since it does not affect the string but perform operation 2 and change the string to 3. We can see that the string does not change further no matter how many times we repeat the above process.</p><p>Your task is to find how the final string will look like for the given S.</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d94f5" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d94f5</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 双链表</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目还是非常不错的，我们首先将字符串用双链表来表示出来．我们首先将双链表中所有可能合并的字符串的头节点全部存储在10个集合中,比如我们知道目前双链表如下:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>此时我们知道可能合并的字符串分别为:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-&gt;<span class="number">1</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line"><span class="number">3</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>我们会存储$0,1,2,3$ 所在的头节点.</li><li>我们依次遍历所有可能合并的组合 $01,12,23,34,45,56,…,90$等等.我们每次取出可以合并的数字组合时,每次合并时可能会产生新的组合,我们将新的可以合并的组合再加入到集合中,比如以下举例:<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...a-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;b...</span><br></pre></td></tr></table></figure>我们将 $01$ 进行合并后生成 $a2b$, 此时我们首先对双链表进行节点的删除与插入,同时对新生成的数字组合判断是否可以构成待消除的组合,如果含有可以消除的组合,则我们将其插入到集合中.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(CN)$,其中 $N$ 为字符串的长度, 我们每次 $10$ 次循环依次判断从 $01 \cdots 90$的消除组合，每次消除时都能消除一个字符，最多需要 $O(10N)$ 的时间复杂度．</li><li>空间复杂度为 $O(N)$,其中 $N$ 为字符串的长度.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">T val;</span><br><span class="line">    ListNode * prev;</span><br><span class="line">    ListNode * next;</span><br><span class="line">    ListNode(T val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> ListNode&lt;T&gt; * insert(ListNode&lt;T&gt; * curr, T val) &#123;</span><br><span class="line">    ListNode&lt;T&gt; * node = <span class="keyword">new</span> ListNode&lt;T&gt;(val);</span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;next)&#123;</span><br><span class="line">        node-&gt;next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curr) &#123;</span><br><span class="line">        curr-&gt;next = node;</span><br><span class="line">        node-&gt;prev = curr;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">   <span class="built_in">string</span> s;</span><br><span class="line">   <span class="built_in">string</span> ans;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nxt(<span class="number">12</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) nxt[i] = (i+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">   nxt[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">   nxt[<span class="number">11</span>] = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* link list*/</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;ListNode&lt;<span class="keyword">int</span>&gt; *&gt;&gt; arr(<span class="number">10</span>);</span><br><span class="line">   ListNode&lt;<span class="keyword">int</span>&gt; * head = <span class="keyword">new</span> ListNode&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">   insert(head,<span class="number">11</span>);</span><br><span class="line">   ListNode&lt;<span class="keyword">int</span>&gt; * tail = head;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">       tail = insert(tail, c - <span class="string">'0'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(ListNode&lt;<span class="keyword">int</span>&gt; * node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">       <span class="keyword">if</span>(node-&gt;next &amp;&amp; nxt[node-&gt;val] == node-&gt;next-&gt;val)&#123;</span><br><span class="line">           arr[node-&gt;val].insert(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* we remove each key and merge*/</span> </span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">bool</span> rflag = <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">           rflag = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">auto</span> t : arr[i])&#123;</span><br><span class="line">               ListNode&lt;<span class="keyword">int</span>&gt; * curr = <span class="keyword">new</span> ListNode&lt;<span class="keyword">int</span>&gt;((nxt[t-&gt;val] + <span class="number">1</span>)%<span class="number">10</span>);</span><br><span class="line">               ListNode&lt;<span class="keyword">int</span>&gt; * prev = t-&gt;prev;</span><br><span class="line">               ListNode&lt;<span class="keyword">int</span>&gt; * next = t-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*remove key node*/</span></span><br><span class="line">               <span class="keyword">if</span>(nxt[prev-&gt;val] == t-&gt;val)&#123;</span><br><span class="line">                   arr[prev-&gt;val].erase(prev);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(nxt[t-&gt;next-&gt;val] == next-&gt;val)&#123;</span><br><span class="line">                   arr[t-&gt;next-&gt;val].erase(t-&gt;next);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*merge new key*/</span></span><br><span class="line">               prev-&gt;next = curr;</span><br><span class="line">               curr-&gt;prev = prev;</span><br><span class="line">               curr-&gt;next = next;</span><br><span class="line">               next-&gt;prev = curr;</span><br><span class="line">               <span class="keyword">if</span>(nxt[prev-&gt;val] == curr-&gt;val)&#123;</span><br><span class="line">                   arr[prev-&gt;val].insert(prev);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(nxt[curr-&gt;val] == next-&gt;val)&#123;</span><br><span class="line">                   arr[curr-&gt;val].insert(curr);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">delete</span> t-&gt;next;</span><br><span class="line">               <span class="keyword">delete</span> t;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">           arr[i].clear();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!rflag) <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(ListNode&lt;<span class="keyword">int</span>&gt; * node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">       <span class="keyword">if</span>(node-&gt;val &gt;= <span class="number">0</span> &amp;&amp; node-&gt;val &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">           ans.push_back(node-&gt;val + <span class="string">'0'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="Dependent-Events"><a href="#Dependent-Events" class="headerlink" title="Dependent Events"></a>Dependent Events</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are N events, numbered <span class="number">1</span> through N. The probability <span class="keyword">of</span> occurrence <span class="keyword">of</span> <span class="keyword">each</span> <span class="keyword">event</span> depends upon the occurrence <span class="keyword">of</span> exactly one other <span class="keyword">event</span> called the parent <span class="keyword">event</span>, <span class="keyword">except</span> <span class="keyword">event</span> <span class="number">1</span>, which <span class="keyword">is</span> an independent <span class="keyword">event</span>. <span class="keyword">In</span> other words, <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">event</span> <span class="keyword">from</span> <span class="number">2</span> <span class="keyword">to</span> N, <span class="number">3</span> values are given: Pi denoting the parent <span class="keyword">event</span> <span class="keyword">of</span> <span class="keyword">event</span> i, Ai denoting the probability <span class="keyword">of</span> occurrence <span class="keyword">of</span> <span class="keyword">event</span> i <span class="keyword">if</span> its parent <span class="keyword">event</span> occurs, <span class="keyword">and</span> Bi denoting the probability <span class="keyword">of</span> occurrence <span class="keyword">of</span> <span class="keyword">event</span> i <span class="keyword">if</span> its parent <span class="keyword">event</span> does <span class="keyword">not</span> occur. <span class="keyword">For</span> <span class="keyword">event</span> <span class="number">1</span>, its probability <span class="keyword">of</span> occurrence K <span class="keyword">is</span> given. There are Q queries that we want <span class="keyword">to</span> answer. <span class="keyword">Each</span> query consists <span class="keyword">of</span> <span class="number">2</span> <span class="keyword">distinct</span> events, uj <span class="keyword">and</span> vj, <span class="keyword">and</span> you need <span class="keyword">to</span> find the probability that both events uj <span class="keyword">and</span> vj have occurred.</span><br></pre></td></tr></table></figure><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9970" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9970</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目太难了，不会．</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kickstart-2021-round-H&quot;&gt;&lt;a href=&quot;#kickstart-2021-round-H&quot; class=&quot;headerlink&quot; title=&quot;kickstart 2021 round  H&quot;&gt;&lt;/a&gt;kickstart 2021 round  H&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kickstart&lt;/code&gt;的题目一向质量高,并且难度非常大，感觉基本上是校招面试题中难度最大的题目了，感觉力扣的难度弱爆了. 前三题感觉基本上只需要基本的数学技巧和数据结构的基本知识就可以做出来，最后一题真心是达到&lt;code&gt;ACM&lt;/code&gt;的入门难度，还是挺难的题目。第四题花了好长时间才能弄懂题解.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Weekly Contest 267</title>
    <link href="http://yoursite.com/2021/11/15/344/"/>
    <id>http://yoursite.com/2021/11/15/344/</id>
    <published>2021-11-15T03:21:04.506Z</published>
    <updated>2021-11-15T04:00:06.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-267"><a href="#leetcode-contest-267" class="headerlink" title="leetcode contest 267"></a>leetcode contest 267</h1><p>最后一题果真没有区分度,基本上都做出来了,就是一个简单集合合并的问题.</p><h3 id="2073-买票需要的时间"><a href="#2073-买票需要的时间" class="headerlink" title="2073. 买票需要的时间"></a>2073. 买票需要的时间</h3><p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 最前方 ，第 <code>(n - 1)</code> 人站在队伍 最后方 。</p><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p><a id="more"></a><p>每个人买票都需要用掉 恰好 <code>1</code> 秒 。一个人 一次只能买一张票 ，如果需要购买更多票，他必须走到  队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 离开 队伍。</p><p>返回位于位置 <code>k</code>（下标从 <code>0</code> 开始）的人完成买票需要的时间（以秒为单位）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释： </span><br><span class="line">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>] 。</span><br><span class="line">- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>] 。</span><br><span class="line">位置 <span class="number">2</span> 的人成功买到 <span class="number">2</span> 张票，用掉 <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span> 秒。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：</span><br><span class="line">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] 。</span><br><span class="line">- 接下来的 <span class="number">4</span> 轮，只有位置 <span class="number">0</span> 的人在买票。</span><br><span class="line">位置 <span class="number">0</span> 的人成功买到 <span class="number">5</span> 张票，用掉 <span class="number">4</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">8</span> 秒。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == tickets.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= tickets[i] &lt;= 100</code></li><li><code>0 &lt;= k &lt; n</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/time-needed-to-buy-tickets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/time-needed-to-buy-tickets</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 模拟队列或者数学问题均可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接模拟即可实现所有的排队完成.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(K \times N)$,其中 $N$ 为数组的长度。</li><li>空间复杂度: $O(N)$,其中 $C = 26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeRequiredToBuy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tickets, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = tickets.size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            qu.push(make_pair(tickets[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            ans++;</span><br><span class="line">            curr.first--;</span><br><span class="line">            <span class="keyword">if</span>(curr.first &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                qu.push(curr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr.second == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2074-反转偶数长度组的节点"><a href="#2074-反转偶数长度组的节点" class="headerlink" title="2074. 反转偶数长度组的节点"></a>2074. 反转偶数长度组的节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 <code>head</code> 。</p><p>链表中的节点 按顺序 划分成若干 非空 组，这些非空组的长度构成一个自然数序列<code>（1, 2, 3, 4, ...）</code>。一个组的 长度 就是组中分配到的节点数目。换句话说：</p><ul><li>节点 1 分配给第一组</li><li>节点 2 和 3 分配给第二组</li><li>节点 4、5 和 6 分配给第三组，以此类推</li><li>注意，最后一组的长度可能小于或者等于 1 + 倒数第二组的长度 。</li></ul><p>反转 每个 偶数 长度组中的节点，并返回修改后链表的头节点 <code>head</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">解释：</span><br><span class="line">- 第一组长度为 <span class="number">1</span> ，奇数，没有发生反转。</span><br><span class="line">- 第二组长度为 <span class="number">2</span> ，偶数，节点反转。</span><br><span class="line">- 第三组长度为 <span class="number">3</span> ，奇数，没有发生反转。</span><br><span class="line">- 最后一组长度为 <span class="number">4</span> ，偶数，节点反转。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">- 第一组长度为 <span class="number">1</span> ，没有发生反转。</span><br><span class="line">- 第二组长度为 <span class="number">2</span> ，节点反转。</span><br><span class="line">- 最后一组长度为 <span class="number">1</span> ，没有发生反转。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：</span><br><span class="line">- 第一组长度为 <span class="number">1</span> ，没有发生反转。</span><br><span class="line">- 最后一组长度为 <span class="number">1</span> ，没有发生反转。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">8</span>]</span><br><span class="line">解释：只有一个长度为 <span class="number">1</span> 的组，没有发生反转。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表中节点数目范围是 <code>[1, 105]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 链表转数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目本身比较奇葩的问题，真心不如转换成数组，然后进行翻转，题目本上就变得非常简单.我们将链表转换为数组，然后按照题目要求进行分组翻转，然后再重建链表即可，比较坑的一点在于：</li></ol><ul><li>特别需要注意最后一组的长度可能为偶数,此时我们需要进行翻转.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$,其中 $N$ 为链表的长度.</li><li>空间复杂度分析: 空间复杂度为 $O(N)$,其中 $N$ 为链表的长度.</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseEvenLengthGroups</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(ListNode * node = head; node; node = node-&gt;next)&#123;</span><br><span class="line">            arr.emplace_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; n &gt; <span class="number">0</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = (i<span class="number">-1</span>)*i/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> r = min((<span class="keyword">int</span>)arr.size(),(i+<span class="number">1</span>)*i/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>((r - l)%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                reverse(arr.begin() + l,arr.begin() + r);</span><br><span class="line">            &#125;</span><br><span class="line">            n -= r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * newhead = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode * curr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;           </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                curr = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">                newhead = curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr-&gt;next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2075-解码斜向换位密码"><a href="#2075-解码斜向换位密码" class="headerlink" title="2075. 解码斜向换位密码"></a>2075. 解码斜向换位密码</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>字符串 <code>originalText</code> 使用 斜向换位密码 ，经由 行数固定 为 rows 的矩阵辅助，加密得到一个字符串 <code>encodedText</code> 。</p><p><code>originalText</code> 先按从左上到右下的方式放置到矩阵中。</p><p>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 <code>originalText</code> 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 ‘ ‘ 进行填充。矩阵的列数需满足：用 <code>originalText</code> 填充之后，最右侧列 不为空 。</p><p>接着按行将字符附加到矩阵中，构造 <code>encodedText</code> 。</p><p>先把蓝色单元格中的字符附加到 <code>encodedText</code> 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。</p><p>例如，如果 <code>originalText = &quot;cipher&quot;</code> 且 <code>rows = 3</code> ，那么我们可以按下述方法将其编码：</p><p>蓝色箭头标识 <code>originalText</code> 是如何放入矩阵中的，红色箭头标识形成 <code>encodedText</code> 的顺序。在上述例子中，<code>encodedText = &quot;ch   ie   pr&quot;</code>。</p><p>给你编码后的字符串 encodedText 和矩阵的行数 rows ，返回源字符串 originalText 。</p><p>注意：<code>originalText</code> 不 含任何尾随空格 ‘ ‘ 。生成的测试用例满足 仅存在一个 可能的 <code>originalText</code> 。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">encodedText</span> = <span class="string">"ch   ie   pr"</span>, <span class="attr">rows</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"cipher"</span></span><br><span class="line">解释：此示例与问题描述中的例子相同。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：encodedText = <span class="string">"iveo    eed   l te   olc"</span>, rows = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"i love leetcode"</span></span><br><span class="line">解释：上图标识用于编码 <span class="keyword">originalText </span>的矩阵。 </span><br><span class="line">蓝色箭头展示如何从 encodedText 找到 <span class="keyword">originalText </span>。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：encodedText = <span class="string">"coding"</span>, rows = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"coding"</span></span><br><span class="line">解释：由于只有 <span class="number">1</span> 行，所以 originalText 和 encodedText 是相同的。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">encodedText</span> = <span class="string">" b  ac"</span>, <span class="attr">rows</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="string">" abc"</span></span><br><span class="line">解释：originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>0 &lt;= encodedText.length &lt;= 106</code></li><li><code>encodedText</code> 仅由小写英文字母和 ‘ ‘ 组成</li><li><code>encodedText</code> 是对某个 不含 尾随空格的 <code>originalText</code> 的一个有效编码</li><li><code>1 &lt;= rows &lt;= 1000</code></li><li>生成的测试用例满足 仅存在一个 可能的 <code>originalText</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/decode-the-slanted-ciphertext" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-the-slanted-ciphertext</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 对字符串进行还原即可</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>少点这种奇奇怪怪的题目,还是能够多一点思考和智力的题目,题目本身感觉非常怪异,题目本省其实也比较简答.我们首先可以确定矩阵的列数为 $cols = \frac{n}{rows}$,然后我们就可以知道 $originalText$ 的第 $i$ 个字符对应矩阵的位置坐标为 $(i/cols,i\%cols)$,我们还原矩阵后,就按照斜行的访问方式还原原始字符串,最终需要去掉字符串末尾的空格.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$,其中 $N$ 为字符串的个数．</li><li>空间复杂度为 $O(N)$,其中 $N$ 为字符串的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeCiphertext</span><span class="params">(<span class="built_in">string</span> encodedText, <span class="keyword">int</span> rows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = encodedText.size();</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> cols = n/rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; mat(rows,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(cols,<span class="string">'#'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            mat[i/cols][i%cols] = encodedText[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cols; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = i;</span><br><span class="line">            <span class="keyword">while</span>(x &lt; rows &amp;&amp; y &lt; cols &amp;&amp; mat[x][y] != <span class="string">'#'</span>)&#123;</span><br><span class="line">                ans.push_back(mat[x][y]);</span><br><span class="line">                x++;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ans.size(); i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.back() == <span class="string">' '</span>) ans.pop_back();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2076-处理含限制条件的好友请求"><a href="#2076-处理含限制条件的好友请求" class="headerlink" title="2076. 处理含限制条件的好友请求"></a>2076. 处理含限制条件的好友请求</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code> ，表示网络上的用户数目。每个用户按从 <code>0</code> 到 <code>n - 1</code>进行编号。</p><p>给你一个下标从 0 开始的二维整数数组 <code>restrictions</code> ，其中<code>restrictions[i] = [xi, yi]</code> 意味着用户 <code>xi</code> 和用户 <code>yi</code> 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。</p><p>最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 <code>requests</code> 表示好友请求的列表，其中 <code>requests[j] = [uj, vj]</code>是用户 <code>uj</code>和用户 vj 之间的一条好友请求。</p><p>如果<code>uj</code> 和 <code>vj</code> 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，<code>requests[j]</code> 会在 <code>requests[j + 1]</code>前）。一旦请求成功，那么对所有未来的好友请求而言， <code>uj</code> 和 <code>vj</code> 将会 成为直接朋友 。</p><p>返回一个 布尔数组 <code>result</code> ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 <code>result[j]</code> 就是 <code>true</code> ；否则，为 <code>false</code> 。</p><p>注意：如果 <code>uj</code>和<code>vj</code> 已经是直接朋友，那么他们之间的请求将仍然 成功 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, restrictions = [[<span class="number">0</span>,<span class="number">1</span>]], requests = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：</span><br><span class="line">请求 <span class="number">0</span> ：用户 <span class="number">0</span> 和 用户 <span class="number">2</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">1</span> ：用户 <span class="number">2</span> 和 用户 <span class="number">1</span> 不能成为朋友，因为这会使 用户 <span class="number">0</span> 和 用户 <span class="number">1</span> 成为间接朋友 (<span class="number">1</span>-<span class="number">-2</span>-<span class="number">-0</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, restrictions = [[<span class="number">0</span>,<span class="number">1</span>]], requests = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：</span><br><span class="line">请求 <span class="number">0</span> ：用户 <span class="number">1</span> 和 用户 <span class="number">2</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">1</span> ：用户 <span class="number">0</span> 和 用户 <span class="number">2</span> 不能成为朋友，因为这会使 用户 <span class="number">0</span> 和 用户 <span class="number">1</span> 成为间接朋友 (<span class="number">0</span>-<span class="number">-2</span>-<span class="number">-1</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, restrictions = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]], requests = [[<span class="number">0</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：</span><br><span class="line">请求 <span class="number">0</span> ：用户 <span class="number">0</span> 和 用户 <span class="number">4</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">1</span> ：用户 <span class="number">1</span> 和 用户 <span class="number">2</span> 不能成为朋友，因为他们之间存在限制。</span><br><span class="line">请求 <span class="number">2</span> ：用户 <span class="number">3</span> 和 用户 <span class="number">1</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">3</span> ：用户 <span class="number">3</span> 和 用户 <span class="number">4</span> 不能成为朋友，因为这会使 用户 <span class="number">0</span> 和 用户 <span class="number">1</span> 成为间接朋友 (<span class="number">0</span>-<span class="number">-4</span>-<span class="number">-3</span>-<span class="number">-1</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>0 &lt;= restrictions.length &lt;= 1000</code></li><li><code>restrictions[i].length == 2</code></li><li><code>0 &lt;= xi, yi &lt;= n - 1</code></li><li><code>xi != yi</code></li><li><code>1 &lt;= requests.length &lt;= 1000</code></li><li><code>requests[j].length == 2</code></li><li><code>0 &lt;= uj, vj &lt;= n - 1</code></li><li><code>uj != vj</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/process-restricted-friend-requests" target="_blank" rel="noopener">https://leetcode-cn.com/problems/process-restricted-friend-requests</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 集合</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目可以算是中等题目．难点在于如何判断两个人是否通过朋友圈链接合法性,我们可以利用集合的特性,如果两个人 $x,y$ 不能成为朋友,我们只需要判断这两个人是否在同一个集合中即可.</li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(mn \cdot \alpha(n))$，其中 mm 是数组 $\textit{restrictions}$ 的长度，$\alpha(\cdot)$ 是反阿克曼函数，表示在路径压缩和按秩合并优化下的并查集的单次操作时间复杂度。</li><li>空间复杂度分析: $O(n)$，即为并查集需要使用的空间.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x] == f[y]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">        f[x1] = y1;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; friendRequests(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; restrictions, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requests) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = restrictions.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requests.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = requests[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = requests[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> fx = find(f,x);</span><br><span class="line">            <span class="keyword">int</span> fy = find(f,y);</span><br><span class="line">            <span class="keyword">if</span>(fx == fy)&#123;</span><br><span class="line">                ans.push_back(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> fa = find(f,restrictions[j][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> fb = find(f,restrictions[j][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>((fa == fx &amp;&amp; fb == fy) || (fa == fy &amp;&amp; fb == fx))&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                uni(f,x,y);</span><br><span class="line">                ans.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-267&quot;&gt;&lt;a href=&quot;#leetcode-contest-267&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 267&quot;&gt;&lt;/a&gt;leetcode contest 267&lt;/h1&gt;&lt;p&gt;最后一题果真没有区分度,基本上都做出来了,就是一个简单集合合并的问题.&lt;/p&gt;&lt;h3 id=&quot;2073-买票需要的时间&quot;&gt;&lt;a href=&quot;#2073-买票需要的时间&quot; class=&quot;headerlink&quot; title=&quot;2073. 买票需要的时间&quot;&gt;&lt;/a&gt;2073. 买票需要的时间&lt;/h3&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个人前来排队买票，其中第 &lt;code&gt;0&lt;/code&gt; 人站在队伍 最前方 ，第 &lt;code&gt;(n - 1)&lt;/code&gt; 人站在队伍 最后方 。&lt;/p&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;tickets&lt;/code&gt; ，数组长度为 &lt;code&gt;n&lt;/code&gt; ，其中第 &lt;code&gt;i&lt;/code&gt; 人想要购买的票数为 &lt;code&gt;tickets[i]&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 65</title>
    <link href="http://yoursite.com/2021/11/14/343/"/>
    <id>http://yoursite.com/2021/11/14/343/</id>
    <published>2021-11-14T15:30:25.886Z</published>
    <updated>2021-11-15T01:45:37.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-65"><a href="#leetcode-biweekly-contest-65" class="headerlink" title="leetcode biweekly contest 65"></a>leetcode biweekly contest 65</h1><p>双周赛的难度还是挺大的,</p><h3 id="5910-检查两个字符串是否几乎相等"><a href="#5910-检查两个字符串是否几乎相等" class="headerlink" title="5910. 检查两个字符串是否几乎相等"></a>5910. 检查两个字符串是否几乎相等</h3><p>如果两个字符串 <code>word1</code> 和 <code>word2</code> 中从 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 每一个字母出现频率之差都 不超过 3 ，那么我们称这两个字符串 <code>word1</code> 和 <code>word2</code> 几乎相等 。</p><a id="more"></a><p>给你两个长度都为 <code>n</code> 的字符串 <code>word1</code> 和 <code>word2</code> ，如果 <code>word1</code> 和 <code>word2</code> 几乎相等 ，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>一个字母 <code>x</code> 的出现 频率 指的是它在字符串中出现的次数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"aaaa"</span>, word2 = <span class="string">"bccb"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：字符串 <span class="string">"aaaa"</span> 中有 <span class="number">4</span> 个 'a' ，但是 <span class="string">"bccb"</span> 中有 <span class="number">0</span> 个 'a' 。</span><br><span class="line">两者之差为 <span class="number">4</span> ，大于上限 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"abcdeef"</span>, word2 = <span class="string">"abaaacc"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：word1 和 word2 中每个字母出现频率之差至多为 <span class="number">3</span> ：</span><br><span class="line">- 'a' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">4</span> 次，差为 <span class="number">3</span> 。</span><br><span class="line">- 'b' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">1</span> 次，差为 <span class="number">0</span> 。</span><br><span class="line">- 'c' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">2</span> 次，差为 <span class="number">1</span> 。</span><br><span class="line">- 'd' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">1</span> 。</span><br><span class="line">- 'e' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">2</span> 。</span><br><span class="line">- 'f' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"cccddabba"</span>, word2 = <span class="string">"babababab"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：word1 和 word2 中每个字母出现频率之差至多为 <span class="number">3</span> ：</span><br><span class="line">- 'a' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">4</span> 次，差为 <span class="number">2</span> 。</span><br><span class="line">- 'b' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">5</span> 次，差为 <span class="number">3</span> 。</span><br><span class="line">- 'c' 在 word1 中出现了 <span class="number">3</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">3</span> 。</span><br><span class="line">- 'd' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == word1.length == word2.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>word1</code> 和 <code>word2</code> 都只包含小写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-whether-two-strings-are-almost-equivalent" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-whether-two-strings-are-almost-equivalent</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>统计两个字符串中所有字符的统计个数,然后检测每个字符的统计个数的差的绝对值.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串的长度。</li><li>空间复杂度: $O(C)$,其中 $C = 26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkAlmostEquivalent</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt1(<span class="number">26</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt2(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word1)&#123;</span><br><span class="line">            cnt1[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word2)&#123;</span><br><span class="line">            cnt2[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(cnt1[i] - cnt2[i]) &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5911-模拟行走机器人-II"><a href="#5911-模拟行走机器人-II" class="headerlink" title="5911. 模拟行走机器人 II"></a>5911. 模拟行走机器人 II</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个在 <code>XY</code> 平面上的 <code>width x height</code> 的网格图，左下角 的格子为 <code>(0, 0)</code> ，右上角 的格子为 <code>(width - 1, height - 1)</code> 。网格图中相邻格子为四个基本方向之一<code>（&quot;North&quot;，&quot;East&quot;，&quot;South&quot; 和 &quot;West&quot;）</code>。一个机器人 初始 在格子 <code>(0, 0)</code>，方向为 “East” 。</p><p>机器人可以根据指令移动指定的 步数 。每一步，它可以执行以下操作。</p><ul><li>沿着当前方向尝试 往前一步 。</li><li>如果机器人下一步将到达的格子 超出了边界 ，机器人会 逆时针 转 90 度，然后再尝试往前一步。</li><li>如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。</li></ul><p>请你实现 <code>Robot</code> 类：</p><ul><li><code>Robot(int width, int height)</code> 初始化一个 width x height 的网格图，机器人初始在 (0, 0) ，方向朝 “East” 。</li><li><code>void move(int num)</code> 给机器人下达前进 num 步的指令。</li><li><code>int[] getPos()</code> 返回机器人当前所处的格子位置，用一个长度为 2 的数组 [x, y] 表示。</li><li><code>String getDir()</code> 返回当前机器人的朝向，为 “North” ，”East” ，”South” 或者 “West” 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"Robot"</span>, <span class="string">"move"</span>, <span class="string">"move"</span>, <span class="string">"getPos"</span>, <span class="string">"getDir"</span>, <span class="string">"move"</span>, <span class="string">"move"</span>, <span class="string">"move"</span>, <span class="string">"getPos"</span>, <span class="string">"getDir"</span>]</span><br><span class="line">[[<span class="number">6</span>, <span class="number">3</span>], [<span class="number">2</span>], [<span class="number">2</span>], [], [], [<span class="number">2</span>], [<span class="number">1</span>], [<span class="number">4</span>], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, [<span class="number">4</span>, <span class="number">0</span>], <span class="string">"East"</span>, null, null, null, [<span class="number">1</span>, <span class="number">2</span>], <span class="string">"West"</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Robot robot = new Robot(<span class="number">6</span>, <span class="number">3</span>); <span class="comment">// 初始化网格图，机器人在 (0, 0) ，朝东。</span></span><br><span class="line">robot.move(<span class="number">2</span>);  <span class="comment">// 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。</span></span><br><span class="line">robot.move(<span class="number">2</span>);  <span class="comment">// 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。</span></span><br><span class="line">robot.getPos(); <span class="comment">// 返回 [4, 0]</span></span><br><span class="line">robot.getDir(); <span class="comment">// 返回 "East"</span></span><br><span class="line">robot.move(<span class="number">2</span>);  <span class="comment">// 朝东移动 1 步到达 (5, 0) ，并朝东。</span></span><br><span class="line">                <span class="comment">// 下一步继续往东移动将出界，所以逆时针转变方向朝北。</span></span><br><span class="line">                <span class="comment">// 然后，往北移动 1 步到达 (5, 1) ，并朝北。</span></span><br><span class="line">robot.move(<span class="number">1</span>);  <span class="comment">// 朝北移动 1 步到达 (5, 2) ，并朝 北 （不是朝西）。</span></span><br><span class="line">robot.move(<span class="number">4</span>);  <span class="comment">// 下一步继续往北移动将出界，所以逆时针转变方向朝西。</span></span><br><span class="line">                <span class="comment">// 然后，移动 4 步到 (1, 2) ，并朝西。</span></span><br><span class="line">robot.getPos(); <span class="comment">// 返回 [1, 2]</span></span><br><span class="line">robot.getDir(); <span class="comment">// 返回 "West"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= width, height &lt;= 100</code></li><li><code>1 &lt;= num &lt;= 105</code></li><li><code>move</code> ，<code>getPos</code> 和 <code>getDir</code> 总共 调用次数不超过 104 次。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/walking-robot-simulation-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/walking-robot-simulation-ii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>真心是个很蛋疼的题目, 我们仔细分析一下即可得知,机器人始终会在最外圈一直循环行走, 因此我们可以求出最外圈的坐标的数组及方向的数组, 机器人的移动实际等价于数组上的循环移动,因此就比较简单了,有两点比较坑的是:</li></ol><ul><li>每个拐角处的方向需要注意实际上在四个拐角处不会切换方向,在拐角处的下一个方块需要切换方向, 及这四个坐标方向会改变 $(1,0),(width-1,1),(widht-2,height-1),(0,height-2)$.</li><li>机器人起始的坐标和移动方向需要特别注意,当它下一次移动到 $(0,0)$ 坐标时的方向实际应该是向南.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $Robot$ 函数的时间复杂度为 $0(width \times height)$，$move,getPos，getDir$的时间复杂度均为 $O(1)$.</li><li>空间复杂度分析: 空间复杂度为$O(width \times height)$．</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Robot(<span class="keyword">int</span> width, <span class="keyword">int</span> height) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; width; ++i)&#123;</span><br><span class="line">            arr.push_back(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height; ++i)&#123;</span><br><span class="line">            arr.push_back(&#123;width<span class="number">-1</span>,i&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = width<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            arr.push_back(&#123;i,height<span class="number">-1</span>&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = height<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            arr.push_back(&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;curr = arr.size()<span class="number">-1</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        num = num%arr.size();</span><br><span class="line">        curr = (curr + num)%arr.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getPos() &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;arr[curr].first,arr[curr].second&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"East"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dirstr[arrd[curr]];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> curr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dirstr = &#123;<span class="string">"East"</span>,<span class="string">"North"</span>,<span class="string">"West"</span>,<span class="string">"South"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; arr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Robot object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Robot* obj = new Robot(width, height);</span></span><br><span class="line"><span class="comment"> * obj-&gt;move(num);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;getPos();</span></span><br><span class="line"><span class="comment"> * string param_3 = obj-&gt;getDir();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="5912-每一个查询的最大美丽值"><a href="#5912-每一个查询的最大美丽值" class="headerlink" title="5912. 每一个查询的最大美丽值"></a>5912. 每一个查询的最大美丽值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>items</code> ，其中 <code>items[i] = [pricei, beautyi]</code> 分别表示每一个物品的 价格 和 美丽值 。</p><p>同时给你一个下标从 <code>0</code> 开始的整数数组 <code>queries</code> 。对于每个查询 <code>queries[j]</code> ，你想求出价格小于等于 <code>queries[j]</code> 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为<code>0</code> 。</p><p>请你返回一个长度与 <code>queries</code> 相同的数组 <code>answer</code>，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>]], queries = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">- queries[<span class="number">0</span>]=<span class="number">1</span> ，[<span class="number">1</span>,<span class="number">2</span>] 是唯一价格 &lt;= <span class="number">1</span> 的物品。所以这个查询的答案为 <span class="number">2</span> 。</span><br><span class="line">- queries[<span class="number">1</span>]=<span class="number">2</span> ，符合条件的物品有 [<span class="number">1</span>,<span class="number">2</span>] 和 [<span class="number">2</span>,<span class="number">4</span>] 。</span><br><span class="line">  它们中的最大美丽值为 <span class="number">4</span> 。</span><br><span class="line">- queries[<span class="number">2</span>]=<span class="number">3</span> 和 queries[<span class="number">3</span>]=<span class="number">4</span> ，符合条件的物品都为 [<span class="number">1</span>,<span class="number">2</span>] ，[<span class="number">3</span>,<span class="number">2</span>] ，[<span class="number">2</span>,<span class="number">4</span>] 和 [<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">  它们中的最大美丽值为 <span class="number">5</span> 。</span><br><span class="line">- queries[<span class="number">4</span>]=<span class="number">5</span> 和 queries[<span class="number">5</span>]=<span class="number">6</span> ，所有物品都符合条件。</span><br><span class="line">  所以，答案为所有物品中的最大美丽值，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]], queries = [<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">每个物品的价格均为 <span class="number">1</span> ，所以我们选择最大美丽值 <span class="number">4</span> 。</span><br><span class="line">注意，多个物品可能有相同的价格和美丽值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="number">10</span>,<span class="number">1000</span>]], queries = [<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">没有物品的价格小于等于 <span class="number">5</span> ，所以没有物品可以选择。</span><br><span class="line">因此，查询的结果为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= items.length, queries.length &lt;= 105</code></li><li><code>items[i].length == 2</code></li><li><code>1 &lt;= pricei, beautyi, queries[j] &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/most-beautiful-item-for-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-beautiful-item-for-each-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找或者双指针</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>应该可以说是简单题目，我们首先将所有的物品按照价格进行排序，我们用 $prefix[i]$ 表示排序的物品中前 $i$ 个物品的最大美丽值. 我们每次进行查询 $x$ 时,我们找到物品价格小于等于 $x$ 的最大的索引 $j$, $prefix[j]$ 即为本次需要查询的结果.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O((m+n) \log n)$,其中 $n$ 为商品的个数, $m$ 为查询的此时．</li><li>空间复杂度为 $O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maximumBeauty(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; items, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = items.size();</span><br><span class="line">        sort(items.begin(),items.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                prefix[i] = items[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prefix[i] = max(prefix[i<span class="number">-1</span>], items[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(items[mid][<span class="number">0</span>] &lt;= queries[i])&#123;</span><br><span class="line">                    curr = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(prefix[curr]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5913-你可以安排的最多任务数目"><a href="#5913-你可以安排的最多任务数目" class="headerlink" title="5913. 你可以安排的最多任务数目"></a>5913. 你可以安排的最多任务数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 $n$ 个任务和 $m$ 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <code>0</code> 开始的整数数组 <code>tasks</code> 中，第 <code>i</code> 个任务需要 <code>tasks[i]</code> 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 <code>workers</code> 中，第 <code>j</code> 个工人的力量值为 <code>workers[j]</code> 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 <code>workers[j] &gt;= tasks[i]</code> ）。</p><p>除此以外，你还有 <code>pills</code> 个神奇药丸，可以给 一个工人的力量值 增加 <code>strength</code> 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。</p><p>给你下标从 <code>0</code> 开始的整数数组<code>tasks</code> 和 <code>workers</code> 以及两个整数 <code>pills</code> 和 <code>strength</code> ，请你返回 最多 有多少个任务可以被完成。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], workers = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>], pills = <span class="number">1</span>, strength = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">0</span> 号工人药丸。</span><br><span class="line">- <span class="number">0</span> 号工人完成任务 <span class="number">2</span>（<span class="number">0</span> + <span class="number">1</span> &gt;= <span class="number">1</span>）</span><br><span class="line">- <span class="number">1</span> 号工人完成任务 <span class="number">1</span>（<span class="number">3</span> &gt;= <span class="number">2</span>）</span><br><span class="line">- <span class="number">2</span> 号工人完成任务 <span class="number">0</span>（<span class="number">3</span> &gt;= <span class="number">3</span>）</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">5</span>,<span class="number">4</span>], workers = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], pills = <span class="number">1</span>, strength = <span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">0</span> 号工人药丸。</span><br><span class="line">- <span class="number">0</span> 号工人完成任务 <span class="number">0</span>（<span class="number">0</span> + <span class="number">5</span> &gt;= <span class="number">5</span>）</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">10</span>,<span class="number">15</span>,<span class="number">30</span>], workers = [<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>], pills = <span class="number">3</span>, strength = <span class="number">10</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">0</span> 号和 <span class="number">1</span> 号工人药丸。</span><br><span class="line">- <span class="number">0</span> 号工人完成任务 <span class="number">0</span>（<span class="number">0</span> + <span class="number">10</span> &gt;= <span class="number">10</span>）</span><br><span class="line">- <span class="number">1</span> 号工人完成任务 <span class="number">1</span>（<span class="number">10</span> + <span class="number">10</span> &gt;= <span class="number">15</span>）</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>], workers = [<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>], pills = <span class="number">1</span>, strength = <span class="number">5</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">2</span> 号工人药丸。</span><br><span class="line">- <span class="number">1</span> 号工人完成任务 <span class="number">0</span>（<span class="number">6</span> &gt;= <span class="number">5</span>）</span><br><span class="line">- <span class="number">2</span> 号工人完成任务 <span class="number">2</span>（<span class="number">4</span> + <span class="number">5</span> &gt;= <span class="number">8</span>）</span><br><span class="line">- <span class="number">4</span> 号工人完成任务 <span class="number">3</span>（<span class="number">6</span> &gt;= <span class="number">5</span>）</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == tasks.length</code></li><li><code>m == workers.length</code></li><li><code>1 &lt;= n, m &lt;= 5 * 104</code></li><li><code>0 &lt;= pills &lt;= m</code></li><li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找 + 贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们可以想到最优的解，肯定可以用二分查找找到最多可以完成多少个任务，重点是在于检测当前给定的条件下可以完成 $n$ 个任务. 首先我们想到一点的是,假设我们当前可以完全 $n$ 个人任务,那么根据贪心算法,可以知道我们一定是可以完成需要力量值最小的 $n$ 个任务.因此我们将任务按照所需要的力量值的大小进行排序,每次尝试是安排最强的 $x$ 个人完成前 $x$ 个任务.可以参考下官方题解，感觉写的非常清楚，证明也非常清晰．</li><li>我们如何检测给定条件下, 是否能够完成前 $n$ 个任务，需要一定的贪心策略．</li></ol><ul><li>当我们考虑当前任务值最大的任务时，此时我们的选择策略有贪心策略，能够不用药丸的情况下我们应该尽量避免使用药丸，因此我们应当从任务值最大的任务开始检测起：</li><li><ul><li>a. 要么直接选择当前力量值刚好能够大于等于这个任务的工人，此时我们有能够满足条件的工人，此时我们直接选择最小能够满足该任务的工人，避免使用药丸;</li></ul></li><li><ul><li>b. 要么选择一个工人吃一颗药丸后的力量值刚好能够大于等于这个任务.则此时我们应当选择满足条件下力量值最小的工人．<br>我们按照上述的贪心策略进行选择即可．</li></ul></li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(m \log m + n \log n + min(m,n) \times \log n\times log m)$, 其中 $m$ 表示任务的个数, $n$ 表示工人的数量.</li><li>空间复杂度分析: $O(n + \log n + \log m)$,其中 $m$ 表示任务的个数, $n$ 表示工人的数量.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTaskAssign</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tasks, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; workers, <span class="keyword">int</span> pills, <span class="keyword">int</span> strength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = tasks.size();</span><br><span class="line">        <span class="keyword">int</span> n = workers.size();</span><br><span class="line">        sort(tasks.begin(), tasks.end());</span><br><span class="line">        sort(workers.begin(), workers.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> x)-&gt;<span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> p = pills;</span><br><span class="line">            <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : workers) cnt.insert(v);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = cnt.lower_bound(tasks[i]);</span><br><span class="line">                <span class="keyword">if</span>(it != cnt.end())&#123;</span><br><span class="line">                    cnt.erase(it);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">auto</span> it1 = cnt.lower_bound(tasks[i] - strength);</span><br><span class="line">                    <span class="keyword">if</span>(it1 == cnt.end()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt.erase(it1);</span><br><span class="line">                    p--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = m;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-65&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-65&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 65&quot;&gt;&lt;/a&gt;leetcode biweekly contest 65&lt;/h1&gt;&lt;p&gt;双周赛的难度还是挺大的,&lt;/p&gt;&lt;h3 id=&quot;5910-检查两个字符串是否几乎相等&quot;&gt;&lt;a href=&quot;#5910-检查两个字符串是否几乎相等&quot; class=&quot;headerlink&quot; title=&quot;5910. 检查两个字符串是否几乎相等&quot;&gt;&lt;/a&gt;5910. 检查两个字符串是否几乎相等&lt;/h3&gt;&lt;p&gt;如果两个字符串 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt; 中从 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 到 &lt;code&gt;&amp;#39;z&amp;#39;&lt;/code&gt; 每一个字母出现频率之差都 不超过 3 ，那么我们称这两个字符串 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt; 几乎相等 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 266</title>
    <link href="http://yoursite.com/2021/11/07/342/"/>
    <id>http://yoursite.com/2021/11/07/342/</id>
    <published>2021-11-07T08:28:00.218Z</published>
    <updated>2021-11-09T15:47:16.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-266"><a href="#leetcode-contest-266" class="headerlink" title="leetcode contest 266"></a>leetcode contest 266</h1><p>今天周赛的题目比较简单，前三题基本上没有什么难度的题目，最后一题做法上想的太复杂了点，最后用一个简单的$BFS$ 搞定.</p><h3 id="5918-统计字符串中的元音子字符串"><a href="#5918-统计字符串中的元音子字符串" class="headerlink" title="5918. 统计字符串中的元音子字符串"></a>5918. 统计字符串中的元音子字符串</h3><p>子字符串 是字符串中的一个连续（非空）的字符序列。</p><p>元音子字符串 是 仅 由元音<code>（&#39;a&#39;、&#39;e&#39;、&#39;i&#39;、&#39;o&#39; 和 &#39;u&#39;）6</code>组成的一个子字符串，且必须包含 全部五种 元音。</p><a id="more"></a><p>给你一个字符串 word ，统计并返回 word 中 元音子字符串的数目 。</p><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"aeiouu"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：下面列出 <span class="built_in">word</span> 中的元音子字符串（斜体加粗部分）：</span><br><span class="line">- <span class="string">"aeiouu"</span></span><br><span class="line">- <span class="string">"aeiouu"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"unicornarihan"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="built_in">word</span> 中不含 <span class="number">5</span> 种元音，所以也不会存在元音子字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "cuaieuouac"</span><br><span class="line">输出：7</span><br><span class="line">解释：下面列出 word 中的元音子字符串（斜体加粗部分）：</span><br><span class="line">-<span class="ruby"> <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">word</span> = <span class="string">"bbaeixoubb"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：所有包含全部五种元音的子字符串都含有辅音，所以不存在元音子字符串。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= <span class="keyword">word</span>.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="keyword">word</span>` 仅由小写英文字母组成</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-266/problems/count-vowel-substrings-of-a-string/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  枚举</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 枚举每个子字符串，检测每个字符串是否满足元音要求。</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度: $O(N^<span class="number">3</span>)$,其中 $N$ 为字符串的长度。</span><br><span class="line">+ 空间复杂度: $O(<span class="number">1</span>)$。</span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="keyword">int</span> countVowelSubstrings(<span class="keyword">string</span> <span class="keyword">word</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        cnt.insert(<span class="string">'a'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'e'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'i'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'o'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'u'</span>);</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">for</span>(<span class="keyword">int</span> j = i + <span class="number">4</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">bool</span> <span class="built_in">isValid</span> = true;</span><br><span class="line">                unordered_set&lt;<span class="keyword">char</span>&gt; curr;</span><br><span class="line">                <span class="built_in">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++k)&#123;</span><br><span class="line">                    <span class="built_in">if</span>(!cnt.count(<span class="keyword">word</span>[k]))&#123;</span><br><span class="line">                        <span class="built_in">isValid</span> = false;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;<span class="built_in">else</span>&#123;</span><br><span class="line">                        curr.insert(<span class="keyword">word</span>[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">if</span>(<span class="built_in">isValid</span> &amp;&amp; curr.<span class="built_in">size</span>() == <span class="number">5</span>)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5919-所有子字符串中的元音"><a href="#5919-所有子字符串中的元音" class="headerlink" title="5919. 所有子字符串中的元音"></a>5919. 所有子字符串中的元音</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>word</code> ，返回 <code>word</code> 的所有子字符串中 元音的总数 ，元音是指 <code>&#39;a&#39;、&#39;e&#39;、&#39;i&#39;、&#39;o&#39;</code> 和 <code>&#39;u&#39;</code> 。</p><p>子字符串 是字符串中一个连续（非空）的字符序列。</p><p>注意：由于对 <code>word</code> 长度的限制比较宽松，答案可能超过有符号 <code>32</code> 位整数的范围。计算时需当心。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"aba"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">所有子字符串是：<span class="string">"a"</span>、<span class="string">"ab"</span>、<span class="string">"aba"</span>、<span class="string">"b"</span>、<span class="string">"ba"</span> 和 <span class="string">"a"</span> 。</span><br><span class="line">- <span class="string">"b"</span> 中有 <span class="number">0</span> 个元音</span><br><span class="line">- <span class="string">"a"</span>、<span class="string">"ab"</span>、<span class="string">"ba"</span> 和 <span class="string">"a"</span> 每个都有 <span class="number">1</span> 个元音</span><br><span class="line">- <span class="string">"aba"</span> 中有 <span class="number">2</span> 个元音</span><br><span class="line">因此，元音总数 = <span class="number">0</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"abc"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">所有子字符串是：<span class="string">"a"</span>、<span class="string">"ab"</span>、<span class="string">"abc"</span>、<span class="string">"b"</span>、<span class="string">"bc"</span> 和 <span class="string">"c"</span> 。</span><br><span class="line">- <span class="string">"a"</span>、<span class="string">"ab"</span> 和 <span class="string">"abc"</span> 每个都有 <span class="number">1</span> 个元音</span><br><span class="line">- <span class="string">"b"</span>、<span class="string">"bc"</span> 和 <span class="string">"c"</span> 每个都有 <span class="number">0</span> 个元音</span><br><span class="line">因此，元音总数 = <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">0</span> + <span class="number">0</span> + <span class="number">0</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"ltcd"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"ltcd"</span> 的子字符串均不含元音。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"noosabasboosa"</span></span><br><span class="line">输出：<span class="number">237</span></span><br><span class="line">解释：所有子字符串中共有 <span class="number">237</span> 个元音。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= word.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `word` 由小写英文字母组成</span><br><span class="line"></span><br><span class="line"><span class="comment">### 地址</span></span><br><span class="line"><span class="symbol">https:</span>/<span class="regexp">/leetcode-cn.com/contest</span><span class="regexp">/weekly-contest-266/problems</span><span class="regexp">/vowels-of-all-substrings/</span></span><br><span class="line"><span class="comment">### 题意</span></span><br><span class="line">&gt;  DP</span><br><span class="line"><span class="comment">### 思路</span></span><br><span class="line"><span class="number">1</span>. 题目为一个比较简单的动态规划,我们设 <span class="variable">$dp</span>[i]<span class="variable">$ </span>表示以字符串中第 <span class="variable">$i</span><span class="variable">$ </span>个元素为结尾的连续子字符串包含的元音字母. 则我们可以知道分为以下两种情况<span class="symbol">:</span></span><br><span class="line">+ 如果第 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个子母为非元音字母: 则我们知道以第 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个字母为结尾的字符中包含的原因字符刚好等于 <span class="variable">$dp</span>[i]<span class="variable">$,</span> 则此时可以知道 <span class="variable">$dp</span>[i+<span class="number">1</span>] = dp[i].</span><br><span class="line">+ 如果第 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个子母为元音字母: 则我们知道以 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>为结尾的字符串有 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个, 同时包含之前以 <span class="variable">$i</span><span class="variable">$ </span>为结尾的子字符串中的元音字母, 因此 <span class="variable">$dp</span>[i+<span class="number">1</span>] = dp[i] + i + <span class="number">1</span><span class="variable">$.</span></span><br><span class="line">总的子字符串中包含的元音字母的个数为 <span class="variable">$sum</span> = \sum<span class="number">_</span>&#123;i=<span class="number">0</span>&#125;^&#123;n-<span class="number">1</span>&#125;dp[i]<span class="variable">$.</span></span><br><span class="line"><span class="number">2</span>. 复杂度分析<span class="symbol">:</span></span><br><span class="line">+ 时间复杂度分析: 时间复杂度为 <span class="variable">$O</span>(N)<span class="variable">$.</span> 其中 <span class="variable">$N</span><span class="variable">$ </span>为字符串的长度.</span><br><span class="line">+ 空间复杂度分析: 空间复杂度为<span class="variable">$O</span>(N)<span class="variable">$,</span> 其中 <span class="variable">$N</span><span class="variable">$ </span>为字符串的长度．</span><br><span class="line"></span><br><span class="line"><span class="comment">### 代码</span></span><br><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    long long countVowels(string word) &#123;</span><br><span class="line">        int n = word.size();</span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;long long&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">        int curr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        unordered_set&lt;char&gt; cnt;</span><br><span class="line">        cnt.insert(<span class="string">'a'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'e'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'i'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'o'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'u'</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            if(cnt.count(word[i]))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i] + i + <span class="number">1</span>;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5920-分配给商店的最多商品的最小值"><a href="#5920-分配给商店的最多商品的最小值" class="headerlink" title="5920. 分配给商店的最多商品的最小值"></a>5920. 分配给商店的最多商品的最小值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 间零售商店。总共有 <code>m</code> 种产品，每种产品的数目用一个下标从 <code>0</code> 开始的整数数组 <code>quantities</code> 表示，其中 <code>quantities[i]</code> 表示第 <code>i</code> 种商品的数目。</p><p>你需要将 所有商品 分配到零售商店，并遵守这些规则：</p><ul><li>一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。</li><li>分配后，每间商店都会被分配一定数目的商品（可能为 <code>0</code> 件）。用 <code>x</code> 表示所有商店中+ 分配商品数目的最大值，你希望 <code>x</code> 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的最大值 。<br>请你返回最小的可能的 <code>x</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, quantities = [<span class="number">11</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释： 一种最优方案为：</span><br><span class="line">- <span class="number">11</span> 件种类为 <span class="number">0</span> 的商品被分配到前 <span class="number">4</span> 间商店，分配数目分别为：<span class="number">2</span>，<span class="number">3</span>，<span class="number">3</span>，<span class="number">3</span> 。</span><br><span class="line">- <span class="number">6</span> 件种类为 <span class="number">1</span> 的商品被分配到另外 <span class="number">2</span> 间商店，分配数目分别为：<span class="number">3</span>，<span class="number">3</span> 。</span><br><span class="line">分配给所有商店的最大商品数目为 max(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, quantities = [<span class="number">15</span>,<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一种最优方案为：</span><br><span class="line">- <span class="number">15</span> 件种类为 <span class="number">0</span> 的商品被分配到前 <span class="number">3</span> 间商店，分配数目为：<span class="number">5</span>，<span class="number">5</span>，<span class="number">5</span> 。</span><br><span class="line">- <span class="number">10</span> 件种类为 <span class="number">1</span> 的商品被分配到接下来 <span class="number">2</span> 间商店，数目为：<span class="number">5</span>，<span class="number">5</span> 。</span><br><span class="line">- <span class="number">10</span> 件种类为 <span class="number">2</span> 的商品被分配到最后 <span class="number">2</span> 间商店，数目为：<span class="number">5</span>，<span class="number">5</span> 。</span><br><span class="line">分配给所有商店的最大商品数目为 max(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>) = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, quantities = [<span class="number">100000</span>]</span><br><span class="line">输出：<span class="number">100000</span></span><br><span class="line">解释：唯一一种最优方案为：</span><br><span class="line">- 所有 <span class="number">100000</span> 件商品 <span class="number">0</span> 都分配到唯一的商店中。</span><br><span class="line">分配给所有商店的最大商品数目为 max(<span class="number">100000</span>) = <span class="number">100000</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == quantities.length</code></li><li><code>1 &lt;= m &lt;= n &lt;= 105</code></li><li><code>1 &lt;= quantities[i] &lt;= 105</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-convert-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-convert-number</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>如果直接来做,肯定比麻烦. 因为题目中要求每个零售店最多只能持有一种商品, 我们知道对于最大上限的$x$, 对于第 $i$ 个商品总量为 $quantities[i]$,我们知道最少需要配备 $\lfloor \frac{quantities[i] + x - 1}{x} \rfloor$ 个商店来分配该商品, 总共需要配备的商调的数目为 $\sum_{i=0}^{n-1}\lfloor \frac{quantities[i] + x - 1}{x} \rfloor$. 所以我们采用二分法测试 $x$,每次检测对于 $x$ 最少需要配备多少个商店来满足分配要求, 如果需要的商店的个数小于等于 $n$,则满足题目要求,否则我们需要增大 $x$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(M\log(\max(quantities)))$,其中 $M$ 为商品的个数, $MAX(quantities)$ 为商品的个数的最大值．</li><li>空间复杂度为 $O(1)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quantities,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : quantities)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curr += (v + val - <span class="number">1</span>)/val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr &lt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimizedMaximum</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quantities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = quantities.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = *max_element(quantities.begin(),quantities.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(n,quantities,mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5921-最大化一张图中的路径价值"><a href="#5921-最大化一张图中的路径价值" class="headerlink" title="5921. 最大化一张图中的路径价值"></a>5921. 最大化一张图中的路径价值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一张 无向 图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> （都包括）。同时给你一个下标从 <code>0</code> 开始的整数数组 <code>values</code> ，其中 <code>values[i]</code> 是第 <code>i</code> 个节点的 价值 。同时给你一个下标从 <code>0</code> 开始的二维整数数组 <code>edges</code> ，其中 <code>edges[j] = [uj, vj, timej]</code> 表示节点 <code>uj</code> 和 <code>vj</code> 之间有一条需要 <code>timej</code> 秒才能通过的无向边。最后，给你一个整数 <code>maxTime</code> 。</p><p>合法路径 指的是图中任意一条从节点 <code>0</code> 开始，最终回到节点<code>0</code>，且花费的总时间 不超过<code>maxTime</code> 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 价值 定义为路径中 不同节点 的价值 之和 （每个节点的价值 至多 算入价值总和中一次）。</p><p>请你返回一条合法路径的 最大 价值。</p><p>注意：每个节点 至多 有 四条 边与之相连。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">0</span>,<span class="number">32</span>,<span class="number">10</span>,<span class="number">43</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]], maxTime = <span class="number">49</span></span><br><span class="line">输出：<span class="number">75</span></span><br><span class="line">解释：</span><br><span class="line">一条可能的路径为：<span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">3</span> -&gt; <span class="number">0</span> 。总花费时间为 <span class="number">10</span> + <span class="number">10</span> + <span class="number">10</span> + <span class="number">10</span> = <span class="number">40</span> &lt;= <span class="number">49</span> 。</span><br><span class="line">访问过的节点为 <span class="number">0</span> ，<span class="number">1</span> 和 <span class="number">3</span> ，最大路径价值为 <span class="number">0</span> + <span class="number">32</span> + <span class="number">43</span> = <span class="number">75</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]], maxTime = <span class="number">30</span></span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">一条可能的路径为：<span class="number">0</span> -&gt; <span class="number">3</span> -&gt; <span class="number">0</span> 。总花费时间为 <span class="number">10</span> + <span class="number">10</span> = <span class="number">20</span> &lt;= <span class="number">30</span> 。</span><br><span class="line">访问过的节点为 <span class="number">0</span> 和 <span class="number">3</span> ，最大路径价值为 <span class="number">5</span> + <span class="number">20</span> = <span class="number">25</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">13</span>]], maxTime = <span class="number">50</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">一条可能的路径为：<span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> 。总花费时间为 <span class="number">10</span> + <span class="number">13</span> + <span class="number">13</span> + <span class="number">10</span> = <span class="number">46</span> &lt;= <span class="number">50</span> 。</span><br><span class="line">访问过的节点为 <span class="number">0</span> ，<span class="number">1</span> 和 <span class="number">3</span> ，最大路径价值为 <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], edges = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>]], maxTime = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">唯一一条路径为 <span class="number">0</span> 。总花费时间为 <span class="number">0</span> 。</span><br><span class="line">唯一访问过的节点为 <span class="number">0</span> ，最大路径价值为 <span class="number">0</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == values.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= values[i] &lt;= <span class="number">108</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= edges.length &lt;= <span class="number">2000</span>`</span><br><span class="line">+ `edges[j].length == <span class="number">3</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= uj &lt; vj &lt;= n - <span class="number">1</span>`</span><br><span class="line">+ `<span class="number">10</span> &lt;= timej, maxTime &lt;= <span class="number">100</span>`</span><br><span class="line">+ `[uj, vj]` 所有节点对 互不相同 。</span><br><span class="line">+ 每个节点至多有四条 边。</span><br><span class="line">+ 图可能不连通。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-266/problems/maximum-path-quality-of-a-graph/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  BFS+减枝或者DFS</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 题目中关键的提示在于`<span class="number">10</span> &lt;= timej, maxTime &lt;= <span class="number">100</span>`,这就意味着最大路径的节点最多不会超过 $<span class="number">10</span>$ 步,每个节点最多有 $<span class="number">4</span>$ 条边,实际意味着最多可能的路径选择空间在 $<span class="number">4</span>^<span class="number">10</span>$ 以内,因此这个数量级就决定了我们可以用暴力的 $DFS$ 或者 $BFS$ 来进行搜索,找到符合要求的最大路径即可.</span><br><span class="line"><span class="number">2.</span> 稍微麻烦的是需要涉及到减枝的优化：</span><br><span class="line">+ 对路径上每个节点进行标记,如果已经访问过的,则计算价值时不再做计算.</span><br><span class="line">+ 可以记录在某个节点在某个时间内到达时的最大价值,如果当前的价值小于该值则直接返回.</span><br><span class="line"><span class="number">3.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度分析: $O(D^&#123;\frac&#123;maxt&#125;&#123;t&#125;&#125;)$, 其中 $D$ 为节点的最大度数.</span><br><span class="line">+ 空间复杂度分析: $O(V+E)$,其中 $V$ 为节点的个数, $E$ 为边的数目.</span><br><span class="line">### 代码</span><br><span class="line">+ `BFS`</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    <span class="built_in">int</span> x;</span><br><span class="line">    <span class="built_in">int</span> cost;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    unordered_set&lt;<span class="built_in">int</span>&gt; visit;</span><br><span class="line">    Node(<span class="built_in">int</span> x,<span class="built_in">int</span> cost,<span class="built_in">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maximalPathQuality(vector&lt;<span class="built_in">int</span>&gt;&amp; values, vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; edges, <span class="built_in">int</span> maxTime) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = values.size();</span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; graph(n);</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; dp(n,vector&lt;long long&gt;(maxTime + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(make_pair(v[<span class="number">1</span>],v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(make_pair(v[<span class="number">0</span>],v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        queue&lt;Node&gt; qu;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = values[<span class="number">0</span>];</span><br><span class="line">        Node node(<span class="number">0</span>,<span class="number">0</span>,values[<span class="number">0</span>]);</span><br><span class="line">        node.visit.insert(<span class="number">0</span>);</span><br><span class="line">        qu.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            Node curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">auto</span> [x, time] : graph[curr.x])&#123;</span><br><span class="line">                <span class="built_in">int</span> cost = curr.cost + time;</span><br><span class="line">                <span class="keyword">if</span>(cost &gt; maxTime) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">int</span> val = curr.val;</span><br><span class="line">                <span class="keyword">if</span>(!curr.visit.count(x))&#123;</span><br><span class="line">                    val += values[x];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[x][cost] &lt;= val)&#123;</span><br><span class="line">                    dp[x][cost] = val;</span><br><span class="line">                    Node nx(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                    nx.x = x;</span><br><span class="line">                    nx.cost = cost;</span><br><span class="line">                    nx.val = val;</span><br><span class="line">                    nx.visit = curr.visit;</span><br><span class="line">                    nx.visit.insert(x);</span><br><span class="line">                    qu.push(nx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= maxTime; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><code>DFS</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; graph;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> curTime, <span class="keyword">int</span> curValue, <span class="keyword">int</span> maxTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curTime &gt; maxTime) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == <span class="number">0</span>) &#123; <span class="comment">/* 回到起点, 更新最大值 */</span></span><br><span class="line">            ans = fmax(ans, curValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : graph[start]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123; <span class="comment">/* 目标节点没有访问过 */</span></span><br><span class="line">                visited[v] = <span class="number">1</span>;</span><br><span class="line">                dfs(v, curTime + w, curValue + values[v], maxTime, values);</span><br><span class="line">                visited[v] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">/* 目标节点已经访问过 */</span></span><br><span class="line">                dfs(v, curTime + w, curValue, maxTime, values);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalPathQuality</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> maxTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = values.size();</span><br><span class="line">        graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;(n);</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">int</span> curTime  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curValue = <span class="number">0</span>;</span><br><span class="line">        ans = values[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : edges) &#123; <span class="comment">/* 建立连接表 */</span></span><br><span class="line">            graph[e[<span class="number">0</span>]].emplace_back(e[<span class="number">1</span>], e[<span class="number">2</span>]);</span><br><span class="line">            graph[e[<span class="number">1</span>]].emplace_back(e[<span class="number">0</span>], e[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, curTime, curValue, maxTime, values);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-266&quot;&gt;&lt;a href=&quot;#leetcode-contest-266&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 266&quot;&gt;&lt;/a&gt;leetcode contest 266&lt;/h1&gt;&lt;p&gt;今天周赛的题目比较简单，前三题基本上没有什么难度的题目，最后一题做法上想的太复杂了点，最后用一个简单的$BFS$ 搞定.&lt;/p&gt;&lt;h3 id=&quot;5918-统计字符串中的元音子字符串&quot;&gt;&lt;a href=&quot;#5918-统计字符串中的元音子字符串&quot; class=&quot;headerlink&quot; title=&quot;5918. 统计字符串中的元音子字符串&quot;&gt;&lt;/a&gt;5918. 统计字符串中的元音子字符串&lt;/h3&gt;&lt;p&gt;子字符串 是字符串中的一个连续（非空）的字符序列。&lt;/p&gt;&lt;p&gt;元音子字符串 是 仅 由元音&lt;code&gt;（&amp;#39;a&amp;#39;、&amp;#39;e&amp;#39;、&amp;#39;i&amp;#39;、&amp;#39;o&amp;#39; 和 &amp;#39;u&amp;#39;）6&lt;/code&gt;组成的一个子字符串，且必须包含 全部五种 元音。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 265</title>
    <link href="http://yoursite.com/2021/10/31/341/"/>
    <id>http://yoursite.com/2021/10/31/341/</id>
    <published>2021-10-31T11:19:28.168Z</published>
    <updated>2021-11-07T08:28:18.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-265"><a href="#leetcode-contest-265" class="headerlink" title="leetcode contest 265"></a>leetcode contest 265</h1><p>题目质量还可以,还是三道题的节奏,最后一题质量真心很高, 确实是非常好的思考的题目. </p><h3 id="2057-值相等的最小索引"><a href="#2057-值相等的最小索引" class="headerlink" title="2057. 值相等的最小索引"></a>2057. 值相等的最小索引</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，返回 <code>nums</code> 中满足 <code>i mod 10 == nums[i]</code> 的最小下标 <code>i</code> ；如果不存在这样的下标，返回 <code>-1</code> 。<br><code>x mod y</code> 表示 <code>x</code> 除以 <code>y</code> 的 余数 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">0</span>: <span class="number">0</span> mod <span class="number">10</span> = <span class="number">0</span> == nums[<span class="number">0</span>].</span><br><span class="line">i=<span class="number">1</span>: <span class="number">1</span> mod <span class="number">10</span> = <span class="number">1</span> == nums[<span class="number">1</span>].</span><br><span class="line">i=<span class="number">2</span>: <span class="number">2</span> mod <span class="number">10</span> = <span class="number">2</span> == nums[<span class="number">2</span>].</span><br><span class="line">所有下标都满足 i mod <span class="number">10</span> == nums[i] ，所以返回最小下标 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">0</span>: <span class="number">0</span> mod <span class="number">10</span> = <span class="number">0</span> != nums[<span class="number">0</span>].</span><br><span class="line">i=<span class="number">1</span>: <span class="number">1</span> mod <span class="number">10</span> = <span class="number">1</span> != nums[<span class="number">1</span>].</span><br><span class="line">i=<span class="number">2</span>: <span class="number">2</span> mod <span class="number">10</span> = <span class="number">2</span> == nums[<span class="number">2</span>].</span><br><span class="line">i=<span class="number">3</span>: <span class="number">3</span> mod <span class="number">10</span> = <span class="number">3</span> != nums[<span class="number">3</span>].</span><br><span class="line"><span class="number">2</span> 唯一一个满足 i mod <span class="number">10</span> == nums[i] 的下标</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：不存在满足 i mod <span class="number">10</span> == nums[i] 的下标</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="number">1</span> 是唯一一个满足 i mod <span class="number">10</span> == nums[i] 的下标</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 9</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/smallest-index-with-equal-value" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-index-with-equal-value</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 枚举</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>枚举每个元素，找到第一个元素 $i$ 满足 $i \mod 10 == nums[i]$返回即可。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为数组的长度,我们此时需要遍历两遍即可。</li><li>空间复杂度: $O(1)$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">10</span> == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2058-找出临界点之间的最小和最大距离"><a href="#2058-找出临界点之间的最小和最大距离" class="headerlink" title="2058. 找出临界点之间的最小和最大距离"></a>2058. 找出临界点之间的最小和最大距离</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。</p><ul><li><p>如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个  局部极大值点 。</p></li><li><p>如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个  局部极小值点 。</p></li><li><p>注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 / 极小值点 。</p></li></ul><p>给你一个链表 <code>head</code> ，返回一个长度为 <code>2</code> 的数组 <code>[minDistance, maxDistance]</code> ，其中 <code>minDistance</code> 是任意两个不同临界点之间的最小距离，<code>maxDistance</code> 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 <code>[-1，-1]</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：链表 [<span class="number">3</span>,<span class="number">1</span>] 中不存在临界点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：存在三个临界点：</span><br><span class="line">- [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]：第三个节点是一个局部极小值点，因为 <span class="number">1</span> 比 <span class="number">3</span> 和 <span class="number">2</span> 小。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]：第五个节点是一个局部极大值点，因为 <span class="number">5</span> 比 <span class="number">2</span> 和 <span class="number">1</span> 大。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]：第六个节点是一个局部极小值点，因为 <span class="number">1</span> 比 <span class="number">5</span> 和 <span class="number">2</span> 小。</span><br><span class="line">第五个节点和第六个节点之间距离最小。minDistance = <span class="number">6</span> - <span class="number">5</span> = <span class="number">1</span> 。</span><br><span class="line">第三个节点和第六个节点之间距离最大。maxDistance = <span class="number">6</span> - <span class="number">3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：存在两个临界点：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>]：第二个节点是一个局部极大值点，因为 <span class="number">3</span> 比 <span class="number">1</span> 和 <span class="number">2</span> 大。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>]：第五个节点是一个局部极大值点，因为 <span class="number">3</span> 比 <span class="number">2</span> 和 <span class="number">2</span> 大。</span><br><span class="line">最小和最大距离都存在于第二个节点和第五个节点之间。</span><br><span class="line">因此，minDistance 和 maxDistance 是 <span class="number">5</span> - <span class="number">2</span> = <span class="number">3</span> 。</span><br><span class="line">注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：链表 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>] 中不存在临界点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表中节点的数量在范围 <code>[2, 105]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 枚举</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较无聊, 感觉真心直接把链表转化成数组,什么问题都解决了, 这个题目可以说是个简单题.当然链表的操作确实复杂了一点,不过确实很无趣.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$. 其中 $N$ 为链表的长度.</li><li>空间复杂度分析: 空间复杂度为$O(n)$, 如果直接用链表操作空间复杂度可以做到 $O(1)$．</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nodesBetweenCriticalPoints(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(<span class="number">2</span>,INT_MAX);</span><br><span class="line">        <span class="keyword">for</span>(ListNode * curr = head; curr != <span class="literal">nullptr</span>; curr = curr-&gt;next) &#123;</span><br><span class="line">            arr.push_back(curr-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; critical;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i<span class="number">-1</span>] &amp;&amp; arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                critical.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i<span class="number">-1</span>] &amp;&amp; arr[i] &lt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                critical.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; critical.size(); ++i) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = min(ans[<span class="number">0</span>],critical[i] - critical[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(critical.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">            ans[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[<span class="number">1</span>] = critical.back() - critical[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2059-转化数字的最小运算数"><a href="#2059-转化数字的最小运算数" class="headerlink" title="2059. 转化数字的最小运算数"></a>2059. 转化数字的最小运算数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，该数组由 互不相同 的数字组成。另给你两个整数 <code>start</code> 和 <code>goal</code> 。</p><p>整数 <code>x</code> 的值最开始设为 <code>start</code> ，你打算执行一些运算使 <code>x</code> 转化为 <code>goal</code> 。你可以对数字 <code>x</code> 重复执行下述运算：</p><p>如果 <code>0 &lt;= x &lt;= 1000</code> ，那么，对于数组中的任一下标 <code>i（0 &lt;= i &lt; nums.length）</code>，可以将 <code>x</code> 设为下述任一值：</p><ul><li><code>x + nums[i]</code></li><li><code>x - nums[i]</code></li><li><code>x ^ nums[i]</code>（按位异或 <code>XOR</code>）<br>注意，你可以按任意顺序使用每个 <code>nums[i]</code> 任意次。使 <code>x</code> 越过 <code>0 &lt;= x &lt;= 1000</code> 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。</li></ul><p>返回将 <code>x = start</code> 转化为 <code>goal</code> 的最小操作数；如果无法完成转化，则返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>], start = <span class="number">6</span>, goal = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">可以按 <span class="number">6</span> → <span class="number">7</span> → <span class="number">4</span> 的转化路径进行，只需执行下述 <span class="number">2</span> 次运算：</span><br><span class="line">- <span class="number">6</span> ^ <span class="number">1</span> = <span class="number">7</span></span><br><span class="line">- <span class="number">7</span> ^ <span class="number">3</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">12</span>], start = <span class="number">2</span>, goal = <span class="number">12</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">可以按 <span class="number">2</span> → <span class="number">14</span> → <span class="number">12</span> 的转化路径进行，只需执行下述 <span class="number">2</span> 次运算：</span><br><span class="line">- <span class="number">2</span> + <span class="number">12</span> = <span class="number">14</span></span><br><span class="line">- <span class="number">14</span> - <span class="number">2</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], start = <span class="number">0</span>, goal = <span class="number">-4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">可以按 <span class="number">0</span> → <span class="number">3</span> → <span class="number">-4</span> 的转化路径进行，只需执行下述 <span class="number">2</span> 次运算：</span><br><span class="line">- <span class="number">0</span> + <span class="number">3</span> = <span class="number">3</span></span><br><span class="line">- <span class="number">3</span> - <span class="number">7</span> = <span class="number">-4</span></span><br><span class="line">注意，最后一步运算使 x 超过范围 <span class="number">0</span> &lt;= x &lt;= <span class="number">1000</span> ，但该运算仍然可以生效。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>], start = <span class="number">0</span>, goal = <span class="number">1</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">无法将 <span class="number">0</span> 转化为 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], start = <span class="number">0</span>, goal = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">可以按 <span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span> → <span class="number">3</span> 的转化路径进行，只需执行下述 <span class="number">3</span> 次运算：</span><br><span class="line">- <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span> </span><br><span class="line">- <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">- <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-109 &lt;= nums[i], goal &lt;= 109</code></li><li><code>0 &lt;= start &lt;= 1000</code></li><li><code>start != goal</code></li><li><code>nums</code> 中的所有整数互不相同</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-convert-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-convert-number</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>作完这个题目感觉很无语，想了半天感觉到貌似变换过程没啥规律，只能暴力搜索．首先我们设 $dp[x]$ 表示从 $start$ 转换到 $x$ 的最小操作步数且满足 $0 \le x \le 1000$, 我们根据题目给定的转换规则可以知道 $goal$ 分为以下两种情况:</li></ol><ul><li>我们知道如果 $0 \le goal \le 1000$, 则此时最小的转换步数为 $minStep = dp[goal]$； </li><li>我们知道如果 $ goal &gt; 1000$, 我们假设可以通过 $0 \le y \le 1000$ 再经过一步变换即可到大 $goal$, 则此时最小的转换步数为 $minStep = dp[y] + 1$；<br>如果不满足上述两种情况,则我们直接返回 $-1$.</li></ul><ol><li>我们可以很容易的利用 $BFS$ 来求得所有满足变换的最小步骤, 然后根据 $1$ 中的两个规则来求解即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N*1000)$,其中 $N$ 为数组的个数．</li><li>空间复杂度为 $O(C)$, 在此 $C = 1000$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1001</span>,<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start == goal)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        qu.push(start);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// add</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr + nums[j] &lt;= <span class="number">1000</span> &amp;&amp; curr + nums[j] &gt;= <span class="number">0</span> &amp;&amp; dp[curr + nums[j]] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[curr + nums[j]] = step;</span><br><span class="line">                        qu.push(curr + nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(curr - nums[j] &lt;= <span class="number">1000</span> &amp;&amp; curr - nums[j] &gt;= <span class="number">0</span> &amp;&amp; dp[curr - nums[j]] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[curr - nums[j]] = step;</span><br><span class="line">                        qu.push(curr - nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>((curr^nums[j]) &lt;= <span class="number">1000</span> &amp;&amp; (curr^nums[j]) &gt;= <span class="number">0</span> &amp;&amp; dp[curr^nums[j]] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[curr^nums[j]] = step;</span><br><span class="line">                        qu.push(curr^nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(goal &gt;= <span class="number">0</span> &amp;&amp; goal &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[goal];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i + nums[j] == goal || i - nums[j] == goal || (i^nums[j]) == goal)&#123;</span><br><span class="line">                        ans = min(ans,dp[i] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span>: ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2060-同源字符串检测"><a href="#2060-同源字符串检测" class="headerlink" title="2060. 同源字符串检测"></a>2060. 同源字符串检测</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>原字符串由小写字母组成，可以按下述步骤编码：</p><ul><li>任意将其 分割 为由若干 非空 子字符串组成的一个 序列 。</li><li>任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。</li><li>重新 顺次连接 序列，得到编码后的字符串。<br>例如，编码 <code>&quot;abcdefghijklmnop&quot;</code> 的一种方法可以描述为：</li></ul><p>将原字符串分割得到一个序列：[<code>&quot;ab&quot;</code>, <code>&quot;cdefghijklmn&quot;</code>, <code>&quot;o&quot;</code>, <code>&quot;p&quot;</code>] 。<br>选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 <code>[&quot;ab&quot;, &quot;12&quot;, &quot;1&quot;, &quot;p&quot;]</code>。<br>重新顺次连接序列中的元素，得到编码后的字符串：<code>&quot;ab121p&quot;</code>。<br>给你两个编码后的字符串 <code>s1</code> 和 <code>s2</code> ，由小写英文字母和数字 1-9 组成。如果存在能够同时编码得到 <code>s1</code> 和 <code>s2</code> 原字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>注意：生成的测试用例满足 <code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code> 。</p><p>示例 1：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = <span class="string">"internationalization"</span>, s2 = <span class="string">"i18n"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：<span class="string">"internationalization"</span> 可以作为原字符串</span><br><span class="line">- <span class="string">"internationalization"</span> </span><br><span class="line">  -&gt; 分割：      [<span class="string">"internationalization"</span>]</span><br><span class="line">  -&gt; 不替换任何元素</span><br><span class="line">  -&gt; 连接：      <span class="string">"internationalization"</span>，得到 s1</span><br><span class="line">- <span class="string">"internationalization"</span></span><br><span class="line">  -&gt; 分割：      [<span class="string">"i"</span>, <span class="string">"nternationalizatio"</span>, <span class="string">"n"</span>]</span><br><span class="line">  -&gt; 替换：      [<span class="string">"i"</span>, <span class="string">"18"</span>,                 <span class="string">"n"</span>]</span><br><span class="line">  -&gt; 连接：      <span class="string">"i18n"</span>，得到 s2</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = <span class="string">"l123e"</span>, s2 = <span class="string">"44"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：<span class="string">"leetcode"</span> 可以作为原字符串</span><br><span class="line">- <span class="string">"leetcode"</span> </span><br><span class="line">  -&gt; 分割：       [<span class="string">"l"</span>, <span class="string">"e"</span>, <span class="string">"et"</span>, <span class="string">"cod"</span>, <span class="string">"e"</span>]</span><br><span class="line">  -&gt; 替换：       [<span class="string">"l"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>,  <span class="string">"3"</span>,   <span class="string">"e"</span>]</span><br><span class="line">  -&gt; 连接：       <span class="string">"l123e"</span>，得到 s1</span><br><span class="line">- <span class="string">"leetcode"</span> </span><br><span class="line">  -&gt; 分割：       [<span class="string">"leet"</span>, <span class="string">"code"</span>]</span><br><span class="line">  -&gt; 替换：       [<span class="string">"4"</span>,    <span class="string">"4"</span>]</span><br><span class="line">  -&gt; 连接：       <span class="string">"44"</span>，得到 s2</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"a5b"</span>, <span class="built_in">s2</span> = <span class="string">"c5b"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：不存在这样的原字符串</span><br><span class="line">- 编码为 <span class="built_in">s1</span> 的字符串必须以字母 <span class="string">'a'</span> 开头</span><br><span class="line">- 编码为 <span class="built_in">s2</span> 的字符串必须以字母 <span class="string">'c'</span> 开头</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = <span class="string">"112s"</span>, s2 = <span class="string">"g841"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：<span class="string">"gaaaaaaaaaaaas"</span> 可以作为原字符串</span><br><span class="line">- <span class="string">"gaaaaaaaaaaaas"</span></span><br><span class="line">  -&gt; 分割：       [<span class="string">"g"</span>, <span class="string">"aaaaaaaaaaaa"</span>, <span class="string">"s"</span>]</span><br><span class="line">  -&gt; 替换：       [<span class="string">"1"</span>, <span class="string">"12"</span>,           <span class="string">"s"</span>]</span><br><span class="line">  -&gt; 连接：       <span class="string">"112s"</span>，得到 s1</span><br><span class="line">- <span class="string">"gaaaaaaaaaaaas"</span></span><br><span class="line">  -&gt; 分割：       [<span class="string">"g"</span>, <span class="string">"aaaaaaaa"</span>, <span class="string">"aaaa"</span>, <span class="string">"s"</span>]</span><br><span class="line">  -&gt; 替换：       [<span class="string">"g"</span>, <span class="string">"8"</span>,        <span class="string">"4"</span>,    <span class="string">"1"</span>]</span><br><span class="line">  -&gt; 连接         <span class="string">"g841"</span>，得到 s2</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"ab"</span>, <span class="built_in">s2</span> = <span class="string">"a2"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：不存在这样的原字符串</span><br><span class="line">- 编码为 <span class="built_in">s1</span> 的字符串由两个字母组成</span><br><span class="line">- 编码为 <span class="built_in">s2</span> 的字符串由三个字母组成</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 40</code></li><li><code>s1</code> 和 <code>s2</code> 仅由数字 <code>1-9</code> 和小写英文字母组成</li><li><code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code><br>。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS　或者 dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>感觉算是比较难的题目,非常有难度的思考的题目,非常喜欢这类的动态规划思考的题目, 自我感觉非常喜欢这类思考的题目．这个<a href="https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/solution/dong-tai-gui-hua-ji-lu-ke-neng-de-chang-o87gp/" target="_blank" rel="noopener">题解</a>写的很好,代码也写的非常优雅,确实是非常好的解法. 后面为优化后的记忆化搜索 $DFS$.</li><li>设 $dp[i][j]$ 表示前 $s1$的前 $i$ 个字符与 $s2$ 的前 $j$ 个字符匹配后的二者可能的长度的差值, 我们设 $ d = dp[i][j]$.</li></ol><ul><li>如果当下一个匹配的是数字,则我们尽可能的匹配数字;</li><li>如果当前匹配的为字符,则我们尽可能的调整去匹配字符与差值;</li><li>中间涉及到贪心算法,如果当前匹配的差值大于 $0$, 则此时我们应该增加 $s2$ 的字符来减小差值; 如果当前匹配的差值小于 $0$, 则此时我们应该增加 $s1$ 的字符来加大差值.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(nC^{n})$, 其中 $C$ 为某个常数, $n$ 为棋子的个数.</li><li>空间复杂度分析: $O(nC)$,其中 $C$ 为某个常数, $n$ 为棋子的个数.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possiblyEquals</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.size();</span><br><span class="line">        <span class="keyword">int</span> n = s2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(m + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>].emplace(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> d : dp[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; min(m,i+<span class="number">3</span>); ++k)&#123;</span><br><span class="line">                        num = num*<span class="number">10</span> + s1[k] - <span class="string">'0'</span>;</span><br><span class="line">                        <span class="keyword">if</span>(isDigit(s1[k]))&#123;</span><br><span class="line">                            dp[k+<span class="number">1</span>][j].emplace(d + num);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; min(n,j+<span class="number">3</span>); ++k) &#123;</span><br><span class="line">                        num = num*<span class="number">10</span> + s2[k] - <span class="string">'0'</span>;</span><br><span class="line">                        <span class="keyword">if</span>(isDigit(s2[k]))&#123;</span><br><span class="line">                            dp[i][k+<span class="number">1</span>].emplace(d - num);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; m &amp;&amp; d &lt; <span class="number">0</span> &amp;&amp; isAlpha(s1[i])) &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][j].emplace(d + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; n &amp;&amp; d &gt; <span class="number">0</span> &amp;&amp; isAlpha(s2[j])) &#123;</span><br><span class="line">                        dp[i][j+<span class="number">1</span>].emplace(d - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; m &amp;&amp; j &lt; n &amp;&amp; d == <span class="number">0</span> &amp;&amp; s1[i] == s2[j]) &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>].emplace(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n].count(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>DFS</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;pii,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp; s1, <span class="built_in">string</span> &amp; s2,<span class="keyword">int</span> l1,<span class="keyword">int</span> l2,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[make_pair(l1,l2)].count(res))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 == s1.size() &amp;&amp; l2 == s2.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[make_pair(l1,l2)].emplace(res);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[make_pair(l1,l2)].emplace(res);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l1; i &lt; s1.size() &amp;&amp; i &lt; l1 + <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isDigit(s1[i]))&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + s1[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s1,s2,i + <span class="number">1</span>,l2,res + num))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l2; i &lt; s2.size() &amp;&amp; i &lt; l2 + <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isDigit(s2[i]))&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + s2[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s1,s2,l1,i + <span class="number">1</span>,res - num))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 &lt; s1.size() &amp;&amp; res &lt; <span class="number">0</span> &amp;&amp; isAlpha(s1[l1]))&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(s1, s2, l1 + <span class="number">1</span>,l2, res + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 &lt; s2.size() &amp;&amp; res &gt; <span class="number">0</span> &amp;&amp; isAlpha(s2[l2])) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(s1, s2, l1, l2 + <span class="number">1</span>, res - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 &lt; s1.size() &amp;&amp; l2 &lt; s2.size() &amp;&amp; res == <span class="number">0</span> &amp;&amp; s1[l1] == s2[l2]) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(s1, s2, l1 + <span class="number">1</span>, l2 + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possiblyEquals</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.size();</span><br><span class="line">        <span class="keyword">int</span> n = s2.size();</span><br><span class="line">        <span class="keyword">return</span> dfs(s1,s2,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-265&quot;&gt;&lt;a href=&quot;#leetcode-contest-265&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 265&quot;&gt;&lt;/a&gt;leetcode contest 265&lt;/h1&gt;&lt;p&gt;题目质量还可以,还是三道题的节奏,最后一题质量真心很高, 确实是非常好的思考的题目. &lt;/p&gt;&lt;h3 id=&quot;2057-值相等的最小索引&quot;&gt;&lt;a href=&quot;#2057-值相等的最小索引&quot; class=&quot;headerlink&quot; title=&quot;2057. 值相等的最小索引&quot;&gt;&lt;/a&gt;2057. 值相等的最小索引&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; ，返回 &lt;code&gt;nums&lt;/code&gt; 中满足 &lt;code&gt;i mod 10 == nums[i]&lt;/code&gt; 的最小下标 &lt;code&gt;i&lt;/code&gt; ；如果不存在这样的下标，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;br&gt;&lt;code&gt;x mod y&lt;/code&gt; 表示 &lt;code&gt;x&lt;/code&gt; 除以 &lt;code&gt;y&lt;/code&gt; 的 余数 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest Biweekly 64</title>
    <link href="http://yoursite.com/2021/10/31/340/"/>
    <id>http://yoursite.com/2021/10/31/340/</id>
    <published>2021-10-31T11:19:22.290Z</published>
    <updated>2021-11-02T15:04:30.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-biweekly-64"><a href="#leetcode-contest-biweekly-64" class="headerlink" title="leetcode contest biweekly 64"></a>leetcode contest biweekly 64</h1><p>题目质量还可以,还是三道题的节奏,最后一题确实不会做．</p><h3 id="5898-数组中第-K-个独一无二的字符串"><a href="#5898-数组中第-K-个独一无二的字符串" class="headerlink" title="5898. 数组中第 K 个独一无二的字符串"></a>5898. 数组中第 K 个独一无二的字符串</h3><p>独一无二的字符串 指的是在一个数组中只出现过 一次 的字符串。</p><p>给你一个字符串数组 <code>arr</code> 和一个整数 <code>k</code> ，请你返回 <code>arr</code>中第 <code>k</code> 个 独一无二的字符串 。如果 少于 k 个独一无二的字符串，那么返回 空字符串 “” 。</p><a id="more"></a><p>注意，按照字符串在原数组中的 顺序 找到第 k 个独一无二字符串。</p><p>示例 1:<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="comment">"d"</span>,<span class="comment">"b"</span>,<span class="comment">"c"</span>,<span class="comment">"b"</span>,<span class="comment">"c"</span>,<span class="comment">"a"</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="comment">"a"</span></span><br><span class="line">解释：</span><br><span class="line">arr 中独一无二字符串包括 <span class="comment">"d"</span> 和 <span class="comment">"a"</span> 。</span><br><span class="line"><span class="comment">"d"</span> 首先出现，所以它是第 <span class="number">1</span> 个独一无二字符串。</span><br><span class="line"><span class="comment">"a"</span> 第二个出现，所以它是 <span class="number">2</span> 个独一无二字符串。</span><br><span class="line">由于 k == <span class="number">2</span> ，返回 <span class="comment">"a"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="string">"aaa"</span>,<span class="string">"aa"</span>,<span class="string">"a"</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"aaa"</span></span><br><span class="line">解释：</span><br><span class="line">arr 中所有字符串都是独一无二的，所以返回第 <span class="number">1</span> 个字符串 <span class="string">"aaa"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"a"</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：</span><br><span class="line">唯一一个独一无二字符串是 <span class="string">"b"</span> 。由于少于 <span class="number">3</span> 个独一无二字符串，我们返回空字符串 <span class="string">""</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i].length &lt;= 5</code></li><li><code>arr[i]</code> 只包含小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/kth-distinct-string-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-distinct-string-in-an-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  字符串</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>哈希统计字符的次数，然后依次遍历字符串找到第 $k$ 只出现一次的字符;</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串的长度,我们此时需要遍历两遍即可。</li><li>空间复杂度: $O(C)$,其中 $C$ 为字符串的个数,在这里为 $26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">kthDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : arr) cnt[v]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5899-两个最好的不重叠活动"><a href="#5899-两个最好的不重叠活动" class="headerlink" title="5899. 两个最好的不重叠活动"></a>5899. 两个最好的不重叠活动</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的二维整数数组 <code>events</code> ，其中 <code>events[i] = [startTimei, endTimei, valuei]</code> 。第 <code>i</code> 个活动开始于 <code>startTimei</code> ，结束于 <code>endTimei</code> ，如果你参加这个活动，那么你可以得到价值 <code>valuei</code> 。你 最多 可以参加 两个时间不重叠 活动，使得它们的价值之和 最大 。</p><p>请你返回价值之和的 最大值 。注意，活动的开始时间和结束时间是 包括 在活动时间内的，也就是说，你不能参加两个活动且它们之一的开始时间等于另一个活动的结束时间。更具体的，如果你参加一个活动，且结束时间为<code>t</code> ，那么下一个活动必须在 <code>t + 1</code> 或之后的时间开始。</p><p>示例 1:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：选择绿色的活动 <span class="number">0</span> 和 <span class="number">1</span> ，价值之和为 <span class="number">2</span> + <span class="number">2</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：选择活动 <span class="number">2</span> ，价值和为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：选择活动 <span class="number">0</span> 和 <span class="number">2</span> ，价值之和为 <span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= events.length &lt;= 105</code></li><li><code>events[i].length == 3</code></li><li><code>1 &lt;= startTimei &lt;= endTimei &lt;= 109</code></li><li><code>1 &lt;= valuei &lt;= 106</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/two-best-non-overlapping-events" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-best-non-overlapping-events</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 枚举 +　二分差值</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们首先按照会议的开始时间进行排序，然后我们枚举每个会议 $i$, 其中会议 $i$ 的起始时间为 $start_{i}$, 结束时间为 $end_{i}$, 我们找到会议起始时间大于等于 $end_{i}$ 且价值最大的会议 $j$, 我们可以知道价值最大的等于：<script type="math/tex; mode=display">maxVal = \max(value_{i}, value_{i} + value_{j}) \qquad (i \in [0,n-1], end_{i} \leq start_{j})</script></li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N\log{N})$. 其中 $N$ 为数组的长度, 我们每次枚举, 然后利用二分差值,找到会议起始时间大于等于当前会议的结束时间的最大值.</li><li>空间复杂度分析: 空间复杂度为$O(n)$．</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTwoEvents</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = events.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; events.size(); ++i)&#123;</span><br><span class="line">            events[i][<span class="number">0</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(events.begin(),events.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr[i] = events[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            suffix[i] = max(events[i][<span class="number">2</span>], suffix[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = events[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr.begin(),arr.end(),events[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(it != arr.end())&#123;</span><br><span class="line">                curr += suffix[it-arr.begin()];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5900-蜡烛之间的盘子"><a href="#5900-蜡烛之间的盘子" class="headerlink" title="5900. 蜡烛之间的盘子"></a>5900. 蜡烛之间的盘子</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 <code>0</code> 开始的字符串 <code>s</code> ，它只包含字符 <code>&#39;*&#39;</code> 和 <code>&#39;|&#39;</code> ，其中 <code>&#39;*&#39;</code> 表示一个 盘子 ，’|’ 表示一支 蜡烛 。</p><p>同时给你一个下标从 <code>0</code> 开始的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [lefti, righti]</code> 表示 子字符串 <code>s[lefti...righti]</code> （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。</p><p>比方说，<code>s = &quot;||**||**|*&quot;</code> ，查询 <code>[3, 8]</code>，表示的是子字符串 <code>&quot;*||**|&quot;</code> 。子字符串中在两支蜡烛之间的盘子数目为 <code>2</code> ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。<br>请你返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p><p>示例 1:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"**|**|***|"</span>, queries = [[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">- queries[<span class="number">0</span>] 有两个盘子在蜡烛之间。</span><br><span class="line">- queries[<span class="number">1</span>] 有三个盘子在蜡烛之间。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"***|**|*****|**||**|*"</span>, queries = [[<span class="number">1</span>,<span class="number">17</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">14</span>,<span class="number">17</span>],[<span class="number">5</span>,<span class="number">11</span>],[<span class="number">15</span>,<span class="number">16</span>]]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">- queries[<span class="number">0</span>] 有 <span class="number">9</span> 个盘子在蜡烛之间。</span><br><span class="line">- 另一个查询没有盘子在蜡烛之间。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 只包含字符<code>&#39;*&#39;</code>和 <code>&#39;|&#39;</code> 。</li><li><code>1 &lt;= queries.length &lt;= 105</code></li><li><code>queries[i].length == 2</code></li><li><code>0 &lt;= lefti &lt;= righti &lt; s.length</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/plates-between-candles" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plates-between-candles</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 前缀和或者二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>对于每个查询 $[l,r]$,我们只需要找到最小的索引 $j$ 满足 $j \ge l$ 且 $s[i] = \texttt{‘|’}$, 我们只需要找到最大的索引 $k$ 满足 $k \le r$ 且 $s[k] = \texttt{‘|’}$, 类似的我们可以利用前缀或者后缀,或者二分查找的方法快速找到索引 $j,k$, 然后我们可以利用前缀和,快速的求出 $[j,k]$ 之间的 $\texttt{‘*’}$ 的个数即可.我们需要提前预处理数组即可,$left[i]$ 记录左侧距离索引 $i$ 最近的 $\texttt{‘|’}$ 的位置,$right[i]$ 记录右侧侧距离索引 $i$ 最近的 $\texttt{‘|’}$ 的位置.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N + M)$,其中 $N$ 为数组的个数，$M$ 为查询的次数,我们需要提前与</li><li>空间复杂度为 $O(2N)$,其中 $N$ 为节点的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; platesBetweenCandles(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = (s[<span class="number">0</span>] == <span class="string">'|'</span> ? <span class="number">0</span> : <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                left[i] = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left[i] = left[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right[n<span class="number">-1</span>] = (s[n<span class="number">-1</span>] == <span class="string">'|'</span> ? <span class="number">0</span> : <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                right[i] = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                sum[i+<span class="number">1</span>] = sum[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum[i+<span class="number">1</span>] = sum[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : queries) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right[v[<span class="number">0</span>]] &lt; left[v[<span class="number">1</span>]])&#123;</span><br><span class="line">                ans.push_back(sum[left[v[<span class="number">1</span>]] + <span class="number">1</span>] - sum[right[v[<span class="number">0</span>]]]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; platesBetweenCandles(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = queries.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                arr1.push_back(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr2.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : queries)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = v[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r = v[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> it1 = lower_bound(arr2.begin(),arr2.end(),l);</span><br><span class="line">            <span class="keyword">if</span>(it1 == arr2.end())&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l = arr2[it1-arr2.begin()];</span><br><span class="line">            <span class="keyword">auto</span> it2 = lower_bound(arr2.begin(),arr2.end(),r+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(it2 == arr2.begin())&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            it2--;</span><br><span class="line">            r = arr2[it2-arr2.begin()];</span><br><span class="line">            <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it3 = lower_bound(arr1.begin(),arr1.end(),l);</span><br><span class="line">            <span class="keyword">if</span>(it3 == arr1.end())&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it4 = lower_bound(arr1.begin(),arr1.end(),r);</span><br><span class="line">            <span class="keyword">if</span>(it4 == arr1.begin())&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(it4-it3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5901-棋盘上有效移动组合的数目"><a href="#5901-棋盘上有效移动组合的数目" class="headerlink" title="5901. 棋盘上有效移动组合的数目"></a>5901. 棋盘上有效移动组合的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一个 <code>8 x 8</code> 的棋盘，它包含 <code>n</code> 个棋子（棋子包括车，后和象三种）。给你一个长度为 <code>n</code> 的字符串数组 <code>pieces</code> ，其中 <code>pieces[i]</code> 表示第 i 个棋子的类型（车，后或象）。除此以外，还给你一个长度为 <code>n</code> 的二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [ri, ci]</code> 表示第 <code>i</code> 个棋子现在在棋盘上的位置为 <code>(ri, ci)</code> ，棋盘下标从 <code>1</code> 开始。</p><p>棋盘上每个棋子都可以移动 至多一次 。每个棋子的移动中，首先选择移动的 方向 ，然后选择 移动的步数 ，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：</p><p>车可以 水平或者竖直 从 <code>(r, c)</code> 沿着方向 <code>(r+1, c)，(r-1, c)，(r, c+1)</code> 或者 <code>(r, c-1)</code> 移动。<br>后可以 水平竖直或者斜对角 从 <code>(r, c)</code> 沿着方向 <code>(r+1, c)，(r-1, c)，(r, c+1)，(r, c-1)，(r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1)</code> 移动。<br>象可以 斜对角 从 <code>(r, c)</code> 沿着方向 <code>(r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1)</code> 移动。<br>移动组合 包含所有棋子的 移动 。每一秒，每个棋子都沿着它们选择的方向往前移动 一步 ，直到它们到达目标位置。所有棋子从时刻 <code>0</code> 开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 不有效 。</p><p>请你返回 有效 移动组合的数目。</p><p>注意：</p><ul><li>初始时，不会有两个棋子 在 同一个位置 。</li><li>有可能在一个移动组合中，有棋子不移动。</li><li>如果两个棋子 直接相邻 且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 交换位置 。</li></ul><p>示例 1:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"rook"</span>], positions = <span class="string">[[1,1]]</span></span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：上图展示了棋子所有可能的移动。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"queen"</span>], positions = <span class="string">[[1,1]]</span></span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：上图展示了棋子所有可能的移动。</span><br></pre></td></tr></table></figure><br>示例 3:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"bishop"</span>], positions = <span class="string">[[4,3]]</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：上图展示了棋子所有可能的移动。</span><br></pre></td></tr></table></figure><br>示例 4:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"rook"</span>,<span class="string">"rook"</span>], positions = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">8</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">223</span></span><br><span class="line">解释：每个车有 <span class="number">15</span> 种移动，所以总共有 <span class="number">15</span> * <span class="number">15</span> = <span class="number">225</span> 种移动组合。</span><br><span class="line">但是，有两个是不有效的移动组合：</span><br><span class="line">- 将两个车都移动到 (<span class="number">8</span>, <span class="number">1</span>) ，会导致它们在同一个格子相遇。</span><br><span class="line">- 将两个车都移动到 (<span class="number">1</span>, <span class="number">8</span>) ，会导致它们在同一个格子相遇。</span><br><span class="line">所以，总共有 <span class="number">225</span> - <span class="number">2</span> = <span class="number">223</span> 种有效移动组合。</span><br><span class="line">注意，有两种有效的移动组合，分别是一个车在 (<span class="number">1</span>, <span class="number">8</span>) ，另一个车在 (<span class="number">8</span>, <span class="number">1</span>) 。</span><br><span class="line">即使棋盘状态是相同的，这两个移动组合被视为不同的，因为每个棋子移动操作是不相同的。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"queen"</span>,<span class="string">"bishop"</span>], positions = [[<span class="number">5</span>,<span class="number">7</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">281</span></span><br><span class="line">解释：总共有 <span class="number">12</span> * <span class="number">24</span> = <span class="number">288</span> 种移动组合。</span><br><span class="line">但是，有一些不有效的移动组合：</span><br><span class="line">- 如果后停在 (<span class="number">6</span>, <span class="number">7</span>) ，它会阻挡象到达 (<span class="number">6</span>, <span class="number">7</span>) 或者 (<span class="number">7</span>, <span class="number">8</span>) 。</span><br><span class="line">- 如果后停在 (<span class="number">5</span>, <span class="number">6</span>) ，它会阻挡象到达 (<span class="number">5</span>, <span class="number">6</span>) ，(<span class="number">6</span>, <span class="number">7</span>) 或者 (<span class="number">7</span>, <span class="number">8</span>) 。</span><br><span class="line">- 如果象停在 (<span class="number">5</span>, <span class="number">2</span>) ，它会阻挡后到达 (<span class="number">5</span>, <span class="number">2</span>) 或者 (<span class="number">5</span>, <span class="number">1</span>) 。</span><br><span class="line">在 <span class="number">288</span> 个移动组合当中，<span class="number">281</span> 个是有效的。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == pieces.length</code></li><li><code>n == positions.length</code></li><li><code>1 &lt;= n &lt;= 4</code></li><li><code>pieces</code> 只包含字符串 <code>&quot;rook&quot;</code> ，<code>&quot;queen&quot;</code> 和 <code>&quot;bishop&quot;</code> 。</li><li>棋盘上总共最多只有一个后。</li><li><code>1 &lt;= xi, yi &lt;= 8</code></li><li>每一个 <code>positions[i]</code> 互不相同。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-valid-move-combinations-on-chessboard" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-valid-move-combinations-on-chessboard</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目还算是比较新颖的题目，首先我们可以测算皇后的可能走的方法有 $28$ 种, 题目种给定数据大小 $ n \le 4 $, 因此最多只有 $22^4 = 234256$种可能的走法组合,因此我们可以利用暴力求解, 找到所有可能的组合,然后检测每种组合是否合法.</li><li>每种棋子我们定义每种走法的状态为 ($s, d)$ ,其中 $s$ 代表该棋子会移动多少步后停止, $d$ 代表该棋子移动的方法．同时我们还需要检测每种状态组合是否合法, 如果该状态组合为非法需要满足以下任意一个:</li></ol><ul><li>棋子 $i$ 与棋子 $j$ 经过相同的移动步数进入同一个格子;</li><li>棋子 $i$ 的刚好进入棋子 $j$ 停留的格子.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(nC^{n})$, 其中 $C$ 为某个常数, $n$ 为棋子的个数.</li><li>空间复杂度分析: $O(nC)$,其中 $C$ 为某个常数, $n$ 为棋子的个数.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; positions, <span class="built_in">vector</span>&lt;pii&gt; &amp; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = positions.size();</span><br><span class="line">        <span class="keyword">int</span> mx = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = curr[i].first;</span><br><span class="line">            <span class="keyword">int</span> d = curr[i].second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = positions[i][<span class="number">0</span>] + j*dx[d];</span><br><span class="line">                <span class="keyword">int</span> y = positions[i][<span class="number">1</span>] + j*dy[d];</span><br><span class="line">                cnt[i].push_back(x*<span class="number">8</span> + y);</span><br><span class="line">            &#125;</span><br><span class="line">            mx = min(mx, <span class="keyword">int</span>(cnt[i].size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mx; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j][i] == cnt[j+<span class="number">1</span>][i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt[i].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == k) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[i][j] == cnt[k].back()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; positions, <span class="built_in">vector</span>&lt;pii&gt; &amp; curr, <span class="keyword">int</span> &amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == arr.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(positions, curr)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr[x].size(); ++i) &#123;</span><br><span class="line">            curr.emplace_back(arr[x][i]);</span><br><span class="line">            dfs(x + <span class="number">1</span>, arr, positions, curr, res);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCombinations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pieces, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; positions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = pieces.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; arr(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*initial*/</span></span><br><span class="line">        dirs[<span class="string">"queen"</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line">        dirs[<span class="string">"rook"</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">        dirs[<span class="string">"bishop"</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            arr[i].push_back(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> d : dirs[pieces[i]]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = positions[i][<span class="number">0</span>] + dx[d]*k;</span><br><span class="line">                    <span class="keyword">int</span> y = positions[i][<span class="number">1</span>] + dy[d]*k;</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= <span class="number">8</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">                        arr[i].push_back(&#123;k, d&#125;);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* deap first search*/</span></span><br><span class="line">        dfs(<span class="number">0</span>, arr, positions, curr, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-biweekly-64&quot;&gt;&lt;a href=&quot;#leetcode-contest-biweekly-64&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest biweekly 64&quot;&gt;&lt;/a&gt;leetcode contest biweekly 64&lt;/h1&gt;&lt;p&gt;题目质量还可以,还是三道题的节奏,最后一题确实不会做．&lt;/p&gt;&lt;h3 id=&quot;5898-数组中第-K-个独一无二的字符串&quot;&gt;&lt;a href=&quot;#5898-数组中第-K-个独一无二的字符串&quot; class=&quot;headerlink&quot; title=&quot;5898. 数组中第 K 个独一无二的字符串&quot;&gt;&lt;/a&gt;5898. 数组中第 K 个独一无二的字符串&lt;/h3&gt;&lt;p&gt;独一无二的字符串 指的是在一个数组中只出现过 一次 的字符串。&lt;/p&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;arr&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你返回 &lt;code&gt;arr&lt;/code&gt;中第 &lt;code&gt;k&lt;/code&gt; 个 独一无二的字符串 。如果 少于 k 个独一无二的字符串，那么返回 空字符串 “” 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 建信金科</title>
    <link href="http://yoursite.com/2021/10/30/339/"/>
    <id>http://yoursite.com/2021/10/30/339/</id>
    <published>2021-10-30T04:27:29.486Z</published>
    <updated>2021-11-11T15:09:41.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-建信金科"><a href="#leetcode-contest-建信金科" class="headerlink" title="leetcode contest 建信金科"></a>leetcode contest 建信金科</h1><p>题目质量还是非常高的，只做出两道的节奏，最后两道题目没有做出来，但是又从中学到了新的知识点和技能．第四题可能是我最喜欢的题目类型了，带有思考性质和数学问题，非常喜欢这种思维加数学的题型，通过算法和计算可以学习到数学的问题．</p><h3 id="建信01-间隔删除链表结点"><a href="#建信01-间隔删除链表结点" class="headerlink" title="建信01. 间隔删除链表结点"></a>建信01. 间隔删除链表结点</h3><p>给你一个链表的头结点 <code>head</code>，每隔一个结点删除另一个结点（要求保留头结点）。<br>请返回最终链表的头结点。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">蓝色结点为删除的结点</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表中结点的数目在<code>[1, 5000]</code>范围内。</li><li><code>1 &lt;= Node.val &lt;= 10000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/woGGnF/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/ccbft-2021fall/problems/woGGnF/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  遍历</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的比较无聊，我们每隔一个节点删除一个节点即可，将节点的指针指向下一个节点的下一个节点即可。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为链表的长度,我们此时需要遍历一遍即可。</li><li>空间复杂度: $O(1)$,我们指针保存中间变量即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteListNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            ListNode * prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(curr)&#123;</span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="建信02-柱状图分析"><a href="#建信02-柱状图分析" class="headerlink" title="建信02. 柱状图分析"></a>建信02. 柱状图分析</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>某柱状图上共有 <code>N</code>个柱形，数组 <code>heights</code> 中按照排列顺序记录了每个柱形的高度。假定任选 <code>cnt</code> 个柱形可组成一个柱形组，请在所有可能的柱形组中，找出最大高度与最小高度的差值为最小的柱形组，按高度升序返回该柱形组。若存在多个柱形组满足条件，则返回第一个元素最小的柱形组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>], cnt = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 与 [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>] 都符合在所有的柱形组中，最大高度与最小高度的差值为最小的条件，选择第一个元素最小的 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 返回。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">10</span>], cnt = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">解释：柱形组 [<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>] 满足最大高度与最小高度的差值为最小条件。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= cnt &lt; heights.length &lt;= 10^5</code></li><li><code>0 &lt;= heights[i] &lt;= 10^6</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/9Rs2aO/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/ccbft-2021fall/problems/9Rs2aO/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>所谓任选 $cnt$ 个柱形使得最大高度与最小高度最小，则此时我们按照排序从小到大，最大值与最小值之差的最小值肯定是在选择连续 $cnt$ 个元素中．</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n\log(n))$，其中 $n$ 表示数组的长度．</li><li>空间复杂度分析: 空间复杂度为 $O(1)$，我们只需要常数个变量保存中间变量．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; analysisHistogram(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights, <span class="keyword">int</span> cnt) &#123;</span><br><span class="line">        sort(heights.begin(),heights.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> mindiff = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> n = heights.size();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-cnt; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(heights[i+cnt<span class="number">-1</span>] - heights[i] &lt; mindiff)&#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                mindiff = heights[i+cnt<span class="number">-1</span>] - heights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; idx+cnt; ++i)&#123;</span><br><span class="line">            ans.push_back(heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="建信03-地铁路线规划"><a href="#建信03-地铁路线规划" class="headerlink" title="建信03. 地铁路线规划"></a>建信03. 地铁路线规划</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>某城市有若干条地铁线路，<code>lines</code> 记录了每条地铁线路依次停靠的站点（每条线路均是双向的）<br>李林想从站点 <code>start</code> 出发前往 <code>end</code>，请规划一条可行路线使得他可以以最小的换乘次数到达目的站点。若有多条路线满足要求，请返回字典序最小的路线（要求路线上无重复的站点）。</p><p>注意：</p><ul><li>输入数据保证存在 <code>start</code> 到 <code>end</code> 的路线</li><li>任意路线上的点在该条路线上仅出现一次（即任意一条路线均不是环线）</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：lines = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>],[<span class="number">10</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">13</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">11</span>]], start = <span class="number">1</span>, end = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">解释：路线如图所示</span><br><span class="line">从站点 <span class="number">1</span> 到站点 <span class="number">7</span> 的最少换乘 <span class="number">1</span> 次，路线为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：lines = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>],[<span class="number">12</span>,<span class="number">13</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">15</span>],[<span class="number">16</span>,<span class="number">1</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">18</span>]], start = <span class="number">9</span>, end = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">解释：路线如图所示</span><br><span class="line">从站点 <span class="number">9</span> 到站点 <span class="number">1</span> 的最少换乘 <span class="number">0</span> 次，路线为 [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= lines.length, lines[i].length &lt;= 100</code></li><li><code>1 &lt;= lines[i][j], start, end &lt;= 10000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/zQTFs4/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/ccbft-2021fall/problems/zQTFs4/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra 或者　DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>感觉这个题目当时拿到时确实没有特别好的思路, 感觉可以通过暴力搜索即可解决该题目，最后看到几个解答，发现有直接 $DFS$ 加减枝就可以搞定的. 其实想想这个题目最难的地方有两点需要注意:</li></ol><ul><li>字典序最小的路径如何求出,最后看了下别人的解法竟然都是直接记录下当前的路径,然后比较两个整数数组的字典序大小即可，当初拿到题目的时候一直在想如何记录最小的字典序，结果都是使用暴力来记录．</li><li>如何记录两个站点之间的线路切换，我们在遍历的时候需要记录上一站的站点 $x$ 和路线 $y$，在下一站点切换时，我们会遍历站点 $x$ 周围所有的站点和路线, 这个需要稍微用点技巧, 我们在记录站点的邻接站点时,同时记录下它的站点号和路线号.</li></ul><ol><li>$DFS$ 暴力搜索的解法就感觉比较简单, 利用回溯记录下所有从 $start$ 可能的路径,并同时记录该路径经历的换乘次数, 同时记录下路径用来比较字典序,感觉这个解法确实没有什么难度,但是感觉复杂度还挺高的,感觉需要用到欧拉拓扑之类的，这个解法的时间复杂度应该挺高的，感觉应该在 $O(n^{3})$.当时感觉应该用 $BFS$ 来解决的,但是确实没有想到 $BFS$ 解决的好办法.</li><li>$BFS$: 我们可以使用 $dijistra$ 算法快速收敛,每次记录下当前路线的换站次数，路线号，已经经过的站点路劲，每次选择下一跳时，我们优先选择切换站点次数最少，且路径字典序最小的路径．实际 $BFS$ 写起来非常简洁.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(MN\times log(MN))$,其中 $N$ 为站点的个数, $M$ 为线路的个数.</li><li>空间复杂度为 $O(N^2)$,其中 $N$ 为站点的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li><code>DFS</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; vis, <span class="keyword">int</span> last, <span class="keyword">int</span> cost, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(cost &gt; ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur == target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cost &lt; ans || (cost == ans &amp;&amp; path &lt; ret)) &#123;</span><br><span class="line">                ans = cost;</span><br><span class="line">                ret = path;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [next, route] : g[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[next]) &#123;</span><br><span class="line">                vis[next] = <span class="literal">true</span>;</span><br><span class="line">                path.push_back(next);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(route != last) &#123;</span><br><span class="line">                    dfs(next, target, g, vis, route, cost + <span class="number">1</span>, path);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dfs(next, target, g, vis, route, cost, path);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                path.pop_back();</span><br><span class="line">                vis[next] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; metroRouteDesignI(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(); <span class="comment">// 路线个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&gt; g(<span class="number">10005</span>); <span class="comment">// 邻接表</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = a[i].size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">                    g[a[i][j]].push_back(&#123;a[i][j + <span class="number">1</span>], i&#125;);</span><br><span class="line">                    g[a[i][j + <span class="number">1</span>]].push_back(&#123;a[i][j], i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(<span class="number">10005</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        </span><br><span class="line">        path.push_back(start);</span><br><span class="line">        vis[start] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 深搜</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [next, route] : g[start]) &#123;</span><br><span class="line">            vis[next] = <span class="literal">true</span>;</span><br><span class="line">            path.push_back(next);</span><br><span class="line">            </span><br><span class="line">            dfs(next, end, g, vis, route, <span class="number">0</span>, path);</span><br><span class="line">            </span><br><span class="line">            path.pop_back();</span><br><span class="line">            vis[next] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>BFS</code>:</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> line;</span><br><span class="line">    <span class="keyword">int</span> change;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a, <span class="keyword">const</span> Node &amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.change == b.change)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.path &gt; b.path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.change &gt; b.change;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; metroRouteDesignI(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; lines, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = lines.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nodes;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : lines[i])&#123;</span><br><span class="line">                nodes[v].emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; lines[i].size(); ++j)&#123;</span><br><span class="line">                graph[lines[i][j<span class="number">-1</span>]].push_back(make_pair(i,lines[i][j]));</span><br><span class="line">                graph[lines[i][j]].push_back(make_pair(i,lines[i][j<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nodes[start])&#123;</span><br><span class="line">            Node t;</span><br><span class="line">            t.line = v;</span><br><span class="line">            t.change = <span class="number">0</span>;</span><br><span class="line">            t.path.emplace_back(start);</span><br><span class="line">            pq.push(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(curr.path.back() == end)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr.path;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : curr.path)&#123;</span><br><span class="line">                visited.insert(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> neg : graph[curr.path.back()])&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited.count(neg.second)) <span class="keyword">continue</span>;</span><br><span class="line">                Node next;</span><br><span class="line">                next.line = neg.first;</span><br><span class="line">                next.path = curr.path;</span><br><span class="line">                next.path.emplace_back(neg.second);</span><br><span class="line">                <span class="comment">//change line*/</span></span><br><span class="line">                <span class="keyword">if</span>(neg.first != curr.line)&#123;</span><br><span class="line">                    next.change = curr.change + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// the same line</span></span><br><span class="line">                    next.change = curr.change;</span><br><span class="line">                &#125;</span><br><span class="line">                pq.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="建信04-电学实验课"><a href="#建信04-电学实验课" class="headerlink" title="建信04. 电学实验课"></a>建信04. 电学实验课</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>某电学实验使用了 <code>row * col</code> 个插孔的面包板，可视作二维矩阵，左上角记作 <code>(0,0)</code>。老师设置了若干「目标插孔」，它们位置对应的矩阵下标记于二维数组 <code>position</code>。实验目标要求同学们用导线连接所有「目标插孔」，即从任意一个「目标插孔」沿导线可以到达其他任意「目标插孔」。受实验导线长度所限，导线的连接规则如下：</p><ul><li>一条导线可连接相邻两列的且行间距不超过 1 的两个插孔</li><li>每一列插孔中最多使用其中一个插孔（包括「目标插孔」）<br>若实验目标可达成，请返回使用导线数量最少的连接所有目标插孔的方案数；否则请返回 0。</li></ul><p>注意：</p><ul><li>输入数据保证每列最多仅有一个「目标插孔」；</li><li>答案需要以 <code>1e9 + 7 (1000000007)</code> 为底取模， 如：计算初始结果为：<code>1000000008</code>，请返回 <code>1</code><br>示例 1：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">5</span>, col = <span class="number">6</span>, position = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：根据连接规则无法达成实验目标。</span><br></pre></td></tr></table></figure>示例 2：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">3</span>，col = <span class="number">4</span>, position = [[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：根据连接规则共有三种方案达成目标。</span><br></pre></td></tr></table></figure></li></ul><p>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">5</span>, col = <span class="number">6</span>, position = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">解释：根据连接规则共有六种方案达成目标。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= row &lt;= 20</code></li><li><code>3 &lt;= col &lt;= 10^9</code></li><li><code>1 &lt; position.length &lt;= 1000</code></li><li><code>0 &lt;= position[i][0] &lt; row</code></li><li><code>0 &lt;= position[i][1] &lt; col</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/lSjqMF/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/ccbft-2021fall/problems/lSjqMF/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划 + 数学问题　</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目,我非常喜欢的类型, 用数学方法解决类似于动态规划的题目，与<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a>的数学解法非常相似．我们知道斐波那契数数列的递推关系为$f[i] = f[i-1] + f[i-2]$, 然后我们可以利用利用矩阵乘法,求解公式如下:<script type="math/tex; mode=display">[f(n+1),f(n)] = [f(n) + f(n-1), f(n)] \\= [f(n),f(n-1)] \times \left[\begin{array}{l}1 & 1 \\1 & 0 \\\end{array}\right]</script></li><li>首先在本题中我们需要分析一下, 每个目标插孔连接时一定是按照列的大小依次进行相连的, 因为题目的约束规则是一条导线可连接相邻两列的且行间距不超过 1 的两个插孔且每一列插孔中最多使用其中一个插孔,这就意味着我们不可能先连接列数较大的目标孔后,再来连接列数较小的目标控. 因此首先我们需要按照列数的大小对目标孔进行排序, 然后依次按照列数大小开始连接.</li><li>我们知道对于递推关系如下,设$f[i][j]$ 表示第 $i$ 行 $j$ 列的导线的穿线数目，则我们可以知道:<script type="math/tex; mode=display">f[i][j] = f[i-1][j-1] + f[i][j-1] + f[i+1][j-1]</script>我们可以归纳递推关系为:<script type="math/tex; mode=display">\left\{\begin{array}{lr}f[0][j] = f[0][j-1] + f[1][j-1]\\f[1][j] = f[0][j-1] + f[1][j-1] + f[2][j-1]\\\cdots \\f[n-2][j] = f[n-3][j-1] + f[n-2][j-1] + f[n-1][j-1]\\f[n-1][j] = f[n-2][j-1] + f[n-1][j-1]\\\end{array}\right.</script>转换为矩阵乘法即为:<script type="math/tex; mode=display">[f[0][j], f[1][j], \cdots,f[n-2][j],f[n-1][j]] = [f[0][j-1], f[1][j-1], \cdots,f[n-2][j-1],f[n-1][j-1]] \times\left[\begin{array}{lr}1 & 1 & 0 & \cdots 0 & 0 \\1 & 1 & 1 & \cdots 0 & 0 \\0 & 1 & 1 & \cdots 0 & 0 \\0 & 0 & 1 & \cdots 0 & 0 \\0 & 0 & 0 & \cdots 0 & 0 \\\vdots & \vdots & \vdots & \ddots & \vdots \\0 & 0 & 0 & \cdots 1 & 0 \\0 & 0 & 0 & \cdots 1 & 1 \\0 & 0 & 0 & \cdots 1 & 1 \\\end{array}\right]</script>我们设矩阵 $A$ 满足:<script type="math/tex; mode=display">A = \left[\begin{array}{lr}1 & 1 & 0 & \cdots 0 & 0 \\1 & 1 & 1 & \cdots 0 & 0 \\0 & 1 & 1 & \cdots 0 & 0 \\0 & 0 & 1 & \cdots 0 & 0 \\0 & 0 & 0 & \cdots 0 & 0 \\\vdots & \vdots & \vdots & \ddots & \vdots \\0 & 0 & 0 & \cdots 1 & 0 \\0 & 0 & 0 & \cdots 1 & 1 \\0 & 0 & 0 & \cdots 1 & 1 \\\end{array}\right]</script>则此时我们可以知道对于第 $i$ 列的元素设为矩阵 $f[j]$, 对于第 $j$ 列的方法数的元素为矩阵 $f[i]$, 我们假设 $ i \le j$, 则我们可以知道递推关系为:<script type="math/tex; mode=display">f[j] = f[i]\times A^{j-i}</script>此时我们则将方法数的计算转换为矩阵的乘法运算, 我们只需要每次求出第到达 $i$ 列的目标控的方法数，然后根据矩阵的乘法可以计算出处在第 $j$ 列的目标孔的方法数.</li><li>实际计算过程中,我们还需要利用快速幂法,快速的计算出矩阵的 $n$ 次幂.　我们可以进行预处离．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(C\times n \times row^{3}$, 其中 $n$ 为点的个数, $C = 32$, $row$ 为矩阵的行数.</li><li>空间复杂度分析: $O(C\times row \times col)$,其中 $C=32$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>数学问题<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; mult(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; mat1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; mat2, <span class="keyword">long</span> <span class="keyword">long</span> mod)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat1.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat1[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> n = mat2[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; res(m,<span class="built_in">vector</span>&lt;ll&gt;(n));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; col; ++k)&#123;</span><br><span class="line">                    res[i][j] = (res[i][j] + mat1[i][k]*mat2[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; fastpow(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; &amp; mat, <span class="keyword">int</span> p, <span class="keyword">long</span> <span class="keyword">long</span> mod)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; res(m,<span class="built_in">vector</span>&lt;ll&gt;(m));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; curr = mat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            res[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; p != <span class="number">0</span>; p = (p&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(p%<span class="number">2</span>)&#123;</span><br><span class="line">                res = mult(res,curr,mod);</span><br><span class="line">            &#125;</span><br><span class="line">            curr = mult(curr,curr,mod);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">electricityExperiment</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = position.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        sort(position.begin(),position.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; mat(row,<span class="built_in">vector</span>&lt;ll&gt;(row));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt;&gt; arr(<span class="number">32</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            mat[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span>) mat[i][i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; row) mat[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[<span class="number">0</span>] = mat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; ++i)&#123;</span><br><span class="line">            arr[i] = mult(arr[i<span class="number">-1</span>],arr[i<span class="number">-1</span>],mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; curr(<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(row));</span><br><span class="line">        curr[<span class="number">0</span>][position[<span class="number">0</span>][<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p = position[i][<span class="number">1</span>] - position[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">31</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr = mult(curr,arr[j],mod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j != position[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    curr[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr[<span class="number">0</span>][position[n<span class="number">-1</span>][<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-建信金科&quot;&gt;&lt;a href=&quot;#leetcode-contest-建信金科&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 建信金科&quot;&gt;&lt;/a&gt;leetcode contest 建信金科&lt;/h1&gt;&lt;p&gt;题目质量还是非常高的，只做出两道的节奏，最后两道题目没有做出来，但是又从中学到了新的知识点和技能．第四题可能是我最喜欢的题目类型了，带有思考性质和数学问题，非常喜欢这种思维加数学的题型，通过算法和计算可以学习到数学的问题．&lt;/p&gt;&lt;h3 id=&quot;建信01-间隔删除链表结点&quot;&gt;&lt;a href=&quot;#建信01-间隔删除链表结点&quot; class=&quot;headerlink&quot; title=&quot;建信01. 间隔删除链表结点&quot;&gt;&lt;/a&gt;建信01. 间隔删除链表结点&lt;/h3&gt;&lt;p&gt;给你一个链表的头结点 &lt;code&gt;head&lt;/code&gt;，每隔一个结点删除另一个结点（要求保留头结点）。&lt;br&gt;请返回最终链表的头结点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest  264</title>
    <link href="http://yoursite.com/2021/10/24/338/"/>
    <id>http://yoursite.com/2021/10/24/338/</id>
    <published>2021-10-24T03:51:53.603Z</published>
    <updated>2021-10-24T05:03:33.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-264"><a href="#leetcode-contest-264" class="headerlink" title="leetcode contest 264"></a>leetcode contest 264</h1><p>本周的题目出的题目真心不好,质量严重下降,比前几次的题目差不少,缺少太多的思考难点.感觉题目确实放水严重．<br><img src="https://i.loli.net/2021/10/24/YqfN8P2clJCm3Za.png" alt></p><h3 id="5906-句子中的有效单词数"><a href="#5906-句子中的有效单词数" class="headerlink" title="5906. 句子中的有效单词数"></a>5906. 句子中的有效单词数</h3><p>句子仅由小写字母（<code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code>）、数字（<code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code>）、连字符（<code>&#39;-&#39;</code>）、标点符号（<code>&#39;!&#39;</code>、<code>&#39;.&#39;</code> 和 <code>&#39;,&#39;</code>）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 <code>token</code> ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。</p><a id="more"></a><p>如果一个 <code>token</code> 同时满足下述条件，则认为这个 <code>token</code> 是一个有效单词：</p><p>仅由小写字母、连字符和/或标点（不含数字）。<br>至多一个 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（<code>&quot;a-b&quot;</code> 是一个有效单词，但 <code>&quot;-ab&quot;</code> 和 <code>&quot;ab-&quot;</code> 不是有效单词）。<br>至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。<br>这里给出几个有效单词的例子：<code>&quot;a-b.&quot;、&quot;afad&quot;、&quot;ba-c&quot;、&quot;a!&quot; 和 &quot;!&quot;</code> 。</p><p>给你一个字符串 <code>sentence</code> ，请你找出并返回 <code>sentence</code> 中 有效单词的数目 。</p><p>示例 1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"cat and  dog"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：句子中的有效单词是 <span class="string">"cat"</span>、<span class="string">"and"</span> 和 <span class="string">"dog"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"!this  1-s b8d!"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：句子中没有有效单词</span><br><span class="line"><span class="string">"!this"</span> 不是有效单词，因为它以一个标点开头</span><br><span class="line"><span class="string">"1-s"</span> 和 <span class="string">"b8d"</span> 也不是有效单词，因为它们都包含数字</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = <span class="comment">"alice and  bob are playing stone-game10"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：句子中的有效单词是 <span class="comment">"alice"</span>、<span class="comment">"and"</span>、<span class="comment">"bob"</span>、<span class="comment">"are"</span> 和 <span class="comment">"playing"</span></span><br><span class="line"><span class="comment">"stone-game10"</span> 不是有效单词，因为它含有数字</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"he bought 2 pencils, 3 erasers, and 1  pencil-sharpener."</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：句子中的有效单词是 <span class="string">"he"</span>、<span class="string">"bought"</span>、<span class="string">"pencils,"</span>、<span class="string">"erasers,"</span>、<span class="string">"and"</span> 和 <span class="string">"pencil-sharpener."</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 1000</code></li><li><code>sentence</code> 由小写英文字母、数字<code>（0-9）</code>、以及字符<code>（&#39; &#39;、&#39;-&#39;、&#39;!&#39;、&#39;.&#39; 和 &#39;,&#39;）</code>组成</li><li>句子中至少有 <code>1</code> 个 <code>token</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-264/problems/number-of-valid-words-in-a-sentence/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-264/problems/number-of-valid-words-in-a-sentence/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  字符串</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的比较无聊，确实只能算是 $curd$。</li><li>首先我们解析出字符串中的每个 $token$，然后对每个 $token$ 进行检查:</li></ol><ul><li>如果为分割符<code>-</code>,则检查该分割符的是否是该 $token$ 的第一个元素还是最末尾的元素,同时检测 $token$ 的前后字符是否是字母;</li><li>如果为标点符<code>!</code>,<code>.</code>,<code>,</code>,则检查该标点符号是否为该 $token$ 的最后一个字符;</li><li>既不是分割符也不是标点符号的字符是否为字母;</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串的长度,我们此时需要遍历一遍即可。</li><li>空间复杂度: $O(N)$,其中 $N$ 为字符串的长度,我们需要保留每个 $token$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countValidWords</span><span class="params">(<span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sentence.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*split*/</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; sentence[pos] == <span class="string">' '</span>) pos++;</span><br><span class="line">            <span class="keyword">int</span> curr = pos;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; sentence[pos] != <span class="string">' '</span>) pos++;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; n) &#123;</span><br><span class="line">                arr.push_back(sentence.substr(curr,pos-curr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*check every token*/</span></span><br><span class="line">        <span class="keyword">int</span> m = arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> connect = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == <span class="number">0</span> || j == arr[i].size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!isAlpha(arr[i][j<span class="number">-1</span>]) || !isAlpha(arr[i][j+<span class="number">1</span>]))&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    connect++;</span><br><span class="line">                    <span class="keyword">if</span>(connect &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] == <span class="string">'!'</span> || arr[i][j] == <span class="string">'.'</span> || arr[i][j] == <span class="string">','</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j != arr[i].size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!isAlpha(arr[i][j]))&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5907-下一个更大的数值平衡数"><a href="#5907-下一个更大的数值平衡数" class="headerlink" title="5907. 下一个更大的数值平衡数"></a>5907. 下一个更大的数值平衡数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果整数  <code>x</code> 满足：对于每个数位 <code>d</code> ，这个数位 恰好 在 <code>x</code>中出现 <code>d</code>次。那么整数 <code>x</code>就是一个 数值平衡数 。</p><p>给你一个整数 <code>n</code>，请你返回 严格大于<code>n</code>的 最小数值平衡数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">22</span> 是一个数值平衡数，因为：</span><br><span class="line">- 数字 <span class="number">2</span> 出现 <span class="number">2</span> 次 </span><br><span class="line">这也是严格大于 <span class="number">1</span> 的最小数值平衡数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1000</span></span><br><span class="line">输出：<span class="number">1333</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">1333</span> 是一个数值平衡数，因为：</span><br><span class="line">- 数字 <span class="number">1</span> 出现 <span class="number">1</span> 次。</span><br><span class="line">- 数字 <span class="number">3</span> 出现 <span class="number">3</span> 次。 </span><br><span class="line">这也是严格大于 <span class="number">1000</span> 的最小数值平衡数。</span><br><span class="line">注意，<span class="number">1022</span> 不能作为本输入的答案，因为数字 <span class="number">0</span> 的出现次数超过了 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3000</span></span><br><span class="line">输出：<span class="number">3133</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">3133</span> 是一个数值平衡数，因为：</span><br><span class="line">- 数字 <span class="number">1</span> 出现 <span class="number">1</span> 次。</span><br><span class="line">- 数字 <span class="number">3</span> 出现 <span class="number">3</span> 次。 </span><br><span class="line">这也是严格大于 <span class="number">3000</span> 的最小数值平衡数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>0 &lt;= n &lt;= 106</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-264/problems/next-greater-numerically-balanced-number/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-264/problems/next-greater-numerically-balanced-number/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目也不知大有什么规律，想来想去，最后干脆直接暴力，因为 $n$ 的数量级很小．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(1)$.</li><li>空间复杂度分析: 空间复杂度为$O(n)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            cnt[x%<span class="number">10</span>]++;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span> &amp;&amp; cnt[i] != i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextBeautifulNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">for</span>(++n;; ++n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(n)) </span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5908-统计最高分的节点数目"><a href="#5908-统计最高分的节点数目" class="headerlink" title="5908. 统计最高分的节点数目"></a>5908. 统计最高分的节点数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一棵根节点为 <code>0</code> 的 二叉树 ，它总共有 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个下标从 <code>0</code> 开始的整数数组 <code>parents</code> 表示这棵树，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 0 是根，所以 <code>parents[0] == -1</code> 。</p><p>一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。</p><p>请你返回有 最高得分 节点的 数目 。</p><p>示例 1:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">- 节点 <span class="number">0</span> 的分数为：<span class="number">3</span> * <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">- 节点 <span class="number">1</span> 的分数为：<span class="number">4</span> = <span class="number">4</span></span><br><span class="line">- 节点 <span class="number">2</span> 的分数为：<span class="number">1</span> * <span class="number">1</span> * <span class="number">2</span> = <span class="number">2</span></span><br><span class="line">- 节点 <span class="number">3</span> 的分数为：<span class="number">4</span> = <span class="number">4</span></span><br><span class="line">- 节点 <span class="number">4</span> 的分数为：<span class="number">4</span> = <span class="number">4</span></span><br><span class="line">最高得分为 <span class="number">4</span> ，有三个节点得分为 <span class="number">4</span> （分别是节点 <span class="number">1</span>，<span class="number">3</span> 和 <span class="number">4</span> ）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 节点 <span class="number">0</span> 的分数为：<span class="number">2</span> = <span class="number">2</span></span><br><span class="line">- 节点 <span class="number">1</span> 的分数为：<span class="number">2</span> = <span class="number">2</span></span><br><span class="line">- 节点 <span class="number">2</span> 的分数为：<span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">最高分数为 <span class="number">2</span> ，有两个节点分数为 <span class="number">2</span> （分别为节点 <span class="number">0</span> 和 <span class="number">1</span> ）。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == parents.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>parents[0] == -1</code></li><li>对于 <code>i != 0</code> ，有 <code>0 &lt;= parents[i] &lt;= n - 1</code></li><li><code>parents</code> 表示一棵二叉树。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-264/problems/count-nodes-with-the-highest-score/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-264/problems/count-nodes-with-the-highest-score/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的 $DFS$, 我们利用 $DFS$ 求出每个节点的子树所含有的节点的个数．我们在设节点的总数为 $n$, 设以节点 $i$ 为子数的节点数目为 $tree(i)$,则每个节点 $i$ 的分计算公式为: <script type="math/tex; mode=display">score(i) = (n-tree(i)) \times tree(left(i)) \times tree(right(i))</script></li><li>计算出每个节点的分数,然后找到最大值的个数即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$,其中 $N$ 为节点的个数，我们只需要遍历一遍二叉树即可 .</li><li>空间复杂度为 $O(2N)$,其中 $N$ 为节点的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; graph,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr)</span> </span>&#123;</span><br><span class="line">        arr[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[root])&#123;</span><br><span class="line">            dfs(v,graph,arr);</span><br><span class="line">            arr[root] += arr[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[root];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countHighestScoreNodes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = parents.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            graph[parents[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>,graph,arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(parents[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                curr *= (n - arr[i]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[i])&#123;</span><br><span class="line">                curr *= arr[v];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[curr]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt.rbegin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5909-并行课程-III"><a href="#5909-并行课程-III" class="headerlink" title="5909. 并行课程 III"></a>5909. 并行课程 III</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 节课，课程编号从 <code>1</code> 到 <code>n</code> 。同时给你一个二维整数数组 <code>relations</code> ，其中 <code>relations[j] = [prevCoursej, nextCoursej]</code> ，表示课程 <code>prevCoursej</code>必须在课程 <code>nextCoursej</code> 之前 完成（先修课的关系）。同时给你一个下标从 <code>0</code> 开始的整数数组 <code>time</code> ，其中 <code>time[i]</code> 表示完成第 <code>(i+1)</code> 门课程需要花费的月份数。</p><p>请你根据以下规则算出完成所有课程所需要的 最少 月份数：</p><ul><li>如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。</li><li>你可以 同时 上 任意门课程 。</li><li>请你返回完成所有课程所需要的 最少 月份数。<br>注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。</li></ul><p>示例 1:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, relations = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]], time = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 <span class="number">0</span> 同时开始课程 <span class="number">1</span> 和 <span class="number">2</span> 。</span><br><span class="line">课程 <span class="number">1</span> 花费 <span class="number">3</span> 个月，课程 <span class="number">2</span> 花费 <span class="number">2</span> 个月。</span><br><span class="line">所以，最早开始课程 <span class="number">3</span> 的时间是月份 <span class="number">3</span> ，完成所有课程所需时间为 <span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span> 个月。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, relations = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]], time = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 <span class="number">0</span> 同时开始课程 <span class="number">1</span> ，<span class="number">2</span> 和 <span class="number">3</span> 。</span><br><span class="line">在月份 <span class="number">1</span>，<span class="number">2</span> 和 <span class="number">3</span> 分别完成这三门课程。</span><br><span class="line">课程 <span class="number">4</span> 需在课程 <span class="number">3</span> 之后开始，也就是 <span class="number">3</span> 个月后。课程 <span class="number">4</span> 在 <span class="number">3</span> + <span class="number">4</span> = <span class="number">7</span> 月完成。</span><br><span class="line">课程 <span class="number">5</span> 需在课程 <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span> 和 <span class="number">4</span> 之后开始，也就是在 max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>) = <span class="number">7</span> 月开始。</span><br><span class="line">所以完成所有课程所需的最少时间为 <span class="number">7</span> + <span class="number">5</span> = <span class="number">12</span> 个月。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 104)</code></li><li><code>relations[j].length == 2</code></li><li><code>1 &lt;= prevCoursej, nextCoursej &lt;= n</code></li><li><code>prevCoursej != nextCoursej</code></li><li>所有的先修课程对 <code>[prevCoursej, nextCoursej]</code> 都是 互不相同 的。</li><li><code>time.length == n</code></li><li><code>1 &lt;= time[i] &lt;= 104</code></li><li>先修课程图是一个有向无环图。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination" target="_blank" rel="noopener">https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP + 拓扑排序</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目感觉只能算是中等难度题目了,非常经典的模板题. 首先我们知道课程的先后顺序,肯定需要用到拓扑排序才能解决该问题,我们设 $dp[i]$ 表示完成该课程所需要的最少月份，则我们知道对于以来关系为 $[i,j]$ 的课程来说,即课程 $j$ 需要依赖课程 $i$ 的完成,则我们知道递推关系为: <script type="math/tex">dp[j] = max(dp[j],dp[i] + time[j])</script>，我们知道题目中一定存在拓扑关系，我们按照拓扑关系的要求，依次求出每个课程完成所需要的最少月份即可．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(V + E)$, 其中 $V$ 为课程的个数, $E$ 为课程的依赖关系个数,因为我们只需要要一次拓扑排序即可.</li><li>空间复杂度分析: $O(V)$,其中 $V$ 为课程的个数.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>暴力解法,超时<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relations, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : relations) &#123;</span><br><span class="line">            v[<span class="number">0</span>]--;</span><br><span class="line">            v[<span class="number">1</span>]--;</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = time[i];</span><br><span class="line">                qu.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> neg : graph[curr])&#123;</span><br><span class="line">                indegree[neg]--;</span><br><span class="line">                dp[neg] = max(dp[neg],dp[curr] + time[neg]);</span><br><span class="line">                <span class="keyword">if</span>(indegree[neg] == <span class="number">0</span>)&#123;</span><br><span class="line">                    qu.push(neg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-264&quot;&gt;&lt;a href=&quot;#leetcode-contest-264&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 264&quot;&gt;&lt;/a&gt;leetcode contest 264&lt;/h1&gt;&lt;p&gt;本周的题目出的题目真心不好,质量严重下降,比前几次的题目差不少,缺少太多的思考难点.感觉题目确实放水严重．&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/10/24/YqfN8P2clJCm3Za.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5906-句子中的有效单词数&quot;&gt;&lt;a href=&quot;#5906-句子中的有效单词数&quot; class=&quot;headerlink&quot; title=&quot;5906. 句子中的有效单词数&quot;&gt;&lt;/a&gt;5906. 句子中的有效单词数&lt;/h3&gt;&lt;p&gt;句子仅由小写字母（&lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 到 &lt;code&gt;&amp;#39;z&amp;#39;&lt;/code&gt;）、数字（&lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt; 到 &lt;code&gt;&amp;#39;9&amp;#39;&lt;/code&gt;）、连字符（&lt;code&gt;&amp;#39;-&amp;#39;&lt;/code&gt;）、标点符号（&lt;code&gt;&amp;#39;!&amp;#39;&lt;/code&gt;、&lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;,&amp;#39;&lt;/code&gt;）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 &lt;code&gt;token&lt;/code&gt; ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Kickstart】 Kickstart 2021 Round G</title>
    <link href="http://yoursite.com/2021/10/17/337/"/>
    <id>http://yoursite.com/2021/10/17/337/</id>
    <published>2021-10-17T09:26:12.823Z</published>
    <updated>2021-10-27T14:06:24.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kickstart-2021-round-G"><a href="#kickstart-2021-round-G" class="headerlink" title="kickstart 2021 round G"></a>kickstart 2021 round G</h1><p><code>kickstart</code>的算法果真还是非常的有难度,比力扣的难度大太多了.感觉还是智商不够，现在感觉 $\textit{leetcode}$ 上面只有 $\textit{hard}$ 题目比较感兴趣了，中等难度及以下，感觉基本上就是重复了。感觉每次比赛的第二题和第三题的质量非常高，非常适合新手练习和比赛．</p><a id="more"></a><h3 id="problem-B"><a href="#problem-B" class="headerlink" title="problem B"></a>problem B</h3><p>With online classes in full swing, it is important for Grace to take breaks and keep herself hydrated at all times. She has decided to place a water bottle in her room in the most convenient place. This means that the position of this water bottle should be close to all the places in the room where she generally hangs out like the study desk, bed and coffee table among other places.</p><p>The room is represented in the form of a coordinate plane. The number of steps Grace needs to go from Point A to Point B is equal to the Manhattan distance between the 2 points. This means, Grace can only walk parallel to the axes of the coordinate plane and with each step, she can move one unit in either of the four directions.</p><p>Can you help her find a position in the room to keep the bottle, such that the sum of steps from the bottle to all her favourite furniture pieces will be minimum?</p><p><strong>Notes</strong>:</p><ul><li>All the furniture (like study desk, bed, or coffee table) can be represented as rectangles of non-zero area in the plane with edges parallel to the axes.</li><li>It is possible for furniture pieces to overlap, as she likes to work on her bed-table too.</li><li>Assume that Grace can simply pass through the furniture while walking and does not need to go around them.<br><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow.<br>The first line of each test case contains an integer K which represents the number of objects in Grace’s room.<br>K lines follow, each of them describing one object. The i-th line contains four integers, xi,1, yi,1, xi,2, yi,2, where (xi,1, yi,1) represents coordinates of the bottom left corner and (xi,2, yi,2) represents coordinates of the top right corner of the i-th rectangular object.<br><strong>Output</strong><br>For each test case, output one line containing Case #i: x y, where i is the test case number (starting from 1) and x and y are coordinates of the water bottle such that the sum of steps from these coordinates to all the furniture pieces will be minimum.<br>Note, the bottle can lie on the floor or on top of any furniture but should be placed on integer coordinates only.<br>If multiple solutions exist, output the one with minimum x coordinate, if multiple solutions have the same x coordinate output the one with minimum y coordinate.</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b3a1c" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b3a1c</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  前缀和</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题意大概是说有一堆物体为长方形，散落在二维坐标系中，我们在二维坐标系中找打一个点使得该点到所有物体的曼哈顿距离之和最小．题目难度本身不是特别难，但是感觉有许多值得思考的地方，特别锻炼思维能力．</li><li>题目看似很难,实际上我们将曼哈顿距离分解为横坐标与总坐标,横坐标与纵坐标之间时间上处于独立的关系,因此我们可以分别求出横坐标与纵坐标.点$P=(x,y)$到矩形 $R$ 的曼哈顿距离计算公式为 $d(P,R) = max(x_{1}−x,x−x_{2},0) + max(y_{1}−y,y−y_{2},0)$, 其中矩形的左下端点为$(x_{1}, y_{1})$, 矩形的右上端点为$(x_{2}, y_{2})$.我们将所有的横坐标进行排列，假设分布如下：<br><img src="https://i.loli.net/2021/10/27/5SxOZ7VNnGRX1Dm.png" alt="1"><br>对于给定的 $x$ 我们只需要找到所有右侧小于 $x$ 的矩形数目 $a(x)$, 以及找到所有左侧大于 $x$ 的矩形数目 $b(x)$.我们可以知道它的计算公式为:<script type="math/tex; mode=display">d(x) = (a(x)\times x - \sum_{j=0}^{a(x)}x_j) + (\sum_{i=0}^{b(x)}x_i - b(x)\times x) \qquad (x_j < x < x_i)</script>对于给定的 $y$ 我们只需要找到所上边缘小于 $y$ 的矩形数目 $a(y)$, 以及找到所有下边缘大于 $y$ 的矩形数目 $b(y)$.我们可以知道它的计算公式为:<script type="math/tex; mode=display">d(y) = (a(y)\times y - \sum_{j=0}^{a(y)}y_j) + (\sum_{i=0}^{b(y)}y_i - b(y)\times y) \qquad (y_j < y < y_i)</script></li><li>我们可以找到最小的 $d(x) + d(y)$ 即可.我们可以依次遍历所有的可能的坐标，对于每个一个坐标 $x$ 我们依次求即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N\lg(N))$,其中 $N$ 为所有矩形物品的数目.</li><li>空间复杂度: $O(N)$,其中 $N$ 为所有矩形物品的数目.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; pll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    ll x1,y1,x2,y2;</span><br><span class="line">    ll x,y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; px1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; px2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; py1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; py2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; sumx(k+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; sumy(k+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; arrx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; arry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        px1.push_back(x1);</span><br><span class="line">        px2.push_back(x2);</span><br><span class="line">        arrx.push_back(x1);</span><br><span class="line">        arrx.push_back(x2);</span><br><span class="line">        py1.push_back(y1);</span><br><span class="line">        py2.push_back(y2);</span><br><span class="line">        arry.push_back(y1);</span><br><span class="line">        arry.push_back(y2);</span><br><span class="line">    &#125;</span><br><span class="line">    ll distx = LLONG_MAX;</span><br><span class="line">    ll disty = LLONG_MAX;</span><br><span class="line">    sort(px1.begin(),px1.end());</span><br><span class="line">    sort(px2.begin(),px2.end());</span><br><span class="line">    sort(py1.begin(),py1.end());</span><br><span class="line">    sort(py2.begin(),py2.end());</span><br><span class="line">    sort(arrx.begin(),arrx.end());</span><br><span class="line">    sort(arry.begin(),arry.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        sumx[i] = sumx[i+<span class="number">1</span>] + px1[i];</span><br><span class="line">        sumy[i] = sumy[i+<span class="number">1</span>] + py1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll pre = <span class="number">0</span>;</span><br><span class="line">    ll l1 = <span class="number">0</span>;</span><br><span class="line">    ll l2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrx.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l2 &lt; k &amp;&amp; px2[l2] &lt;= arrx[i])&#123;</span><br><span class="line">            pre += px2[l2];</span><br><span class="line">            l2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; k &amp;&amp; px1[l1] &lt;= arrx[i]) &#123;</span><br><span class="line">            l1++;</span><br><span class="line">        &#125;</span><br><span class="line">        ll curr = l2*arrx[i] - pre + (sumx[l1] - (k-l1)*arrx[i]);</span><br><span class="line">        <span class="keyword">if</span>(curr &lt; distx) &#123;</span><br><span class="line">            distx = curr;</span><br><span class="line">            x = arrx[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = <span class="number">0</span>;</span><br><span class="line">    l2 = <span class="number">0</span>;</span><br><span class="line">    pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arry.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (l2 &lt; k &amp;&amp; py2[l2] &lt;= arry[i]) &#123;</span><br><span class="line">            pre += py2[l2];</span><br><span class="line">            l2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1 &lt; k &amp;&amp; py1[l1] &lt;= arry[i]) &#123;</span><br><span class="line">            l1++;</span><br><span class="line">        &#125;</span><br><span class="line">        ll curr = l2*arry[i] - pre + (sumy[l1] - (k-l1)*arry[i]);</span><br><span class="line">        <span class="keyword">if</span>(curr &lt; disty) &#123;</span><br><span class="line">            disty = curr;</span><br><span class="line">            y = arry[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;y;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="problem-C"><a href="#problem-C" class="headerlink" title="problem C"></a>problem C</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Problem<br>Barbara goes to Alan’s banana farm, where the N banana trees are organized in one long line represented by an array B. The tree at position i has Bi banana bunches. Each tree has the same cost. Once Barbara buys a tree, she gets all the banana bunches on that tree.<br>Alan has a special rule: because he does not want too many gaps in his line, he allows Barbara to buy at most 2 contiguous sections of his banana tree line.</p><p>Barbara wants to buy some number of trees such that the total number of banana bunches on these purchased trees equals the capacity K of her basket. She wants to do this while spending as little money as possible. How many trees should she buy?</p><p><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow.<br>Each test case begins with a line containing two integers integer N, the number of trees on Alan’s farm, and K, the capacity of Barbara’s basket.<br>The next line contains N non-negative integers $B1,B2,…,BN$ representing array B, where the i-th integer represents the number of banana bunches on the i-th tree on Alan’s farm.<br><strong>Output</strong><br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum number of trees Barbara must purchase to obtain K banana bunches using at most 2 contiguous sections of the farm, or -1 if it is impossible to do so.</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b44ef" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b44ef</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目虽然不是很难, 但是感觉出的非常好.题目要求找到最多两个非重复的连续子序列的和等于 $k$ 的最短长度,我们设 $dp[i]$ 表示连续子序列的和等于 $i$ 的最短长度.</li><li>我们每次从 $i$ 开始往后遍历, 找到从 $i$ 到 $n$ 的连续子序列的和等于 $x$ 的最短长度. 我们从 $i$ 往前开始往前遍历,依次遍历每一个截至到 $i$ 的连续子序列的和 $curr$ ,同时我们从 $i+1$ 往后找到 $dp[k-curr]$.<br><img src="https://i.loli.net/2021/10/27/fg5rpOQyvUw3iIc.png" alt><br>我们找到递推公式如下:<script type="math/tex; mode=display">dp[k] = min(dp[k], x + d[k-i])</script></li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n\times k)$ , 其中 $n$ 为数组的长度, $k$ 为目标要求的和.</li><li>空间复杂度分析: 空间复杂度为$O(k)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(k+<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            curr += arr[j];</span><br><span class="line">            <span class="keyword">if</span>(curr &lt;= k) &#123;</span><br><span class="line">                dp[k] = min(dp[k],dp[k-curr]+i+<span class="number">1</span>-j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            curr += arr[j];</span><br><span class="line">            <span class="keyword">if</span>(curr &lt;= k)&#123;</span><br><span class="line">                dp[curr] = min(dp[curr],j+<span class="number">1</span>-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(dp[k] &gt; n ? <span class="number">-1</span> : dp[k])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kickstart-2021-round-G&quot;&gt;&lt;a href=&quot;#kickstart-2021-round-G&quot; class=&quot;headerlink&quot; title=&quot;kickstart 2021 round G&quot;&gt;&lt;/a&gt;kickstart 2021 round G&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kickstart&lt;/code&gt;的算法果真还是非常的有难度,比力扣的难度大太多了.感觉还是智商不够，现在感觉 $\textit{leetcode}$ 上面只有 $\textit{hard}$ 题目比较感兴趣了，中等难度及以下，感觉基本上就是重复了。感觉每次比赛的第二题和第三题的质量非常高，非常适合新手练习和比赛．&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="kickstart" scheme="http://yoursite.com/tags/kickstart/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest  263</title>
    <link href="http://yoursite.com/2021/10/17/336/"/>
    <id>http://yoursite.com/2021/10/17/336/</id>
    <published>2021-10-17T04:47:30.652Z</published>
    <updated>2021-10-24T04:57:47.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-263"><a href="#leetcode-contest-263" class="headerlink" title="leetcode contest 263"></a>leetcode contest 263</h1><p>终于做出了四题,真心是智商不够,勤奋来补.前三题真心比较简单的题目．<br><img src="https://i.loli.net/2021/10/17/EUrTcu1xCHyNWbY.png" alt></p><h3 id="5902-检查句子中的数字是否递增"><a href="#5902-检查句子中的数字是否递增" class="headerlink" title="5902. 检查句子中的数字是否递增"></a>5902. 检查句子中的数字是否递增</h3><p>句子是由若干 <code>token</code> 组成的一个列表，<code>token</code> 间用 单个 空格分隔，句子没有前导或尾随空格。每个 <code>token</code> 要么是一个由数字 <code>0-9</code> 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。</p><a id="more"></a><p>示例，<code>&quot;a puppy has 2 eyes 4 legs&quot;</code> 是一个由 7 个 <code>token</code> 组成的句子：<code>&quot;2&quot;</code> 和 <code>&quot;4&quot;</code> 是数字，其他像 <code>&quot;puppy&quot;</code> 这样的 <code>tokens</code> 属于单词。<br>给你一个表示句子的字符串 <code>s</code>，你需要检查 <code>s</code>中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，<code>s</code> 中的 每个 数字都严格小于它 右侧 的数字）。</p><p>如果满足题目要求，返回 <code>true</code>，否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">example<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"1 box has 3 blue 4 red 6 green and 12 yellow marbles"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：句子中的数字是：<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">12</span> 。</span><br><span class="line">这些数字是按从左到右严格递增的 <span class="number">1</span> &lt; <span class="number">3</span> &lt; <span class="number">4</span> &lt; <span class="number">6</span> &lt; <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"hello world 5 x 5"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：句子中的数字是：<span class="number">5</span>, <span class="number">5</span> 。这些数字不是严格递增的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">example<span class="number">-3</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：s 中的数字是：<span class="number">7</span>, <span class="number">51</span>, <span class="number">50</span>, <span class="number">60</span> 。这些数字不是严格递增的。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"4 5 11 26"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：s 中的数字是：<span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">26</span> 。</span><br><span class="line">这些数字是按从左到右严格递增的：<span class="number">4</span> &lt; <span class="number">5</span> &lt; <span class="number">11</span> &lt; <span class="number">26</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 由小写英文字母、空格和数字 0 到 9 组成（包含 0 和 9）</li><li><code>s</code> 中数字 <code>token</code> 的数目在 <code>2</code> 和 <code>100</code> 之间（包含 2 和 100）</li><li><code>s</code> 中的 <code>token</code> 之间由单个空格分隔</li><li><code>s</code> 中至少有 两个 数字</li><li><code>s</code> 中的每个数字都是一个 小于 <code>100</code> 的 正 数，且不含前导零</li><li><code>s</code> 不含前导或尾随空格</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-263/problems/check-if-numbers-are-ascending-in-a-sentence/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-263/problems/check-if-numbers-are-ascending-in-a-sentence/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  字符串</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们取出字符串中的所有数字即可,然后判断数组是否严格递增。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串的长度,我们此时需要遍历一遍即可。</li><li>空间复杂度: $O(N)$,其中 $N$ 为字符串的长度.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areNumbersAscending</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pos &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; s.size() &amp;&amp; !(s[pos] &gt;= <span class="string">'0'</span> &amp;&amp; s[pos] &lt;= <span class="string">'9'</span>))&#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pos &lt; s.size())&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos &lt; s.size() &amp;&amp; s[pos] &gt;= <span class="string">'0'</span> &amp;&amp; s[pos] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                    curr = curr*<span class="number">10</span> + s[pos] - <span class="string">'0'</span>;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">                arr.push_back(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= arr[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5903-简易银行系统"><a href="#5903-简易银行系统" class="headerlink" title="5903. 简易银行系统"></a>5903. 简易银行系统</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 <code>n</code>个账户，编号从 <code>1</code>到 <code>n</code> 。每个账号的初始余额存储在一个下标从 <code>0</code>开始的整数数组 <code>balance</code> 中，其中第 <code>(i + 1)</code>个账户的初始余额是 <code>balance[i]</code> 。</p><p>请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：</p><ul><li>指定的账户数量在 <code>1</code> 和 <code>n</code> 之间，且</li><li>取款或者转账需要的钱的总数 小于或者等于 账户余额。<br>实现<code>Bank</code> 类：</li><li><code>Bank(long[] balance)</code> 使用下标从 0 开始的整数数组 <code>balance</code> 初始化该对象。</li><li><code>boolean transfer(int account1, int account2, long money)</code> 从编号为 account1 的账户向编号为 account2 的账户转帐 money 美元。如果交易成功，返回 true ，否则，返回 false 。</li><li><code>boolean deposit(int account, long money)</code> 向编号为 <code>account</code> 的账户存款 money 美元。如果交易成功，返回 true ；否则，返回 <code>false</code> 。</li><li><code>boolean withdraw(int account, long money)</code> 从编号为 <code>account</code> 的账户取款 money 美元。如果交易成功，返回 true ；否则，返回 false 。</li></ul><p>示例：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"Bank"</span>, <span class="string">"withdraw"</span>, <span class="string">"transfer"</span>, <span class="string">"deposit"</span>, <span class="string">"transfer"</span>, <span class="string">"withdraw"</span>]</span><br><span class="line">[[[<span class="number">10</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">30</span>]], [<span class="number">3</span>, <span class="number">10</span>], [<span class="number">5</span>, <span class="number">1</span>, <span class="number">20</span>], [<span class="number">5</span>, <span class="number">20</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">15</span>], [<span class="number">10</span>, <span class="number">50</span>]]</span><br><span class="line">输出：</span><br><span class="line">[<span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Bank bank = new Bank([<span class="number">10</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">30</span>]);</span><br><span class="line">bank.withdraw(<span class="number">3</span>, <span class="number">10</span>);    <span class="comment">// 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。</span></span><br><span class="line">                         <span class="comment">// 账户 3 余额为 $20 - $10 = $10 。</span></span><br><span class="line">bank.transfer(<span class="number">5</span>, <span class="number">1</span>, <span class="number">20</span>); <span class="comment">// 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。</span></span><br><span class="line">                         <span class="comment">// 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。</span></span><br><span class="line">bank.deposit(<span class="number">5</span>, <span class="number">20</span>);     <span class="comment">// 返回 true ，可以向账户 5 存款 $20 。</span></span><br><span class="line">                         <span class="comment">// 账户 5 的余额为 $10 + $20 = $30 。</span></span><br><span class="line">bank.transfer(<span class="number">3</span>, <span class="number">4</span>, <span class="number">15</span>); <span class="comment">// 返回 false ，账户 3 的当前余额是 $10 。</span></span><br><span class="line">                         <span class="comment">// 所以无法转账 $15 。</span></span><br><span class="line">bank.withdraw(<span class="number">10</span>, <span class="number">50</span>);   <span class="comment">// 返回 false ，交易无效，因为账户 10 并不存在。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == balance.length</code></li><li><code>1 &lt;= n, account, account1, account2 &lt;= 105</code></li><li><code>0 &lt;= balance[i], money &lt;= 1012</code></li><li><code>transfer</code>, <code>deposit</code>, <code>withdraw</code> 三个函数，每个 最多调用 104 次</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/simple-bank-system" target="_blank" rel="noopener">https://leetcode-cn.com/problems/simple-bank-system</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简答,用数组记录记录相同当前拥有的钱的值即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(1)$.</li><li>空间复杂度分析: 空间复杂度为$O(n)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bank(<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; balance) &#123;</span><br><span class="line">        arr = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> account1, <span class="keyword">int</span> account2, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        account1--;</span><br><span class="line">        account2--;</span><br><span class="line">        <span class="keyword">if</span>(account1 &gt;= arr.size()||account2 &gt;= arr.size()) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[account1] &lt; money)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[account1] -= money;</span><br><span class="line">        arr[account2] += money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        account--;</span><br><span class="line">        <span class="keyword">if</span>(account &gt;= arr.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        arr[account] += money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        account--;</span><br><span class="line">        <span class="keyword">if</span>(account &gt;= arr.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[account] &lt; money)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        arr[account] -= money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Bank object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Bank* obj = new Bank(balance);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;transfer(account1,account2,money);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;deposit(account,money);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;withdraw(account,money);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5904-统计按位或能得到最大值的子集数目"><a href="#5904-统计按位或能得到最大值的子集数目" class="headerlink" title="5904. 统计按位或能得到最大值的子集数目"></a>5904. 统计按位或能得到最大值的子集数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。</p><p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 a 是数组 <code>b</code> 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。</p><p>对数组 <code>a</code> 执行 按位或 ，结果等于 <code>a[0] OR a[1] OR ... OR a[a.length - 1]</code>（下标从 0 开始）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子集按位或能得到的最大值是 <span class="number">3</span> 。有 <span class="number">2</span> 个子集按位或可以得到 <span class="number">3</span> ：</span><br><span class="line">- [<span class="number">3</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 的所有非空子集的按位或都可以得到 <span class="number">2</span> 。总共有 <span class="number">23</span> - <span class="number">1</span> = <span class="number">7</span> 个子集。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：子集按位或可能的最大值是 <span class="number">7</span> 。有 <span class="number">6</span> 个子集按位或可以得到 <span class="number">7</span> ：</span><br><span class="line">- [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 16</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题 + 状态子集</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们需要找到或的最大值，此时我们只需要将数组中所有元素进行或运算，即可得到最大元素 $maxV$．</li><li>其次我们遍历该数组的所有子集,对所有子集的元素进行或运算,检测子集元素或运算后的结果是否与 $maxV$ 相等.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(2^N + N)$,其中 $N$ 为数组的长度 .</li><li>空间复杂度为 $O(1)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMaxOrSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            maxnum |= v;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr |= nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == maxnum)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5905-到达目的地的第二短时间"><a href="#5905-到达目的地的第二短时间" class="headerlink" title="5905. 到达目的地的第二短时间"></a>5905. 到达目的地的第二短时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>城市用一个 双向连通 图表示，图中有 <code>n</code> 个节点，从 1 到 <code>n</code> 编号（包含 1 和 <code>n</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中每个 <code>edges[i] = [ui, vi]</code> 表示一条节点 <code>ui</code> 和节点 <code>vi</code> 之间的双向连通边。每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 <code>time</code> 分钟。</p><p>每个节点都有一个交通信号灯，每 <code>change</code> 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。如果信号灯是  绿色 ，你 不能 在节点等待，必须离开。</p><p>第二小的值 是 严格大于 最小值的所有值中最小的值。</p><p>例如，<code>[2, 3, 4]</code> 中第二小的值是 <code>3</code> ，而 <code>[2, 2, 4]</code> 中第二小的值是 4 。<br>给你 <code>n、edges、time</code> 和 <code>change</code> ，返回从节点 1 到节点 n 需要的 第二短时间 。</p><p>注意：</p><ul><li>你可以 任意次 穿过任意顶点，包括<code>1</code>和 <code>n</code> 。</li><li>你可以假设在 启程时 ，所有信号灯刚刚变成 绿色 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]], time = <span class="number">3</span>, change = <span class="number">5</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：</span><br><span class="line">上面的左图展现了给出的城市交通图。</span><br><span class="line">右图中的蓝色路径是最短时间路径。</span><br><span class="line">花费的时间是：</span><br><span class="line">- 从节点 <span class="number">1</span> 开始，总花费时间=<span class="number">0</span></span><br><span class="line">- <span class="number">1</span> -&gt; <span class="number">4</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">3</span></span><br><span class="line">- <span class="number">4</span> -&gt; <span class="number">5</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">6</span></span><br><span class="line">因此需要的最小时间是 <span class="number">6</span> 分钟。</span><br><span class="line"></span><br><span class="line">右图中的红色路径是第二短时间路径。</span><br><span class="line">- 从节点 <span class="number">1</span> 开始，总花费时间=<span class="number">0</span></span><br><span class="line">- <span class="number">1</span> -&gt; <span class="number">3</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">3</span></span><br><span class="line">- <span class="number">3</span> -&gt; <span class="number">4</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">6</span></span><br><span class="line">- 在节点 <span class="number">4</span> 等待 <span class="number">4</span> 分钟，总花费时间=<span class="number">10</span></span><br><span class="line">- <span class="number">4</span> -&gt; <span class="number">5</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">13</span></span><br><span class="line">因此第二短时间是 <span class="number">13</span> 分钟。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>]], time = <span class="number">3</span>, change = <span class="number">2</span></span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：</span><br><span class="line">最短时间路径是 <span class="number">1</span> -&gt; <span class="number">2</span> ，总花费时间 = <span class="number">3</span> 分钟</span><br><span class="line">最短时间路径是 <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> ，总花费时间 = <span class="number">11</span> 分钟</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 104</code></li><li><code>n - 1 &lt;= edges.length &lt;= min(2 * 104, n * (n - 1) / 2)</code></li><li><code>edges[i].length == 2</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li>不含重复边</li><li>每个节点都可以从其他节点直接或者间接到达</li><li><code>1 &lt;= time, change &lt;= 103</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination" target="_blank" rel="noopener">https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra求最短路径</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们来分析如何求从节点 $1$ 到节点 $n$ 的花费的最小时间,这个实际上我们利用 <code>dijistra</code>求最短距离即可,　难点在已知达到当前节点 $i$ 的时间为 $t_{i}$,我们需要需要计算到底相邻节点的 $j$ 的时间为多少,分为以下两种情形:</li></ol><ul><li>达到当前节点如果刚好处于绿灯时,则我们到达节点 $j$ 的时间为 $t_{j} = t_{i} + time$. 此时我们只需要判断当前时间$t_{i} + change - 1$ 除以 $change$ 之后的轮次为奇数. </li><li>达到当前节点如果刚好处于红灯时,首先我们需要等待红灯变为绿灯,等待的时间计算公式为 $wait = change - t_{i} \% change$,则我们到达节点 $j$ 的时间为 $t_{j} = t_{i} + change - t_{i} \% change + time$. 此时我们只需要判断当前时间$t_{i} + change - 1$ 除以 $change$ 之后的轮次为偶数. </li></ul><ol><li>我们通过一的分析可以看出,如果求出花费的最短时间,还是非常容易的,但是题目中要求求出花费的第二少的,则此时我们只需要记录每个访问每个节点花费最少的两个时间值,而我们这样计算的过程中肯定可以得到到达节点 $n$ 的花费时间时间第二小的值.我们对于每个节点的花费时间更新如下,我们设 $dp[i][0],dp[i][1]$ 表示到达节点 $i$ 的最小和第二小的花费的时间,则我们每次更新规则如下: </li></ol><ul><li>如果当前计算的时间$t_{i}$小于到节点 $i$ 的最小时间 $dp[i][0]$,即$t_{i} &lt; dp[i][0]$,则我们将 $dp[i][0] = t_{i},dp[i][1] = dp[i][0]$.</li><li>如果当前计算的时间$t_{i}$大于到节点 $i$ 的最小时间 $dp[i][0]$且小于到节点 $i$ 的第二小的时间 $dp[i][1]$,即此时满足 $dp[i][0] &lt; t_{i} &lt; dp[i][1]$,则我们将 $dp[i][1] = t_{i}$.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(2*N + M)$, 其中 $N$ 为节点的个数, $M$ 为边的个数.</li><li>空间复杂度分析: $O(N)$,其中 $N$ 为节点的个数.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>暴力解法,超时<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondMinimum</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> time, <span class="keyword">int</span> change)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,INF));</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            v[<span class="number">0</span>]--;</span><br><span class="line">            v[<span class="number">1</span>]--;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        pq.push(make_pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            pii curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr.second == n<span class="number">-1</span>)&#123;</span><br><span class="line">                ans.insert(curr.first);</span><br><span class="line">                <span class="keyword">if</span>(ans.size() &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.second])&#123;</span><br><span class="line">                <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>((curr.first/change)%<span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">// current round is green</span></span><br><span class="line">                    cost = curr.first + time;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//current round is red</span></span><br><span class="line">                    cost = curr.first + time + (change - curr.first%change);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cost &lt; dp[v][<span class="number">0</span>])&#123;</span><br><span class="line">                    swap(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]);</span><br><span class="line">                    dp[v][<span class="number">0</span>] = cost;</span><br><span class="line">                    pq.push(make_pair(cost,v));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[v][<span class="number">0</span>] &lt; cost &amp;&amp; cost &lt; dp[v][<span class="number">1</span>] )&#123;</span><br><span class="line">                    dp[v][<span class="number">1</span>] = cost;</span><br><span class="line">                    pq.push(make_pair(cost,v));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *ans.rbegin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://https://mike-box.github.io/" target="_blank" rel="noopener">http://https://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-263&quot;&gt;&lt;a href=&quot;#leetcode-contest-263&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 263&quot;&gt;&lt;/a&gt;leetcode contest 263&lt;/h1&gt;&lt;p&gt;终于做出了四题,真心是智商不够,勤奋来补.前三题真心比较简单的题目．&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/10/17/EUrTcu1xCHyNWbY.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5902-检查句子中的数字是否递增&quot;&gt;&lt;a href=&quot;#5902-检查句子中的数字是否递增&quot; class=&quot;headerlink&quot; title=&quot;5902. 检查句子中的数字是否递增&quot;&gt;&lt;/a&gt;5902. 检查句子中的数字是否递增&lt;/h3&gt;&lt;p&gt;句子是由若干 &lt;code&gt;token&lt;/code&gt; 组成的一个列表，&lt;code&gt;token&lt;/code&gt; 间用 单个 空格分隔，句子没有前导或尾随空格。每个 &lt;code&gt;token&lt;/code&gt; 要么是一个由数字 &lt;code&gt;0-9&lt;/code&gt; 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest Biweekly 63</title>
    <link href="http://yoursite.com/2021/10/17/335/"/>
    <id>http://yoursite.com/2021/10/17/335/</id>
    <published>2021-10-16T16:15:37.295Z</published>
    <updated>2021-10-17T09:07:45.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-63"><a href="#leetcode-biweekly-63" class="headerlink" title="leetcode biweekly 63"></a>leetcode biweekly 63</h1><p>还是继续三道题的节奏。最后一题一开始的方法都弄错了,真心是智商不够.前三题确实太简单了.</p><h3 id="5885-使每位学生都有座位的最少移动次数"><a href="#5885-使每位学生都有座位的最少移动次数" class="headerlink" title="5885. 使每位学生都有座位的最少移动次数"></a>5885. 使每位学生都有座位的最少移动次数</h3><p>一个房间里有 <code>n</code>个座位和 n 名学生，房间用一个数轴表示。给你一个长度为 n 的数组 seats ，其中 <code>seats[i]</code> 是第 i 个座位的位置。同时给你一个长度为 n 的数组 <code>students</code> ，其中<code>students[j]</code> 是第 <code>j</code> 位学生的位置。</p><a id="more"></a><p>你可以执行以下操作任意次：</p><p>增加或者减少第<code>i</code>位学生的位置，每次变化量为 <code>1</code> （也就是将第 <code>i</code> 位学生从位置 <code>x</code> 移动到 <code>x + 1</code> 或者 <code>x - 1</code>）<br>请你返回使所有学生都有座位坐的 最少移动次数 ，并确保没有两位学生的座位相同。</p><p>请注意，初始时有可能有多个座位或者多位学生在 同一 位置。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：seats = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>], students = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：学生移动方式如下：</span><br><span class="line">- 第一位学生从位置 <span class="number">2</span> 移动到位置 <span class="number">1</span> ，移动 <span class="number">1</span> 次。</span><br><span class="line">- 第二位学生从位置 <span class="number">7</span> 移动到位置 <span class="number">5</span> ，移动 <span class="number">2</span> 次。</span><br><span class="line">- 第三位学生从位置 <span class="number">4</span> 移动到位置 <span class="number">3</span> ，移动 <span class="number">1</span> 次。</span><br><span class="line">总共 <span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">4</span> 次移动。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：seats = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>], students = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：学生移动方式如下：</span><br><span class="line">- 第一位学生不移动。</span><br><span class="line">- 第二位学生从位置 <span class="number">3</span> 移动到位置 <span class="number">4</span> ，移动 <span class="number">1</span> 次。</span><br><span class="line">- 第三位学生从位置 <span class="number">2</span> 移动到位置 <span class="number">5</span> ，移动 <span class="number">3</span> 次。</span><br><span class="line">- 第四位学生从位置 <span class="number">6</span> 移动到位置 <span class="number">9</span> ，移动 <span class="number">3</span> 次。</span><br><span class="line">总共 <span class="number">0</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">3</span> = <span class="number">7</span> 次移动。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">输入：seats = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>], students = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：学生移动方式如下：</span><br><span class="line">- 第一位学生从位置 <span class="number">1</span> 移动到位置 <span class="number">2</span> ，移动 <span class="number">1</span> 次。</span><br><span class="line">- 第二位学生从位置 <span class="number">3</span> 移动到位置 <span class="number">6</span> ，移动 <span class="number">3</span> 次。</span><br><span class="line">- 第三位学生不移动。</span><br><span class="line">- 第四位学生不移动。</span><br><span class="line">总共 <span class="number">1</span> + <span class="number">3</span> + <span class="number">0</span> + <span class="number">0</span> = <span class="number">4</span> 次移动。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">+ `n == seats.length == students.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= seats[i], students[j] &lt;= <span class="number">100</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/minimum-number-of-moves-to-seat-everyone/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   排序</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 最小交换次数一定是按照编号的大小与位置的大小是一一对应的，可以用反证法来证明。</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度: $O(N \lg N)$,其中 $N$ 为数组的长度,我们此时需要遍历两边即可。</span><br><span class="line">+ 空间复杂度: $O(<span class="number">1</span>)$.</span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minMovesToSeat(vector&lt;<span class="built_in">int</span>&gt;&amp; seats, vector&lt;<span class="built_in">int</span>&gt;&amp; students) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = seats.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(seats.begin(),seats.end());</span><br><span class="line">        sort(students.begin(),students.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += abs(students[i] - seats[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5886-如果相邻两个颜色均相同则删除当前颜色"><a href="#5886-如果相邻两个颜色均相同则删除当前颜色" class="headerlink" title="5886. 如果相邻两个颜色均相同则删除当前颜色"></a>5886. 如果相邻两个颜色均相同则删除当前颜色</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>总共有 <code>n</code> 个颜色片段排成一列，每个颜色片段要么是 <code>&#39;A&#39;</code> 要么是 <code>&#39;B&#39;</code>。给你一个长度为 <code>n</code> 的字符串 <code>colors</code>，其中 <code>colors[i]</code> 表示第 <code>i</code> 个颜色片段的颜色。</p><p><code>Alice</code> 和 <code>Bob</code> 在玩一个游戏，他们 轮流 从这个字符串中删除颜色。<code>Alice</code> 先手 。</p><p>如果一个颜色片段为 ‘A’ 且 相邻两个颜色 都是颜色 ‘A’ ，那么 <code>Alice</code> 可以删除该颜色片段。Alice 不可以 删除任何颜色 ‘B’ 片段。<br>如果一个颜色片段为 ‘B’ 且 相邻两个颜色 都是颜色 ‘B’ ，那么 <code>Bob</code> 可以删除该颜色片段。<code>Bob</code> 不可以 删除任何颜色 ‘A’ 片段。<br><code>Alice</code> 和 <code>Bob</code> 不能 从字符串两端删除颜色片段。<br>如果其中一人无法继续操作，则该玩家 输 掉游戏且另一玩家 获胜 。<br>假设 <code>Alice</code> 和 <code>Bob</code> 都采用最优策略，如果 <code>Alice</code> 获胜，请返回 <code>true</code>，否则 <code>Bob</code> 获胜，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = <span class="string">"AAABABB"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">AAABABB -&gt; AABABB</span><br><span class="line">Alice 先操作。</span><br><span class="line">她删除从左数第二个 <span class="string">'A'</span> ，这也是唯一一个相邻颜色片段都是 <span class="string">'A'</span> 的 <span class="string">'A'</span> 。</span><br><span class="line"></span><br><span class="line">现在轮到 Bob 操作。</span><br><span class="line">Bob 无法执行任何操作，因为没有相邻位置都是 <span class="string">'B'</span> 的颜色片段 <span class="string">'B'</span> 。</span><br><span class="line">因此，Alice 获胜，返回 <span class="keyword">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = <span class="string">"AA"</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">Alice 先操作。</span><br><span class="line">只有 <span class="number">2</span> 个 <span class="string">'A'</span> 且它们都在字符串的两端，所以她无法执行任何操作。</span><br><span class="line">因此，Bob 获胜，返回 <span class="keyword">false</span> 。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：colors = <span class="string">"ABBBBBBBAAA"</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">ABBBBBBBAAA -&gt; ABBBBBBBAA</span><br><span class="line">Alice 先操作。</span><br><span class="line">她唯一的选择是删除从右数起第二个 <span class="string">'A'</span> 。</span><br><span class="line"></span><br><span class="line">ABBBBBBBAA -&gt; ABBBBBBAA</span><br><span class="line">接下来轮到 Bob 操作。</span><br><span class="line">他有许多选择，他可以选择任何一个 <span class="string">'B'</span> 删除。</span><br><span class="line"></span><br><span class="line">然后轮到 Alice 操作，她无法删除任何片段。</span><br><span class="line">所以 Bob 获胜，返回 <span class="keyword">false</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= colors.length &lt;= 105</code></li><li><code>colors</code> 只包含字母 <code>&#39;A&#39;</code> 和 <code>&#39;B&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数组</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简答,我们只需要求出字符串中<code>&quot;AAA&quot;</code>与<code>&quot;BBB&quot;</code>的个数即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n)$，需要一次遍历即可.</li><li>空间复杂度分析: 空间复杂度为$O(m*n)$．<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">winnerOfGame</span><span class="params">(<span class="built_in">string</span> colors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = colors.size();</span><br><span class="line">        <span class="keyword">int</span> acnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; colors[pos] == colors[curr]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = pos - curr;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; n &amp;&amp; len &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[curr] == <span class="string">'A'</span>) &#123;</span><br><span class="line">                    acnt += len - <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    bcnt += len - <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             curr = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> acnt &gt; bcnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5888-网络空闲的时刻"><a href="#5888-网络空闲的时刻" class="headerlink" title="5888. 网络空闲的时刻"></a>5888. 网络空闲的时刻</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个有 <code>n</code>个服务器的计算机网络，服务器编号为 <code>0</code> 到 <code>n - 1</code>。同时给你一个二维整数数组 <code>edges</code>，其中 <code>edges[i] = [ui, vi]</code> 表示服务器 <code>ui</code> 和 <code>vi</code> 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 <code>patience</code> 。</p><p>题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p><p>编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。</p><p>在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p><ul><li>如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 <code>patience[i]</code> 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 <code>patience[i]</code> 秒 后 会重发一条信息给主服务器。</li><li>否则，该数据服务器 不会重发 信息。<br>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。</li></ul><p>请返回计算机网络变为 空闲 状态的 最早秒数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]], patience = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">0</span> 秒最开始时，</span><br><span class="line">- 数据服务器 <span class="number">1</span> 给主服务器发出信息（用 <span class="number">1</span>A 表示）。</span><br><span class="line">- 数据服务器 <span class="number">2</span> 给主服务器发出信息（用 <span class="number">2</span>A 表示）。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 秒时，</span><br><span class="line">- 信息 <span class="number">1</span>A 到达主服务器，主服务器立刻处理信息 <span class="number">1</span>A 并发出 <span class="number">1</span>A 的回复信息。</span><br><span class="line">- 数据服务器 <span class="number">1</span> 还没收到任何回复。距离上次发出信息过去了 <span class="number">1</span> 秒（<span class="number">1</span> &lt; patience[<span class="number">1</span>] = <span class="number">2</span>），所以不会重发信息。</span><br><span class="line">- 数据服务器 <span class="number">2</span> 还没收到任何回复。距离上次发出信息过去了 <span class="number">1</span> 秒（<span class="number">1</span> == patience[<span class="number">2</span>] = <span class="number">1</span>），所以它重发一条信息（用 <span class="number">2</span>B 表示）。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 秒时，</span><br><span class="line">- 回复信息 <span class="number">1</span>A 到达服务器 <span class="number">1</span> ，服务器 <span class="number">1</span> 不会再重发信息。</span><br><span class="line">- 信息 <span class="number">2</span>A 到达主服务器，主服务器立刻处理信息 <span class="number">2</span>A 并发出 <span class="number">2</span>A 的回复信息。</span><br><span class="line">- 服务器 <span class="number">2</span> 重发一条信息（用 <span class="number">2</span>C 表示）。</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span> 秒时，</span><br><span class="line">- 回复信息 <span class="number">2</span>A 到达服务器 <span class="number">2</span> ，服务器 <span class="number">2</span> 不会再重发信息。</span><br><span class="line">...</span><br><span class="line"><span class="number">7</span> 秒时，回复信息 <span class="number">2</span>D 到达服务器 <span class="number">2</span> 。</span><br><span class="line"></span><br><span class="line">从第 <span class="number">8</span> 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。</span><br><span class="line">所以第 <span class="number">8</span> 秒是网络变空闲的最早时刻。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]], patience = [<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：数据服务器 <span class="number">1</span> 和 <span class="number">2</span> 第 <span class="number">2</span> 秒初收到回复信息。</span><br><span class="line">从第 <span class="number">3</span> 秒开始，网络变空闲。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == patience.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `patience[<span class="number">0</span>] == <span class="number">0</span>`</span><br><span class="line">+ 对于 `<span class="number">1</span> &lt;= i &lt; n ，满足 <span class="number">1</span> &lt;= patience[i] &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= edges.length &lt;= min(<span class="number">105</span>, n * (n - <span class="number">1</span>) / <span class="number">2</span>)`</span><br><span class="line">+ `edges[i].length == <span class="number">2</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= ui, vi &lt; n`</span><br><span class="line">+ `ui != vi`</span><br><span class="line">+ 不会有重边。</span><br><span class="line">+ 每个服务器都直接或间接与别的服务器相连。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学问题</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 题目很简答,首先我们利用`BFS`求出主服务器到各个服务器的最短距离,本质上我们需要求某个服务器 $i$ 从发出在第一个消息到收到主服务器的回复的时间为 $<span class="number">2</span>*dist[i]$,然后我们可以看到在等地回复消息的这段时间内总共重发了 $\frac&#123;<span class="number">2</span>*dist[i]<span class="number">-1</span>&#125;&#123;patience[i]&#125;$ 次消息,因此我们只需要找到最后一次发送消息后,且该服务器最后一次收到回复的时间的下一秒,网络即变为空闲.我们可以知道最后一次发送消息的时间为 $\frac&#123;<span class="number">2</span>*dist[i]<span class="number">-1</span>&#125;&#123;patience[i]&#125; * patience[i]$,消息发出后等待回复的时间总共为 $<span class="number">2</span>*dist[i] + <span class="number">1</span>$.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度为 $O(N)$, 我们只需要一遍`BFS`即可.</span><br><span class="line">+ 空间复杂度为 $O(N)$,我们需要存储所有的股票的价格.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> networkBecomesIdle(vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="built_in">int</span>&gt;&amp; patience) &#123;</span><br><span class="line">        <span class="built_in">int</span> m = edges.size();</span><br><span class="line">        <span class="built_in">int</span> n = patience.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; graph(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; dist(n,<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;<span class="built_in">int</span>&gt; qu;</span><br><span class="line">        visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        qu.push(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="built_in">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="built_in">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">auto</span> v : graph[curr])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                    dist[v] = step;</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*dist[i] &lt;= patience[i])&#123;</span><br><span class="line">                ans = max(ans,<span class="number">2</span>*dist[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = max(ans,patience[i]*((<span class="number">2</span>*dist[i] - <span class="number">1</span>)/patience[i]) + dist[i]*<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5887-两个有序数组的第-K-小乘积"><a href="#5887-两个有序数组的第-K-小乘积" class="headerlink" title="5887. 两个有序数组的第 K 小乘积"></a>5887. 两个有序数组的第 K 小乘积</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个 从小到大排好序 且下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> 以及一个整数 <code>k</code> ，请你返回第 <code>k</code> （从 <code>1</code> 开始编号）小的 <code>nums1[i] * nums2[j]</code> 的乘积，其中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">5</span>], nums2 = [<span class="number">3</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：第 <span class="number">2</span> 小的乘积计算如下：</span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">0</span>] = <span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span></span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">1</span>] = <span class="number">2</span> * <span class="number">4</span> = <span class="number">8</span></span><br><span class="line">第 <span class="number">2</span> 小的乘积为 <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">0</span>,<span class="number">3</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>], k = <span class="number">6</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：第 <span class="number">6</span> 小的乘积计算如下：</span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">1</span>] = (<span class="number">-4</span>) * <span class="number">4</span> = <span class="number">-16</span></span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">0</span>] = (<span class="number">-4</span>) * <span class="number">2</span> = <span class="number">-8</span></span><br><span class="line">- nums1[<span class="number">1</span>] * nums2[<span class="number">1</span>] = (<span class="number">-2</span>) * <span class="number">4</span> = <span class="number">-8</span></span><br><span class="line">- nums1[<span class="number">1</span>] * nums2[<span class="number">0</span>] = (<span class="number">-2</span>) * <span class="number">2</span> = <span class="number">-4</span></span><br><span class="line">- nums1[<span class="number">2</span>] * nums2[<span class="number">0</span>] = <span class="number">0</span> * <span class="number">2</span> = <span class="number">0</span></span><br><span class="line">- nums1[<span class="number">2</span>] * nums2[<span class="number">1</span>] = <span class="number">0</span> * <span class="number">4</span> = <span class="number">0</span></span><br><span class="line">第 <span class="number">6</span> 小的乘积为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">-3</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-6</span></span><br><span class="line">解释：第 <span class="number">3</span> 小的乘积计算如下：</span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">4</span>] = (<span class="number">-2</span>) * <span class="number">5</span> = <span class="number">-10</span></span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">3</span>] = (<span class="number">-2</span>) * <span class="number">4</span> = <span class="number">-8</span></span><br><span class="line">- nums1[<span class="number">4</span>] * nums2[<span class="number">0</span>] = <span class="number">2</span> * (<span class="number">-3</span>) = <span class="number">-6</span></span><br><span class="line">第 <span class="number">3</span> 小的乘积为 <span class="number">-6</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 5 * 104</code></li><li><code>-105 &lt;= nums1[i], nums2[j] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= nums1.length * nums2.length</code></li><li><code>nums1</code> 和 <code>nums2</code> 都是从小到大排好序的。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本题没有做出来，借鉴别人的解题思路．利用优先级队列,暴力解法,这个时间复杂度肯定会超时.我们只能考虑其他的方法，考虑二分查找．我们可以利用双指针很快的求出两个数组中的元素相乘，小于等给定元素的组合有多少个．</li><li>我们利用二分查找，每次选定一个数 $C$，然后在给定数组中查找小于等于数组的元素$C$的乘法组合个数有多少个.题目最重要的处理是对正负数的处理问题．<br>把两个数列分为正负两个部分，并且把负数的部分全部取相反数并且翻转。我们假设 <code>nums1</code> 数列被分为了 <code>p1</code> 和 <code>n1</code> 数组，<code>nums2</code> 数列被分为了 <code>p2</code> 和 <code>n2</code> 数组，随后我们统计答案的方式改为：</li></ol><ul><li><code>p1</code> 和 <code>n1</code> 的乘积中小于 $x$ 的个数</li><li><code>p2</code> 和 <code>n2</code> 的乘积中小于 $x$ 的个数</li><li><code>p1</code> 和 <code>n2</code> 的乘积中大于 $-x$ 的个数</li><li><code>p2</code> 和 <code>n1</code> 的乘积中大于 $-x$ 的个数</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(n*\log C)$, 利用二分查找.</li><li>空间复杂度分析: $O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li><li>暴力解法,超时<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">long</span> <span class="keyword">long</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a, <span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kthSmallestProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; visit;</span><br><span class="line">        </span><br><span class="line">        visit.insert(make_pair(m<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">        visit.insert(make_pair(<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">        pq.push(Node(m<span class="number">-1</span>,<span class="number">0</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[m<span class="number">-1</span>]*nums2[<span class="number">0</span>]));</span><br><span class="line">        pq.push(Node(<span class="number">0</span>,n<span class="number">-1</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[<span class="number">0</span>]*nums2[n<span class="number">-1</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m &gt; <span class="number">1</span> &amp;&amp; n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            visit.insert(make_pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">            pq.push(Node(<span class="number">0</span>,<span class="number">0</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[<span class="number">0</span>]*nums2[<span class="number">0</span>]));</span><br><span class="line">            visit.insert(make_pair(m<span class="number">-1</span>,n<span class="number">-1</span>));</span><br><span class="line">            pq.push(Node(m<span class="number">-1</span>,n<span class="number">-1</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[m<span class="number">-1</span>]*nums2[n<span class="number">-1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            k--;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr.val;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr.x &lt; m<span class="number">-1</span> &amp;&amp; !visit.count(make_pair(curr.x+<span class="number">1</span>,curr.y)))&#123;</span><br><span class="line">                visit.insert(make_pair(curr.x+<span class="number">1</span>,curr.y));</span><br><span class="line">                pq.push(Node(curr.x+<span class="number">1</span>,curr.y,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[curr.x+<span class="number">1</span>]*nums2[curr.y]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.y &lt; n<span class="number">-1</span> &amp;&amp; !visit.count(make_pair(curr.x,curr.y+<span class="number">1</span>)))&#123;</span><br><span class="line">                visit.insert(make_pair(curr.x,curr.y+<span class="number">1</span>));</span><br><span class="line">                pq.push(Node(curr.x,curr.y+<span class="number">1</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[curr.x]*nums2[curr.y+<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.x &gt; <span class="number">0</span> &amp;&amp; !visit.count(make_pair(curr.x<span class="number">-1</span>,curr.y)))&#123;</span><br><span class="line">                visit.insert(make_pair(curr.x<span class="number">-1</span>,curr.y));</span><br><span class="line">                pq.push(Node(curr.x<span class="number">-1</span>,curr.y,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[curr.x<span class="number">-1</span>]*nums2[curr.y]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.y &gt; <span class="number">0</span> &amp;&amp; !visit.count(make_pair(curr.x,curr.y<span class="number">-1</span>)))&#123;</span><br><span class="line">                visit.insert(make_pair(curr.x,curr.y<span class="number">-1</span>));</span><br><span class="line">                pq.push(Node(curr.x,curr.y<span class="number">-1</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[curr.x]*nums2[curr.y<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)nums1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="number">0</span> &amp;&amp; <span class="number">1l</span>l * nums2[p<span class="number">-1</span>] * nums1[i] &gt;= m)</span><br><span class="line">                -- p;</span><br><span class="line">            cnt += p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)nums1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="number">0</span> &amp;&amp; <span class="number">1l</span>l * nums2[p<span class="number">-1</span>] * nums1[i] &gt; m)</span><br><span class="line">                -- p;</span><br><span class="line">            cnt += nums2.size() - p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kthSmallestProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">0</span>), b(<span class="number">0</span>), c(<span class="number">0</span>), d(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums1)</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span>)   a.push_back(-x);</span><br><span class="line">            <span class="keyword">else</span>    b.push_back(x);</span><br><span class="line">        reverse(a.begin(), a.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums2)</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span>)   c.push_back(-x);</span><br><span class="line">            <span class="keyword">else</span>    d.push_back(x);</span><br><span class="line">        reverse(c.begin(), c.end());</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">-1e18</span>, r = <span class="number">1e18</span>, m;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r - <span class="number">1</span>)&#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">            cnt += get(b, d, m);</span><br><span class="line">            cnt += get(a, c, m);</span><br><span class="line">            cnt += get2(a, d, -m);</span><br><span class="line">            cnt += get2(c, b, -m);</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= k)</span><br><span class="line">                r = m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-63&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-63&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly 63&quot;&gt;&lt;/a&gt;leetcode biweekly 63&lt;/h1&gt;&lt;p&gt;还是继续三道题的节奏。最后一题一开始的方法都弄错了,真心是智商不够.前三题确实太简单了.&lt;/p&gt;&lt;h3 id=&quot;5885-使每位学生都有座位的最少移动次数&quot;&gt;&lt;a href=&quot;#5885-使每位学生都有座位的最少移动次数&quot; class=&quot;headerlink&quot; title=&quot;5885. 使每位学生都有座位的最少移动次数&quot;&gt;&lt;/a&gt;5885. 使每位学生都有座位的最少移动次数&lt;/h3&gt;&lt;p&gt;一个房间里有 &lt;code&gt;n&lt;/code&gt;个座位和 n 名学生，房间用一个数轴表示。给你一个长度为 n 的数组 seats ，其中 &lt;code&gt;seats[i]&lt;/code&gt; 是第 i 个座位的位置。同时给你一个长度为 n 的数组 &lt;code&gt;students&lt;/code&gt; ，其中&lt;code&gt;students[j]&lt;/code&gt; 是第 &lt;code&gt;j&lt;/code&gt; 位学生的位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 262</title>
    <link href="http://yoursite.com/2021/10/11/334/"/>
    <id>http://yoursite.com/2021/10/11/334/</id>
    <published>2021-10-11T15:28:37.583Z</published>
    <updated>2021-10-11T15:28:45.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-262"><a href="#leetcode-contest-262" class="headerlink" title="leetcode contest 262"></a>leetcode contest 262</h1><p>周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.</p><h2 id="5894-至少在两个数组中出现的值"><a href="#5894-至少在两个数组中出现的值" class="headerlink" title="5894. 至少在两个数组中出现的值"></a>5894. 至少在两个数组中出现的值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">3</span> ，在全部三个数组中都出现过。</span><br><span class="line">- <span class="number">2</span> ，在数组 nums1 和 nums2 中出现过。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">3</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">2</span> ，在数组 nums2 和 nums3 中出现过。</span><br><span class="line">- <span class="number">3</span> ，在数组 nums1 和 nums2 中出现过。</span><br><span class="line">- <span class="number">1</span> ，在数组 nums1 和 nums3 中出现过。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>], nums3 = [<span class="number">5</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：不存在至少在两个数组中出现的值。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100</code></li><li><code>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/two-out-of-three" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-out-of-three</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接对每个元素统计它所在的数组的标记，如果标记大于等等于$2$,则我们认为该元素满足题目要求。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为数组的长度,我们此时需要遍历两边即可。</li><li>空间复杂度: $O(N*M)$,其中 $N$ 为每个数组的最长长度, $M$ 为数组的个数.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoOutOfThree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums3) &#123;</span><br><span class="line">            cnt[v].insert(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans.push_back(v.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5895-获取单值网格的最小操作数"><a href="#5895-获取单值网格的最小操作数" class="headerlink" title="5895. 获取单值网格的最小操作数"></a>5895. 获取单值网格的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>m x n</code>的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 加 <code>x</code> 或 减 <code>x</code>。<br>单值网格 是全部元素都相等的网格。<br>返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">8</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：可以执行下述操作使所有元素都等于 <span class="number">4</span> ： </span><br><span class="line">- <span class="number">2</span> 加 x 一次。</span><br><span class="line">- <span class="number">6</span> 减 x 一次。</span><br><span class="line">- <span class="number">8</span> 减 x 两次。</span><br><span class="line">共计 <span class="number">4</span> 次操作。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>]], x = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：可以使所有元素都等于 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：无法使所有元素相等。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>1 &lt;= x, grid[i][j] &lt;= 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简答,典型的数学问题，首先我们需要检测该数组是否能够变成同一个元素：</li></ol><ul><li>需要满足单元格中的任意两个元素的差的绝对值可以被 $v$ 整除.</li><li>我们只需要依次检测相邻的元素的差可以被 $v$ 整除即可.</li><li>我们可以证明,最终的变换元素一定为单元格中的某个元素.</li></ul><ol><li>我们依次尝试每一个元素 $v$,尝试将网格中所有的元素都变为 $v$, 则我们需要所有小于 $v$ 的元素都加上 $x$,所有大于 $v$ 的元素都减去 $x$,$prefix[i]$ 表示前$i$个元素的前缀和,$suffix[i]$ 表示从$i$开始以后的元素的后缀和,我们依次计算得到最小的 $cost[i]$ 即可．计算$cost[i]$的公式为:<script type="math/tex; mode=display">cost[i] = \frac{(i-1)*nums[i] - prefix[i-1]}{x} + \frac{suffix[i+1]-(n-i)*nums[i]}{x}</script></li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n<em>m</em>\lg(m<em>n))$，由于需要一次排序,因此时间复杂度为 $O(n</em>m<em>\lg(m</em>n))$.</li><li>空间复杂度分析: 空间复杂度为$O(m*n)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> k = m*n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[i] - arr[i<span class="number">-1</span>])%x != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; left(k+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; right(k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            left[i+<span class="number">1</span>] = left[i] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">            l = (arr[i]*i - left[i])/x;</span><br><span class="line">            r = (right[i+<span class="number">1</span>] - arr[i]*(k<span class="number">-1</span>-i))/x;</span><br><span class="line">            ans = min(ans,l + r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5896-股票价格波动"><a href="#5896-股票价格波动" class="headerlink" title="5896. 股票价格波动"></a>5896. 股票价格波动</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一支股票价格的数据流。数据流中每一条记录包含一个 时间戳 和该时间点股票对应的 价格 。</p><p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 更正 前一条错误的记录。</p><p>请你设计一个算法，实现：</p><ul><li>更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 更正 之前的错误价格。</li><li>找到当前记录里 最新股票价格 。最新股票价格 定义为时间戳最晚的股票价格。</li><li>找到当前记录里股票的 最高价格 。</li><li>找到当前记录里股票的 最低价格 。<br>请你实现 <code>StockPrice</code> 类：</li><li><code>StockPrice()</code> 初始化对象，当前无股票价格记录。</li><li><code>void update(int timestamp, int price)</code> 在时间点 timestamp 更新股票价格为 <code>price</code> 。</li><li><code>int current()</code> 返回股票 最新价格 。</li><li><code>int maximum()</code> 返回股票 最高价格 。</li><li><code>int minimum()</code> 返回股票 最低价格 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"StockPrice"</span>, <span class="string">"update"</span>, <span class="string">"update"</span>, <span class="string">"current"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"minimum"</span>]</span><br><span class="line">[[], [<span class="number">1</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">5</span>], [], [], [<span class="number">1</span>, <span class="number">3</span>], [], [<span class="number">4</span>, <span class="number">2</span>], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">5</span>, <span class="number">10</span>, null, <span class="number">5</span>, null, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">StockPrice stockPrice = new StockPrice();</span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 时间戳为 [1] ，对应的股票价格为 [10] 。</span></span><br><span class="line">stockPrice.update(<span class="number">2</span>, <span class="number">5</span>);  <span class="comment">// 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。</span></span><br><span class="line">stockPrice.current();     <span class="comment">// 返回 5 ，最新时间戳为 2 ，对应价格为 5 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。</span></span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 之前时间戳为 1 的价格错误，价格更新为 3 。</span></span><br><span class="line">                          <span class="comment">// 时间戳为 [1,2] ，对应股票价格为 [3,5] 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 5 ，更正后最高价格为 5 。</span></span><br><span class="line">stockPrice.update(<span class="number">4</span>, <span class="number">2</span>);  <span class="comment">// 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。</span></span><br><span class="line">stockPrice.minimum();     <span class="comment">// 返回 2 ，最低价格时间戳为 4 ，价格为 2 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= timestamp, price &lt;= 109</code></li><li><code>update</code>，<code>current</code>，<code>maximum</code> 和 <code>minimum</code> 总 调用次数不超过 105 。</li><li><code>current</code>，<code>maximum</code> 和 <code>minimum</code> 被调用时，<code>update</code> 操作 至少 已经被调用过一次. </li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stock-price-fluctuation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stock-price-fluctuation</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> <code>Treemap</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目感觉比第二题要简单一些,我们用<code>TreeMap</code>存储股票的时间戳对应的股票价格即可,会自动按照时间早晚进行存储和更新.</li><li>我们用<code>multiset</code>存储存储股票的所有价格,当出现股票更新操作时,需要将将股票的价格从 $x$ 更新到 $y$ 时,则我们从<code>multiset</code>中删除$x$,并同时插入$y$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(\lg n)$, $\texttt{update}$的时间复杂度为$O(\lg n)$,其余的操作时间复杂度为 $O(1)$.</li><li>空间复杂度为 $O(N)$,我们需要存储所有的股票的价格.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockPrice() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> timestamp, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(timestamp))&#123;</span><br><span class="line">            <span class="built_in">log</span>.erase(<span class="built_in">log</span>.find(cnt[timestamp]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>.insert(price);</span><br><span class="line">        cnt[timestamp] = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.rbegin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.rbegin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.begin();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5897-将数组分成两个数组并最小化数组和的差"><a href="#5897-将数组分成两个数组并最小化数组和的差" class="headerlink" title="5897. 将数组分成两个数组并最小化数组和的差"></a>5897. 将数组分成两个数组并最小化数组和的差</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 两个 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。<code>nums</code> 中每个元素都需要放入两个数组之一。<br>请你返回 最小 的数组和之差。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">3</span>,<span class="number">9</span>] 和 [<span class="number">7</span>,<span class="number">3</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">3</span> + <span class="number">9</span>) - (<span class="number">7</span> + <span class="number">3</span>)) = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-36</span>,<span class="number">36</span>]</span><br><span class="line">输出：<span class="number">72</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">-36</span>] 和 [<span class="number">36</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">-36</span>) - (<span class="number">36</span>)) = <span class="number">72</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">-2</span>,<span class="number">-9</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">-9</span>] 和 [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">2</span> + <span class="number">4</span> + <span class="number">-9</span>) - (<span class="number">-1</span> + <span class="number">0</span> + <span class="number">-2</span>)) = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 15</code></li><li><code>nums.length == 2 * n</code></li><li><code>-107 &lt;= nums[i] &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩 + 二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的很好,还是非常有深度的思考题目,既考虑了状态压缩,也考虑了二分查找.</li><li>如果我们直接枚举所有的含有$n$个元素的子数组的话,时间复杂度为$C_{m}^{n}$,d当$m = 30$时,则总的耗费的时间约为$C_{30}^{15}$，这时肯定会超时.</li><li>此时我们想到用折半的办法,假设数组的长度为$2n$,我们在前$n$个元素中选择$x$个元素,设这$x$个元素的和为$left[x]$;我们在后$n$个元素中选择$n-x$个元素,设这$n-x$个元素的和为$right[n-x]$,则此时我们共选出$n$个元素,这$n$个元素的和为<script type="math/tex">left[x] + right[n-x]</script>,我们设$sum$表示整个数组的元素的和,则我们此时知道两个子数组的差为<script type="math/tex">sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])|</script>,因此我们选取子数组使的上述等式的结果最小即可.</li><li>我们对上式进行变形可以得到:<script type="math/tex; mode=display">\begin{aligned}sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])| \\= |2*left[x]+2*right[n-x] - sum| \\= |(sum - 2*left[x]) - 2*right[n-x]| \\\end{aligned}</script>因此我们只需要找到满足 $(sum - 2<em>left[x])$ 与 $2</em>right[n-x]$ 尽可能的接近即可.因此我们可以对每一个$left[x]$进行枚举,然后我们可以利用二分查找找到最接近的值$2<em>right[n-x]$即可,我们利用状态压缩枚举所有的$(sum - 2</em>left[x])$的值即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(n*2^{n})$，其中$2n$表示数组的长度.</li><li>空间复杂度分析: $O(2^{n})$，其中$2n$表示数组的长度.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = m/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    left += nums[j];</span><br><span class="line">                    right += nums[n+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[__builtin_popcount(i)].push_back(<span class="number">2</span>*right);</span><br><span class="line">            dp[i] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            sort(arr[i].begin(),arr[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = n - __builtin_popcount(i);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = sum - <span class="number">2</span>*dp[i];</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr[x].begin(),arr[x].end(),curr);</span><br><span class="line">            <span class="keyword">if</span>(it == arr[x].begin())&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == arr[x].end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-262&quot;&gt;&lt;a href=&quot;#leetcode-contest-262&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 262&quot;&gt;&lt;/a&gt;leetcode contest 262&lt;/h1&gt;&lt;p&gt;周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.&lt;/p&gt;&lt;h2 id=&quot;5894-至少在两个数组中出现的值&quot;&gt;&lt;a href=&quot;#5894-至少在两个数组中出现的值&quot; class=&quot;headerlink&quot; title=&quot;5894. 至少在两个数组中出现的值&quot;&gt;&lt;/a&gt;5894. 至少在两个数组中出现的值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你三个整数数组 &lt;code&gt;nums1&lt;/code&gt;、&lt;code&gt;nums2&lt;/code&gt; 和 &lt;code&gt;nums3&lt;/code&gt; ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 262</title>
    <link href="http://yoursite.com/2021/10/09/333/"/>
    <id>http://yoursite.com/2021/10/09/333/</id>
    <published>2021-10-09T08:29:33.238Z</published>
    <updated>2021-10-10T10:58:52.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-262"><a href="#leetcode-contest-262" class="headerlink" title="leetcode contest 262"></a>leetcode contest 262</h1><p>周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.</p><h2 id="5894-至少在两个数组中出现的值"><a href="#5894-至少在两个数组中出现的值" class="headerlink" title="5894. 至少在两个数组中出现的值"></a>5894. 至少在两个数组中出现的值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">3</span> ，在全部三个数组中都出现过。</span><br><span class="line">- <span class="number">2</span> ，在数组 nums1 和 nums2 中出现过。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">3</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">2</span> ，在数组 nums2 和 nums3 中出现过。</span><br><span class="line">- <span class="number">3</span> ，在数组 nums1 和 nums2 中出现过。</span><br><span class="line">- <span class="number">1</span> ，在数组 nums1 和 nums3 中出现过。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>], nums3 = [<span class="number">5</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：不存在至少在两个数组中出现的值。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100</code></li><li><code>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/two-out-of-three" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-out-of-three</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接对每个元素统计它所在的数组的标记，如果标记大于等等于$2$,则我们认为该元素满足题目要求。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为数组的长度,我们此时需要遍历两边即可。</li><li>空间复杂度: $O(N*M)$,其中 $N$ 为每个数组的最长长度, $M$ 为数组的个数.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoOutOfThree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums3) &#123;</span><br><span class="line">            cnt[v].insert(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans.push_back(v.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5895-获取单值网格的最小操作数"><a href="#5895-获取单值网格的最小操作数" class="headerlink" title="5895. 获取单值网格的最小操作数"></a>5895. 获取单值网格的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>m x n</code>的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 加 <code>x</code> 或 减 <code>x</code>。<br>单值网格 是全部元素都相等的网格。<br>返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">8</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：可以执行下述操作使所有元素都等于 <span class="number">4</span> ： </span><br><span class="line">- <span class="number">2</span> 加 x 一次。</span><br><span class="line">- <span class="number">6</span> 减 x 一次。</span><br><span class="line">- <span class="number">8</span> 减 x 两次。</span><br><span class="line">共计 <span class="number">4</span> 次操作。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>]], x = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：可以使所有元素都等于 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：无法使所有元素相等。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>1 &lt;= x, grid[i][j] &lt;= 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简答,典型的数学问题，首先我们需要检测该数组是否能够变成同一个元素：</li></ol><ul><li>需要满足单元格中的任意两个元素的差的绝对值可以被 $v$ 整除.</li><li>我们只需要依次检测相邻的元素的差可以被 $v$ 整除即可.</li><li>我们可以证明,最终的变换元素一定为单元格中的某个元素.</li></ul><ol><li>我们依次尝试每一个元素 $v$,尝试将网格中所有的元素都变为 $v$, 则我们需要所有小于 $v$ 的元素都加上 $x$,所有大于 $v$ 的元素都减去 $x$,$prefix[i]$ 表示前$i$个元素的前缀和,$suffix[i]$ 表示从$i$开始以后的元素的后缀和,我们依次计算得到最小的 $cost[i]$ 即可．计算$cost[i]$的公式为:<script type="math/tex; mode=display">cost[i] = \frac{(i-1)*nums[i] - prefix[i-1]}{x} + \frac{suffix[i+1]-(n-i)*nums[i]}{x}</script></li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n<em>m</em>\lg(m<em>n))$，由于需要一次排序,因此时间复杂度为 $O(n</em>m<em>\lg(m</em>n))$.</li><li>空间复杂度分析: 空间复杂度为$O(m*n)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> k = m*n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[i] - arr[i<span class="number">-1</span>])%x != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; left(k+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; right(k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            left[i+<span class="number">1</span>] = left[i] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">            l = (arr[i]*i - left[i])/x;</span><br><span class="line">            r = (right[i+<span class="number">1</span>] - arr[i]*(k<span class="number">-1</span>-i))/x;</span><br><span class="line">            ans = min(ans,l + r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5896-股票价格波动"><a href="#5896-股票价格波动" class="headerlink" title="5896. 股票价格波动"></a>5896. 股票价格波动</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一支股票价格的数据流。数据流中每一条记录包含一个 时间戳 和该时间点股票对应的 价格 。</p><p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 更正 前一条错误的记录。</p><p>请你设计一个算法，实现：</p><ul><li>更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 更正 之前的错误价格。</li><li>找到当前记录里 最新股票价格 。最新股票价格 定义为时间戳最晚的股票价格。</li><li>找到当前记录里股票的 最高价格 。</li><li>找到当前记录里股票的 最低价格 。<br>请你实现 <code>StockPrice</code> 类：</li><li><code>StockPrice()</code> 初始化对象，当前无股票价格记录。</li><li><code>void update(int timestamp, int price)</code> 在时间点 timestamp 更新股票价格为 <code>price</code> 。</li><li><code>int current()</code> 返回股票 最新价格 。</li><li><code>int maximum()</code> 返回股票 最高价格 。</li><li><code>int minimum()</code> 返回股票 最低价格 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"StockPrice"</span>, <span class="string">"update"</span>, <span class="string">"update"</span>, <span class="string">"current"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"minimum"</span>]</span><br><span class="line">[[], [<span class="number">1</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">5</span>], [], [], [<span class="number">1</span>, <span class="number">3</span>], [], [<span class="number">4</span>, <span class="number">2</span>], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">5</span>, <span class="number">10</span>, null, <span class="number">5</span>, null, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">StockPrice stockPrice = new StockPrice();</span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 时间戳为 [1] ，对应的股票价格为 [10] 。</span></span><br><span class="line">stockPrice.update(<span class="number">2</span>, <span class="number">5</span>);  <span class="comment">// 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。</span></span><br><span class="line">stockPrice.current();     <span class="comment">// 返回 5 ，最新时间戳为 2 ，对应价格为 5 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。</span></span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 之前时间戳为 1 的价格错误，价格更新为 3 。</span></span><br><span class="line">                          <span class="comment">// 时间戳为 [1,2] ，对应股票价格为 [3,5] 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 5 ，更正后最高价格为 5 。</span></span><br><span class="line">stockPrice.update(<span class="number">4</span>, <span class="number">2</span>);  <span class="comment">// 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。</span></span><br><span class="line">stockPrice.minimum();     <span class="comment">// 返回 2 ，最低价格时间戳为 4 ，价格为 2 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= timestamp, price &lt;= 109</code></li><li><code>update</code>，<code>current</code>，<code>maximum</code> 和 <code>minimum</code> 总 调用次数不超过 105 。</li><li><code>current</code>，<code>maximum</code> 和 <code>minimum</code> 被调用时，<code>update</code> 操作 至少 已经被调用过一次. </li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stock-price-fluctuation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stock-price-fluctuation</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> <code>Treemap</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目感觉比第二题要简单一些,我们用<code>TreeMap</code>存储股票的时间戳对应的股票价格即可,会自动按照时间早晚进行存储和更新.</li><li>我们用<code>multiset</code>存储存储股票的所有价格,当出现股票更新操作时,需要将将股票的价格从 $x$ 更新到 $y$ 时,则我们从<code>multiset</code>中删除$x$,并同时插入$y$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(\lg n)$, $\texttt{update}$的时间复杂度为$O(\lg n)$,其余的操作时间复杂度为 $O(1)$.</li><li>空间复杂度为 $O(N)$,我们需要存储所有的股票的价格.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockPrice() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> timestamp, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(timestamp))&#123;</span><br><span class="line">            <span class="built_in">log</span>.erase(<span class="built_in">log</span>.find(cnt[timestamp]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>.insert(price);</span><br><span class="line">        cnt[timestamp] = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.rbegin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.rbegin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.begin();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5897-将数组分成两个数组并最小化数组和的差"><a href="#5897-将数组分成两个数组并最小化数组和的差" class="headerlink" title="5897. 将数组分成两个数组并最小化数组和的差"></a>5897. 将数组分成两个数组并最小化数组和的差</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 两个 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。<code>nums</code> 中每个元素都需要放入两个数组之一。<br>请你返回 最小 的数组和之差。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">3</span>,<span class="number">9</span>] 和 [<span class="number">7</span>,<span class="number">3</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">3</span> + <span class="number">9</span>) - (<span class="number">7</span> + <span class="number">3</span>)) = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-36</span>,<span class="number">36</span>]</span><br><span class="line">输出：<span class="number">72</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">-36</span>] 和 [<span class="number">36</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">-36</span>) - (<span class="number">36</span>)) = <span class="number">72</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">-2</span>,<span class="number">-9</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">-9</span>] 和 [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">2</span> + <span class="number">4</span> + <span class="number">-9</span>) - (<span class="number">-1</span> + <span class="number">0</span> + <span class="number">-2</span>)) = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 15</code></li><li><code>nums.length == 2 * n</code></li><li><code>-107 &lt;= nums[i] &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩 + 二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的很好,还是非常有深度的思考题目,既考虑了状态压缩,也考虑了二分查找.</li><li>如果我们直接枚举所有的含有$n$个元素的子数组的话,时间复杂度为$C_{m}^{n}$,d当$m = 30$时,则总的耗费的时间约为$C_{30}^{15}$，这时肯定会超时.</li><li>此时我们想到用折半的办法,假设数组的长度为$2n$,我们在前$n$个元素中选择$x$个元素,设这$x$个元素的和为$left[x]$;我们在后$n$个元素中选择$n-x$个元素,设这$n-x$个元素的和为$right[n-x]$,则此时我们共选出$n$个元素,这$n$个元素的和为<script type="math/tex">left[x] + right[n-x]</script>,我们设$sum$表示整个数组的元素的和,则我们此时知道两个子数组的差为<script type="math/tex">sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])|</script>,因此我们选取子数组使的上述等式的结果最小即可.</li><li>我们对上式进行变形可以得到:<script type="math/tex; mode=display">\begin{aligned}sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])| \\= |2*left[x]+2*right[n-x] - sum| \\= |(sum - 2*left[x]) - 2*right[n-x]| \\\end{aligned}</script>因此我们只需要找到满足 $(sum - 2<em>left[x])$ 与 $2</em>right[n-x]$ 尽可能的接近即可.因此我们可以对每一个$left[x]$进行枚举,然后我们可以利用二分查找找到最接近的值$2<em>right[n-x]$即可,我们利用状态压缩枚举所有的$(sum - 2</em>left[x])$的值即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(n*2^{n})$，其中$2n$表示数组的长度.</li><li>空间复杂度分析: $O(2^{n})$，其中$2n$表示数组的长度.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = m/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    left += nums[j];</span><br><span class="line">                    right += nums[n+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[__builtin_popcount(i)].push_back(<span class="number">2</span>*right);</span><br><span class="line">            dp[i] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            sort(arr[i].begin(),arr[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = n - __builtin_popcount(i);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = sum - <span class="number">2</span>*dp[i];</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr[x].begin(),arr[x].end(),curr);</span><br><span class="line">            <span class="keyword">if</span>(it == arr[x].begin())&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == arr[x].end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-262&quot;&gt;&lt;a href=&quot;#leetcode-contest-262&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 262&quot;&gt;&lt;/a&gt;leetcode contest 262&lt;/h1&gt;&lt;p&gt;周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.&lt;/p&gt;&lt;h2 id=&quot;5894-至少在两个数组中出现的值&quot;&gt;&lt;a href=&quot;#5894-至少在两个数组中出现的值&quot; class=&quot;headerlink&quot; title=&quot;5894. 至少在两个数组中出现的值&quot;&gt;&lt;/a&gt;5894. 至少在两个数组中出现的值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你三个整数数组 &lt;code&gt;nums1&lt;/code&gt;、&lt;code&gt;nums2&lt;/code&gt; 和 &lt;code&gt;nums3&lt;/code&gt; ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab7 Thread</title>
    <link href="http://yoursite.com/2021/10/08/332/"/>
    <id>http://yoursite.com/2021/10/08/332/</id>
    <published>2021-10-08T15:30:08.810Z</published>
    <updated>2021-10-09T05:25:32.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><p>感觉<code>thread lab</code>是我做的基本上最简单的<code>lab</code>了，但是感觉这个章节是干货最多的章节，很多操作系统的原理和技术实现细节就一下子全部很清晰．再配合<code>lab</code>完成现程的实现,感觉对操作系统的进程调度有了一个非常清晰的认识,是非常值得仔细学习和思考的章节.</p><ul><li><p>时间片调度的本质: CPU内部有定时器,定时器会定期的发起中断.操作系统内核接收到了定时器中断后，通过<code>context</code>切换,从当前进程的内核线程切换内核的进程调度程序，而在调度程序内部会实现对进程的调度．我们仔细分析一下源代码可以知道,进程调度工作的流程．</p></li><li><p>在所有的进程中顺序查找到下一个处在就绪态的进程,然后通过切换上下文将该进程的内核线程切换到<code>CPU</code>中,而该内核线程又通过<code>trapret</code>，<code>cpu</code>恢复到该进程的用户线程.如果当前进程接受到中断时,就会进入<code>usertrap</code>中,在<code>usertrap</code>中检测如果当前为定时器中断,则进行上下文切换切换到内核中的线程调度程序．实际的进程调度分为两种方式，一种方式是时间片到了，当前的进程被动放弃<code>CPU</code>,另一种方式是当前的进程可能需要等待挂起,主动的放弃<code>CPU</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"wfi"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>进程调度的实现原理: 在<code>xv6</code>系统中,进程调度直接顺序查找即可,当然找到下一个线程需要$O(n)$的时间复杂度,在实际的<code>Linux</code>系统中,线程都带有优先级,在做线程切换时,可以利用堆的特性,在 $O(\lg n)$ 的时间复杂度内即可将优先级最高的线程且处于就绪态的线程找出来.</li><li>上下文切换的本质: 本质即为切换寄存器的值.将程序运行过程中的<code>ra</code>以及<code>sp</code>以及几个常用的由<code>callee</code>保存的寄存器进行保存相关的值即可.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, <span class="number">0</span>(a0)</span><br><span class="line">        sd sp, <span class="number">8</span>(a0)</span><br><span class="line">        sd s0, <span class="number">16</span>(a0)</span><br><span class="line">        sd s1, <span class="number">24</span>(a0)</span><br><span class="line">        sd s2, <span class="number">32</span>(a0)</span><br><span class="line">        sd s3, <span class="number">40</span>(a0)</span><br><span class="line">        sd s4, <span class="number">48</span>(a0)</span><br><span class="line">        sd s5, <span class="number">56</span>(a0)</span><br><span class="line">        sd s6, <span class="number">64</span>(a0)</span><br><span class="line">        sd s7, <span class="number">72</span>(a0)</span><br><span class="line">        sd s8, <span class="number">80</span>(a0)</span><br><span class="line">        sd s9, <span class="number">88</span>(a0)</span><br><span class="line">        sd s10, <span class="number">96</span>(a0)</span><br><span class="line">        sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, <span class="number">0</span>(a1)</span><br><span class="line">        ld sp, <span class="number">8</span>(a1)</span><br><span class="line">        ld s0, <span class="number">16</span>(a1)</span><br><span class="line">        ld s1, <span class="number">24</span>(a1)</span><br><span class="line">        ld s2, <span class="number">32</span>(a1)</span><br><span class="line">        ld s3, <span class="number">40</span>(a1)</span><br><span class="line">        ld s4, <span class="number">48</span>(a1)</span><br><span class="line">        ld s5, <span class="number">56</span>(a1)</span><br><span class="line">        ld s6, <span class="number">64</span>(a1)</span><br><span class="line">        ld s7, <span class="number">72</span>(a1)</span><br><span class="line">        ld s8, <span class="number">80</span>(a1)</span><br><span class="line">        ld s9, <span class="number">88</span>(a1)</span><br><span class="line">        ld s10, <span class="number">96</span>(a1)</span><br><span class="line">        ld s11, <span class="number">104</span>(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></li><li>本章还讲述了<code>spin lock</code>的实现原理,感觉非常清晰明了.首先我们需要知道<code>CPU</code>支持的原子操作,一般使用编译器自带的几个通用的原子操作如下，具体可以参考<code>gcc</code>的文档:<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">Gcc手册中《Using the GNU Compiler Collection (GCC)》</a>.</li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value加到*ptr上，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 从*ptr减去value，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相或，结果更新到*ptr， 并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相与，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value异或，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_add_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value加到*ptr上，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_sub_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 从*ptr减去value，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_or_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相或， 结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_and_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_xor_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value异或，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_nand_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line"><span class="keyword">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"><span class="comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true</span></span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"><span class="comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回操作之前*ptr的值</span></span><br><span class="line">__sync_synchronize (...)</span><br><span class="line"><span class="comment">// 发出完整内存栅栏</span></span><br><span class="line">type __sync_lock_test_and_set (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value写入*ptr，对*ptr加锁，并返回操作之前*ptr的值。即，try spinlock语义</span></span><br><span class="line"><span class="keyword">void</span> __sync_lock_release (type *ptr, ...)</span><br><span class="line"><span class="comment">// 将0写入到*ptr，并对*ptr解锁。即，unlock spinlock语义</span></span><br></pre></td></tr></table></figure><ul><li>典型的<code>spin lock</code>的实现，仔细分析一下源代码：</li><li><ul><li><code>acquire</code>期间会关闭中断,这是为了防止死锁.并同时将计数加<code>1</code>.<code>release</code>时,将计数减<code>1</code>,同时会恢复中断.</li></ul></li><li><ul><li>我们会一直等待<code>lk-&gt;locked</code>变为<code>0</code>,如果<code>lk-&gt;locked</code>为<code>1</code>则会一直等待,<code>lk-&gt;locked</code>为<code>0</code>,则我们会继续进程到下一步.</li></ul></li><li><ul><li>从自旋锁的实现方式上来看,我们可以看到自旋锁的资源的消耗还是非常大的,这就需要我们谨慎的使用锁.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">"acquire"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section's memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">release(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">"release"</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn't use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether this cpu is holding the lock.</span></span><br><span class="line"><span class="comment">// Interrupts must be off.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">holding(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">push_off(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">pop_off(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> = <span class="title">mycpu</span>();</span></span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">"pop_off - interruptible"</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"pop_off"</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>线程的切换：在XV6中，任何时候都需要经历：</p></li></ul><ol><li>从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存<br>用户进程的状态并运行第一个用户进程的内核线程。</li><li>再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。</li><li>之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。</li><li>最后返回到第二个用户进程继续执行。<br><img src="https://i.loli.net/2021/10/09/OuJrW8gPRQfx9nU.png" alt></li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>本次<code>lab</code>的几个程序倒是非常简单.<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-cow-handin" target="_blank" rel="noopener">git repo</a></p><h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your job <span class="keyword">is</span> <span class="keyword">to</span> come up <span class="keyword">with</span> a plan <span class="keyword">to</span> create threads <span class="keyword">and</span> save/restore registers <span class="keyword">to</span> switch between threads, <span class="keyword">and</span> implement that plan. <span class="keyword">When</span> you<span class="comment">'re done, make grade should say that your solution passes the uthread test.</span></span><br></pre></td></tr></table></figure><p>实现几个基本线程的切换：上下文切换这部分最难，但是我们可以直接可以参考<code>switch.S</code>的实现，直接<code>copy</code>过来即可.关于线程切换时．每个线程都有独立的栈，我们在初始化线程时，会将线程的上下文中<code>sp</code>和<code>ra</code>进行初始化,分别指向当前线程的栈的高位地址,返回地址则指向线程的起始函数地址.</p><ul><li>最坑的一个<code>bug</code>是: 线程的栈的地址是从高地址向低地址增长,刚开始没有发现这个问题,直接将低地址赋给$sp$,然后总是出错.莫名奇妙的会改写线程的状态,总是找不到原因,最终查看,由于栈的地址是从高往低增长,我们在对栈进行操作时会覆盖掉$thread$结构体中的其他信息和内容.</li><li>关于线程的定义:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread's stack */</span></span><br><span class="line">  <span class="keyword">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>       <span class="comment">/* thread context */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>thread_switch</strong>定义：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">sd ra, <span class="number">0</span>(a0)</span><br><span class="line">    sd sp, <span class="number">8</span>(a0)</span><br><span class="line">    sd s0, <span class="number">16</span>(a0)</span><br><span class="line">    sd s1, <span class="number">24</span>(a0)</span><br><span class="line">    sd s2, <span class="number">32</span>(a0)</span><br><span class="line">    sd s3, <span class="number">40</span>(a0)</span><br><span class="line">    sd s4, <span class="number">48</span>(a0)</span><br><span class="line">    sd s5, <span class="number">56</span>(a0)</span><br><span class="line">    sd s6, <span class="number">64</span>(a0)</span><br><span class="line">    sd s7, <span class="number">72</span>(a0)</span><br><span class="line">    sd s8, <span class="number">80</span>(a0)</span><br><span class="line">    sd s9, <span class="number">88</span>(a0)</span><br><span class="line">    sd s10, <span class="number">96</span>(a0)</span><br><span class="line">    sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, <span class="number">0</span>(a1)</span><br><span class="line">    ld sp, <span class="number">8</span>(a1)</span><br><span class="line">    ld s0, <span class="number">16</span>(a1)</span><br><span class="line">    ld s1, <span class="number">24</span>(a1)</span><br><span class="line">    ld s2, <span class="number">32</span>(a1)</span><br><span class="line">    ld s3, <span class="number">40</span>(a1)</span><br><span class="line">    ld s4, <span class="number">48</span>(a1)</span><br><span class="line">    ld s5, <span class="number">56</span>(a1)</span><br><span class="line">    ld s6, <span class="number">64</span>(a1)</span><br><span class="line">    ld s7, <span class="number">72</span>(a1)</span><br><span class="line">    ld s8, <span class="number">80</span>(a1)</span><br><span class="line">    ld s9, <span class="number">88</span>(a1)</span><br><span class="line">    ld s10, <span class="number">96</span>(a1)</span><br><span class="line">    ld s11, <span class="number">104</span>(a1)</span><br><span class="line">    </span><br><span class="line">ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure></li><li>线程初始化：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">thread_create(<span class="keyword">void</span> (*func)())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;t-&gt;context,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct context));</span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>线程调度与切换:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">thread_schedule(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>, *<span class="title">next_thread</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find another runnable thread. */</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br><span class="line">  t = current_thread + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">      t = all_thread;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">      next_thread = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next_thread == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread_schedule: no runnable threads\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;context,(uint64)&amp;next_thread-&gt;context);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">     next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you will explore <span class="keyword">parallel</span> programming <span class="keyword">with</span> threads <span class="keyword">and</span> locks <span class="keyword">using</span> a hash table. You should <span class="keyword">do</span> this assignment <span class="keyword">on</span> a real Linux <span class="keyword">or</span> MacOS computer (<span class="keyword">not</span> xv6, <span class="keyword">not</span> qemu) that <span class="keyword">has</span> multiple cores. Most recent laptops have multicore processors.</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>在多线程下,多个线程同时更新和查找<code>hash table</code>,会出现数据竞争的问题,如何去解决该问题?很明显就是加锁，在更新<code>hash table</code>时加锁,防止两个线程同时更新<code>hash tbale</code>即可.</p></li><li><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> = 0;</span></span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;lock);</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you<span class="symbol">'ll</span> implement a barrier: a point <span class="keyword">in</span> an application at which <span class="keyword">all</span> participating threads must <span class="keyword">wait</span> <span class="keyword">until</span> <span class="keyword">all</span> other participating threads reach that point too. You<span class="symbol">'ll</span> <span class="keyword">use</span> pthread condition variables, which are a <span class="keyword">sequence</span> coordination technique similar <span class="keyword">to</span> xv6<span class="symbol">'s</span> sleep <span class="keyword">and</span> wakeup.</span><br></pre></td></tr></table></figure><ul><li>题目中用了多个线程的同步,实际上利用了条件变量<code>cond</code>,这个与<code>C++</code>中的条件变量实现原理类似<code>condition_variable</code>, 可以参考<code>pthread_cond_wait</code>与<code>pthread_cond_timedwait</code>的用法.<a href="https://baike.baidu.com/item/pthread_cond_wait/3011997?fr=aladdin" target="_blank" rel="noopener">cond</a></li><li><ul><li>阻塞功能: 必须和一个互斥锁配合，以防止多个线程同时请求<code>pthread_cond_wait()</code>（或<code>pthread_cond_timedwait()</code>，下同）的竞争条件（<code>Race Condition</code>）。<code>mutex</code>互斥锁必须是普通锁（<code>PTHREAD_MUTEX_TIMED_NP</code>）或者适应锁（<code>PTHREAD_MUTEX_ADAPTIVE_NP</code>），且在调用pthread_cond_wait()前必须由本线程加锁（<code>pthread_mutex_lock()</code>），而在更新条件等待队列以前，<code>mutex</code>保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开<code>pthread_cond_wait()</code>之前，<code>mutex</code>将被重新加锁，以与进入<code>pthread_cond_wait()</code>前的加锁动作对应。阻塞时处于解锁状态。</li></ul></li><li><ul><li>pthread_cond_wait进入阻塞时,则会释放锁,从而别的线程可以获取到该锁;当<code>pthread_cond_wait</code>被唤醒时,则又会加锁,因此当它唤醒后,还需要释放锁的操作.</li></ul></li><li><ul><li>在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应</li></ul></li><li><ul><li>激活功能: 激发条件有两种形式，<code>pthread_cond_signal()</code>激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而<code>pthread_cond_broadcast()</code>则激活所有等待线程。</li></ul></li><li><p>重要函数的使用说明:　使用<code>pthread_mutex_lock(&amp;mutex1)</code>;加互斥所，然后在<code>pthread_cond_wait(&amp;cond, &amp;mutex1)</code>;这样可以保证这期间没有<code>pthread_cond_broadcast</code>或者<code>pthread_cond_signal</code>操作，从而保证条件不会丢失，当<code>pthread_cond_wait(&amp;cond, &amp;mutex1)</code>;</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">barrier()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">　<span class="comment">// acquire mutex</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread == nthread)&#123;</span><br><span class="line">  bstate.round += <span class="number">1</span>;</span><br><span class="line">  bstate.nthread = <span class="number">0</span>;</span><br><span class="line">  pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  pthread_cond_wait(&amp;bstate.barrier_cond,&amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul><li>通过这一章几个重要的原理讲解,非常清晰的了解操作系统进程调度的第层实现原理与锁的实现原理.</li><li>通过学习<code>pthread_cond_wait</code>的原理从而能够学习<code>c++</code>中<code>conditional_variable</code>的原理.</li><li>下一步计划:</li><li><ul><li>完成<code>option chanllenge</code>的<code>project</code>;</li></ul></li><li><ul><li>学习<code>conditional_variable</code>的实现原理;</li></ul></li><li><ul><li>阅读<code>pthread_cond_wait</code>的源代码.<h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ul></li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;thread&quot;&gt;&lt;a href=&quot;#thread&quot; class=&quot;headerlink&quot; title=&quot;thread&quot;&gt;&lt;/a&gt;thread&lt;/h1&gt;&lt;p&gt;感觉&lt;code&gt;thread lab&lt;/code&gt;是我做的基本上最简单的&lt;code&gt;lab&lt;/code&gt;了，但是感觉这个章节是干货最多的章节，很多操作系统的原理和技术实现细节就一下子全部很清晰．再配合&lt;code&gt;lab&lt;/code&gt;完成现程的实现,感觉对操作系统的进程调度有了一个非常清晰的认识,是非常值得仔细学习和思考的章节.&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;时间片调度的本质: CPU内部有定时器,定时器会定期的发起中断.操作系统内核接收到了定时器中断后，通过&lt;code&gt;context&lt;/code&gt;切换,从当前进程的内核线程切换内核的进程调度程序，而在调度程序内部会实现对进程的调度．我们仔细分析一下源代码可以知道,进程调度工作的流程．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在所有的进程中顺序查找到下一个处在就绪态的进程,然后通过切换上下文将该进程的内核线程切换到&lt;code&gt;CPU&lt;/code&gt;中,而该内核线程又通过&lt;code&gt;trapret&lt;/code&gt;，&lt;code&gt;cpu&lt;/code&gt;恢复到该进程的用户线程.如果当前进程接受到中断时,就会进入&lt;code&gt;usertrap&lt;/code&gt;中,在&lt;code&gt;usertrap&lt;/code&gt;中检测如果当前为定时器中断,则进行上下文切换切换到内核中的线程调度程序．实际的进程调度分为两种方式，一种方式是时间片到了，当前的进程被动放弃&lt;code&gt;CPU&lt;/code&gt;,另一种方式是当前的进程可能需要等待挂起,主动的放弃&lt;code&gt;CPU&lt;/code&gt;.&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;usertrap(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; which_dev = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((r_sstatus() &amp;amp; SSTATUS_SPP) != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    panic(&lt;span class=&quot;string&quot;&gt;&quot;usertrap: not from user mode&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// send interrupts and exceptions to kerneltrap(),&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// since we&#39;re now in the kernel.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  w_stvec((uint64)kernelvec);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;proc&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;myproc&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// save user program counter.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  p-&amp;gt;trapframe-&amp;gt;epc = r_sepc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r_scause() == &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// system call&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;killed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// sepc points to the ecall instruction,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// but we want to return to the next instruction.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;trapframe-&amp;gt;epc += &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// an interrupt will change sstatus &amp;amp;c registers,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// so don&#39;t enable until done with those registers.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    intr_on();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    syscall();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((which_dev = devintr()) != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ok&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;usertrap(): unexpected scause %p pid=%d\n&quot;&lt;/span&gt;, r_scause(), p-&amp;gt;pid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;            sepc=%p stval=%p\n&quot;&lt;/span&gt;, r_sepc(), r_stval());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;killed = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;killed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// give up the CPU if this is a timer interrupt.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(which_dev == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yield();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  usertrapret();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Avoid deadlock by ensuring that devices can interrupt.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    intr_on();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nproc = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(p = proc; p &amp;lt; &amp;amp;proc[NPROC]; p++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      acquire(&amp;amp;p-&amp;gt;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;state != UNUSED) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nproc++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;state == RUNNABLE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Switch to chosen process.  It is the process&#39;s job&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// to release its lock and then reacquire it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// before jumping back to us.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p-&amp;gt;state = RUNNING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c-&amp;gt;proc = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        swtch(&amp;amp;c-&amp;gt;context, &amp;amp;p-&amp;gt;context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Process is done running for now.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// It should have changed its p-&amp;gt;state before coming back.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c-&amp;gt;proc = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      release(&amp;amp;p-&amp;gt;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nproc &amp;lt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// only init and sh exist&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      intr_on();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volatile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;wfi&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;进程调度的实现原理: 在&lt;code&gt;xv6&lt;/code&gt;系统中,进程调度直接顺序查找即可,当然找到下一个线程需要$O(n)$的时间复杂度,在实际的&lt;code&gt;Linux&lt;/code&gt;系统中,线程都带有优先级,在做线程切换时,可以利用堆的特性,在 $O(\lg n)$ 的时间复杂度内即可将优先级最高的线程且处于就绪态的线程找出来.&lt;/li&gt;
&lt;li&gt;上下文切换的本质: 本质即为切换寄存器的值.将程序运行过程中的&lt;code&gt;ra&lt;/code&gt;以及&lt;code&gt;sp&lt;/code&gt;以及几个常用的由&lt;code&gt;callee&lt;/code&gt;保存的寄存器进行保存相关的值即可.&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.globl swtch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swtch:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd ra, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd sp, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s0, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s1, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s2, &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s3, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s4, &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s5, &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s6, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s7, &lt;span class=&quot;number&quot;&gt;72&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s8, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s9, &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s10, &lt;span class=&quot;number&quot;&gt;96&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s11, &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld ra, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld sp, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s0, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s1, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s2, &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s3, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s4, &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s5, &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s6, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s7, &lt;span class=&quot;number&quot;&gt;72&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s8, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s9, &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s10, &lt;span class=&quot;number&quot;&gt;96&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s11, &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;本章还讲述了&lt;code&gt;spin lock&lt;/code&gt;的实现原理,感觉非常清晰明了.首先我们需要知道&lt;code&gt;CPU&lt;/code&gt;支持的原子操作,一般使用编译器自带的几个通用的原子操作如下，具体可以参考&lt;code&gt;gcc&lt;/code&gt;的文档:&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gcc手册中《Using the GNU Compiler Collection (GCC)》&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 261</title>
    <link href="http://yoursite.com/2021/10/05/331/"/>
    <id>http://yoursite.com/2021/10/05/331/</id>
    <published>2021-10-05T03:14:03.459Z</published>
    <updated>2021-10-05T08:09:41.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-261"><a href="#leetcode-contest-261" class="headerlink" title="leetcode contest 261"></a>leetcode contest 261</h1><p>周赛题目质量非常不错，还是继续三道题的节奏。</p><h2 id="2027-转换字符串的最少操作次数"><a href="#2027-转换字符串的最少操作次数" class="headerlink" title="2027. 转换字符串的最少操作次数"></a>2027. 转换字符串的最少操作次数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，由 <code>n</code> 个字符组成，每个字符不是 <code>&#39;X&#39;</code> 就是 <code>&#39;O&#39;</code> 。</p><p>一次 操作 定义为从<code>s</code>中选出 三个连续字符 并将选中的每个字符都转换为 <code>&#39;O&#39;</code>。注意，如果字符已经是 <code>&#39;O&#39;</code>，只需要保持 不变 。</p><a id="more"></a><p>返回将 <code>s</code>中所有字符均转换为 <code>&#39;O</code>‘ 需要执行的 最少 操作次数。</p><p>示例 1：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"XXX"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：XXX -&gt; OOO</span><br><span class="line">一次操作，选中全部 <span class="number">3</span> 个字符，并将它们转换为 <span class="string">'O'</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"XXOX"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：XXOX -&gt; OOOX -&gt; OOOO</span><br><span class="line">第一次操作，选择前 <span class="number">3</span> 个字符，并将这些字符转换为 <span class="string">'O'</span> 。</span><br><span class="line">然后，选中后 <span class="number">3</span> 个字符，并执行转换。最终得到的字符串全由字符 <span class="string">'O'</span> 组成。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"OOOO"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：s 中不存在需要转换的 'X' 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 1000</code></li><li><code>s[i]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-convert-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-moves-to-convert-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接转化即可，每次尝试改变三个字符即可。</li><li>尝试所有可能性即可，时间复杂度为 $O(N)$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; s[pos] == <span class="string">'O'</span>) pos++;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; s[pos] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ans += (curr + <span class="number">2</span>)/<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr%<span class="number">3</span>)&#123;</span><br><span class="line">                pos += <span class="number">3</span>-(curr%<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="2028-找出缺失的观测数据"><a href="#2028-找出缺失的观测数据" class="headerlink" title="2028. 找出缺失的观测数据"></a>2028. 找出缺失的观测数据</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>现有一份 <code>n + m</code> 次投掷单个 六面 骰子的观测数据，骰子的每个面从 <code>1</code>到 <code>6</code>编号。观测数据中缺失了 <code>n</code>份，你手上只拿到剩余 <code>m</code> 次投掷的数据。幸好你有之前计算过的这 <code>n + m</code> 次投掷数据的 平均值 。</p><p>给你一个长度为<code>m</code>的整数数组 <code>rolls</code> ，其中 <code>rolls[i]</code> 是第 <code>i</code> 次观测的值。同时给你两个整数 <code>mean</code> 和 <code>n</code>。</p><p>返回一个长度为 <code>n</code> 的数组，包含所有缺失的观测数据，且满足这 <code>n + m</code> 次投掷的 平均值 是 <code>mean</code> 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p><p><code>k</code>个数字的 平均值 为这些数字求和后再除以 <code>k</code>。</p><p>注意 <code>mean</code> 是一个整数，所以 <code>n + m</code> 次投掷的总和需要被 <code>n + m</code>整除。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], mean = <span class="number">4</span>, n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (<span class="number">3</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">6</span> + <span class="number">6</span>) / <span class="number">6</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>], mean = <span class="number">3</span>, n = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (<span class="number">1</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">2</span>) / <span class="number">7</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], mean = <span class="number">6</span>, n = <span class="number">4</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：无论丢失的 <span class="number">4</span> 次数据是什么，平均值都不可能是 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>], mean = <span class="number">3</span>, n = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">5</span>]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (<span class="number">1</span> + <span class="number">5</span>) / <span class="number">2</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示:</p><ul><li><code>m == rolls.length</code></li><li><code>1 &lt;= n, m &lt;= 105</code></li><li><code>1 &lt;= rolls[i], mean &lt;= 6</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-missing-observations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-missing-observations</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目其实非常简答，首先我们需要求出缺失的 $n$ 份数据的总和 $sum$，$sum$ 满足合法的条件为 $6 \le sum \le 6*n$.</li><li>我们可以选择任意一种方法分配即可,一种比较直接的简单方法为 $n$ 份数据中的每个元素 $nums[i] = \frac{sum}{n} + sum \mod n$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N + M)$，所有数据的总量．</li><li>空间复杂度分析: 空间复杂度为$O(N)$,其中$N$为缺失数据的长度．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; missingRolls(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rolls, <span class="keyword">int</span> mean, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = rolls.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : rolls) sum += v;</span><br><span class="line">        <span class="keyword">int</span> tot = mean*(n+m) - sum;</span><br><span class="line">        <span class="keyword">if</span>(tot &gt; <span class="number">6</span>*n || tot &lt; n) <span class="keyword">return</span> ans;</span><br><span class="line">        ans = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans[i] = tot/n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (tot%n); ++i)&#123;</span><br><span class="line">            ans[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2029-石子游戏-IX"><a href="#2029-石子游戏-IX" class="headerlink" title="2029. 石子游戏 IX"></a>2029. 石子游戏 IX</h2><p><code>Alice</code> 和 <code>Bob</code> 再次设计了一款新的石子游戏。现有一行 <code>n</code> 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code>是第 <code>i</code>个石子的价值。</p><p><code>Alice</code> 和 <code>Bob</code> 轮流进行自己的回合，<code>Alice</code> 先手。每一回合，玩家需要从 <code>stones</code> 中移除任一石子。</p><ul><li>如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 <code>3</code> 整除，那么该玩家就 输掉游戏 。</li><li>如果不满足上一条，且移除后没有任何剩余的石子，那么 <code>Bob</code>将会直接获胜（即便是在<code>Alice</code> 的回合）。<br>假设两位玩家均采用 最佳 决策。如果<code>Alice</code> 获胜，返回 <code>true</code> ；如果 <code>Bob</code> 获胜，返回 <code>false</code>。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：游戏进行如下：</span><br><span class="line">- 回合 <span class="number">1</span>：Alice 可以移除任意一个石子。</span><br><span class="line">- 回合 <span class="number">2</span>：Bob 移除剩下的石子。 </span><br><span class="line">已移除的石子的值总和为 <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> 且可以被 <span class="number">3</span> 整除。因此，Bob 输，Alice 获胜。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：Alice 会移除唯一一个石子，已移除石子的值总和为 <span class="number">2</span> 。 </span><br><span class="line">由于所有石子都已移除，且值总和无法被 <span class="number">3</span> 整除，Bob 获胜。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：</span><br><span class="line">- 回合 <span class="number">1</span>：Alice 可以移除值为 <span class="number">1</span> 的第 <span class="number">2</span> 个石子。已移除石子值总和为 <span class="number">1</span> 。</span><br><span class="line">- 回合 <span class="number">2</span>：Bob 可以移除值为 <span class="number">3</span> 的第 <span class="number">5</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br><span class="line">- 回合 <span class="number">3</span>：Alices 可以移除值为 <span class="number">4</span> 的第 <span class="number">4</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">8</span> 。</span><br><span class="line">- 回合 <span class="number">4</span>：Bob 可以移除值为 <span class="number">2</span> 的第 <span class="number">3</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">10.</span></span><br><span class="line">- 回合 <span class="number">5</span>：Alice 可以移除值为 <span class="number">5</span> 的第 <span class="number">1</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">2</span> + <span class="number">5</span> = <span class="number">15.</span></span><br><span class="line">Alice 输掉游戏，因为已移除石子值总和（<span class="number">15</span>）可以被 <span class="number">3</span> 整除，Bob 获胜。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= stones.length &lt;= 105</code></li><li><code>1 &lt;= stones[i] &lt;= 104</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stone-game-ix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-ix</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>贪心算法，每个人都会防止当前已经取得的石子总和能够被 $3$ 整除，则 $\textit{Bob}$ 和 $\textit{Alice}$ 的最优选择一定如下:</li></ol><ul><li>如果 $\textit{Alice}$ 第一次选择的是 $1$，我们暂时不考虑能被 $3$ 整除的数，则 $Bob$ 的选择一定为 $1$,紧接着 $\textit{Alice}$ 选择 $2$,$Bob$会选择 $1$,二者的选择序列一定为:$1,1,2,1,2,1,2,…$.直达无法按照上述规律继续取石头为止,而能被 $3$ 整除的数则可以在上述序列中的任意为止插入即可,因此我们只需要找到按照上述规律组成的序列的最长长度即可.如果组成的最长长度能够被 $2$ 整除,则表示 $Bob$为最后一个取,下一次轮到 $ALICE$ 取时一定会打破上述规律,导致已经取的数据的和被 $3$ 整除.</li><li>如果 $\textit{Alice}$ 第一次选择的是 $2$，我们暂时不考虑能被 $3$ 整除的数，则 $Bob$ 的选择一定为 $2$,紧接着 $\textit{Alice}$ 选择 $1$,$Bob$会选择 $2$,二者的选择序列一定为:$2,2,1,2,1,2,1,…$.直达无法按照上述规律继续取石头为止,而能被 $3$ 整除的数则可以在上述序列中的任意为止插入即可,因此我们只需要找到按照上述规律组成的序列的最长长度即可.如果组成的最长长度能够被 $2$ 整除,则表示 $Bob$为最后一个取,下一次轮到 $ALICE$ 取时一定会打破上述规律,导致已经取的数据的和被 $3$ 整除.</li><li>特殊情况需要考虑的是,假如$ALICE$ 取最后一个剩余得数,则此时$ALICE$会失败.</li><li>我们只需要按照贪心算法,如果 $\textit{Alice}$ 尝试先手取 $1$ 能够保证 $ALICE$ 一定赢,则我们直接先手取 $1$;如果 $\textit{Alice}$ 尝试先手取 $2$ 能够保证 $ALICE$ 一定赢,则我们直接先手取 $2$,</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$, 其中 $N$ 表示数组的长度.</li><li>空间复杂度为 $O(1)$, 我们只需要三个变量分别存储当前数组中.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGameIX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : stones) &#123;</span><br><span class="line">            cnt[v%<span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*first one:1121212....*/</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = min(cnt[<span class="number">1</span>]<span class="number">-1</span>,cnt[<span class="number">2</span>]);</span><br><span class="line">            maxlen = <span class="number">1</span> + a*<span class="number">2</span> + cnt[<span class="number">0</span>] + ((cnt[<span class="number">1</span>] - <span class="number">1</span>) &gt; a ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>((maxlen%<span class="number">2</span>) &amp;&amp; maxlen != n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*first two:2212121....*/</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = min(cnt[<span class="number">1</span>],cnt[<span class="number">2</span>]<span class="number">-1</span>);</span><br><span class="line">            maxlen = <span class="number">1</span> + a*<span class="number">2</span> + cnt[<span class="number">0</span>] + ((cnt[<span class="number">2</span>] - <span class="number">1</span>) &gt; a ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>((maxlen%<span class="number">2</span>) &amp;&amp; maxlen != n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2030-含特定字母的最小子序列"><a href="#2030-含特定字母的最小子序列" class="headerlink" title="2030. 含特定字母的最小子序列"></a>2030. 含特定字母的最小子序列</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，一个整数 <code>k</code> ，一个字母 <code>letter</code> 以及另一个整数 <code>repetition</code>。</p><p>返回 <code>s</code>中长度为 <code>k</code>且 字典序最小 的子序列，该子序列同时应满足字母 <code>letter</code>出现 至少 <code>repetition</code> 次。生成的测试用例满足 <code>letter</code>在 <code>s</code> 中出现 至少 <code>repetition</code> 次。</p><p>子序列 是由原字符串删除一些（或不删除）字符且不改变剩余字符顺序得到的剩余字符串。</p><p>字符串 <code>a</code> 字典序比字符串 <code>b</code> 小的定义为：在 <code>a</code> 和<code>b</code>出现不同字符的第一个位置上，字符串<code>a</code>的字符在字母表中的顺序早于字符串 b 的字符。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leet"</span>, k = <span class="number">3</span>, letter = <span class="string">"e"</span>, repetition = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"eet"</span></span><br><span class="line">解释：存在 <span class="number">4</span> 个长度为 <span class="number">3</span> ，且满足字母 'e' 出现至少 <span class="number">1</span> 次的子序列：</span><br><span class="line">- <span class="string">"lee"</span>（<span class="string">"leet"</span>）</span><br><span class="line">- <span class="string">"let"</span>（<span class="string">"leet"</span>）</span><br><span class="line">- <span class="string">"let"</span>（<span class="string">"leet"</span>）</span><br><span class="line">- <span class="string">"eet"</span>（<span class="string">"leet"</span>）</span><br><span class="line">其中字典序最小的子序列是 <span class="string">"eet"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">4</span>, letter = <span class="string">"e"</span>, repetition = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"ecde"</span></span><br><span class="line">解释：<span class="string">"ecde"</span> 是长度为 <span class="number">4</span> 且满足字母 <span class="string">"e"</span> 出现至少 <span class="number">2</span> 次的字典序最小的子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"bb"</span>, k = <span class="number">2</span>, letter = <span class="string">"b"</span>, repetition = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"bb"</span></span><br><span class="line">解释：<span class="string">"bb"</span> 是唯一一个长度为 <span class="number">2</span> 且满足字母 <span class="string">"b"</span> 出现至少 <span class="number">2</span> 次的子序列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= repetition &lt;= k &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>letter</code> 是一个小写英文字母，在 <code>s</code> 中至少出现 <code>repetition</code> 次</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们贪心算法，依次尝试 $k$个位置处所有可能的字符组合,找到索引最小且满足题目要求的组合即可.我们记录当前目标字符中已经压入到栈中的最后一个字符的索引为 $last$,我们记录当前已经压入到栈中的字符 $\textit{letter}$ 的个数,我们记录当前栈中的长度为$len$.假设我们已经找到的目标字符串的长度为 $i$, 最后一个字符的索引为 $last$,当前的目标字符串中已经包含 $\textit{letter}$ 的个数为 $repetition$,则我们在寻找第$i+1$ 个字符时,应当按照如下规则进行尝试:</li></ol><ul><li>我们从原始字符串的索引 $0$ 开始依次尝试.</li><li>我们按照字符的从小到大的顺序开始尝试,即我们从 $\texttt{‘a’}$ 到 $\texttt{‘z’}$ 开始尝试,这样才能保证字符串的字典序最小;</li><li>索引小于当前字符串的最后的索引 $last$ 的字符全部需要跳过, 这样才能保证子序列的正确顺序；</li><li>假设我们可以将当前的索引 $k$ 的字符加入到字符串中的第 $i+1$ 个字符,则必须满足以下几个条件:<ul><li>索引 $k+1$ 以后的字符串中至少还需要包含 $n - k - 1$ 个字符;</li><li>索引 $k$ 以后的字符串中至少还需要包含 $repetition$ 个$\textit{letter}$;</li><li>如果索引 $k$ 的对应的字符为 $letter$,则索引 $k+1$ 以后的字符串中至少还需要包含 $repetition-1$ 个$\textit{letter}$,且目标字符串中剩余的位置还能够满足可以放置$repetition-1$ 个字符;如果索引 $k$ 的对应的字符不为 $letter$,则索引 $k+1$ 以后的字符串中至少还需要包含 $repetition$ 个$\textit{letter}$,且目标字符串中剩余的位置还能够满足可以放置$repetition$ 个字符;</li></ul></li></ul><ol><li>非常典型的贪心算法,感觉还算非常不错的题目,值得好好思考的题目,扩展提示如何找到满足要求且字典序最大的字符串？</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(26*K + |S|)$，其中 |S| 表示字符串的长度，$K$ 表示目标字符串的长度.</li><li>空间复杂度分析: $O(K + |S|)$，其中 |S| 表示字符串的长度，$K$ 表示目标字符串的长度.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k, <span class="keyword">char</span> letter, <span class="keyword">int</span> repetition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rem(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            rem[i] = rem[i+<span class="number">1</span>] + (s[i] == letter ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; pos(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pos[s[i] - <span class="string">'a'</span>].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!pos[j].empty() &amp;&amp; pos[j].front() &lt; last) pos[j].pop();</span><br><span class="line">                <span class="comment">// 下一个索引处最少需要 need 个 letter</span></span><br><span class="line">                <span class="keyword">int</span> need = (j == letter - <span class="string">'a'</span>) ? repetition - <span class="number">1</span> : repetition;</span><br><span class="line">                <span class="keyword">if</span>(pos[j].empty() || rem[pos[j].front() + <span class="number">1</span>] &lt; need) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 剩余的字符中至少需要预留 need 个位置, 且剩余的索引中至少应该包含k - i个元素</span></span><br><span class="line">                <span class="keyword">if</span>(k - i - <span class="number">1</span> &gt;= need &amp;&amp; n - pos[j].front() &gt;= k - i) &#123;</span><br><span class="line">                    ans.push_back(<span class="string">'a'</span> + j);</span><br><span class="line">                    <span class="keyword">if</span>(j == letter - <span class="string">'a'</span>) &#123;</span><br><span class="line">                        repetition--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    last = pos[j].front();</span><br><span class="line">                    pos[j].pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-261&quot;&gt;&lt;a href=&quot;#leetcode-contest-261&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 261&quot;&gt;&lt;/a&gt;leetcode contest 261&lt;/h1&gt;&lt;p&gt;周赛题目质量非常不错，还是继续三道题的节奏。&lt;/p&gt;&lt;h2 id=&quot;2027-转换字符串的最少操作次数&quot;&gt;&lt;a href=&quot;#2027-转换字符串的最少操作次数&quot; class=&quot;headerlink&quot; title=&quot;2027. 转换字符串的最少操作次数&quot;&gt;&lt;/a&gt;2027. 转换字符串的最少操作次数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，由 &lt;code&gt;n&lt;/code&gt; 个字符组成，每个字符不是 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 就是 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;一次 操作 定义为从&lt;code&gt;s&lt;/code&gt;中选出 三个连续字符 并将选中的每个字符都转换为 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt;。注意，如果字符已经是 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt;，只需要保持 不变 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
