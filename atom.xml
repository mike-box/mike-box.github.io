<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-08-01T09:01:24.616Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 252</title>
    <link href="http://yoursite.com/2021/08/01/310/"/>
    <id>http://yoursite.com/2021/08/01/310/</id>
    <published>2021-08-01T08:00:59.210Z</published>
    <updated>2021-08-01T09:01:24.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-252"><a href="#leetcode-contest-252" class="headerlink" title="leetcode  contest 252"></a>leetcode  contest 252</h1><p>本周周赛题目放水严重，基本上都是<code>mid</code>难度而已，不过自己还是太水,不晓得积分到达2200.不过感觉参加的周赛越多，排名和积分掉落的可能性越大。<br><img src="https://i.loli.net/2021/08/01/jHsWTAZgwkRiSNY.png" alt></p><h2 id="5830-三除数"><a href="#5830-三除数" class="headerlink" title="5830. 三除数"></a>5830. 三除数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code> 。如果 <code>n</code> 恰好有三个正除数 ，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>如果存在整数 <code>k</code>，满足 <code>n = k * m</code>，那么整数<code>m</code>就是 <code>n</code> 的一个 除数 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">2</span> 只有两个除数：<span class="number">1</span> 和 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">4</span> 有三个除数：<span class="number">1</span>、<span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/three-divisors</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   直接换算</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接暴力检测除数的个数即可，算法时间复杂度为$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> isThree(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i != n / i)&#123;</span><br><span class="line">                    <span class="comment">// 此时 i 与 n / i 为不同整数</span></span><br><span class="line">                    cnt += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时 i 与 n / i 相等</span></span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5831-你可以工作的最大周数"><a href="#5831-你可以工作的最大周数" class="headerlink" title="5831. 你可以工作的最大周数"></a>5831. 你可以工作的最大周数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你 <code>n</code>个项目，编号从 0 到 <code>n - 1</code>。同时给你一个整数数组 <code>milestones</code> ，其中每个<code>milestones[i]</code>表示第 i 个项目中的阶段任务数量。</p><p>你可以按下面两个规则参与项目中的工作：</p><ul><li>每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。</li><li>在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。<br>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</li></ul><p>返回在不违反上面规则的情况下你 最多 能工作多少周。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：milestones = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">​​​​- 第 <span class="number">1</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">2</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">3</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">4</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">5</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">6</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">总周数是 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：milestones = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">- 第 <span class="number">1</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">2</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">3</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">4</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">5</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">6</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">7</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">总周数是 <span class="number">7</span> 。</span><br><span class="line">注意，你不能在第 <span class="number">8</span> 周参与完成项目 <span class="number">0</span> 中的最后一个阶段任务，因为这会违反规则。</span><br><span class="line">因此，项目 <span class="number">0</span> 中会有一个阶段任务维持未完成状态。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == milestones.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= milestones[i] &lt;= 109</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题 + 贪心算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接假设需要将相邻的两周分配成为不同的任务即可，我们采购从高到底进行分配，我们可以看到，加入数量最多的任务可以被完成，则剩余的任务一定可以被完成。</li><li>我们实际可以看到剩余的任务为$rest = sum - longest$,如果$rest &gt;= longest - 1$,我们把剩余的任务看成一组，我们可以看到总有办法可以让相邻的两个任务交替运行且不相等。</li><li>算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">numberOfWeeks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; milestones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = milestones.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        sort(milestones.begin(),milestones.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum += milestones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(milestones.back()*<span class="number">2</span> &gt; sum)&#123;</span><br><span class="line">            <span class="keyword">return</span> (sum - milestones.back())*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5187-收集足够苹果的最小花园周长"><a href="#5187-收集足够苹果的最小花园周长" class="headerlink" title="5187. 收集足够苹果的最小花园周长"></a>5187. 收集足够苹果的最小花园周长</h2><p>给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 <code>(i, j)</code>处的苹果树有<code>|i| + |j|</code>个苹果。</p><p>你将会买下正中心坐标是 <code>(0, 0)</code>的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。</p><p>给你一个整数 <code>neededApples</code>，请你返回土地的 最小周长 ，使得 至少 有 <code>neededApples</code> 个苹果在土地 里面或者边缘上。</p><p><code>|x|</code> 的值定义为：</p><p>如果 <code>x &gt;= 0</code>，那么值为 <code>x</code><br>如果 <code>x &lt; 0</code>，那么值为 <code>-x</code></p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：neededApples = <span class="number">1</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：边长长度为 <span class="number">1</span> 的正方形不包含任何苹果。</span><br><span class="line">但是边长为 <span class="number">2</span> 的正方形包含 <span class="number">12</span> 个苹果（如上图所示）。</span><br><span class="line">周长为 <span class="number">2</span> * <span class="number">4</span> = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：neededApples = <span class="number">13</span></span><br><span class="line">输出：<span class="number">16</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：neededApples = <span class="number">1000000000</span></span><br><span class="line">输出：<span class="number">5040</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= neededApples &lt;= 1015</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的数学问题，我们先观察规律求出数列的通项公式，我们设正方形的边上为$2n$,则我们可以先观察正方形右下部分的数字分布规律，当前正方形的右上方也为正方形，边长为$n$.<script type="math/tex; mode=display">0 ,1 ,2 ,3, ... ,n \\1 ,2 ,3 ,4, ... ,n+1 \\2 ,3 ,4 ,5, ... ,n+2 \\... \\n, n+1, n+2, n+3, ... ,n+n \\</script>所以我们对每一列求数列之和为:<script type="math/tex; mode=display">sum = \frac{(n+1)(0+n)}{2} + \frac{(n+1)(1+n+1)}{2}+ \frac{(n+1)(2+n+2)}{2} + ... + \frac{(n+1)(n+n+n)}{2} \\= \frac{(n+1)(\frac{(n+1)(n+3*n)}{2})}{2} \\= n*(n+1)^{2}</script>我们求出了一部分的通项和，此时我们需要相加，并减去充分的边缘。<script type="math/tex; mode=display">total = 4*n*(n+1)^{2} - 4*\frac{(n+1)*(0+n)}{2} \\= 4*n*(n+1)^{2} - 2n*(n+1) \\= 2n*(2n+1)*(n+1)</script></li><li>由<code>1</code>式我们得出通项公式，则此时我们即可利用二分查找的方式，来快速确定周长小于等于$neededApples$的正方形。</li><li>算法时间复杂度为$O(n^{\frac{1}{3}})$.</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">minimumPerimeter</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> neededApples)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">2</span>*mid*(<span class="number">2</span>*mid + <span class="number">1</span>)*(mid + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(curr &gt;= neededApples)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans*<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5833-统计特殊子序列的数目"><a href="#5833-统计特殊子序列的数目" class="headerlink" title="5833. 统计特殊子序列的数目"></a>5833. 统计特殊子序列的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>特殊序列 是由 正整数 个<code>0</code> ，紧接着 正整数 个 <code>1</code> ，最后 正整数 个 <code>2</code> 组成的序列。</p><ul><li>比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。</li><li>相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。</li><li>给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。</li></ul><p>一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：特殊子序列为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]，[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 和 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：数组 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>] 中没有特殊子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：特殊子序列包括：</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 2</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-special-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-number-of-special-subsequences</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>最后一题为简单的<code>dp</code>，感觉可能难度只有<code>mid</code>.我们设<code>dp[i][j]</code>表示前<code>i</code>个元素中组成以<code>j</code>为结尾的合法的字串的个数。则我们可以知道:</li></ol><ul><li>当<code>nums[i] == 0</code>时，则我们可以知道要么当前的<code>0</code>作为独立的字符串开始，要么当前的<code>0</code>可以加在其余为<code>0</code>为结尾的字串中，要么当前的<code>0</code>不要，此时我们可以知道:<script type="math/tex; mode=display">dp[i][0] = 1 + dp[i-1][0] + dp[i-1][0]</script></li><li>当<code>nums[i] == 1</code>时，则我们可以知道要么当前的<code>1</code>可以加在其余为<code>1</code>为结尾的字串中，要么当前的<code>1</code>加在以<code>0</code>为结尾的字串中，要么当前的<code>1</code>不要，此时我们可以知道:<script type="math/tex; mode=display">dp[i][1] = dp[i-1][1] + dp[i-1][0] + dp[i-1][1]</script></li><li>当<code>nums[i] == 2</code>时，则我们可以知道要么当前的<code>2</code>可以加在其余为<code>2</code>为结尾的字串中，要么当前的<code>2</code>加在以<code>1</code>为结尾的字串中，要么当前的<code>2</code>不要，此时我们可以知道:<script type="math/tex; mode=display">dp[i][1] = dp[i-1][2] + dp[i-1][1] + dp[i-1][2]</script></li></ul><ol><li>本身来说是非常常规的<code>dp</code>，算法时间复杂度为$O(3n)$,空间复杂度为$O(3n)$. <h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSpecialSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">0</span>] + dp[i][<span class="number">0</span>] + <span class="number">1</span>)%mod;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">1</span>] = (dp[i][<span class="number">1</span>] + dp[i][<span class="number">1</span>] + dp[i][<span class="number">0</span>])%mod;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">2</span>] = (dp[i][<span class="number">2</span>] + dp[i][<span class="number">1</span>] + dp[i][<span class="number">2</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-252&quot;&gt;&lt;a href=&quot;#leetcode-contest-252&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 252&quot;&gt;&lt;/a&gt;leetcode  contest 252&lt;/h1&gt;&lt;p&gt;本周周赛题目放水严重，基本上都是&lt;code&gt;mid&lt;/code&gt;难度而已，不过自己还是太水,不晓得积分到达2200.不过感觉参加的周赛越多，排名和积分掉落的可能性越大。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/01/jHsWTAZgwkRiSNY.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5830-三除数&quot;&gt;&lt;a href=&quot;#5830-三除数&quot; class=&quot;headerlink&quot; title=&quot;5830. 三除数&quot;&gt;&lt;/a&gt;5830. 三除数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数&lt;code&gt;n&lt;/code&gt; 。如果 &lt;code&gt;n&lt;/code&gt; 恰好有三个正除数 ，返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果存在整数 &lt;code&gt;k&lt;/code&gt;，满足 &lt;code&gt;n = k * m&lt;/code&gt;，那么整数&lt;code&gt;m&lt;/code&gt;就是 &lt;code&gt;n&lt;/code&gt; 的一个 除数 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 57</title>
    <link href="http://yoursite.com/2021/07/25/309/"/>
    <id>http://yoursite.com/2021/07/25/309/</id>
    <published>2021-07-25T06:38:08.473Z</published>
    <updated>2021-07-25T07:34:47.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-251"><a href="#leetcode-contest-251" class="headerlink" title="leetcode  contest 251"></a>leetcode  contest 251</h1><p>周赛的题目质量依然很好，最后一题还是依靠自己的思考给解出来了，感觉这才是值得自己思考的地方，叶看到了自己的进步。<br><img src="https://i.loli.net/2021/07/25/2xsDzHhLZqYRyJG.png" alt></p><h2 id="5823-字符串转化后的各位数字之和"><a href="#5823-字符串转化后的各位数字之和" class="headerlink" title="5823. 字符串转化后的各位数字之和"></a>5823. 字符串转化后的各位数字之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由小写字母组成的字符串 <code>s</code>，以及一个整数 <code>k</code> 。</p><p>首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，’a’ 用 1 替换，’b’ 用 2 替换，… ‘z’ 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。</p><a id="more"></a><p>例如，如果 <code>s = &quot;zbax&quot;</code> 且<code>k = 2</code>，那么执行下述步骤后得到的结果是整数 8 ：</p><ul><li>转化：<code>&quot;zbax&quot; ➝ &quot;(26)(2)(1)(24)&quot; ➝ &quot;262124&quot; ➝ 262124</code></li><li>转换 <code>#1：262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17</code></li><li>转换 <code>#2：17 ➝ 1 + 7 ➝ 8</code><br>返回执行上述操作后得到的结果整数。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"iiii"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">36</span></span><br><span class="line">解释：操作如下：</span><br><span class="line">- 转化：<span class="string">"iiii"</span> ➝ <span class="string">"(9)(9)(9)(9)"</span> ➝ <span class="string">"9999"</span> ➝ <span class="number">9999</span></span><br><span class="line">- 转换 #<span class="number">1</span>：<span class="number">9999</span> ➝ <span class="number">9</span> + <span class="number">9</span> + <span class="number">9</span> + <span class="number">9</span> ➝ <span class="number">36</span></span><br><span class="line">因此，结果整数为 <span class="number">36</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：操作如下：</span><br><span class="line">- 转化：<span class="string">"leetcode"</span> ➝ <span class="string">"(12)(5)(5)(20)(3)(15)(4)(5)"</span> ➝ <span class="string">"12552031545"</span> ➝ <span class="number">12552031545</span></span><br><span class="line">- 转换 #<span class="number">1</span>：<span class="number">12552031545</span> ➝ <span class="number">1</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">2</span> + <span class="number">0</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">5</span> + <span class="number">4</span> + <span class="number">5</span> ➝ <span class="number">33</span></span><br><span class="line">- 转换 #<span class="number">2</span>：<span class="number">33</span> ➝ <span class="number">3</span> + <span class="number">3</span> ➝ <span class="number">6</span></span><br><span class="line">因此，结果整数为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 10</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-digits-of-string-after-convert" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-digits-of-string-after-convert</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  直接换算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一步首先我们需要将字母全部转换为数字。</li><li>我们依次执行<code>k</code>次变换，每次对数字求和然后转换为新的字符串。算法时间复杂度为$O(nk)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLucky</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            curr = curr + to_string(c-<span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : curr)&#123;</span><br><span class="line">                sum += c - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = to_string(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5824-子字符串突变后可能得到的最大整数"><a href="#5824-子字符串突变后可能得到的最大整数" class="headerlink" title="5824. 子字符串突变后可能得到的最大整数"></a>5824. 子字符串突变后可能得到的最大整数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>num</code>，该字符串表示一个大整数。另给你一个长度为 10 且 下标从 0  开始 的整数数组 <code>change</code> ，该数组将 0-9 中的每个数字映射到另一个数字。更规范的说法是，数字 d 映射为数字 <code>change[d]</code> 。</p><p>你可以选择 突变 <code>num</code>的任一子字符串。突变 子字符串意味着将每位数字 num[i] 替换为该数字在 <code>change</code>中的映射（也就是说，将 <code>num[i]</code>替换为 <code>change[num[i]]</code>）。</p><p>请你找出在对 num 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 最大整数 ，并用字符串表示返回。</p><p>子字符串 是字符串中的一个连续序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"132"</span>, change = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="string">"832"</span></span><br><span class="line">解释：替换子字符串 <span class="string">"1"</span>：</span><br><span class="line">- <span class="number">1</span> 映射为 change[<span class="number">1</span>] = <span class="number">8</span> 。</span><br><span class="line">因此 <span class="string">"132"</span> 变为 <span class="string">"832"</span> 。</span><br><span class="line"><span class="string">"832"</span> 是可以构造的最大整数，所以返回它的字符串表示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"021"</span>, change = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="string">"934"</span></span><br><span class="line">解释：替换子字符串 <span class="string">"021"</span>：</span><br><span class="line">- <span class="number">0</span> 映射为 change[<span class="number">0</span>] = <span class="number">9</span> 。</span><br><span class="line">- <span class="number">2</span> 映射为 change[<span class="number">2</span>] = <span class="number">3</span> 。</span><br><span class="line">- <span class="number">1</span> 映射为 change[<span class="number">1</span>] = <span class="number">4</span> 。</span><br><span class="line">因此，<span class="string">"021"</span> 变为 <span class="string">"934"</span> 。</span><br><span class="line"><span class="string">"934"</span> 是可以构造的最大整数，所以返回它的字符串表示。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"5"</span>, change = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="string">"5"</span></span><br><span class="line">解释：<span class="string">"5"</span> 已经是可以构造的最大整数，所以返回它的字符串表示。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 105</code></li><li><code>num</code> 仅由数字 0-9 组成</li><li><code>change.length == 10</code></li><li><code>0 &lt;= change[d] &lt;= 9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-number-after-mutating-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-number-after-mutating-substring</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质为贪心算法，我们优先找到最左侧可以替换为较大数字的字符，直到出现当前的字符<code>c</code>比<code>change[c]</code>大为止则结束。</li><li>算法时间复杂度为$O(n)$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maximumNumber</span><span class="params">(<span class="built_in">string</span> num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; change)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">bool</span> start = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = num[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(change[x] &gt; x)&#123;</span><br><span class="line">                num[i] = change[x] + <span class="string">'0'</span>;</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(change[x] &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(start) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5825-最大兼容性评分和"><a href="#5825-最大兼容性评分和" class="headerlink" title="5825. 最大兼容性评分和"></a>5825. 最大兼容性评分和</h2><p>有一份由 n 个问题组成的调查问卷，每个问题的答案要么是 0（<code>no</code>，否），要么是 1（<code>yes</code>，是）。</p><p>这份调查问卷被分发给 <code>m</code> 名学生和 <code>m</code> 名导师，学生和导师的编号都是从 0 到 m - 1 。学生的答案用一个二维整数数组 <code>students</code>表示，其中 <code>students[i]</code>是一个整数数组，包含第 i 名学生对调查问卷给出的答案（下标从 0 开始）。导师的答案用一个二维整数数组<code>mentors</code> 表示，其中 <code>mentors[j]</code>是一个整数数组，包含第 <code>j</code> 名导师对调查问卷给出的答案（下标从 0 开始）。</p><p>每个学生都会被分配给 一名 导师，而每位导师也会分配到 一名 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。</p><ul><li>例如，学生答案为<code>[1, 0, 1]</code> 而导师答案为 <code>[0, 0, 1]</code> ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。<br>请你找出最优的学生与导师的配对方案，以 最大程度上 提高 兼容性评分和 。</li></ul><p>给你 <code>students</code> 和 <code>mentors</code> ，返回可以得到的 最大兼容性评分和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：students = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]], mentors = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：按下述方式分配学生和导师：</span><br><span class="line">- 学生 <span class="number">0</span> 分配给导师 <span class="number">2</span> ，兼容性评分为 <span class="number">3</span> 。</span><br><span class="line">- 学生 <span class="number">1</span> 分配给导师 <span class="number">0</span> ，兼容性评分为 <span class="number">2</span> 。</span><br><span class="line">- 学生 <span class="number">2</span> 分配给导师 <span class="number">1</span> ，兼容性评分为 <span class="number">3</span> 。</span><br><span class="line">最大兼容性评分和为 <span class="number">3</span> + <span class="number">2</span> + <span class="number">3</span> = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：students = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>]], mentors = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：任意学生与导师配对的兼容性评分都是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == students.length == mentors.length</code></li><li><code>n == students[i].length == mentors[j].length</code></li><li><code>1 &lt;= m, n &lt;= 8</code></li><li><code>students[i][k] 为 0 或 1</code></li><li><code>mentors[j][k] 为 0 或 1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-compatibility-score-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-compatibility-score-sum</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩<code>dp</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的状态压缩<code>dp</code>,我们用<code>dp[x][y]</code>表示<code>x</code>表示的学生的二进制位图与<code>y</code>所表示的导师的二进制位图两者进行配对时的最大值，则此时我们可以直到<code>x</code>表示的学生个数一定与<code>y</code>表示的导师的个数相等。</li><li>我们可以直到递推公式如下：<script type="math/tex; mode=display">dp[x][y] = max(dp[x][y], dp[a][b] + score[x\oplus a][y\oplus b])</script>其中<code>a</code>为<code>x</code>的子集，<code>b</code>为<code>y</code>的子集。</li><li>算法时间复杂度为$O(n^{2}<em>2^{2</em>m})$,空间复杂度为$O(2^{2m})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            x = x&amp;(x<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCompatibilitySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; students, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mentors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = students.size();</span><br><span class="line">        <span class="keyword">int</span> n = students[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span>&lt;&lt;m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(mask,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(mask));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; score(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(students[i][k] == mentors[j][k])&#123;</span><br><span class="line">                        val++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                score[i][j] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = countOne(i);</span><br><span class="line">                <span class="keyword">int</span> y = countOne(j);</span><br><span class="line">                <span class="keyword">if</span>(x != y) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; m; ++a)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; m; ++b)&#123;</span><br><span class="line">                        <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;a))&amp;&amp;(j&amp;(<span class="number">1</span>&lt;&lt;b)))&#123;</span><br><span class="line">                            <span class="keyword">int</span> cx = i&amp;(~(<span class="number">1</span>&lt;&lt;a));</span><br><span class="line">                            <span class="keyword">int</span> cy = j&amp;(~(<span class="number">1</span>&lt;&lt;b));</span><br><span class="line">                            dp[i][j] = max(dp[i][j],dp[cx][cy] + score[a][b]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[mask<span class="number">-1</span>][mask<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5826-删除系统中的重复文件夹"><a href="#5826-删除系统中的重复文件夹" class="headerlink" title="5826. 删除系统中的重复文件夹"></a>5826. 删除系统中的重复文件夹</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组<code>paths</code>，其中 <code>paths[i]</code>是一个表示文件系统中第 i 个文件夹的绝对路径的数组。</p><ul><li><p>例如，<code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code>表示路径 <code>&quot;/one/two/three&quot;</code> 。<br>如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标记 为待删除。</p></li><li><p>例如，下面文件结构中的文件夹 <code>&quot;/a&quot;</code> 和 <code>&quot;/b&quot;</code> 相同。它们（以及它们的子文件夹）应该被 全部 标记为待删除：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/a</span></span><br><span class="line"><span class="string">/a/x</span></span><br><span class="line"><span class="string">/a/x/y</span></span><br><span class="line"><span class="string">/a/z</span></span><br><span class="line"><span class="string">/b</span></span><br><span class="line"><span class="string">/b/x</span></span><br><span class="line"><span class="string">/b/x/y</span></span><br><span class="line"><span class="string">/b/z</span></span><br></pre></td></tr></table></figure></li><li>然而，如果文件结构中还包含路径 <code>&quot;/b/w&quot;</code> ，那么文件夹 <code>&quot;/a&quot;</code> 和 <code>&quot;/b&quot;</code> 就不相同。注意，即便添加了新的文件夹 <code>&quot;/b/w&quot;</code>，仍然认为 <code>&quot;/a/x&quot;</code>和 <code>&quot;/b/x&quot;</code>相同。<br>一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 删除 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。</li></ul><p>返回二维数组<code>ans</code> ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 任意顺序 返回。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"c"</span>],[<span class="string">"d"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"b"</span>],[<span class="string">"d"</span>,<span class="string">"a"</span>]]</span><br><span class="line">输出：[[<span class="string">"d"</span>],[<span class="string">"d"</span>,<span class="string">"a"</span>]]</span><br><span class="line">解释：文件结构如上所示。</span><br><span class="line">文件夹 <span class="string">"/a"</span> 和 <span class="string">"/c"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 <span class="string">"b"</span> 的空文件夹。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"c"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"b"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"x"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"w"</span>],[<span class="string">"w"</span>,<span class="string">"y"</span>]]</span><br><span class="line">输出：[[<span class="string">"c"</span>],[<span class="string">"c"</span>,<span class="string">"b"</span>],[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>]]</span><br><span class="line">解释：文件结构如上所示。</span><br><span class="line">文件夹 <span class="string">"/a/b/x"</span> 和 <span class="string">"/w"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 <span class="string">"y"</span> 的空文件夹。</span><br><span class="line">注意，文件夹 <span class="string">"/a"</span> 和 <span class="string">"/c"</span> 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>],[<span class="string">"c"</span>],[<span class="string">"a"</span>]]</span><br><span class="line">输出：[[<span class="string">"c"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>],[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>]]</span><br><span class="line">解释：文件系统中所有文件夹互不相同。</span><br><span class="line">注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"a"</span>,<span class="string">"z"</span>],[<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：文件结构如上所示。</span><br><span class="line">文件夹 <span class="string">"/a/x"</span> 和 <span class="string">"/b/x"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 <span class="string">"y"</span> 的空文件夹。</span><br><span class="line">文件夹 <span class="string">"/a"</span> 和 <span class="string">"/b"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 <span class="string">"z"</span> 的空文件夹以及上面提到的文件夹 <span class="string">"x"</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"a"</span>,<span class="string">"z"</span>],[<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>],[<span class="string">"b"</span>,<span class="string">"w"</span>]]</span><br><span class="line">输出：[[<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"w"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>],[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"z"</span>]]</span><br><span class="line">解释：本例与上例的结构基本相同，除了新增 <span class="string">"/b/w"</span> 文件夹。</span><br><span class="line">文件夹 <span class="string">"/a/x"</span> 和 <span class="string">"/b/x"</span> 仍然会被标记，但 <span class="string">"/a"</span> 和 <span class="string">"/b"</span> 不再被标记，因为 <span class="string">"/b"</span> 中有名为 <span class="string">"w"</span> 的空文件夹而 <span class="string">"/a"</span> 没有。</span><br><span class="line">注意，<span class="string">"/a/z"</span> 和 <span class="string">"/b/z"</span> 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= paths.length &lt;= 2 * 104</code></li><li><code>1 &lt;= paths[i].length &lt;= 500</code></li><li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li><li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 105</code></li><li><code>path[i][j]</code>由小写英文字母组成</li><li>不会存在两个路径都指向同一个文件夹的情况</li><li>对于不在根层级的任意文件夹，其父文件夹也会包含在输入中</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/delete-duplicate-folders-in-system" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-duplicate-folders-in-system</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS + hash</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>如果了解了题目的本意本题应该不是很难，难点在于如何序列化的编码表示一颗多叉树的子树，在此时处理中我们字符串来表示一棵二叉树，用递归来处理，假设以<code>root</code>为根的节点的多叉树的子树的字符串表示分别为$[s_{1},s_{2},s_{3},…,s{k}]$,根节点的关键字为$val$,我们编码如下：</li></ol><ul><li>以<code>root</code>为根节点的所有的子树且不包含<code>root</code>的字符串编码依次以用<code>,</code>进行相连，编码表示为:<script type="math/tex; mode=display">s_{1} , s_{2} , s_{3} .... ,s{k}</script></li><li><ul><li>以<code>root</code>为根节点的所有的子树且包含<code>root</code>的字符串编码依次以用<code>.</code>进行相连，<code>root</code>节点且包含<code>root</code>节点的子树编码表示为:<script type="math/tex; mode=display">val．s_{1}，s_{2}，s_{3} ....，s{k}</script>采用以上编码即可唯一的标识一颗多叉树，关键一点记住所有的孩子节点都按照字典序进行排序。这样可以防止乱序，但是节点还是相等。这种编码很简单，但是感觉容易出效率问题，最好还是老老实实用字符串<code>hash</code>这种快速的映射方法。</li></ul></li></ul><ol><li>我们首先读取所有的<code>path</code>，然后按照顺序进行建立二叉树；我们第一遍用<code>dfs</code>遍历二叉树，可以得到所有子树的字符串编码，此时我们进行判断，判定子树的字符串编码是否已经存在，如果已经存在，我们则认为当前根结点可以设置为待删除节点，如果不存在则我们更新字典库；最后一次<code>dfs</code>时，我们判断当前节点是否被标记，如果已经被标记，则我们直接跳过即可，依次即可得到最终去重后的树的遍历结果。</li><li>算法时间复杂度为$O(2N + NlgN)$,空间复杂度为$O(N)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> val;</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,Node *&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insertTree</span><span class="params">(Node * root,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; path)</span></span>&#123;</span><br><span class="line">        Node * node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;child.count(path[i]))&#123;</span><br><span class="line">                node-&gt;child[path[i]] = <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;child[path[i]];</span><br><span class="line">            node-&gt;val = path[i];</span><br><span class="line">            node-&gt;valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs1</span><span class="params">(Node * root,<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,Node *&gt; &amp; key)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> stree;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;child.size() == <span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : root-&gt;child)&#123;</span><br><span class="line">            stree += dfs1(v.second,key) + <span class="string">","</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key.count(stree)) &#123;</span><br><span class="line">            root-&gt;valid = <span class="literal">false</span>;</span><br><span class="line">            key[stree]-&gt;valid = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            key[stree] = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="string">"."</span> + stree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs2</span><span class="params">(Node *root,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; curr,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;valid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : root-&gt;child)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second-&gt;valid)&#123;</span><br><span class="line">                curr.push_back(v.first);</span><br><span class="line">                res.push_back(curr);</span><br><span class="line">                dfs2(v.second,curr,res);</span><br><span class="line">                curr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; deleteDuplicateFolder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = paths.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,Node *&gt; key;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr;</span><br><span class="line">       </span><br><span class="line">        Node * root = <span class="keyword">new</span> Node(); </span><br><span class="line">        root-&gt;val = <span class="string">""</span>;</span><br><span class="line">        root-&gt;valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            insertTree(root,paths[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(root,key);</span><br><span class="line">        dfs2(root,arr,ans);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-251&quot;&gt;&lt;a href=&quot;#leetcode-contest-251&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 251&quot;&gt;&lt;/a&gt;leetcode  contest 251&lt;/h1&gt;&lt;p&gt;周赛的题目质量依然很好，最后一题还是依靠自己的思考给解出来了，感觉这才是值得自己思考的地方，叶看到了自己的进步。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/25/2xsDzHhLZqYRyJG.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5823-字符串转化后的各位数字之和&quot;&gt;&lt;a href=&quot;#5823-字符串转化后的各位数字之和&quot; class=&quot;headerlink&quot; title=&quot;5823. 字符串转化后的各位数字之和&quot;&gt;&lt;/a&gt;5823. 字符串转化后的各位数字之和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由小写字母组成的字符串 &lt;code&gt;s&lt;/code&gt;，以及一个整数 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，’a’ 用 1 替换，’b’ 用 2 替换，… ‘z’ 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 57</title>
    <link href="http://yoursite.com/2021/07/24/308/"/>
    <id>http://yoursite.com/2021/07/24/308/</id>
    <published>2021-07-24T15:36:28.653Z</published>
    <updated>2021-07-24T16:11:12.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-57"><a href="#leetcode-biweekly-contest-57" class="headerlink" title="leetcode  biweekly contest 57"></a>leetcode  biweekly contest 57</h1><p>双周赛的题目还是简单啊，基本上思路都不是很复杂，又AK了一次。整体思路不是很难。<br><img src="https://i.loli.net/2021/07/25/myIAJqo7MT16ZB3.png" alt></p><h2 id="5804-检查是否所有字符出现次数相同"><a href="#5804-检查是否所有字符出现次数相同" class="headerlink" title="5804. 检查是否所有字符出现次数相同"></a>5804. 检查是否所有字符出现次数相同</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，如果 <code>s</code>是一个 好 字符串，请你返回<code>true</code>，否则请返回 <code>false</code>。</p><p>如果 <code>s</code> 中出现过的 所有 字符的出现次数 相同 ，那么我们称字符串 <code>s</code>是 好 字符串。</p><a id="more"></a><p>示例 1：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abacbc"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：s 中出现过的字符为 <span class="string">'a'</span>，<span class="string">'b'</span> 和 <span class="string">'c'</span> 。s 中所有字符均出现 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaabb"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：s 中出现过的字符为 <span class="string">'a'</span> 和 <span class="string">'b'</span> 。</span><br><span class="line"><span class="string">'a'</span> 出现了 <span class="number">3</span> 次，<span class="string">'b'</span> 出现了 <span class="number">2</span> 次，两者出现次数不同。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= s.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `s` 只包含小写英文字母。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址 </span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/maximum-number-of-words-you-can-type</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;   暴力检测</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 统计字符串中所有字符的个数即可得到结果。</span><br><span class="line"><span class="number">2.</span> 算法时间复杂度为$O(n)$,空间复杂度为$O(<span class="number">26</span>)$.</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> areOccurrencesEqual(<span class="keyword">string</span> s) &#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(auto c : s) cnt[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = cnt.begin()-&gt;second;</span><br><span class="line">        <span class="keyword">for</span>(auto v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second != x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5805-最小未被占据椅子的编号"><a href="#5805-最小未被占据椅子的编号" class="headerlink" title="5805. 最小未被占据椅子的编号"></a>5805. 最小未被占据椅子的编号</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有 n 个朋友在举办一个派对，这些朋友从 <code>0</code> 到 <code>n - 1</code>编号。派对里有 无数 张椅子，编号为 0 到<code>infinity</code>。当一个朋友到达派对时，他会占据 编号最小 且未被占据的椅子。</p><p>比方说，当一个朋友到达时，如果椅子 <code>0</code> ，<code>1</code>和 <code>5</code>被占据了，那么他会占据 2 号椅子。<br>当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。</p><p>给你一个下标从 0 开始的二维整数数组 <code>times</code>，其中<code>times[i] = [arrivali, leavingi]</code>表示第 i 个朋友到达和离开的时刻，同时给你一个整数 targetFriend 。所有到达时间 互不相同 。</p><p>请你返回编号为 <code>targetFriend</code> 的朋友占据的 椅子编号 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：times = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">6</span>]], targetFriend = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">1</span> 到达，占据椅子 <span class="number">0</span> 。</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">2</span> 到达，占据椅子 <span class="number">1</span> 。</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">3</span> 离开，椅子 <span class="number">1</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">4</span> 离开，椅子 <span class="number">0</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">2</span> 时刻 <span class="number">4</span> 到达，占据椅子 <span class="number">0</span> 。</span><br><span class="line">朋友 <span class="number">1</span> 占据椅子 <span class="number">1</span> ，所以返回 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">输入：times = [[<span class="number">3</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>]], targetFriend = <span class="number">0</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">1</span> 到达，占据椅子 <span class="number">0</span> 。</span><br><span class="line">- 朋友 <span class="number">2</span> 时刻 <span class="number">2</span> 到达，占据椅子 <span class="number">1</span> 。</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">3</span> 到达，占据椅子 <span class="number">2</span> 。</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">5</span> 离开，椅子 <span class="number">0</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">2</span> 时刻 <span class="number">6</span> 离开，椅子 <span class="number">1</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">10</span> 离开，椅子 <span class="number">2</span> 变成未占据。</span><br><span class="line">朋友 <span class="number">0</span> 占据椅子 <span class="number">2</span> ，所以返回 <span class="number">2</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == times.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">104</span>`</span><br><span class="line">+ `times[i].length == <span class="number">2</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= arrivali &lt; leavingi &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= targetFriend &lt;= n - <span class="number">1</span>`</span><br><span class="line">+ 每个 `arrivali` 时刻 互不相同 。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/add-minimum-number-of-rungs</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  贪心 + 优先级队列</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 仔细观察题目，基本就是套路的优先级队列，我们设两个优先级队列，队列`<span class="number">1</span>`保存当前空闲的椅子的编号，并按照标号从小到大排列我们每次可以从队列中取得标号最小的椅子；队列`<span class="number">2</span>`保存当前已经已经占用的椅子的标号，按照椅子释放的时间先后进行排序，我们每次可以取得当前最近会被释放的椅子的编号。</span><br><span class="line"><span class="number">2.</span> 我们首先将所有的朋友按照到达时间的先后进行排序，每次排序完成后，我们每次从队列`<span class="number">1</span>`中取椅子之前，首先将队列`<span class="number">2</span>`中所有释放时间小于等于当前达到时间的椅子全部出队列，并将这些已经释放椅子的编号放入到队列`<span class="number">1</span>`中；然后我们再从队列中取出编号最小的椅子，同时将该椅子的释放时间进入到队列`<span class="number">2</span>`中。按照如上贪心算法即可得到最优结果。</span><br><span class="line"><span class="number">3.</span> 算法时间复杂度为$O(<span class="number">2</span>*(n + nlgn))$,空间复杂度为$O(<span class="number">2</span>n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line">struct cmp&#123;</span><br><span class="line">    <span class="built_in">bool</span> operator()(pii &amp; a,pii &amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> smallestChair(vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; times, <span class="built_in">int</span> targetFriend) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;<span class="built_in">int</span>,vector&lt;<span class="built_in">int</span>&gt;,greater&lt;<span class="built_in">int</span>&gt;&gt; pq1;</span><br><span class="line">        priority_queue&lt;pii,vector&lt;pii&gt;,cmp&gt; pq2;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> n = times.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            times[i].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(times.begin(),times.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) pq1.push(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!pq2.empty() &amp;&amp; pq2.top().first &lt;= times[i][<span class="number">0</span>])&#123;</span><br><span class="line">                pq1.push(pq2.top().second);</span><br><span class="line">                pq2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> x = pq1.top();</span><br><span class="line">            <span class="keyword">if</span>(targetFriend == times[i][<span class="number">2</span>]) ans = x;</span><br><span class="line">            pq1.pop();</span><br><span class="line">            pq2.push(make_pair(times[i][<span class="number">1</span>],x));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5806-描述绘画结果"><a href="#5806-描述绘画结果" class="headerlink" title="5806. 描述绘画结果"></a>5806. 描述绘画结果</h2><p>给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有 独一无二 的颜色。给你二维整数数组<code>segments</code>，其中 <code>segments[i] = [starti, endi, colori]</code>表示线段为 半开区间 <code>[starti, endi)</code>且颜色为 <code>colori</code> 。</p><p>线段间重叠部分的颜色会被 混合 。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个 集合 表示这个混合颜色。</p><p>比方说，如果颜色 2 ，4 和 6 被混合，那么结果颜色为 <code>{2,4,6}</code>。<br>为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的 和 来表示颜色集合。</p><p>你想要用 最少数目 不重叠 半开区间 来 表示 这幅混合颜色的画。这些线段可以用二维数组 <code>painting</code>表示，其中<code>painting[j] = [leftj, rightj, mixj]</code> 表示一个 半开区间<code>[leftj, rightj)</code> 的颜色 和 为 <code>mixj</code> 。</p><p>比方说，这幅画由 <code>segments = [[1,4,5],[1,7,7]]</code>组成，那么它可以表示为 <code>painting = [[1,4,12],[4,7,7]]</code> ，因为：<br>[1,4) 由颜色 {5,7} 组成（和为 12），分别来自第一个线段和第二个线段。<br>[4,7) 由颜色 {7} 组成，来自第二个线段。<br>请你返回二维数组<code>painting</code>，它表示最终绘画的结果（没有 被涂色的部分不出现在结果中）。你可以按 任意顺序 返回最终数组的结果。</p><p>半开区间 <code>[a, b)</code> 是数轴上点 <code>a</code>和点<code>b</code>之间的部分，包含 点 a 且 不包含 点 b 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：segments = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">14</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">16</span>]]</span><br><span class="line">解释：绘画借故偶可以表示为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">4</span>) 颜色为 &#123;<span class="number">5</span>,<span class="number">9</span>&#125; （和为 <span class="number">14</span>），分别来自第一和第二个线段。</span><br><span class="line">- [<span class="number">4</span>,<span class="number">7</span>) 颜色为 &#123;<span class="number">7</span>,<span class="number">9</span>&#125; （和为 <span class="number">16</span>），分别来自第二和第三个线段。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：segments = [[<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>],[<span class="number">6</span>,<span class="number">8</span>,<span class="number">15</span>],[<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">24</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>],[<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>]]</span><br><span class="line">解释：绘画结果可以以表示为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">6</span>) 颜色为 <span class="number">9</span> ，来自第一个线段。</span><br><span class="line">- [<span class="number">6</span>,<span class="number">7</span>) 颜色为 &#123;<span class="number">9</span>,<span class="number">15</span>&#125; （和为 <span class="number">24</span>），来自第一和第二个线段。</span><br><span class="line">- [<span class="number">7</span>,<span class="number">8</span>) 颜色为 <span class="number">15</span> ，来自第二个线段。</span><br><span class="line">- [<span class="number">8</span>,<span class="number">10</span>) 颜色为 <span class="number">7</span> ，来自第三个线段。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：segments = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">12</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">12</span>]]</span><br><span class="line">解释：绘画结果可以表示为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">4</span>) 颜色为 &#123;<span class="number">5</span>,<span class="number">7</span>&#125; （和为 <span class="number">12</span>），分别来自第一和第二个线段。</span><br><span class="line">- [<span class="number">4</span>,<span class="number">7</span>) 颜色为 &#123;<span class="number">1</span>,<span class="number">11</span>&#125; （和为 <span class="number">12</span>），分别来自第三和第四个线段。</span><br><span class="line">注意，只返回一个单独的线段 [<span class="number">1</span>,<span class="number">7</span>) 是不正确的，因为混合颜色的集合不相同。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= segments.length &lt;= 2 * 104</code></li><li><code>segments[i].length == 3</code></li><li><code>1 &lt;= starti &lt; endi &lt;= 105</code></li><li><code>1 &lt;= colori &lt;= 109</code></li><li>每种颜色 <code>colori</code>互不相同。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-points-with-cost" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-points-with-cost</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 差分数组</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的差分数组题目。感觉看到类似的线段区间的题目基本上都可以用差分数组搞定。跟求区间内重合的线段的次数基本上一样的题目。</li><li>我们将区间进行标记，对于区间的左端点则标记为$colori$,区间的右端点标记为$-colori$,当我们到达一个新的区间的左端点时，则此时和肯定会增加，在区间右端点时则减去该线段的贡献。基本上就是套路题目吧。</li><li>因为用了<code>map</code>，所以时间复杂度为$O(nlg)$，用数组的话时间复杂度可以优化到$O(n)$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; splitPainting(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; segments) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = segments.size();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cnt[segments[i][<span class="number">0</span>]].push_back(segments[i][<span class="number">2</span>]);</span><br><span class="line">            cnt[segments[i][<span class="number">1</span>]].push_back(-segments[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            l = r;</span><br><span class="line">            r = v.first;</span><br><span class="line">            <span class="keyword">if</span>(l &gt; <span class="number">0</span> &amp;&amp; sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr = &#123;l,r,sum&#125;;</span><br><span class="line">                ans.push_back(arr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : v.second)&#123;</span><br><span class="line">                sum += x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5196-队列中可以看到的人数"><a href="#5196-队列中可以看到的人数" class="headerlink" title="5196. 队列中可以看到的人数"></a>5196. 队列中可以看到的人数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有 <code>n</code> 个人排成一个队列，从左到右 编号为 0 到 <code>n - 1</code>。给你以一个整数数组 <code>heights</code> ，每个整数 互不相同，<code>heights[i]</code> 表示第 i 个人的高度。</p><p>一个人能 看到 他右边另一个人的条件是这两人之间的所有人都比他们两人 矮 。更正式的，第 i 个人能看到第 j 个人的条件是 <code>i &lt; j</code> 且<code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>。</p><p>请你返回一个长度为 n 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 i 个人在他右侧队列中能 看到 的 人数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">10</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 个人能看到编号为 <span class="number">1</span> ，<span class="number">2</span> 和 <span class="number">4</span> 的人。</span><br><span class="line">第 <span class="number">1</span> 个人能看到编号为 <span class="number">2</span> 的人。</span><br><span class="line">第 <span class="number">2</span> 个人能看到编号为 <span class="number">3</span> 和 <span class="number">4</span> 的人。</span><br><span class="line">第 <span class="number">3</span> 个人能看到编号为 <span class="number">4</span> 的人。</span><br><span class="line">第 <span class="number">4</span> 个人能看到编号为 <span class="number">5</span> 的人。</span><br><span class="line">第 <span class="number">5</span> 个人谁也看不到因为他右边没人。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == heights.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= heights[i] &lt;= <span class="number">105</span>`</span><br><span class="line">+ `heights` 中所有数 互不相同 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-57/problems/number-of-visible-people-in-a-queue/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  单调栈</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 典型的单调栈，不过稍微复杂一点，需要稍微处理.由于我们用单调栈保存右边身高的人，并按照从小到大进行排列。我们每次将找到第一个大于等于当前的人的高度的人，则我们记数当前从队列中弹出的人数加`<span class="number">1</span>`即为可以看见的人数。比赛的时候竟然很搓的二分查找搞定。</span><br><span class="line"><span class="number">2.</span> 时间复杂度为$O(N)$,空间复杂为$O(N)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; canSeePersonsCount(vector&lt;<span class="built_in">int</span>&gt;&amp; heights) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = heights.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        arr.push_back(heights[n<span class="number">-1</span>]);</span><br><span class="line">        ans[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!arr.empty() &amp;&amp; heights[i] &gt;= arr.back())&#123;</span><br><span class="line">                ans[i]++;</span><br><span class="line">                arr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!arr.empty()) ans[i]++;</span><br><span class="line">            arr.push_back(heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-57&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-57&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 57&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 57&lt;/h1&gt;&lt;p&gt;双周赛的题目还是简单啊，基本上思路都不是很复杂，又AK了一次。整体思路不是很难。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/25/myIAJqo7MT16ZB3.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5804-检查是否所有字符出现次数相同&quot;&gt;&lt;a href=&quot;#5804-检查是否所有字符出现次数相同&quot; class=&quot;headerlink&quot; title=&quot;5804. 检查是否所有字符出现次数相同&quot;&gt;&lt;/a&gt;5804. 检查是否所有字符出现次数相同&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，如果 &lt;code&gt;s&lt;/code&gt;是一个 好 字符串，请你返回&lt;code&gt;true&lt;/code&gt;，否则请返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果 &lt;code&gt;s&lt;/code&gt; 中出现过的 所有 字符的出现次数 相同 ，那么我们称字符串 &lt;code&gt;s&lt;/code&gt;是 好 字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 250</title>
    <link href="http://yoursite.com/2021/07/18/307/"/>
    <id>http://yoursite.com/2021/07/18/307/</id>
    <published>2021-07-18T06:22:38.780Z</published>
    <updated>2021-07-18T11:48:23.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-250"><a href="#leetcode-contest-250" class="headerlink" title="leetcode  contest  250"></a>leetcode  contest  250</h1><p>周赛的题目质量还是非常高，还是前3题，不过第三题竟然用了最复杂的线段树搞定。真心是。<br><img src="https://i.loli.net/2021/07/18/Jlbu3VOKG9SYHrE.png" alt></p><h2 id="5161-可以输入的最大单词数"><a href="#5161-可以输入的最大单词数" class="headerlink" title="5161. 可以输入的最大单词数"></a>5161. 可以输入的最大单词数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。</p><p>给你一个由若干单词组成的字符串 <code>text</code> ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 <code>brokenLetters</code> ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 <code>text</code> 中单词的数目。</p><a id="more"></a><p>示例 1：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"hello world"</span>, brokenLetters = <span class="string">"ad"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：无法输入 <span class="string">"world"</span> ，因为字母键 <span class="string">'d'</span> 已损坏。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"leet code"</span>, brokenLetters = <span class="string">"lt"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：无法输入 <span class="string">"leet"</span> ，因为字母键 <span class="string">'l'</span> 和 <span class="string">'t'</span> 已损坏。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"leet code"</span>, brokenLetters = <span class="string">"e"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无法输入任何单词，因为字母键 <span class="string">'e'</span> 已损坏。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= text.length &lt;= 104</code></li><li><code>0 &lt;= brokenLetters.length &lt;= 26</code></li><li><code>text</code> 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格</li><li>每个单词仅由小写英文字母组成</li><li><code>brokenLetters</code> 由 互不相同 的小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-words-you-can-type" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-words-you-can-type</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>通过split函数分离出单词，然后依次检验每个单词是否合法即可统计出合法的单词数目。</li><li>算法时间复杂度为$O(n)$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">string</span> &amp; str)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; str.size() &amp;&amp; str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = i;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; str.size() &amp;&amp; str[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; curr)&#123;</span><br><span class="line">                ans.push_back(str.substr(curr,i-curr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canBeTypedWords</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">string</span> brokenLetters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; valid(<span class="number">26</span>,<span class="literal">true</span>);        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; curr = split(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : brokenLetters)&#123;</span><br><span class="line">            valid[c-<span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curr[i].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!valid[curr[i][j]-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                    isValid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5814-新增的最少台阶数"><a href="#5814-新增的最少台阶数" class="headerlink" title="5814. 新增的最少台阶数"></a>5814. 新增的最少台阶数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 严格递增 的整数数组 <code>rungs</code> ，用于表示梯子上每一台阶的 高度 。当前你正站在高度为 0 的地板上，并打算爬到最后一个台阶。</p><p>另给你一个整数 <code>dist</code> 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）不超过 <code>dist</code> 高度的台阶。当然，你也可以在任何正 整数 高度处插入尚不存在的新台阶。</p><p>返回爬到最后一阶时必须添加到梯子上的 最少 台阶数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>], dist = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">现在无法到达最后一阶。</span><br><span class="line">在高度为 <span class="number">7</span> 和 <span class="number">8</span> 的位置增设新的台阶，以爬上梯子。 </span><br><span class="line">梯子在高度为 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>] 的位置上有台阶。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>], dist = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">这个梯子无需增设新台阶也可以爬上去。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], dist = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">现在无法从地板到达梯子的第一阶。 </span><br><span class="line">在高度为 <span class="number">1</span> 的位置增设新的台阶，以爬上梯子。 </span><br><span class="line">梯子在高度为 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>] 的位置上有台阶。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">5</span>], dist = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：这个梯子无需增设新台阶也可以爬上去。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= rungs.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= rungs[i] &lt;= <span class="number">109</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= dist &lt;= <span class="number">109</span>`</span><br><span class="line">+ `rungs` 严格递增</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/add-minimum-number-of-rungs</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  贪心算法</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接模拟即可，题目要求两个台阶的高度不超过`dist`，则我们可以知道根据贪心算法，我们应该尽可能的跨向高度更高的梯子，$x$与$y$两者之间所需要加的梯子即为向下取整即可，$\frac&#123;y-x<span class="number">-1</span>&#125;&#123;dist&#125;$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> addRungs(vector&lt;<span class="built_in">int</span>&gt;&amp; rungs, <span class="built_in">int</span> dist) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = rungs.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += (rungs[i] - h <span class="number">-1</span>)/dist;</span><br><span class="line">            h = rungs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5815-扣分后的最大得分"><a href="#5815-扣分后的最大得分" class="headerlink" title="5815. 扣分后的最大得分"></a>5815. 扣分后的最大得分</h2><p>给你一个 <code>m x n</code>的整数矩阵 <code>points</code> （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。</p><p>你的得分方式为：每一行 中选取一个格子，选中坐标为 <code>(r, c)</code>的格子会给你的总得分 增加 <code>points[r][c]</code> 。</p><p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code>和 <code>r + 1</code> （其中 <code>0 &lt;= r &lt; m - 1</code>），选中坐标为 <code>(r, c1)</code>和 <code>(r + 1, c2)</code>的格子，你的总得分 减少 <code>abs(c1 - c2)</code>。</p><p>请你返回你能得到的 最大 得分。</p><p><code>abs(x)</code> 定义为：</p><ul><li>如果 <code>x &gt;= 0</code>，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：</span><br><span class="line">蓝色格子是最优方案选中的格子，坐标分别为 (<span class="number">0</span>, <span class="number">2</span>)，(<span class="number">1</span>, <span class="number">1</span>) 和 (<span class="number">2</span>, <span class="number">0</span>) 。</span><br><span class="line">你的总得分增加 <span class="number">3</span> + <span class="number">5</span> + <span class="number">3</span> = <span class="number">11</span> 。</span><br><span class="line">但是你的总得分需要扣除 abs(<span class="number">2</span> - <span class="number">1</span>) + abs(<span class="number">1</span> - <span class="number">0</span>) = <span class="number">2</span> 。</span><br><span class="line">你的最终得分为 <span class="number">11</span> - <span class="number">2</span> = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：</span><br><span class="line">蓝色格子是最优方案选中的格子，坐标分别为 (<span class="number">0</span>, <span class="number">1</span>)，(<span class="number">1</span>, <span class="number">1</span>) 和 (<span class="number">2</span>, <span class="number">0</span>) 。</span><br><span class="line">你的总得分增加 <span class="number">5</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">12</span> 。</span><br><span class="line">但是你的总得分需要扣除 abs(<span class="number">1</span> - <span class="number">1</span>) + abs(<span class="number">1</span> - <span class="number">0</span>) = <span class="number">1</span> 。</span><br><span class="line">你的最终得分为 <span class="number">12</span> - <span class="number">1</span> = <span class="number">11</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == points.length</code></li><li><code>n == points[r].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>0 &lt;= points[r][c] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-points-with-cost" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-points-with-cost</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划<code>dp</code>.</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划<code>dp</code>，我们如果直接利用动态规划转移方程，则会超时，时间复杂度为$O(m*n^{2})$,应该如何优化利用前缀，我们可以知道递推公式为:<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j],max(dp[i-1][k] - k) + points[i][j]) \quad (k\le j) \\dp[i][j] = max(dp[i][j],max(dp[i-1][k] - (n-1-k)) + points[i][j]) \quad (k\ge j) \\</script></li><li>我们利用前缀，可以快速的求出前<code>k</code>项中的$(dp[i-1][k] - k)$的最大值，同时可以利用后缀快速的求出后$n-k$项中的$dp[i-1][k] - (n-1-k)$的最大值。</li><li>时间复杂度为$O(m*n)$,空间复杂度为$O(n)$.比赛中竟然用了坑爹的线段树，快速的把这个题搞定，还是没有仔细思考到点，本来是很简单的题目,线段树只能说真心是利器什么题目都可以搞定。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = points.size();</span><br><span class="line">        <span class="keyword">int</span> col = points[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(col,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp(col,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> maxCurr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                maxCurr = max(maxCurr,dp[j]);</span><br><span class="line">                ndp[j] = max(ndp[j],maxCurr + points[i][j]);</span><br><span class="line">                maxCurr--;</span><br><span class="line">            &#125;</span><br><span class="line">            maxCurr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                maxCurr = max(maxCurr,dp[j]);</span><br><span class="line">                ndp[j] = max(ndp[j],maxCurr + points[i][j]);</span><br><span class="line">                maxCurr--;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> add;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2 + 1)</span></span><br><span class="line"></span><br><span class="line">segTreeNode tree[MAXN*<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lmax = tree[CHL(idx)].val + tree[CHL(idx)].add;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rmax = tree[CHR(idx)].val + tree[CHR(idx)].add;</span><br><span class="line">    tree[idx].val = max(lmax,rmax);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp; arr)</span></span>&#123;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[idx].l = l;</span><br><span class="line">        tree[idx].r = r;</span><br><span class="line">        tree[idx].val = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(CHL(idx),l,mid,arr);</span><br><span class="line">    buildTree(CHR(idx),mid+<span class="number">1</span>,r,arr);</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">addTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt; l) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt;= l &amp;&amp; tree[idx].r &lt;= r)&#123;</span><br><span class="line">        tree[idx].add += val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        addTree(CHL(idx),l,r,val);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        addTree(CHR(idx),l,r,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        addTree(CHL(idx),l,mid,val);</span><br><span class="line">        addTree(CHR(idx),mid+<span class="number">1</span>,r,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt;= l &amp;&amp; tree[idx].r &lt;= r) <span class="keyword">return</span> tree[idx].val + tree[idx].add;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(CHL(idx),l,r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(CHR(idx),l,r);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lmax = queryTree(CHL(idx),l,mid);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rmax = queryTree(CHR(idx),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> max(lmax,rmax) + tree[idx].add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = points.size();</span><br><span class="line">        <span class="keyword">int</span> col = points[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = points[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; curr = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                curr[j] -= j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(tree,<span class="number">0</span>,col*<span class="number">4</span>);</span><br><span class="line">            buildTree(<span class="number">1</span>,<span class="number">0</span>,col<span class="number">-1</span>,curr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                dp[i][j] = queryTree(<span class="number">1</span>,<span class="number">0</span>,col<span class="number">-1</span>) + points[i][j];</span><br><span class="line">                addTree(<span class="number">1</span>,<span class="number">0</span>,j,<span class="number">-1</span>);</span><br><span class="line">                addTree(<span class="number">1</span>,j+<span class="number">1</span>,col<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[row<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5816-查询最大基因差"><a href="#5816-查询最大基因差" class="headerlink" title="5816. 查询最大基因差"></a>5816. 查询最大基因差</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵 n 个节点的有根树，节点编号从 <code>0</code> 到 <code>n - 1</code>。每个节点的编号表示这个节点的 独一无二的基因值 （也就是说节点<code>x</code> 的基因值为 x）。两个基因值的 基因差 是两者的 异或和 。给你整数数组 <code>parents</code>，其中 <code>parents[i]</code>是节点 i 的父节点。如果节点 x 是树的 根 ，那么 <code>parents[x] == -1</code> 。</p><p>给你查询数组<code>queries</code> ，其中 <code>queries[i] = [nodei, vali]</code> 。对于查询<code>i</code>，请你找到 <code>vali</code> 和 <code>pi</code> 的 最大基因差 ，其中 <code>pi</code> 是节点<code>nodei</code>到根之间的任意节点（包含 <code>nodei</code> 和根节点）。更正式的，你想要最大化 <code>vali XOR pi</code> 。</p><p>请你返回数组 <code>ans</code>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], queries = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">解释：查询数组处理如下：</span><br><span class="line">- [<span class="number">0</span>,<span class="number">2</span>]：最大基因差的对应节点为 <span class="number">0</span> ，基因差为 <span class="number">2</span> XOR <span class="number">0</span> = <span class="number">2</span> 。</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>]：最大基因差的对应节点为 <span class="number">1</span> ，基因差为 <span class="number">2</span> XOR <span class="number">1</span> = <span class="number">3</span> 。</span><br><span class="line">- [<span class="number">2</span>,<span class="number">5</span>]：最大基因差的对应节点为 <span class="number">2</span> ，基因差为 <span class="number">5</span> XOR <span class="number">2</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>], queries = [[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">15</span>],[<span class="number">0</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>]</span><br><span class="line">解释：查询数组处理如下：</span><br><span class="line">- [<span class="number">4</span>,<span class="number">6</span>]：最大基因差的对应节点为 <span class="number">0</span> ，基因差为 <span class="number">6</span> XOR <span class="number">0</span> = <span class="number">6</span> 。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">15</span>]：最大基因差的对应节点为 <span class="number">1</span> ，基因差为 <span class="number">15</span> XOR <span class="number">1</span> = <span class="number">14</span> 。</span><br><span class="line">- [<span class="number">0</span>,<span class="number">5</span>]：最大基因差的对应节点为 <span class="number">2</span> ，基因差为 <span class="number">5</span> XOR <span class="number">2</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= parents.length &lt;= 105</code></li><li>对于每个 不是 根节点的 <code>i</code> ，有 <code>0 &lt;= parents[i] &lt;= parents.length - 1</code> 。</li><li><code>parents[root] == -1</code></li><li><code>1 &lt;= queries.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nodei &lt;= parents.length - 1</code></li><li><code>0 &lt;= vali &lt;= 2 * 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-genetic-difference-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-genetic-difference-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS + Trie树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目类似的题目见过，跟<code>google kickstart 2021 roundB</code>的$D$题非常像，感觉难度并不是很大。并且基本上一看到求异或最大值的题目，基本上可以肯定是需要用<code>trie</code>树的结构的。</li><li>我们首先将所有的查询离线化处理，即保存当前节点的所有查询。我们通过从根节点开始<code>dfs</code>遍历，每遍历一个节点<code>x</code>，则我们将节点<code>x</code>的值加入到<code>trie</code>树中，当遍历到当前节点<code>node</code>时，我们利用<code>trie</code>树去查询，跟节点<code>node</code>相关的值$val$进行查询,我们利用<code>dfs</code>遍历，每退出一个节点<code>x</code>时，则将<code>x</code>从<code>trie</code>树中删除。</li><li>本题的难点在于如何从<code>trie</code>中删除一个值<code>val</code>，这时就需要一点技巧来处理，我们为每个<code>trie</code>节点增加一个<code>count</code>的值，利用<code>count</code>记录以当前节点为根的子数下存在有多少个值。我们每次在节点<code>node</code>下增加一个<code>val</code>时，则我们将<code>count + 1</code>;我们每次在节点<code>node</code>下删除一个<code>val</code>时，则我们将<code>count - 1</code>。如果发现<code>count = 0</code>则我们直接将该节点<code>node</code>从树中删除即可。</li><li>空间复杂度为$O((N + Q)*32)$,空间复杂度为$(N + Q + 2^{K})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">31</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    TrieNode * next[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertTrie</span><span class="params">(TrieNode * root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;next[idx])&#123;</span><br><span class="line">            node-&gt;next[idx] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;cnt++;</span><br><span class="line">        node = node-&gt;next[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;cnt++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eraseTrie</span><span class="params">(TrieNode * root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    node-&gt;cnt--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        node = node-&gt;next[idx];</span><br><span class="line">        node-&gt;cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next[idx]-&gt;cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            node-&gt;next[idx] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchTrie</span><span class="params">(TrieNode * root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next[<span class="number">1</span>^idx])&#123;</span><br><span class="line">            node = node-&gt;next[<span class="number">1</span>^idx];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = node-&gt;next[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,TrieNode * trie,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; graph,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; cnt,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(root))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y] : cnt[root])&#123;</span><br><span class="line">                ans[x] = y^searchTrie(trie,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[root])&#123;</span><br><span class="line">            insertTrie(trie,v);</span><br><span class="line">            dfs(v,trie,graph,cnt,ans);</span><br><span class="line">            eraseTrie(trie,v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxGeneticDifference(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parents, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = parents.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); ++i)&#123;</span><br><span class="line">            cnt[queries[i][<span class="number">0</span>]].push_back(&#123;i,queries[i][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parents[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                graph[parents[i]].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TrieNode * trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        insertTrie(trie,root);</span><br><span class="line">        dfs(root,trie,graph,cnt,ans);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-250&quot;&gt;&lt;a href=&quot;#leetcode-contest-250&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  250&quot;&gt;&lt;/a&gt;leetcode  contest  250&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是非常高，还是前3题，不过第三题竟然用了最复杂的线段树搞定。真心是。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/18/Jlbu3VOKG9SYHrE.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5161-可以输入的最大单词数&quot;&gt;&lt;a href=&quot;#5161-可以输入的最大单词数&quot; class=&quot;headerlink&quot; title=&quot;5161. 可以输入的最大单词数&quot;&gt;&lt;/a&gt;5161. 可以输入的最大单词数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。&lt;/p&gt;&lt;p&gt;给你一个由若干单词组成的字符串 &lt;code&gt;text&lt;/code&gt; ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 &lt;code&gt;brokenLetters&lt;/code&gt; ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 &lt;code&gt;text&lt;/code&gt; 中单词的数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Kickstart】 Kickstart 2021 roundD</title>
    <link href="http://yoursite.com/2021/07/14/306/"/>
    <id>http://yoursite.com/2021/07/14/306/</id>
    <published>2021-07-14T14:28:50.732Z</published>
    <updated>2021-07-16T05:19:50.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kickstart-2021-roundD"><a href="#kickstart-2021-roundD" class="headerlink" title="kickstart 2021 roundD"></a>kickstart 2021 roundD</h1><p><code>kick start</code>的题目质量非常高，感觉前三题没有问题，自己可以确定前三题做出来。前两题做出来了，后来因为有事，三四题就没有做。第三题不用看解答就能干出来。<br><img src="https://i.loli.net/2021/07/16/K4dX5Q7H2qkVMEr.png" alt></p><h2 id="Arithmetic-Square"><a href="#Arithmetic-Square" class="headerlink" title="Arithmetic Square"></a>Arithmetic Square</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/07/14/fZaIpsXUNkRwHCv.png" alt></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813</a></p><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一题比较简单，大意就是给定一个<code>3x3</code>的矩阵，求问修改最中间的数，使得上下和对角线的三个数字组成的等差序列最多。暴力尝试所有可能的等差数列即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; matrix(<span class="number">3</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;matrix[<span class="number">0</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">0</span>][<span class="number">1</span>]&gt;&gt;matrix[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;matrix[<span class="number">1</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;matrix[<span class="number">2</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">2</span>][<span class="number">1</span>]&gt;&gt;matrix[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">0</span>][<span class="number">1</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>]) == (matrix[<span class="number">0</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">1</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">2</span>][<span class="number">1</span>] - matrix[<span class="number">2</span>][<span class="number">0</span>]) == (matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">2</span>][<span class="number">1</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">1</span>][<span class="number">0</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>]) == (matrix[<span class="number">2</span>][<span class="number">0</span>] - matrix[<span class="number">1</span>][<span class="number">0</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">1</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">2</span>]) == (matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">1</span>][<span class="number">2</span>])) ans++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = matrix[<span class="number">1</span>][<span class="number">2</span>] - matrix[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[a/<span class="number">2</span> + matrix[<span class="number">1</span>][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = matrix[<span class="number">2</span>][<span class="number">1</span>] - matrix[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[b/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">1</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(c%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[c/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = matrix[<span class="number">2</span>][<span class="number">0</span>] - matrix[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(d%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[d/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">2</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        curr = max(curr,v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += curr;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Cutting-Intervals"><a href="#Cutting-Intervals" class="headerlink" title="Cutting Intervals"></a>Cutting Intervals</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/07/14/r3pNfjUB9gtw6TE.png" alt></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b933" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b933</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 差分数组 + 贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>给定一系列的二维空间中的线段，在限定的切割操作中，求问最多可以把这些线段切成多少段？</li><li>我们可以参考线段的切割情况如下：<br><img src="https://i.loli.net/2021/07/16/uNaOd3vMG4fDtXi.png" alt><br>我们可以看到可以利用查分数组，即可计算连续的区间内每切一次可以增加多少条线段，我们设区间$[x,y]$总共有<code>d</code>条线段重合，则我们首先可以知道在区间$[x+1,y-1]$我们每切割一次则可以增加<code>d</code>条线段，但在区间两个端点处需要特殊处理，我们此时需要判断在点$y$处需要特殊处理，因为端点处；我们首先讲可以进行切割的区间加入到待选队列中，并按照重合的次数进行排序。但是我们需要注意的是区间的右端点，需要将右端点为结束端点的线段去掉。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">__</span>|<span class="string">__</span>|<span class="string">________</span>|<span class="string">  </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">  </span>|<span class="string">  </span>|<span class="string">________</span>|<span class="string">__</span>|<span class="string">________</span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string">  </span>|<span class="string">——</span>|<span class="string">————————</span>|<span class="string">——</span>|<span class="string">        </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string">  </span>|<span class="string">  </span>|<span class="string">        </span>|<span class="string">__</span>|<span class="string">________</span>|<span class="string">_____</span>|</span><br><span class="line">1  2  3        6  7        10    12</span><br></pre></td></tr></table></figure></li><li>如上图所示，我们可以看到在区间<code>[1,2]</code>之间只有1条线段重合，在区间<code>[2,3]</code>之间有两条线段重合，在区间<code>[3,6]</code>之间只有3条线段重合，<code>[6,7]</code>之间有3条线段重合，<code>[7,10]</code>之间有两条线段重合，<code>[10,12]</code>之间有两条线段重合。我们知道区间分布如下：</li></ol><ul><li><code>[1,2]</code>无法分割。</li><li><code>[2,3]</code>无法分割。</li><li><code>[3,6]</code>在<code>(4,5)</code>处每分割一次即可增加3个线段但在<code>6</code>处进行分割只能增加两条线段。</li><li><code>[7，10]</code>在(8,9)处分割每分割一次即可增加2个线段，但在<code>10</code>分割只能增加<code>1</code>个线段</li><li><code>[10,12]</code>在(11)处分割每分割一次即可增加<code>1</code>个线段，但在<code>12</code>处无法分割。</li></ul><ol><li>我们利用查分数组很快即可以计算出每个区间内重叠的线段的次数，并按照次数的大小进行排序即可，我们使用贪心策略，每次选取分割区间最大的点即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,c;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; prev;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; arrl;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; arrr;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="comment">// 查分数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l,r;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        prev[l]++;</span><br><span class="line">        prev[r]--;</span><br><span class="line">        arrl[l]++;</span><br><span class="line">        arrr[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans = n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录左端点与右端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : prev)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">            left = v.first;</span><br><span class="line">            curr += v.second;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[curr] += v.first - left - <span class="number">1</span>;</span><br><span class="line">            arr[curr-arrr[v.first]]++;</span><br><span class="line">            left = v.first;</span><br><span class="line">            curr += v.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 贪心策略每次取切割可以得到的最大线段的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = arr.rbegin(); it != arr.rend(); it++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = min(c,it-&gt;second);</span><br><span class="line">        ans += x*it-&gt;first;</span><br><span class="line">        c -= x;</span><br><span class="line">        <span class="keyword">if</span>(c &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Final-Exam"><a href="#Final-Exam" class="headerlink" title="Final Exam"></a>Final Exam</h2><p><img src="https://i.loli.net/2021/07/14/UkblX734ZqG61JF.png" alt></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bffc" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bffc</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>感觉第三题要比第二题简单许多，就是一个典型的二分查找的应用即可。我们知道给定难度<code>P</code>,则我们知道绝对值最小值得点肯定在距离点<code>p</code>最近的两个区间，我们利用二分查找，查找距离点<code>p</code>最近的两个区间$[l_{1},r_{1}],[l_{2},r_{2}]$且满足$l_{1}\le r_{1}\le l_{2}\le r_{2}$，如果点<code>p</code>在区间$[l_{1},r_{1}]$范围内，则我们可以知道当前最小的绝对值为<code>0</code>，则我们将<code>p</code>从区间内取出，并将原有区间$[l_{1},r_{1}]$划分为两个新的区间$[l_{1},p-1],[p+1,r_{1}]$,并将这两个新的区间加入到待选序列中。<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">_____</span><span class="strong">___  |    __</span><span class="strong">_____</span><span class="emphasis">___</span></span><br><span class="line">[l1,r1]  p       [l2,r2]</span><br></pre></td></tr></table></figure></li><li>如果不在区间内，则肯定距离<code>p</code>最近的点要么为$r_{1},l_{2}$,则我们优先从这两个点中选择距离最近的点即可，假设$r_{1}$距离点<code>p</code>最近，则我们将$r_{1}$从区间内取出，然后再更新区间为$[l_{1},r_{1}-1]$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">map</span>&lt;LL,LL&gt; pb;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; ans;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; arr = <span class="built_in">vector</span>&lt;LL&gt;(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        LL a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        pb[b] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">auto</span> it = pb.lower_bound(arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(it == pb.end())&#123;</span><br><span class="line">            it--;</span><br><span class="line">            ans.push_back(it-&gt;first);</span><br><span class="line">            LL a = it-&gt;first;</span><br><span class="line">            LL b = it-&gt;second;</span><br><span class="line">            pb.erase(a);</span><br><span class="line">            a--;</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= b) pb[a] = b;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            LL a = it-&gt;first;</span><br><span class="line">            LL b = it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second &gt; arr[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(it == pb.begin())&#123;</span><br><span class="line">                    ans.push_back(b);</span><br><span class="line">                    b++;</span><br><span class="line">                    pb.erase(a);</span><br><span class="line">                    <span class="keyword">if</span>(b &lt;= a) pb[a] = b;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    it--;</span><br><span class="line">                    LL c = it-&gt;first;</span><br><span class="line">                    LL d = it-&gt;second;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i]-c) &gt; <span class="built_in">abs</span>(arr[i] - b))&#123;</span><br><span class="line">                        ans.push_back(b);</span><br><span class="line">                        b++;</span><br><span class="line">                        pb.erase(a);</span><br><span class="line">                        <span class="keyword">if</span>(b &lt;= a) pb[a] = b;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ans.push_back(c);</span><br><span class="line">                        pb.erase(c);</span><br><span class="line">                        c--;</span><br><span class="line">                        <span class="keyword">if</span>(d &lt;= c) pb[c] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(arr[i]);</span><br><span class="line">                LL c = arr[i] - <span class="number">1</span>;</span><br><span class="line">                LL d = arr[i] + <span class="number">1</span>;</span><br><span class="line">                pb.erase(a);</span><br><span class="line">                <span class="keyword">if</span>(c &gt;= b) pb[c] = b;</span><br><span class="line">                <span class="keyword">if</span>(d &lt;= a) pb[a] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kickstart-2021-roundD&quot;&gt;&lt;a href=&quot;#kickstart-2021-roundD&quot; class=&quot;headerlink&quot; title=&quot;kickstart 2021 roundD&quot;&gt;&lt;/a&gt;kickstart 2021 roundD&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kick start&lt;/code&gt;的题目质量非常高，感觉前三题没有问题，自己可以确定前三题做出来。前两题做出来了，后来因为有事，三四题就没有做。第三题不用看解答就能干出来。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/16/K4dX5Q7H2qkVMEr.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;Arithmetic-Square&quot;&gt;&lt;a href=&quot;#Arithmetic-Square&quot; class=&quot;headerlink&quot; title=&quot;Arithmetic Square&quot;&gt;&lt;/a&gt;Arithmetic Square&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/14/fZaIpsXUNkRwHCv.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 249</title>
    <link href="http://yoursite.com/2021/07/11/305/"/>
    <id>http://yoursite.com/2021/07/11/305/</id>
    <published>2021-07-11T15:54:04.710Z</published>
    <updated>2021-07-13T16:02:49.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-249"><a href="#leetcode-contest-249" class="headerlink" title="leetcode  contest  249"></a>leetcode  contest  249</h1><p>周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。<br><img src="https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png" alt></p><h2 id="5808-数组串联"><a href="#5808-数组串联" class="headerlink" title="5808. 数组串联"></a>5808. 数组串联</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为<code>2n</code>的答案数组<code>ans</code> ，数组下标 从 <code>0</code>开始计数 ，对于所有 <code>0 &lt;= i &lt; n</code>的 i ，满足下述所有要求：</p><a id="more"></a><ul><li><code>ans[i] == nums[i]</code></li><li><code>ans[i + n] == nums[i]</code><br>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 串联 形成。</li></ul><p>返回数组 <code>ans</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/concatenation-of-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/concatenation-of-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测代码即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getConcatenation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5809-长度为-3-的不同回文子序列"><a href="#5809-长度为-3-的不同回文子序列" class="headerlink" title="5809. 长度为 3 的不同回文子序列"></a>5809. 长度为 3 的不同回文子序列</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 长度为 3 的不同回文子序列 的个数。</p><p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p><p>回文 是正着读和反着读一样的字符串。</p><p>子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p><p>例如，<code>&quot;ace&quot;</code> 是<code>&quot;abcde&quot;</code> 的一个子序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabca"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：长度为 <span class="number">3</span> 的 <span class="number">3</span> 个回文子序列分别是：</span><br><span class="line">- <span class="string">"aba"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aaa"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aca"</span> (<span class="string">"aabca"</span> 的子序列)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"adc"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"adc"</span> 不存在长度为 <span class="number">3</span> 的回文子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "bbcbaba"</span><br><span class="line">输出：4</span><br><span class="line">解释：长度为 3 的 4 个回文子序列分别是：</span><br><span class="line">-<span class="ruby"> <span class="string">"bbb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bcb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bab"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"aba"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 105</code></li><li><code>s</code>仅由小写英文字母组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的滑动窗口，我们设<code>left[i]</code>表示字符串索引从<code>0</code>到<code>i</code>截至时，所拥有的字符的状态，<code>right[i]</code>表示字符串索引从<code>i</code>到<code>n-1</code>截至时所拥有的字符的状态，我们用二进制位图表示字符的状态则我们可以知道前缀和后缀的递推公式如下：<script type="math/tex; mode=display">left[i] = left[i-1] | (1<<(s[i] - a)) \\right[i] = right[i+1] | (1<<(s[i] - a))</script></li><li>我们在判断是否存在字符串时，我们遍历当前位置<code>i</code>左右两边的位图，判断每一位是否左右都包含相同的字符。</li><li>我们可以用<code>hash</code>值来存储<code>3</code>位的字符串，算法时间复杂度为$O(26n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPalindromicSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            right[i] |= (<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = (<span class="number">1</span>&lt;&lt;(s[<span class="number">0</span>] - <span class="string">'a'</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((left[i<span class="number">-1</span>]&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;(right[i+<span class="number">1</span>]&amp;(<span class="number">1</span>&lt;&lt;j)))&#123;</span><br><span class="line">                    cnt.insert(j*<span class="number">26</span>*<span class="number">26</span> + (s[i]-<span class="string">'a'</span>)*<span class="number">26</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>];</span><br><span class="line">            left[i] |=(<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5811-用三种不同颜色为网格涂色"><a href="#5811-用三种不同颜色为网格涂色" class="headerlink" title="5811. 用三种不同颜色为网格涂色"></a>5811. 用三种不同颜色为网格涂色</h2><p>给你两个整数 <code>m</code>和<code>n</code> 。构造一个 <code>m x n</code>的网格，其中每个单元格最开始是白色。请你用 红、绿、蓝 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p><p>涂色方案需要满足：不存在相邻两个单元格颜色相同的情况 。返回网格涂色的方法数。因为答案可能非常大， 返回 对 <code>109 + 7</code>取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：如上图所示，存在三种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：如上图所示，存在六种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">5</span>, n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">580986</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= m &lt;= 5</code></li><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划<code>dp</code>.</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划，此题跟力扣上某个题目很像，基本上是那个题目的改进版本即可，我们设$dp[i][state]$表示第<code>i</code>列的状态为<code>state</code>时所有的方案数。则我们可以知道第<code>i+1</code>列的状态其实只与第<code>i</code>列的状态有关，所有我们很容易想到<code>dp</code>。</li><li>首先我们做预处理，即计算处装$state_x$所表示的状态下，后一列有哪些状态能够与$state_x$可以兼容符合题目要求，这个其实非常简单，我们只需要遍历所有的状态组合即可，我们可以求处哪些状态能够兼容，这个计算过程非常简单，双层遍历即可。</li><li>我们可以利用<code>dp</code>的递推关系，如果状态$x$能够与状态$y$兼容，则我们可以知道如下递推公式:<script type="math/tex; mode=display">dp[i+1][y] = (dp[i+1][y] + dp[i][x])</script>根据递推公式则可以很快的计算出结果。</li><li>时间复杂度为$O(3^{2m} + O(n*3^{2m}))$,空间复杂度为$O(3^{2m} + n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">colorTheGrid</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">                <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    arr1.push_back(x%<span class="number">3</span>);</span><br><span class="line">                    arr2.push_back(y%<span class="number">3</span>);</span><br><span class="line">                    x = x/<span class="number">3</span>;</span><br><span class="line">                    y = y/<span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr1[k] == arr2[k]) &#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; (arr1[k] == arr1[k<span class="number">-1</span>] || arr2[k] == arr2[k<span class="number">-1</span>]))&#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">                    next[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(mask);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : next)&#123;</span><br><span class="line">            dp[v.first] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp(mask);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> v : next[j])&#123;</span><br><span class="line">                        ndp[v] = (ndp[v] + dp[j])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5810-合并多棵二叉搜索树"><a href="#5810-合并多棵二叉搜索树" class="headerlink" title="5810. 合并多棵二叉搜索树"></a>5810. 合并多棵二叉搜索树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 n 个 二叉搜索树的根节点 ，存储在数组 <code>trees</code> 中（下标从 0 开始），对应 n 棵不同的二叉搜索树。<code>trees</code>中的每棵二叉搜索树 最多有 3 个节点 ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p><ul><li>选择两个 不同的 下标 <code>i</code>和 <code>j</code> ，要求满足在 <code>trees[i]</code>中的某个 叶节点 的值等于 <code>trees[j]</code>的 根节点的值 。</li><li>用 <code>trees[j]</code> 替换 <code>trees[i]</code>中的那个叶节点。</li><li>从 <code>trees</code> 中移除 <code>trees[j]</code>。<br>如果在执行<code>n - 1</code>次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 根节点 ；如果无法构造一棵有效的二叉搜索树，返回 <code>null</code> 。</li></ul><p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p><ul><li>任意节点的左子树中的值都 严格小于 此节点的值。</li><li>任意节点的右子树中的值都 严格大于 此节点的值。</li><li>叶节点是不含子节点的节点。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">第一步操作中，选出 i=<span class="number">1</span> 和 j=<span class="number">0</span> ，并将 trees[<span class="number">0</span>] 合并到 trees[<span class="number">1</span>] 中。</span><br><span class="line">删除 trees[<span class="number">0</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">在第二步操作中，选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，然后将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 <span class="literal">null</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = <span class="string">[[5,4],[3]]</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：无法执行任何操作。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：trees 中只有一棵树，且这棵树已经是一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == trees.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li><li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li><li>输入中的所有树都是 有效的二叉树搜索树 。</li><li><code>1 &lt;= TreeNode.val &lt;= 5 * 104</code>.</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>确实感觉看了别人的思路感觉非常简单，主要是记住有以下几点:</li></ol><ul><li>二叉树的根节点的值均不相同，如果存在值相同的根节点，则不可能构成二叉查找树。</li><li>二叉树的叶子节点的值均不相同，如果存在值相同的叶子节点，则不可能构成二叉查找树。</li><li>二叉树的根节点如果可以唯一可以在叶子节点中查找到，则该节点一定不是最终二叉树的根节点，因此我们需要过滤掉那些根节点在叶子节点集合中的二叉树，最终应该只剩下一棵二叉树，该二叉树的根节点即有可能为最终的根节点。</li></ul><ol><li>我们可以利用<code>bfs</code>来重建二叉树，检测是否所有的节点都被用到。然后我们利用中序遍历，遍历所有的节点的值即可，检测其是否按照从小到大的顺序排列。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            dfs(root-&gt;left,res);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            dfs(root-&gt;right,res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">canMerge</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; trees)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,TreeNode *&gt; root;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; leaf;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt; arr;</span><br><span class="line">        TreeNode * node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n = trees.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = trees[i]-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(root.count(val)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            root[val] = trees[i];</span><br><span class="line">            <span class="keyword">if</span>(trees[i]-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">int</span> lval = trees[i]-&gt;left-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(leaf.count(lval)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                leaf.insert(lval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(trees[i]-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> rval = trees[i]-&gt;right-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(leaf.count(rval)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                leaf.insert(rval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the root</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v: root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!leaf.count(v.first))&#123;</span><br><span class="line">                arr.push_back(v.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode * ret = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; qu;</span><br><span class="line">        qu.push(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            TreeNode * node = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            root.erase(node-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root.count(node-&gt;left-&gt;val))&#123;</span><br><span class="line">                    node-&gt;left = root[node-&gt;left-&gt;val];</span><br><span class="line">                    qu.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root.count(node-&gt;right-&gt;val))&#123;</span><br><span class="line">                    node-&gt;right = root[node-&gt;right-&gt;val];</span><br><span class="line">                    qu.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        dfs(ret,res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] &lt;= res[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-249&quot;&gt;&lt;a href=&quot;#leetcode-contest-249&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  249&quot;&gt;&lt;/a&gt;leetcode  contest  249&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5808-数组串联&quot;&gt;&lt;a href=&quot;#5808-数组串联&quot; class=&quot;headerlink&quot; title=&quot;5808. 数组串联&quot;&gt;&lt;/a&gt;5808. 数组串联&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;nums&lt;/code&gt; 。请你构建一个长度为&lt;code&gt;2n&lt;/code&gt;的答案数组&lt;code&gt;ans&lt;/code&gt; ，数组下标 从 &lt;code&gt;0&lt;/code&gt;开始计数 ，对于所有 &lt;code&gt;0 &amp;lt;= i &amp;lt; n&lt;/code&gt;的 i ，满足下述所有要求：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 249</title>
    <link href="http://yoursite.com/2021/07/11/304/"/>
    <id>http://yoursite.com/2021/07/11/304/</id>
    <published>2021-07-11T15:02:27.779Z</published>
    <updated>2021-07-11T15:52:01.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-249"><a href="#leetcode-contest-249" class="headerlink" title="leetcode  contest  249"></a>leetcode  contest  249</h1><p>周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。<br><img src="https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png" alt></p><h2 id="5808-数组串联"><a href="#5808-数组串联" class="headerlink" title="5808. 数组串联"></a>5808. 数组串联</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为<code>2n</code>的答案数组<code>ans</code> ，数组下标 从 <code>0</code>开始计数 ，对于所有 <code>0 &lt;= i &lt; n</code>的 i ，满足下述所有要求：</p><a id="more"></a><ul><li><code>ans[i] == nums[i]</code></li><li><code>ans[i + n] == nums[i]</code><br>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 串联 形成。</li></ul><p>返回数组 <code>ans</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/concatenation-of-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/concatenation-of-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测代码即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getConcatenation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5809-长度为-3-的不同回文子序列"><a href="#5809-长度为-3-的不同回文子序列" class="headerlink" title="5809. 长度为 3 的不同回文子序列"></a>5809. 长度为 3 的不同回文子序列</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 长度为 3 的不同回文子序列 的个数。</p><p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p><p>回文 是正着读和反着读一样的字符串。</p><p>子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p><p>例如，<code>&quot;ace&quot;</code> 是<code>&quot;abcde&quot;</code> 的一个子序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabca"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：长度为 <span class="number">3</span> 的 <span class="number">3</span> 个回文子序列分别是：</span><br><span class="line">- <span class="string">"aba"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aaa"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aca"</span> (<span class="string">"aabca"</span> 的子序列)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"adc"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"adc"</span> 不存在长度为 <span class="number">3</span> 的回文子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "bbcbaba"</span><br><span class="line">输出：4</span><br><span class="line">解释：长度为 3 的 4 个回文子序列分别是：</span><br><span class="line">-<span class="ruby"> <span class="string">"bbb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bcb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bab"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"aba"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 105</code></li><li><code>s</code>仅由小写英文字母组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的滑动窗口，我们设<code>left[i]</code>表示字符串索引从<code>0</code>到<code>i</code>截至时，所拥有的字符的状态，<code>right[i]</code>表示字符串索引从<code>i</code>到<code>n-1</code>截至时所拥有的字符的状态，我们用二进制位图表示字符的状态则我们可以知道前缀和后缀的递推公式如下：<script type="math/tex; mode=display">left[i] = left[i-1] | (1<<(s[i] - a)) \\right[i] = right[i+1] | (1<<(s[i] - a))</script></li><li>我们在判断是否存在字符串时，我们遍历当前位置<code>i</code>左右两边的位图，判断每一位是否左右都包含相同的字符。</li><li>我们可以用<code>hash</code>值来存储<code>3</code>位的字符串，算法时间复杂度为$O(26n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPalindromicSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            right[i] |= (<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = (<span class="number">1</span>&lt;&lt;(s[<span class="number">0</span>] - <span class="string">'a'</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((left[i<span class="number">-1</span>]&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;(right[i+<span class="number">1</span>]&amp;(<span class="number">1</span>&lt;&lt;j)))&#123;</span><br><span class="line">                    cnt.insert(j*<span class="number">26</span>*<span class="number">26</span> + (s[i]-<span class="string">'a'</span>)*<span class="number">26</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>];</span><br><span class="line">            left[i] |=(<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5811-用三种不同颜色为网格涂色"><a href="#5811-用三种不同颜色为网格涂色" class="headerlink" title="5811. 用三种不同颜色为网格涂色"></a>5811. 用三种不同颜色为网格涂色</h2><p>给你两个整数 <code>m</code>和<code>n</code> 。构造一个 <code>m x n</code>的网格，其中每个单元格最开始是白色。请你用 红、绿、蓝 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p><p>涂色方案需要满足：不存在相邻两个单元格颜色相同的情况 。返回网格涂色的方法数。因为答案可能非常大， 返回 对 <code>109 + 7</code>取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：如上图所示，存在三种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：如上图所示，存在六种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">5</span>, n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">580986</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= m &lt;= 5</code></li><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划<code>dp</code>.</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划，此题跟力扣上某个题目很像，基本上是那个题目的改进版本即可，我们设$dp[i][state]$表示第<code>i</code>列的状态为<code>state</code>时所有的方案数。则我们可以知道第<code>i+1</code>列的状态其实只与第<code>i</code>列的状态有关，所有我们很容易想到<code>dp</code>。</li><li>首先我们做预处理，即计算处装$state_x$所表示的状态下，后一列有哪些状态能够与$state_x$可以兼容符合题目要求，这个其实非常简单，我们只需要遍历所有的状态组合即可，我们可以求处哪些状态能够兼容，这个计算过程非常简单，双层遍历即可。</li><li>我们可以利用<code>dp</code>的递推关系，如果状态$x$能够与状态$y$兼容，则我们可以知道如下递推公式:<script type="math/tex; mode=display">dp[i+1][y] = (dp[i+1][y] + dp[i][x])</script>根据递推公式则可以很快的计算出结果。</li><li>时间复杂度为$O(3^{2m} + O(n*3^{2m}))$,空间复杂度为$O(3^{2m} + n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">colorTheGrid</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">                <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    arr1.push_back(x%<span class="number">3</span>);</span><br><span class="line">                    arr2.push_back(y%<span class="number">3</span>);</span><br><span class="line">                    x = x/<span class="number">3</span>;</span><br><span class="line">                    y = y/<span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr1[k] == arr2[k]) &#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; (arr1[k] == arr1[k<span class="number">-1</span>] || arr2[k] == arr2[k<span class="number">-1</span>]))&#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">                    next[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(mask);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : next)&#123;</span><br><span class="line">            dp[v.first] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp(mask);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> v : next[j])&#123;</span><br><span class="line">                        ndp[v] = (ndp[v] + dp[j])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5810-合并多棵二叉搜索树"><a href="#5810-合并多棵二叉搜索树" class="headerlink" title="5810. 合并多棵二叉搜索树"></a>5810. 合并多棵二叉搜索树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 n 个 二叉搜索树的根节点 ，存储在数组 <code>trees</code> 中（下标从 0 开始），对应 n 棵不同的二叉搜索树。<code>trees</code>中的每棵二叉搜索树 最多有 3 个节点 ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p><ul><li>选择两个 不同的 下标 <code>i</code>和 <code>j</code> ，要求满足在 <code>trees[i]</code>中的某个 叶节点 的值等于 <code>trees[j]</code>的 根节点的值 。</li><li>用 <code>trees[j]</code> 替换 <code>trees[i]</code>中的那个叶节点。</li><li>从 <code>trees</code> 中移除 <code>trees[j]</code>。<br>如果在执行<code>n - 1</code>次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 根节点 ；如果无法构造一棵有效的二叉搜索树，返回 <code>null</code> 。</li></ul><p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p><ul><li>任意节点的左子树中的值都 严格小于 此节点的值。</li><li>任意节点的右子树中的值都 严格大于 此节点的值。</li><li>叶节点是不含子节点的节点。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">第一步操作中，选出 i=<span class="number">1</span> 和 j=<span class="number">0</span> ，并将 trees[<span class="number">0</span>] 合并到 trees[<span class="number">1</span>] 中。</span><br><span class="line">删除 trees[<span class="number">0</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">在第二步操作中，选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，然后将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 <span class="literal">null</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = <span class="string">[[5,4],[3]]</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：无法执行任何操作。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：trees 中只有一棵树，且这棵树已经是一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == trees.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li><li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li><li>输入中的所有树都是 有效的二叉树搜索树 。</li><li><code>1 &lt;= TreeNode.val &lt;= 5 * 104</code>.</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-249&quot;&gt;&lt;a href=&quot;#leetcode-contest-249&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  249&quot;&gt;&lt;/a&gt;leetcode  contest  249&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5808-数组串联&quot;&gt;&lt;a href=&quot;#5808-数组串联&quot; class=&quot;headerlink&quot; title=&quot;5808. 数组串联&quot;&gt;&lt;/a&gt;5808. 数组串联&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;nums&lt;/code&gt; 。请你构建一个长度为&lt;code&gt;2n&lt;/code&gt;的答案数组&lt;code&gt;ans&lt;/code&gt; ，数组下标 从 &lt;code&gt;0&lt;/code&gt;开始计数 ，对于所有 &lt;code&gt;0 &amp;lt;= i &amp;lt; n&lt;/code&gt;的 i ，满足下述所有要求：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 56</title>
    <link href="http://yoursite.com/2021/07/11/303/"/>
    <id>http://yoursite.com/2021/07/11/303/</id>
    <published>2021-07-10T23:53:28.496Z</published>
    <updated>2021-07-11T15:02:58.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-56"><a href="#leetcode-contest-56" class="headerlink" title="leetcode  contest  56"></a>leetcode  contest  56</h1><p>今天双周赛的第四题特别简单，就是典型的<code>dijistra</code>算法求最短距离即可，可惜的是第三题竟然没有做出来，智商捉急。<br><img src="https://i.loli.net/2021/07/11/4BXACGqyV56jPEW.png" alt></p><h2 id="5792-统计平方和三元组的数目"><a href="#5792-统计平方和三元组的数目" class="headerlink" title="5792. 统计平方和三元组的数目"></a>5792. 统计平方和三元组的数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个 平方和三元组 <code>(a,b,c)</code> 指的是满足 <code>a2 + b2 = c2</code> 的 整数 三元组 <code>a，b</code> 和 <code>c</code>。</p><a id="more"></a><p>给你一个整数 <code>n</code>，请你返回满足 <code>1 &lt;= a, b, c &lt;= n</code>的 平方和三元组 的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：平方和三元组为 (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) 和 (<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：平方和三元组为 (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)，(<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>)，(<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>) 和 (<span class="number">8</span>,<span class="number">6</span>,<span class="number">10</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 250</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-square-sum-triples" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-square-sum-triples</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测即可，遍历所有可能的$a^{2} + b^{2}$,检测是否存在符合要求的$c$.</li><li>算法时间复杂度为$O(n^{2})$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriples</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) curr.insert(i*i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = i*i + j*j;</span><br><span class="line">                <span class="keyword">if</span>(curr.count(x)) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5793-迷宫中离入口最近的出口"><a href="#5793-迷宫中离入口最近的出口" class="headerlink" title="5793. 迷宫中离入口最近的出口"></a>5793. 迷宫中离入口最近的出口</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>m x n</code>的迷宫矩阵 <code>maze</code>（下标从 0 开始），矩阵中有空格子（用 ‘.’ 表示）和墙（用 ‘+’ 表示）。同时给你迷宫的入口 <code>entrance</code>，用 <code>entrance = [entrancerow, entrancecol]</code>表示你一开始所在格子的行和列。</p><p>每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 <code>entrance</code>最近 的出口。出口 的含义是 maze 边界 上的 空格子。<code>entrance</code>格子 不算 出口。</p><p>请你返回从 <code>entrance</code>到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"."</span>,<span class="string">"+"</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"+"</span>],[<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"."</span>]], entrance = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：总共有 <span class="number">3</span> 个出口，分别位于 (<span class="number">1</span>,<span class="number">0</span>)，(<span class="number">0</span>,<span class="number">2</span>) 和 (<span class="number">2</span>,<span class="number">3</span>) 。</span><br><span class="line">一开始，你在入口格子 (<span class="number">1</span>,<span class="number">2</span>) 处。</span><br><span class="line">- 你可以往左移动 <span class="number">2</span> 步到达 (<span class="number">1</span>,<span class="number">0</span>) 。</span><br><span class="line">- 你可以往上移动 <span class="number">1</span> 步到达 (<span class="number">0</span>,<span class="number">2</span>) 。</span><br><span class="line">从入口处没法到达 (<span class="number">2</span>,<span class="number">3</span>) 。</span><br><span class="line">所以，最近的出口是 (<span class="number">0</span>,<span class="number">2</span>) ，距离为 <span class="number">1</span> 步。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"+"</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"+"</span>]], entrance = [<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：迷宫中只有 <span class="number">1</span> 个出口，在 (<span class="number">1</span>,<span class="number">2</span>) 处。</span><br><span class="line">(<span class="number">1</span>,<span class="number">0</span>) 不算出口，因为它是入口格子。</span><br><span class="line">初始时，你在入口与格子 (<span class="number">1</span>,<span class="number">0</span>) 处。</span><br><span class="line">- 你可以往右移动 <span class="number">2</span> 步到达 (<span class="number">1</span>,<span class="number">2</span>) 处。</span><br><span class="line">所以，最近的出口为 (<span class="number">1</span>,<span class="number">2</span>) ，距离为 <span class="number">2</span> 步。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">"."</span>,<span class="string">"+"</span>]], entrance = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：这个迷宫中没有出口。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>maze.length == m</code></li><li><code>maze[i].length == n</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>maze[i][j]</code>要么是 ‘.’ ，要么是 ‘+’ 。</li><li><code>entrance.length == 2</code></li><li><code>0 &lt;= entrancerow &lt; m</code></li><li><code>0 &lt;= entrancecol &lt; n</code></li><li><code>entrance</code> 一定是空格子。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/nearest-exit-from-entrance-in-maze" target="_blank" rel="noopener">https://leetcode-cn.com/problems/nearest-exit-from-entrance-in-maze</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的<code>BFS</code>即可，检测到边缘位置即返回即可。我们主要检测当前位置是否在边缘，判断条件为:<script type="math/tex; mode=display">x == 0 \quad or \quad x == row-1 \\y == 0 \quad or \quad y == col-1</script></li><li>时间复杂度为$O(m<em>n)$,空间复杂度为$O(m</em>n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nearestExit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; maze, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; entrance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = maze.size();</span><br><span class="line">        <span class="keyword">int</span> col = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        qu.push(entrance[<span class="number">0</span>]*col + entrance[<span class="number">1</span>]);</span><br><span class="line">        visit[entrance[<span class="number">0</span>]][entrance[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = qu.front()/col;</span><br><span class="line">                <span class="keyword">int</span> y = qu.front()%col;</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="comment">/*check edge*/</span></span><br><span class="line">                <span class="keyword">if</span>(!(x == entrance[<span class="number">0</span>] &amp;&amp; y == entrance[<span class="number">1</span>]))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="number">0</span> || x == row<span class="number">-1</span> || y == <span class="number">0</span> || y == col<span class="number">-1</span>) <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + d[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + d[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(visit[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'+'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    qu.push(nx*col+ny);</span><br><span class="line">                    visit[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5794-求和游戏"><a href="#5794-求和游戏" class="headerlink" title="5794. 求和游戏"></a>5794. 求和游戏</h2><p><code>Alice</code> 和 <code>Bob</code> 玩一个游戏，两人轮流行动，<code>Alice</code> 先手 。</p><p>给你一个 偶数长度 的字符串 <code>num</code> ，每一个字符为数字字符或者 ‘?’ 。每一次操作中，如果 <code>num</code>中至少有一个 ‘?’ ，那么玩家可以执行以下操作：</p><p>选择一个下标 <code>i</code>满足 <code>num[i] == &#39;?&#39;</code> 。</p><ul><li>将 <code>num[i]</code> 用 <code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code> 之间的一个数字字符替代。</li><li>当 <code>num</code> 中没有 <code>&#39;?&#39;</code> 时，游戏结束。</li></ul><p><code>Bob</code> 获胜的条件是 <code>num</code> 中前一半数字的和 等于 后一半数字的和。<code>Alice</code> 获胜的条件是前一半的和与后一半的和 不相等 。</p><ul><li>比方说，游戏结束时 <code>num = &quot;243801&quot;</code> ，那么 <code>Bob</code> 获胜，因为 2+4+3 = 8+0+1 。如果游戏结束时 <code>num = &quot;243803&quot;</code> ，那么 Alice 获胜，因为 2+4+3 != 8+0+3 。<br>在 Alice 和 Bob 都采取 最优 策略的前提下，如果 Alice 获胜，请返回 true ，如果 Bob 获胜，请返回 false 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"5023"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：num 中没有 <span class="string">'?'</span> ，没法进行任何操作。</span><br><span class="line">前一半的和等于后一半的和：<span class="number">5</span> + <span class="number">0</span> = <span class="number">2</span> + <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"25??"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：Alice 可以将两个 <span class="string">'?'</span> 中的一个替换为 <span class="string">'9'</span> ，Bob 无论如何都无法使前一半的和等于后一半的和。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"?3295???"</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：Bob 总是能赢。一种可能的结果是：</span><br><span class="line">- Alice 将第一个 <span class="string">'?'</span> 用 <span class="string">'9'</span> 替换。<span class="built_in">num</span> = <span class="string">"93295???"</span> 。</span><br><span class="line">- Bob 将后面一半中的一个 <span class="string">'?'</span> 替换为 <span class="string">'9'</span> 。<span class="built_in">num</span> = <span class="string">"932959??"</span> 。</span><br><span class="line">- Alice 将后面一半中的一个 <span class="string">'?'</span> 替换为 <span class="string">'2'</span> 。<span class="built_in">num</span> = <span class="string">"9329592?"</span> 。</span><br><span class="line">- Bob 将后面一半中最后一个 <span class="string">'?'</span> 替换为 <span class="string">'7'</span> 。<span class="built_in">num</span> = <span class="string">"93295927"</span> 。</span><br><span class="line">Bob 获胜，因为 <span class="number">9</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">9</span> = <span class="number">5</span> + <span class="number">9</span> + <span class="number">2</span> + <span class="number">7</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= num.length &lt;= 105</code></li><li><code>num.length</code>是 偶数 。</li><li><code>num</code>只包含数字字符和 <code>&#39;?&#39;</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-game</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 奥数数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们可以知道假如<code>?</code>的个数为奇数，我们可以知道最后的选择权在<code>Alice</code>，则<code>ALICE</code>因为此时可以选择<code>0~9</code>，所以总可以选择一个数使得两端不相等。</li><li>我们知道最优策略，我们假设如果不管一端<code>ALICE</code>在问号中填写任何值，则<code>BOB</code>的最优策略也是在另一侧填入同样的值，在这种情况下，必然两边相等数量的问号会被消掉，我们假设左侧的问号的个数为$s_{1}$,右侧问号的个数为$s_{2}$,此时一共可以消掉$min(s_{2} ,s_{1})$个问号，这时肯定在右侧只剩下$abs(s_{2} - s_{1})$个问号,则此时这些剩余的括号中，每个人会选择替换$\frac{abs(s_{2} - s_{1})}{2}$次,则我们可以知道此时只有在一种情况下，可以保证<code>bob</code>达到的数目，即当<code>alice</code>选择替换为$x$时，则<code>bob</code>则选择替换为$9-x$，此时可以知道替换后增加的总数为$9<em>\frac{abs(s_{2} - s_{1})}{2}$,如果前后的数字和相差刚好为$9</em>\frac{abs(s_{2} - s_{1})}{2}$，此时一定能保证<code>BOB</code>可以赢。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sumGame</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i] == <span class="string">'?'</span>) s1++;</span><br><span class="line">                <span class="keyword">else</span> sum += num[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i] == <span class="string">'?'</span>) s2++;</span><br><span class="line">                <span class="keyword">else</span> sum -= num[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((s1 + s2)%<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( sum == (s2-s1)/<span class="number">2</span>*<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5795-规定时间内到达终点的最小花费"><a href="#5795-规定时间内到达终点的最小花费" class="headerlink" title="5795. 规定时间内到达终点的最小花费"></a>5795. 规定时间内到达终点的最小花费</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个国家有 <code>n</code>个城市，城市编号为<code>0</code> 到<code>n - 1</code> ，题目保证 所有城市 都由双向道路 连接在一起 。道路由二维整数数组 edges 表示，其中<code>edges[i] = [xi, yi, timei]</code> 表示城市 <code>xi</code> 和 <code>yi</code> 之间有一条双向道路，耗费时间为 timei 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。</p><p>每次经过一个城市时，你需要付通行费。通行费用一个长度为 n 且下标从 0 开始的整数数组 <code>passingFees</code> 表示，其中 <code>passingFees[j]</code>是你经过城市 <code>j</code> 需要支付的费用。</p><p>一开始，你在城市 0 ，你想要在 <code>maxTime</code>分钟以内 （包含 maxTime 分钟）到达城市 <code>n - 1</code> 。旅行的 费用 为你经过的所有城市 通行费之和 （包括 起点和终点城市的通行费）。</p><p>给你 <code>maxTime</code>，<code>edges</code> 和 <code>passingFees</code>，请你返回完成旅行的 最小费用 ，如果无法在 <code>maxTime</code> 分钟以内完成旅行，请你返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：maxTime = <span class="number">30</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">15</span>]], passingFees = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：最优路径为 <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">5</span> ，总共需要耗费 <span class="number">30</span> 分钟，需要支付 <span class="number">11</span> 的通行费。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：maxTime = <span class="number">29</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">15</span>]], passingFees = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">48</span></span><br><span class="line">解释：最优路径为 <span class="number">0</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> ，总共需要耗费 <span class="number">26</span> 分钟，需要支付 <span class="number">48</span> 的通行费。</span><br><span class="line">你不能选择路径 <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">5</span> ，因为这条路径耗费的时间太长。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：maxTime = <span class="number">25</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">15</span>]], passingFees = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：无法在 <span class="number">25</span> 分钟以内从城市 <span class="number">0</span> 到达城市 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= maxTime &lt;= 1000</code></li><li><code>n == passingFees.length</code></li><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>n - 1 &lt;= edges.length &lt;= 1000</code></li><li><code>0 &lt;= xi, yi &lt;= n - 1</code></li><li><code>1 &lt;= timei &lt;= 1000</code></li><li><code>1 &lt;= passingFees[j] &lt;= 1000</code></li><li>图中两个节点之间可能有多条路径。</li><li>图中不含有自环。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> Dijistra算法，dp。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的<code>dijistra</code>算法求最短距离，我们设<code>dp[x][y]</code>表示在<code>y</code>时间到大城市<code>x</code>所花费的最小费用。已经知道<code>x</code>的下一跳城市为$nx$,到达$nx$时花费的时间为$dy$,到达城市$nx$的花费为$cost$，所以我们可以很清楚的知道递推关系如下：<script type="math/tex; mode=display">dp[nx][y+dy] = min(dp[nx][y+dy],dp[x][y] + cost)</script></li><li><code>dijistra</code>算法非常简单直接，时间复杂度为$O((N+M)Tlg(NT)$,空间复杂度为$O(N*T + 2M)$。</li><li><code>dp</code>算法，简单的<code>dp</code>算法，非常容易理解，时间复杂度为$O(N+M)T$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> city;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Node(<span class="keyword">int</span> city,<span class="keyword">int</span> time,<span class="keyword">int</span> cost)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;city = city;</span><br><span class="line">        <span class="keyword">this</span>-&gt;time = time;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> maxTime, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; passingFees)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="keyword">int</span> n = passingFees.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxTime+<span class="number">1</span>,INT_MAX));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(make_pair(v[<span class="number">1</span>],v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(make_pair(v[<span class="number">0</span>],v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; qu;</span><br><span class="line">        qu.push(Node(<span class="number">0</span>,<span class="number">0</span>,passingFees[<span class="number">0</span>]));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = passingFees[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            Node curr = qu.top();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">if</span>(curr.city == n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr.cost;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.city])&#123;</span><br><span class="line">                    <span class="keyword">int</span> ncity = v.first;</span><br><span class="line">                    <span class="keyword">int</span> ntime = curr.time + v.second;</span><br><span class="line">                    <span class="keyword">int</span> ncost = curr.cost + passingFees[ncity];</span><br><span class="line">                    <span class="keyword">if</span>(ntime &gt; maxTime) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dp[ncity][ntime] &lt;= ncost) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[ncity][ntime] = ncost;</span><br><span class="line">                    qu.push(Node(ncity,ntime,ncost));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ans == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> maxTime, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; passingFees)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="keyword">int</span> n = passingFees.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxTime+<span class="number">1</span>,INT_MAX));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(make_pair(v[<span class="number">1</span>],v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(make_pair(v[<span class="number">0</span>],v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = passingFees[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= maxTime; ++x)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][x] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x + v.second &lt;= maxTime)&#123;</span><br><span class="line">                        dp[v.first][x+v.second] = min(dp[v.first][x+v.second],dp[i][x] + passingFees[v.first]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxTime; ++i)&#123;</span><br><span class="line">            ans = min(ans,dp[n<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ans == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-56&quot;&gt;&lt;a href=&quot;#leetcode-contest-56&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  56&quot;&gt;&lt;/a&gt;leetcode  contest  56&lt;/h1&gt;&lt;p&gt;今天双周赛的第四题特别简单，就是典型的&lt;code&gt;dijistra&lt;/code&gt;算法求最短距离即可，可惜的是第三题竟然没有做出来，智商捉急。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/11/4BXACGqyV56jPEW.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5792-统计平方和三元组的数目&quot;&gt;&lt;a href=&quot;#5792-统计平方和三元组的数目&quot; class=&quot;headerlink&quot; title=&quot;5792. 统计平方和三元组的数目&quot;&gt;&lt;/a&gt;5792. 统计平方和三元组的数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个 平方和三元组 &lt;code&gt;(a,b,c)&lt;/code&gt; 指的是满足 &lt;code&gt;a2 + b2 = c2&lt;/code&gt; 的 整数 三元组 &lt;code&gt;a，b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Binarysearch】 每日一题 7.9</title>
    <link href="http://yoursite.com/2021/07/07/302/"/>
    <id>http://yoursite.com/2021/07/07/302/</id>
    <published>2021-07-07T01:01:27.805Z</published>
    <updated>2021-07-10T06:17:24.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p>这个题目确实非常难，不容易想到解答方法,CF上的原题，确实不容易想到解法。</p><h2 id="Best-Interval-to-Remove"><a href="#Best-Interval-to-Remove" class="headerlink" title="Best Interval to Remove"></a>Best Interval to Remove</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>You are given a list of inclusive intervals that are potentially overlapping.<br>Consider an operation where we remove one interval, merge the remaining intervals and then count the number of intervals left over. Return the maximum number of leftover intervals possible after this removal.</p><a id="more"></a><p>Constraints</p><ul><li><code>n ≤ 100,000</code> where n is the length of intervals<br>Example 1<br>Input<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>ervals = [</span><br><span class="line">    [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">    [<span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>Output<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">Explanation</span><br><span class="line">If we remove the <span class="built_in">int</span>erval [<span class="number">2</span>, <span class="number">5</span>] we <span class="keyword">get</span> [<span class="number">3</span>, <span class="number">8</span>] as the merge</span><br><span class="line">If we remove the <span class="built_in">int</span>erval [<span class="number">3</span>, <span class="number">4</span>] we <span class="keyword">get</span> [<span class="number">2</span>, <span class="number">8</span>] as the merge</span><br><span class="line">If we remove the <span class="built_in">int</span>erval [<span class="number">4</span>, <span class="number">7</span>] we <span class="keyword">get</span> [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">8</span>] as the merge</span><br><span class="line">If we remove the <span class="built_in">int</span>erval [<span class="number">6</span>, <span class="number">8</span>] we <span class="keyword">get</span> [<span class="number">2</span>, <span class="number">7</span>] as the merge</span><br><span class="line">So removing [<span class="number">4</span>, <span class="number">7</span>] <span class="keyword">is</span> the best</span><br></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://binarysearch.com/problems/Best-Interval-to-Remove" target="_blank" rel="noopener">https://binarysearch.com/problems/Best-Interval-to-Remove</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数位dp</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;每日一题&quot;&gt;&lt;a href=&quot;#每日一题&quot; class=&quot;headerlink&quot; title=&quot;每日一题&quot;&gt;&lt;/a&gt;每日一题&lt;/h1&gt;&lt;p&gt;这个题目确实非常难，不容易想到解答方法,CF上的原题，确实不容易想到解法。&lt;/p&gt;&lt;h2 id=&quot;Best-Interval-to-Remove&quot;&gt;&lt;a href=&quot;#Best-Interval-to-Remove&quot; class=&quot;headerlink&quot; title=&quot;Best Interval to Remove&quot;&gt;&lt;/a&gt;Best Interval to Remove&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;You are given a list of inclusive intervals that are potentially overlapping.&lt;br&gt;Consider an operation where we remove one interval, merge the remaining intervals and then count the number of intervals left over. Return the maximum number of leftover intervals possible after this removal.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="binarysearch" scheme="http://yoursite.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>【Binarysearch】 每日一题 7.5</title>
    <link href="http://yoursite.com/2021/07/05/301/"/>
    <id>http://yoursite.com/2021/07/05/301/</id>
    <published>2021-07-05T14:25:08.639Z</published>
    <updated>2021-07-07T01:01:16.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p>今天的题目为常见的数位<code>dp</code>，实际比较复杂，感觉一般的面试肯定不会出这么难的题目，最后题目解答出来了，但是竟然有些超时，总体的思想肯定没有问题。</p><h2 id="Minimal-Submatrices"><a href="#Minimal-Submatrices" class="headerlink" title="Minimal Submatrices"></a>Minimal Submatrices</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string s of lowercase letters and an integer k, return the number of strings of equal size as s (only consisting of lowercase letters) that are lexicographically smaller or equal to s and have at most <code>k</code> consecutive equal characters.</p><a id="more"></a><p>Mod the result by <code>10 ** 9 + 7</code>.</p><p>Constraints</p><ul><li><code>n, k ≤ 400</code> where <code>n</code>is the length of <code>s</code>.<br>Example 1<br>Input<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> = <span class="string">"abb"</span></span><br><span class="line"><span class="attr">k</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>Output<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>Explanation<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">We</span> have the following strings: [<span class="string">"aab"</span>, <span class="string">"aac"</span>, <span class="string">"aad"</span>, <span class="string">"aae"</span>, <span class="string">"aaf"</span>, <span class="string">"aag"</span>, <span class="string">"aah"</span>, <span class="string">"aai"</span>, <span class="string">"aaj"</span>, <span class="string">"aak"</span>, <span class="string">"aal"</span>, <span class="string">"aam"</span>, <span class="string">"aan"</span>, <span class="string">"aao"</span>, <span class="string">"aap"</span>, <span class="string">"aaq"</span>, <span class="string">"aar"</span>, <span class="string">"aas"</span>, <span class="string">"aat"</span>, <span class="string">"aau"</span>, <span class="string">"aav"</span>, <span class="string">"aaw"</span>, <span class="string">"aax"</span>, <span class="string">"aay"</span>, <span class="string">"aaz"</span>, <span class="string">"aba"</span>, <span class="string">"abb"</span>].</span><br></pre></td></tr></table></figure>Note that we didn’t count “aaa” since there can be at most 2 consecutive equal characters.<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://binarysearch.com/room/Leaning-Tower-of-Hanoi-eQu4VGPJmd" target="_blank" rel="noopener">https://binarysearch.com/room/Leaning-Tower-of-Hanoi-eQu4VGPJmd</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数位dp</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>典型的数位<code>dp</code>的解法，主要是需要知道<code>dp</code>的递推公式，设<code>dp[i][j][c][flag]</code>，其中<code>flag</code>为<code>1</code>表示当前的前<code>i</code>中最后的<code>j</code>位为连续的字符<code>c</code>，且前<code>i</code>位与当前字符串的前<code>i</code>位相等且符合要求的字符的数目；<code>flag</code>为<code>0</code>则表示前<code>i</code>中最后的<code>j</code>位为连续的字符<code>c</code>，且当前的前<code>i</code>位字符的字典序小于原始字符的<code>s</code>的前<code>i</code>的字典序。这个解释比较绕口，感觉解答都不太好解答。但是感觉数位<code>dp</code>这种题目也都是类似的套路，如果熟悉它的话，则认为它比较简单，否则感觉比较复杂和难以理解，多做几道题目肯定会晓得其中的奥妙和递推关系。<br><a href="https://binarysearch.com/problems/Strings-Down-Under/solutions/810226" target="_blank" rel="noopener">解答</a></li><li>算法时间复杂度为$O(n<em>k</em>2*26)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">401</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn][maxn][<span class="number">26</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp; s,<span class="keyword">int</span> curr,<span class="keyword">int</span> cnt,<span class="keyword">char</span> c,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* dp */</span></span><br><span class="line">    <span class="keyword">if</span>(curr &gt;= s.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(curr == s.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> &amp; tot = dp[curr][cnt][c-<span class="string">'a'</span>][flag];</span><br><span class="line">    <span class="keyword">if</span>(tot &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123; <span class="comment">// lower</span></span><br><span class="line">        <span class="keyword">if</span>(cnt == maxk)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">'a'</span> + i != c)&#123;</span><br><span class="line">                tot = (tot + dfs(s,curr+s1,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">'a'</span> + i != c)&#123;</span><br><span class="line">                tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tot = (tot + dfs(s,curr+<span class="number">1</span>,cnt+<span class="number">1</span>,c,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">/*upper*/</span></span><br><span class="line">       <span class="keyword">if</span>(cnt == maxk)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[curr+<span class="number">1</span>] - <span class="string">'a'</span>; ++i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">'a'</span> + i != c)&#123;</span><br><span class="line">                  tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(s[curr+<span class="number">1</span>] != c)&#123;</span><br><span class="line">              tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,s[curr+<span class="number">1</span>],<span class="number">1</span>))%mod;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[curr+<span class="number">1</span>] - <span class="string">'a'</span>; ++i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">'a'</span> + i != c)&#123;</span><br><span class="line">                  tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  tot = (tot + dfs(s,curr+<span class="number">1</span>,cnt+<span class="number">1</span>,c,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(s[curr+<span class="number">1</span>] != c)&#123;</span><br><span class="line">              tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,s[curr+<span class="number">1</span>],<span class="number">1</span>))%mod;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              tot = (tot + dfs(s,curr+<span class="number">1</span>,cnt+<span class="number">1</span>,c,<span class="number">1</span>))%mod;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tot = <span class="number">0</span>;</span><br><span class="line">    maxk = k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[<span class="number">0</span>] - <span class="string">'a'</span>; ++i)&#123;</span><br><span class="line">      tot = (tot + dfs(s,<span class="number">0</span>,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    tot = (tot + dfs(s,<span class="number">0</span>,<span class="number">1</span>,s[<span class="number">0</span>],<span class="number">1</span>))%mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;每日一题&quot;&gt;&lt;a href=&quot;#每日一题&quot; class=&quot;headerlink&quot; title=&quot;每日一题&quot;&gt;&lt;/a&gt;每日一题&lt;/h1&gt;&lt;p&gt;今天的题目为常见的数位&lt;code&gt;dp&lt;/code&gt;，实际比较复杂，感觉一般的面试肯定不会出这么难的题目，最后题目解答出来了，但是竟然有些超时，总体的思想肯定没有问题。&lt;/p&gt;&lt;h2 id=&quot;Minimal-Submatrices&quot;&gt;&lt;a href=&quot;#Minimal-Submatrices&quot; class=&quot;headerlink&quot; title=&quot;Minimal Submatrices&quot;&gt;&lt;/a&gt;Minimal Submatrices&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a string s of lowercase letters and an integer k, return the number of strings of equal size as s (only consisting of lowercase letters) that are lexicographically smaller or equal to s and have at most &lt;code&gt;k&lt;/code&gt; consecutive equal characters.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="binarysearch" scheme="http://yoursite.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 248</title>
    <link href="http://yoursite.com/2021/07/04/300/"/>
    <id>http://yoursite.com/2021/07/04/300/</id>
    <published>2021-07-04T03:59:34.839Z</published>
    <updated>2021-07-04T14:36:40.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-248"><a href="#leetcode-contest-248" class="headerlink" title="leetcode  contest  248"></a>leetcode  contest  248</h1><p>今天周赛前三题基本上都是简单题目，最后一题难度确实很大，不过感觉也是模板题目，最终极的解法还是利用后缀数组来解答。不过常规的用<code>rabin-karp</code>字符串<code>hash</code>算法也可以解决，但是很蛋疼的题目的解法竟然会卡<code>1e9 + 7</code>的取模答案，所以在实际计算时的取模将会是个很大的问题。官方的解答比较有技巧的是用了两个<code>hash</code>来解决碰撞的概率，确实是个非常好的技巧。还是前三题的节奏，感觉非常蛋疼的题目，如果不知道字符串<code>hash</code>或者<code>suffix array</code>的解法，这个题目就不会。最后一题据说是竞赛网站的模板题目，感觉真心蛋疼。</p><a id="more"></a><h2 id="5800-基于排列构建数组"><a href="#5800-基于排列构建数组" class="headerlink" title="5800. 基于排列构建数组"></a>5800. 基于排列构建数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 从 <code>0</code> 开始的排列 <code>nums</code>（下标也从 0 开始）。请你构建一个 同样长度 的数组 <code>ans</code> ，其中，对于每个 <code>i（0 &lt;= i &lt; nums.length</code>），都满足 <code>ans[i] = nums[nums[i]]</code>。返回构建好的数组 ans 。</p><p>从 0 开始的排列 <code>nums</code> 是一个由 0 到 <code>nums.length - 1</code>（0 和<code>nums.length - 1</code> 也包含在内）的不同整数组成的数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">解释：数组 ans 构建如下：</span><br><span class="line">ans = [nums[nums[<span class="number">0</span>]], nums[nums[<span class="number">1</span>]], nums[nums[<span class="number">2</span>]], nums[nums[<span class="number">3</span>]], nums[nums[<span class="number">4</span>]], nums[nums[<span class="number">5</span>]]]</span><br><span class="line">    = [nums[<span class="number">0</span>], nums[<span class="number">2</span>], nums[<span class="number">1</span>], nums[<span class="number">5</span>], nums[<span class="number">3</span>], nums[<span class="number">4</span>]]</span><br><span class="line">    = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：数组 ans 构建如下：</span><br><span class="line">ans = [nums[nums[<span class="number">0</span>]], nums[nums[<span class="number">1</span>]], nums[nums[<span class="number">2</span>]], nums[nums[<span class="number">3</span>]], nums[nums[<span class="number">4</span>]], nums[nums[<span class="number">5</span>]]]</span><br><span class="line">    = [nums[<span class="number">5</span>], nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>], nums[<span class="number">3</span>], nums[<span class="number">4</span>]]</span><br><span class="line">    = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums<span class="selector-class">.length</span> &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt; nums.length</span><br><span class="line">nums 中的元素 互不相同</span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/build-array-from-permutation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/build-array-from-permutation</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力运算即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buildArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans[i] = nums[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5801-消灭怪物的最大数量"><a href="#5801-消灭怪物的最大数量" class="headerlink" title="5801. 消灭怪物的最大数量"></a>5801. 消灭怪物的最大数量</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 下标从 <code>0</code> 开始 且长度为 <code>n</code> 的整数数组<code>dist</code> ，其中 <code>dist[i]</code> 是第 <code>i</code>个怪物与城市的 初始距离（单位：米）。</p><p>怪物以 恒定 的速度走向城市。给你一个长度为<code>n</code>的整数数组 <code>speed</code>表示每个怪物的速度，其中 <code>speed[i]</code> 是第<code>i</code>个怪物的速度（单位：米/分）。</p><p>怪物从 第 0 分钟 时开始移动。你有一把武器，并可以 选择 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p><p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 恰 在某一分钟开始时到达城市，这会被视为 输掉 游戏，在你可以使用武器之前，游戏就会结束。</p><p>返回在你输掉游戏前可以消灭的怪物的 最大 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  n 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>], speed = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 分钟开始时，怪物的距离是 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]，你消灭了第一个怪物。</span><br><span class="line">第 <span class="number">1</span> 分钟开始时，怪物的距离是 [X,<span class="number">2</span>,<span class="number">3</span>]，你没有消灭任何怪物。</span><br><span class="line">第 <span class="number">2</span> 分钟开始时，怪物的距离是 [X,<span class="number">1</span>,<span class="number">2</span>]，你消灭了第二个怪物。</span><br><span class="line">第 <span class="number">3</span> 分钟开始时，怪物的距离是 [X,X,<span class="number">1</span>]，你消灭了第三个怪物。</span><br><span class="line">所有 <span class="number">3</span> 个怪物都可以被消灭。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], speed = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 分钟开始时，怪物的距离是 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，你消灭了第一个怪物。</span><br><span class="line">第 <span class="number">1</span> 分钟开始时，怪物的距离是 [X,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]，你输掉了游戏。</span><br><span class="line">你只能消灭 <span class="number">1</span> 个怪物。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], speed = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 分钟开始时，怪物的距离是 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]，你消灭了第一个怪物。</span><br><span class="line">第 <span class="number">1</span> 分钟开始时，怪物的距离是 [X,<span class="number">0</span>,<span class="number">2</span>]，你输掉了游戏。 </span><br><span class="line">你只能消灭 <span class="number">1</span> 个怪物。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == dist.length == speed.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= dist[i], speed[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们按照贪心算法排序即可，依次消灭最快到达城市的怪物即可。</li><li>时间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eliminateMaximum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dist.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr.push_back(make_pair(dist[i],speed[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">double</span> ta = <span class="keyword">double</span>(a.first)/a.second;</span><br><span class="line">            <span class="keyword">double</span> tb = <span class="keyword">double</span>(b.first)/b.second;</span><br><span class="line">            <span class="keyword">return</span> ta &lt; tb;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)arr[i].second*i &gt;= arr[i].first) <span class="keyword">break</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5802-统计好数字的数目"><a href="#5802-统计好数字的数目" class="headerlink" title="5802. 统计好数字的数目"></a>5802. 统计好数字的数目</h2><p>我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。</p><p>比方说，<code>&quot;2582&quot;</code> 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。但 <code>&quot;3245&quot;</code> 不是 好数字，因为 3 在偶数下标处但不是偶数。<br>给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对 <code>109 + 7</code> 取余后返回 。</p><p>一个 数字字符串 是每一位都由 0 到 <code>9</code> 组成的字符串，且可能包含前导 0 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：长度为 <span class="number">1</span> 的好数字包括 <span class="string">"0"</span>，<span class="string">"2"</span>，<span class="string">"4"</span>，<span class="string">"6"</span>，<span class="string">"8"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">400</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">50</span></span><br><span class="line">输出：<span class="number">564908303</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1015</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-good-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-good-numbers</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目即为非常简单的数学问题，我们可以将两位划分成为一组，如果如果$n$为偶数，则我们可以知道总的数目为$20^{n/2}$,如果$n$为奇数，则我们可以知道总的数目应该为$5*20^{\frac{n-1}{2}}$.</li><li>可以利用<code>fastpow</code>即可在$lgn$的时间复杂度内求出结果。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = y ; i != <span class="number">0</span>; i = i&gt;&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                ans = (ans*curr)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodNumbers</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> fastpow(<span class="number">20</span>,n/<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">5</span>*fastpow(<span class="number">20</span>,(n<span class="number">-1</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5803-最长公共子路径"><a href="#5803-最长公共子路径" class="headerlink" title="5803. 最长公共子路径"></a>5803. 最长公共子路径</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个国家由 <code>n</code>个编号为 0 到 <code>n - 1</code>的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。</p><p>总共有<code>m</code>个编号为 0 到<code>m - 1</code> 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。</p><p>给你一个整数 <code>n</code>和二维数组 <code>paths</code> ，其中 <code>paths[i]</code>是一个整数数组，表示第 i 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。</p><p>一个 子路径 指的是一条路径中连续的城市序列。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, paths = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                     [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                     [<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长公共子路径为 [<span class="number">2</span>,<span class="number">3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, paths = [[<span class="number">0</span>],[<span class="number">1</span>],[<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：三条路径没有公共子路径。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, paths = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                     [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最长公共子路径为 [<span class="number">0</span>]，[<span class="number">1</span>]，[<span class="number">2</span>]，[<span class="number">3</span>] 和 [<span class="number">4</span>] 。它们长度都为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 105</code></li><li><code>m == paths.length</code></li><li><code>2 &lt;= m &lt;= 105</code></li><li><code>sum(paths[i].length) &lt;= 105</code></li><li><code>0 &lt;= paths[i][j] &lt; n</code></li><li><code>paths[i]</code>中同一个城市不会连续重复出现。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-common-subpath" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subpath</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> KR hash算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><code>Rabin-Karp</code>算法，利用字符串的<code>hash</code>算法将字符串的所有字串进行<code>hash</code>表示<code>key</code>，然后在所有的路径中检测是否都存在相同的<code>key</code>即可。</li><li>算法时间复杂为$O(nlgn)$,总的来说算是个好的题目，但是真心不适合面试。关键在于如何处理<code>hash</code>冲突的问题，官方题解中用了两个<code>hash</code>来检测<code>hash</code>冲突的问题，确实是个不错的技巧，值得学习。</li><li>后缀数组的解法就比较难了，还是老实看题解。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll B1 = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll M1 = <span class="number">1e12</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths,<span class="keyword">int</span> len,ll base,ll mod)</span> </span>&#123;</span><br><span class="line">        ll P = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = paths.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            P = (P*base)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;ll, <span class="keyword">int</span>&gt; total;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : paths) &#123;</span><br><span class="line">            ll curr = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;ll&gt; part;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); i++) &#123;</span><br><span class="line">                curr = (curr*base  + p[i])%mod;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= len) &#123;</span><br><span class="line">                    curr = (curr - (P*p[i-len])%mod + mod)%mod; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= len<span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(part.count(curr)) <span class="keyword">continue</span>;</span><br><span class="line">                    part.insert(curr);</span><br><span class="line">                    total[curr]++;</span><br><span class="line">                    <span class="keyword">if</span>(total[curr] == m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubpath</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.size(); ++i)&#123;</span><br><span class="line">            r = min(r,<span class="keyword">int</span>(paths[i].size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(paths, mid,B1,M1)) &#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>, l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-248&quot;&gt;&lt;a href=&quot;#leetcode-contest-248&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  248&quot;&gt;&lt;/a&gt;leetcode  contest  248&lt;/h1&gt;&lt;p&gt;今天周赛前三题基本上都是简单题目，最后一题难度确实很大，不过感觉也是模板题目，最终极的解法还是利用后缀数组来解答。不过常规的用&lt;code&gt;rabin-karp&lt;/code&gt;字符串&lt;code&gt;hash&lt;/code&gt;算法也可以解决，但是很蛋疼的题目的解法竟然会卡&lt;code&gt;1e9 + 7&lt;/code&gt;的取模答案，所以在实际计算时的取模将会是个很大的问题。官方的解答比较有技巧的是用了两个&lt;code&gt;hash&lt;/code&gt;来解决碰撞的概率，确实是个非常好的技巧。还是前三题的节奏，感觉非常蛋疼的题目，如果不知道字符串&lt;code&gt;hash&lt;/code&gt;或者&lt;code&gt;suffix array&lt;/code&gt;的解法，这个题目就不会。最后一题据说是竞赛网站的模板题目，感觉真心蛋疼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Binarysearch】 每日一题 7.3</title>
    <link href="http://yoursite.com/2021/07/03/299/"/>
    <id>http://yoursite.com/2021/07/03/299/</id>
    <published>2021-07-03T14:56:15.048Z</published>
    <updated>2021-07-03T15:09:27.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p>最近开始计划进行每日一道算法题的训练，初步计划以国外的刷题平台<code>binarysearch</code>为主，这个平台上的题目题目质量很高，感觉还是非常值得学习和思考的，计划坚持每日一题的节奏，计划主要坚持刷<code>mid</code>难度以上的题目，题目还是非常经典的，感觉质量要比<code>leetcode</code>的题目质量高很多。但是难度感觉不算很高，感觉也就是面试题目的难度，远远比不上<code>ACM</code>算法题目的难度，但是感觉还是非常值得学习和思考的题目。</p><a id="more"></a><h2 id="Minimal-Submatrices"><a href="#Minimal-Submatrices" class="headerlink" title="Minimal Submatrices"></a>Minimal Submatrices</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a two-dimensional integer matrix and an integer k, return a matrix containing minimum values of all <code>k</code>by <code>k</code>submatrices.</p><p>Constraints</p><ul><li><code>1 ≤ n * m ≤ 100,000</code> where <code>n</code>and<code>m</code>are the number of rows and columns in <code>matrix</code><br>Example 1<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line">k = <span class="number">2</span></span><br></pre></td></tr></table></figure>Output<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>Explanation<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">The top left submatrix has minimum value of <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line">The top right submatrix has minimum value of <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line">The bottom left submatrix has minimum value of <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line">The bottom right submatrix has minimum value of <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://binarysearch.com/problems/Minimal-Submatrices" target="_blank" rel="noopener">https://binarysearch.com/problems/Minimal-Submatrices</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>典型的滑动窗口，即求数组中连续的子数组中最小的元素，只不过这里改为二维的矩阵了。如果用常规的有序集合即可解决问题，我们首先求出每一列中的前<code>k</code>个行中对应的最小元素数组<code>arr</code>，然后在<code>arr</code>中求出该列中连续的<code>k</code>个元素的最小元素，本质上与一维时原理基本相同。</li><li>求连续的<code>k</code>个元素的最小值或者最大值的解法有很多，比如常见的有序集合、单调栈、线段树等等常见的解法，如果用有序集合或者线段树的解法，则时间复杂度为$O(nlgn)$,如果用单调栈则时间复杂度为$O(n)$.</li><li>本题我是直接用的有序集合来解答改题目，时间复杂度为$O(m<em>n</em>lgk)$<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; solve(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&gt; curr(col);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans(row-k+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initial</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">        curr[i].insert(matrix[j][i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= row-k; ++i)&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; min_row(col);</span><br><span class="line">      <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; curr_row;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">        <span class="comment">// insert every element each col</span></span><br><span class="line">        curr[j].insert(matrix[i+k<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="comment">// get every minimum col element</span></span><br><span class="line">        min_row[j] = *curr[j].begin();</span><br><span class="line">        <span class="comment">// remove every minimum row </span></span><br><span class="line">        <span class="keyword">auto</span> it = curr[j].find(matrix[i][j]);</span><br><span class="line">        curr[j].erase(it);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k<span class="number">-1</span>; ++j) curr_row.insert(min_row[j]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = k<span class="number">-1</span>; j &lt; col; ++j)&#123;</span><br><span class="line">        curr_row.insert(min_row[j]);</span><br><span class="line">        ans[i].push_back(*curr_row.begin());</span><br><span class="line">        <span class="keyword">auto</span> it = curr_row.find(min_row[j-k+<span class="number">1</span>]);</span><br><span class="line">        curr_row.erase(it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;每日一题&quot;&gt;&lt;a href=&quot;#每日一题&quot; class=&quot;headerlink&quot; title=&quot;每日一题&quot;&gt;&lt;/a&gt;每日一题&lt;/h1&gt;&lt;p&gt;最近开始计划进行每日一道算法题的训练，初步计划以国外的刷题平台&lt;code&gt;binarysearch&lt;/code&gt;为主，这个平台上的题目题目质量很高，感觉还是非常值得学习和思考的，计划坚持每日一题的节奏，计划主要坚持刷&lt;code&gt;mid&lt;/code&gt;难度以上的题目，题目还是非常经典的，感觉质量要比&lt;code&gt;leetcode&lt;/code&gt;的题目质量高很多。但是难度感觉不算很高，感觉也就是面试题目的难度，远远比不上&lt;code&gt;ACM&lt;/code&gt;算法题目的难度，但是感觉还是非常值得学习和思考的题目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="binarysearch" scheme="http://yoursite.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab2 Systemcalls</title>
    <link href="http://yoursite.com/2021/06/28/298/"/>
    <id>http://yoursite.com/2021/06/28/298/</id>
    <published>2021-06-28T14:42:20.599Z</published>
    <updated>2021-07-03T01:23:35.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="systemcalls"><a href="#systemcalls" class="headerlink" title="systemcalls"></a>systemcalls</h1><p>最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把<code>lab2</code>的内容作完了，<code>lab2</code>的难度感觉比<code>lab1</code>小多了，主要是为系统添加两个<code>system call</code>，总体来说难度偏低。</p><ul><li>首先我们可以观察到，所有的系统调用函数都存放在<code>usys.S</code>中，用<code>risc-v</code>的指令完成。在用户空间中调用系统调用函数<code>func</code>，实际内核中对应的就是系统调用对应的<code>id</code>写入到寄存器<code>a7</code>，然后调用<code>ecall</code>指令，即在内核中可调用对应的函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># generated by usys.pl - do not edit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/syscall.h"</span></span></span><br><span class="line">.global fork</span><br><span class="line">fork:</span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line"> li a7, SYS_exit</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global wait</span><br><span class="line">wait:</span><br><span class="line"> li a7, SYS_wait</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global pipe</span><br><span class="line">pipe:</span><br><span class="line"> li a7, SYS_pipe</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global read</span><br><span class="line">read:</span><br><span class="line"> li a7, SYS_read</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global close</span><br><span class="line">close:</span><br><span class="line"> li a7, SYS_close</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global kill</span><br><span class="line">kill:</span><br><span class="line"> li a7, SYS_kill</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global exec</span><br><span class="line">exec:</span><br><span class="line"> li a7, SYS_exec</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global open</span><br><span class="line">open:</span><br><span class="line"> li a7, SYS_open</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global mknod</span><br><span class="line">mknod:</span><br><span class="line"> li a7, SYS_mknod</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global unlink</span><br><span class="line">unlink:</span><br><span class="line"> li a7, SYS_unlink</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global fstat</span><br><span class="line">fstat:</span><br><span class="line"> li a7, SYS_fstat</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global link</span><br><span class="line">link:</span><br><span class="line"> li a7, SYS_link</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global mkdir</span><br><span class="line">mkdir:</span><br><span class="line"> li a7, SYS_mkdir</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global chdir</span><br><span class="line">chdir:</span><br><span class="line"> li a7, SYS_chdir</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global dup</span><br><span class="line">dup:</span><br><span class="line"> li a7, SYS_dup</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global getpid</span><br><span class="line">getpid:</span><br><span class="line"> li a7, SYS_getpid</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sbrk</span><br><span class="line">sbrk:</span><br><span class="line"> li a7, SYS_sbrk</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sleep</span><br><span class="line">sleep:</span><br><span class="line"> li a7, SYS_sleep</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global uptime</span><br><span class="line">uptime:</span><br><span class="line"> li a7, SYS_uptime</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global trace</span><br><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sysinfo</span><br><span class="line">sysinfo:</span><br><span class="line"> li a7, SYS_sysinfo</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_trace  22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></table></figure></li><li>在内核中我们可以看到实际的系统调用内核中执行如下:<br>从<code>a7</code>寄存器中取出系统调用号，然后执行对应的内核中的函数,系统调用函数可能会从用户空间中取出传入的参数，然后将执行的返回结果再写回到用户空间中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// system call number</span></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;tracemask &amp; (<span class="number">1</span>&lt;&lt;num))&#123;</span><br><span class="line">        <span class="comment">// printf("sys call num = %d\n",num);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: syscall %s -&gt; %d\n"</span>,p-&gt;pid,syscallname[num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s: unknown sys call %d\n"</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果我们需要添加系统调用，则首先添加系统调用的编号，然后在内核中添加系统调用编号对应的回调函数即可。</li><li>测试结果：<br><img src="https://i.loli.net/2021/07/02/WGBDQaPhdVY54Nk.png" alt></li></ul><a id="more"></a><h2 id="1-trace"><a href="#1-trace" class="headerlink" title="1. trace"></a>1. trace</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you will <span class="builtin-name">add</span> a<span class="built_in"> system </span>call tracing feature that may help you when debugging later labs. You’ll create a new trace<span class="built_in"> system </span>call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which<span class="built_in"> system </span>calls <span class="keyword">to</span> trace. <span class="keyword">For</span> example, <span class="keyword">to</span> trace the fork<span class="built_in"> system </span>call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number <span class="keyword">from</span> kernel/syscall.h. You have <span class="keyword">to</span> modify the xv6 kernel <span class="keyword">to</span> <span class="builtin-name">print</span> out a line when each<span class="built_in"> system </span>call is about <span class="keyword">to</span> return, <span class="keyword">if</span> the<span class="built_in"> system </span>call’s number is <span class="builtin-name">set</span> <span class="keyword">in</span> the mask. The line should contain the process id, the name of the<span class="built_in"> system </span>call <span class="keyword">and</span> the return value; you don’t need <span class="keyword">to</span> <span class="builtin-name">print</span> the<span class="built_in"> system </span>call arguments. The trace<span class="built_in"> system </span>call should <span class="builtin-name">enable</span> tracing <span class="keyword">for</span> the process that calls it <span class="keyword">and</span> any children that it subsequently forks, but should <span class="keyword">not</span> affect other processes.</span><br></pre></td></tr></table></figure><p>实现系统调用的<code>trace</code>功能，即打印出进程中每一个在<code>mask</code>掩码中的系统调用，并且子进程会继承父进程的<code>mask</code>.</p><ul><li>代码实现本身不是特别难，主要是需要弄清楚系统的调用的过程。我们首先添加系统调用编号<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_trace  22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></table></figure>在用户程序中添加如下:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">"sleep"</span>);</span><br><span class="line">entry(<span class="string">"uptime"</span>);</span><br><span class="line">entry(<span class="string">"trace"</span>);</span><br><span class="line">entry(<span class="string">"sysinfo"</span>);</span><br></pre></td></tr></table></figure>在进程的结构体中增加<code>tracemask</code>变量，在<code>systemcall</code>函数中需要修改，每次进行系统调用时，则将系统调用号与掩码进行比对，是否存在于掩码的状态中，如果掩码存在，则此时我们打印出系统调用的具体信息。本身不是特别难。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;tracemask &amp; (<span class="number">1</span>&lt;&lt;num))&#123;</span><br><span class="line">        <span class="comment">// printf("sys call num = %d\n",num);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: syscall %s -&gt; %d\n"</span>,p-&gt;pid,syscallname[num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s: unknown sys call %d\n"</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system trace call, using trace mask to print system call information</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(<span class="keyword">int</span> mask)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  p-&gt;tracemask = mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-sysinfo"><a href="#2-sysinfo" class="headerlink" title="2. sysinfo"></a>2. sysinfo</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you will <span class="builtin-name">add</span> a<span class="built_in"> system </span>call, sysinfo, that collects information about the running system. The<span class="built_in"> system </span>call takes one argument: a pointer <span class="keyword">to</span> a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be <span class="builtin-name">set</span> <span class="keyword">to</span> the number of bytes of free memory, <span class="keyword">and</span> the nproc field should be <span class="builtin-name">set</span> <span class="keyword">to</span> the number of processes whose state is <span class="keyword">not</span> UNUSED. We provide a test program sysinfotest; you pass this assignment <span class="keyword">if</span> it prints “sysinfotest: OK”.</span><br></pre></td></tr></table></figure>完成<code>sysinfo</code>系统调用，主要时获取当前<code>heap</code>中的<code>free</code>的总空间，同时获取当前系统中存在多少非空闲的进程个数。这个也比较简单，难点在于学会将内核空间的数据拷贝到用户空间。</li><li>系统调用添加的流程跟<code>trace</code>是一样的，稍微复杂点即是需要在<code>kalloc.c</code>中添加对<code>free memory</code>的统计，以及在<code>proc</code>中添加对空闲进程的统计。</li><li><code>kalloc</code>中我们可以看到所有的<code>memory free</code>是用<code>list</code>表示的，每一块空闲的内存大小为<code>4096 byte</code>，我们只需要遍历<code>freelist</code>统计块的数目即可。</li><li><code>proc</code>中我们可以看到每一个<code>process</code>都有一个状态，我们只需要检测<code>process</code>的状态即可，<code>process</code>列表用数组表示，我们只需要遍历数组即可。</li><li>关键的一点，获取参数以后，需要将所有的参数信息从内核空间拷贝到用户空间即可，这时需要用到<code>copyout</code>函数.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysinfo</span><span class="params">(uint64 addr)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  st.freemem = totalfree();</span><br><span class="line">  st.nproc   = nproc();</span><br><span class="line">  <span class="comment">// printf("total free: %d\n",st.freemem);</span></span><br><span class="line">  <span class="comment">// printf("total proc：%d\n",st.nproc);</span></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="keyword">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system information null process number.</span></span><br><span class="line"><span class="function">uint64 <span class="title">nproc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 tot = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">      tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">totalfree</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  uint64 tot = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get totall free memory</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    tot += <span class="number">4096</span>;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;systemcalls&quot;&gt;&lt;a href=&quot;#systemcalls&quot; class=&quot;headerlink&quot; title=&quot;systemcalls&quot;&gt;&lt;/a&gt;systemcalls&lt;/h1&gt;&lt;p&gt;最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把&lt;code&gt;lab2&lt;/code&gt;的内容作完了，&lt;code&gt;lab2&lt;/code&gt;的难度感觉比&lt;code&gt;lab1&lt;/code&gt;小多了，主要是为系统添加两个&lt;code&gt;system call&lt;/code&gt;，总体来说难度偏低。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;首先我们可以观察到，所有的系统调用函数都存放在&lt;code&gt;usys.S&lt;/code&gt;中，用&lt;code&gt;risc-v&lt;/code&gt;的指令完成。在用户空间中调用系统调用函数&lt;code&gt;func&lt;/code&gt;，实际内核中对应的就是系统调用对应的&lt;code&gt;id&lt;/code&gt;写入到寄存器&lt;code&gt;a7&lt;/code&gt;，然后调用&lt;code&gt;ecall&lt;/code&gt;指令，即在内核中可调用对应的函数。&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# generated by usys.pl - do not edit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;kernel/syscall.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fork:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_exit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global wait&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wait:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_wait&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global pipe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pipe:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_pipe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global read&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;read:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_read&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global write&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;write:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_write&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global close&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;close:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_close&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global kill&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kill:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_kill&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global exec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exec:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_exec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global open&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;open:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_open&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global mknod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mknod:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_mknod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global unlink&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unlink:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_unlink&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global fstat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fstat:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_fstat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global link&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;link:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_link&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global mkdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_mkdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global chdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chdir:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_chdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global dup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dup:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_dup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global getpid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getpid:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_getpid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global sbrk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sbrk:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_sbrk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global sleep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sleep:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_sleep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global uptime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;uptime:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_uptime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global trace&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;trace:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_trace&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global sysinfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sysinfo:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_sysinfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// System call numbers&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_fork    1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_exit    2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_wait    3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_pipe    4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_read    5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_kill    6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_exec    7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_fstat   8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_chdir   9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_dup    10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_getpid 11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_sbrk   12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_sleep  13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_uptime 14&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_open   15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_write  16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_mknod  17&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_unlink 18&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_link   19&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_mkdir  20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_close  21&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_trace  22&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_sysinfo 23&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;在内核中我们可以看到实际的系统调用内核中执行如下:&lt;br&gt;从&lt;code&gt;a7&lt;/code&gt;寄存器中取出系统调用号，然后执行对应的内核中的函数,系统调用函数可能会从用户空间中取出传入的参数，然后将执行的返回结果再写回到用户空间中。&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;syscall(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;proc&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;myproc&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// system call number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  num = p-&amp;gt;trapframe-&amp;gt;a7;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; num &amp;lt; NELEM(syscalls) &amp;amp;&amp;amp; syscalls[num]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;trapframe-&amp;gt;a0 = syscalls[num]();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;tracemask &amp;amp; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;num))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// printf(&quot;sys call num = %d\n&quot;,num);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d: syscall %s -&amp;gt; %d\n&quot;&lt;/span&gt;,p-&amp;gt;pid,syscallname[num],p-&amp;gt;trapframe-&amp;gt;a0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %s: unknown sys call %d\n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p-&amp;gt;pid, p-&amp;gt;name, num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;trapframe-&amp;gt;a0 = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;如果我们需要添加系统调用，则首先添加系统调用的编号，然后在内核中添加系统调用编号对应的回调函数即可。&lt;/li&gt;
&lt;li&gt;测试结果：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/02/WGBDQaPhdVY54Nk.png&quot; alt&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 247</title>
    <link href="http://yoursite.com/2021/06/27/297/"/>
    <id>http://yoursite.com/2021/06/27/297/</id>
    <published>2021-06-27T05:29:11.848Z</published>
    <updated>2021-06-27T14:11:53.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-247"><a href="#leetcode-contest-247" class="headerlink" title="leetcode  contest  247"></a>leetcode  contest  247</h1><p>周赛的题目质量一向非常高，非常喜欢这类难度适中的题目，稍微带点思考，但并不是特别难的题目。不过还是三题的节奏，第三题竟然没有做出来。</p><h2 id="5797-两个数对之间的最大乘积差"><a href="#5797-两个数对之间的最大乘积差" class="headerlink" title="5797. 两个数对之间的最大乘积差"></a>5797. 两个数对之间的最大乘积差</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>两个数对<code>(a, b)</code> 和 <code>(c, d)</code>之间的 乘积差 定义为 <code>(a * b) - (c * d)</code> 。</p><a id="more"></a><ul><li>例如，<code>(5, 6)</code> 和 <code>(2, 7)</code> 之间的乘积差是 <code>(5 * 6) - (2 * 7) = 16</code> 。</li></ul><p>给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对<code>(nums[w], nums[x])</code> 和 <code>(nums[y], nums[z])</code>之间的 乘积差 取到 最大值 。</p><p>返回以这种方式取得的乘积差中的 最大值 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">34</span></span><br><span class="line">解释：可以选出下标为 <span class="number">1</span> 和 <span class="number">3</span> 的元素构成第一个数对 (<span class="number">6</span>, <span class="number">7</span>) 以及下标 <span class="number">2</span> 和 <span class="number">4</span> 构成第二个数对 (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">乘积差是 (<span class="number">6</span> * <span class="number">7</span>) - (<span class="number">2</span> * <span class="number">4</span>) = <span class="number">34</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">64</span></span><br><span class="line">解释：可以选出下标为 <span class="number">3</span> 和 <span class="number">6</span> 的元素构成第一个数对 (<span class="number">9</span>, <span class="number">8</span>) 以及下标 <span class="number">1</span> 和 <span class="number">5</span> 构成第二个数对 (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">乘积差是 (<span class="number">9</span> * <span class="number">8</span>) - (<span class="number">2</span> * <span class="number">4</span>) = <span class="number">64</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>4 &lt;= nums.length &lt;= 104</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的数学问题，我们知道成绩差的最大值肯定为最大的两数之积减去最小的两数之积。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProductDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[n<span class="number">-1</span>]*nums[n<span class="number">-2</span>] - nums[<span class="number">0</span>]*nums[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5798-循环轮转矩阵"><a href="#5798-循环轮转矩阵" class="headerlink" title="5798. 循环轮转矩阵"></a>5798. 循环轮转矩阵</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>m x n</code>的整数矩阵 <code>grid​​​</code> ，其中 <code>m</code> 和 <code>n</code> 都是 偶数 ；另给你一个整数 k 。</p><p>矩阵由若干层组成，如下图所示，每种颜色代表一层：<br>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 逆时针 方向的相邻元素。轮转示例如下：<br>返回执行 <code>k</code>次循环轮转操作后的矩阵。</p><p>示例 1：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[40,10],[30,20]]</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[10,20],[40,30]]</span></span><br><span class="line">解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]], k = <span class="number">2</span></span><br><span class="line">输出：[[<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>],[<span class="number">2</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">16</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">15</span>],[<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">14</span>]]</span><br><span class="line">解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 50</code></li><li><code>m</code> 和 <code>n</code> 都是 偶数</li><li><code>1 &lt;= grid[i][j] &lt;= 5000</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/cyclically-rotating-a-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cyclically-rotating-a-grid</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们按照层次分别进行模拟旋转即可，这个就是找规律。取出每一层的数据，然后进行向左偏移$k$位即可。</li><li>时间复杂度位$O(2*n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rotateGrid(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> level = min(row/<span class="number">2</span>,col/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copy;</span><br><span class="line">            <span class="comment">/*up*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; col-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*right*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; row-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[j][col-i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*bottom*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                arr.push_back(grid[row<span class="number">-1</span>-i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*left*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = row<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                arr.push_back(grid[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*rotate*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.size(); ++j)&#123;</span><br><span class="line">                copy.push_back(arr[(j+k)%arr.size()]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">             <span class="comment">/*up*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; col-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                ans[i][j] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*right*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; row-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                ans[j][col-i<span class="number">-1</span>] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*bottom*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                ans[row<span class="number">-1</span>-i][j] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*left*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = row<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                ans[j][i] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5799-最美子字符串的数目"><a href="#5799-最美子字符串的数目" class="headerlink" title="5799. 最美子字符串的数目"></a>5799. 最美子字符串的数目</h2><p>如果某个字符串中 至多一个 字母出现 奇数 次，则称其为 最美 字符串。</p><p>例如，<code>&quot;ccjjc&quot;</code> 和 <code>&quot;abab&quot;</code>都是最美字符串，但 <code>&quot;ab&quot;</code>不是。<br>给你一个字符串 <code>word</code> ，该字符串由前十个小写英文字母组成（’a’ 到 ‘j’）。请你返回 <code>word</code> 中 最美非空子字符串 的数目。如果同样的子字符串在 <code>word</code>中出现多次，那么应当对 每次出现 分别计数。</p><p>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"aba"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：<span class="number">4</span> 个最美子字符串如下所示：</span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"b"</span></span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"aba"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"aabb"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：<span class="number">9</span> 个最美子字符串如下所示：</span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"aa"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"aab"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"aabb"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"abb"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"b"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"bb"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"b"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"he"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">2</span> 个最美子字符串如下所示：</span><br><span class="line">- <span class="string">"he"</span> -&gt; <span class="string">"h"</span></span><br><span class="line">- <span class="string">"he"</span> -&gt; <span class="string">"e"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 105</code></li><li><code>word</code>由从 <code>&#39;a&#39;</code>到 <code>&#39;j&#39;</code> 的小写英文字母组成<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/number-of-wonderful-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-wonderful-substrings</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 前缀和 + 状态压缩<code>dp</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>这个题目出的非常不错，我们设状态二进制<code>mask</code>，如果<code>mask</code>的第<code>i</code>位为<code>1</code>则表示字母<code>&#39;a&#39; + i</code>的数目为奇数，如果<code>mask</code>的第<code>i</code>位为<code>0</code>则表示字母<code>&#39;a&#39; + i</code>的数目为偶数。则我们可以字符统计的前缀和，如果状态<code>mask</code>相等的前缀之间的连续子字符串一定每个字符的个数均为偶数。</li><li>题目还给出另一个要求，至多存在一个字符的数目为奇数，则我们可以知道，如果两个前缀之间的某个字符的奇偶性相反，则这两个前缀之间的连续子字符串的该字符的个数一定为奇数，则我们依次尝试假设每一个字符可能为奇数，进行尝试即可。</li><li>时间复杂度为$O(m*n)$,空间复杂度为$2^{m}$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wonderfulSubstrings</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = word.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">1024</span>,<span class="number">0</span>);</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            mask = mask^(<span class="number">1</span>&lt;&lt;(word[i] - <span class="string">'a'</span>));</span><br><span class="line">            ans += cnt[mask];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)&#123;</span><br><span class="line">                ans += cnt[mask^(<span class="number">1</span>&lt;&lt;j)];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[mask]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5204-统计为蚁群构筑房间的不同顺序"><a href="#5204-统计为蚁群构筑房间的不同顺序" class="headerlink" title="5204. 统计为蚁群构筑房间的不同顺序"></a>5204. 统计为蚁群构筑房间的不同顺序</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你是一只蚂蚁，负责为蚁群构筑 <code>n</code>间编号从<code>0</code>到 <code>n-1</code>的新房间。给你一个 下标从 <code>0</code>开始 且长度为 n 的整数数组 <code>prevRoom</code>作为扩建计划。其中，<code>prevRoom[i]</code>表示在构筑房间 i 之前，你必须先构筑房间 <code>prevRoom[i]</code>，并且这两个房间必须 直接 相连。房间 0 已经构筑完成，所以 <code>prevRoom[0] = -1</code>。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 <code>0</code>可以访问到每个房间。</p><p>你一次只能构筑 一个 房间。你可以在 已经构筑好的 房间之间自由穿行，只要这些房间是 相连的 。如果房间 <code>prevRoom[i]</code> 已经构筑完成，那么你就可以构筑房间 <code>i</code>。</p><p>返回你构筑所有房间的 不同顺序的数目 。由于答案可能很大，请返回对<code>109 + 7</code>取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prevRoom = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：仅有一种方案可以完成所有房间的构筑：<span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：prevRoom = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">6</span> 种不同顺序：</span><br><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">3</span> → <span class="number">2</span> → <span class="number">4</span></span><br><span class="line"><span class="number">0</span> → <span class="number">2</span> → <span class="number">4</span> → <span class="number">1</span> → <span class="number">3</span></span><br><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span> → <span class="number">3</span> → <span class="number">4</span></span><br><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span> → <span class="number">4</span> → <span class="number">3</span></span><br><span class="line"><span class="number">0</span> → <span class="number">2</span> → <span class="number">1</span> → <span class="number">3</span> → <span class="number">4</span></span><br><span class="line"><span class="number">0</span> → <span class="number">2</span> → <span class="number">1</span> → <span class="number">4</span> → <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == prevRoom.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>prevRoom[0] == -1</code></li><li>对于所有的 <code>1 &lt;= i &lt; n</code> ，都有 <code>0 &lt;= prevRoom[i] &lt; n</code></li><li>题目保证所有房间都构筑完成后，从房间 <code>0</code>可以访问到每个房间</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-ways-to-build-rooms-in-an-ant-colony" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-ways-to-build-rooms-in-an-ant-colony</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp ，排列组合，乘法逆元</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目除了乘法逆元的数学知识以外，我觉题目本身不难，即为非常容易理解的排列组合。但是觉得这个题目还是出的很好，质量很高，非常适合拿来面试。题目主要要求，构造的拓扑排序的方案数目，我们按照拓扑排序的方式来构造序列即可。</li><li>需要的基础知识为：</li></ol><ul><li>排列数的基本方式，我们知道有$a_{0}$个物品$0$,$a_{1}$个物品$1$,…,$a_{n}$个物品$n$,如果我们需要将这$n$类物品排成一列，则方案数为：<script type="math/tex; mode=display">\frac{(a_{0} + a_{1} + a_{2} + ... + a_{n})!}{a_{0}!.a_{1}!...a_{n}!}</script></li><li>乘法逆元：<script type="math/tex; mode=display">(\frac{b}{a})\mod m ≡ (b * a^{-1} \mod m) \\a*a^{-1} ≡ (1 \mod m) \\a^{-1} ≡ a^{m-2}</script></li></ul><ol><li>设以<code>x</code>为<code>root</code>节点的子树的节点个数为$cnt[x]$,子数的可能的排序方法数为$dp[x]$，则我们可以知道以<code>q</code>为<code>root</code>的树的孩子节点分别为:$p_{1},p_{2},…,p_{k}$,则我们知道根据排列组合可以知道如下：<script type="math/tex; mode=display">cnt[q] = 1 + \sum_{i=1}^{k}p_{i} \\dp[q] = \frac{(p_{1} + p_{2} + p_{3} + ... + p_{k})!}{p_{1}.!p_{2}!...p_{k}!} * \prod_{i=1}^{k}dp[p_{i}]\\= (p_{1} + p_{2} + p_{3} + ... + p_{k})!\prod_{i=1}^{k}((p_{i}!)^{-1}*dp[pi])</script></li><li>算法时间复杂度为$O(32*n)$,空间复杂度为$O(n)$.</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i != <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ret = (ret*curr)%mod;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToBuildRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prevRoom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prevRoom.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; fac(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; inv(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fac[i] = (fac[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">            inv[i] = fastpow(fac[i],mod<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            next[prevRoom[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         function&lt;long long(int)&gt; dfs = [&amp;](int u)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : next[u])&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> curr = dfs(v);</span><br><span class="line">                ret = ((ret*curr)%mod*inv[cnt[v]])%mod;</span><br><span class="line">                cnt[u] += cnt[v];</span><br><span class="line">            &#125;</span><br><span class="line">            ret = (ret*fac[cnt[u]])%mod;</span><br><span class="line">            cnt[u]++;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-247&quot;&gt;&lt;a href=&quot;#leetcode-contest-247&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  247&quot;&gt;&lt;/a&gt;leetcode  contest  247&lt;/h1&gt;&lt;p&gt;周赛的题目质量一向非常高，非常喜欢这类难度适中的题目，稍微带点思考，但并不是特别难的题目。不过还是三题的节奏，第三题竟然没有做出来。&lt;/p&gt;&lt;h2 id=&quot;5797-两个数对之间的最大乘积差&quot;&gt;&lt;a href=&quot;#5797-两个数对之间的最大乘积差&quot; class=&quot;headerlink&quot; title=&quot;5797. 两个数对之间的最大乘积差&quot;&gt;&lt;/a&gt;5797. 两个数对之间的最大乘积差&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;两个数对&lt;code&gt;(a, b)&lt;/code&gt; 和 &lt;code&gt;(c, d)&lt;/code&gt;之间的 乘积差 定义为 &lt;code&gt;(a * b) - (c * d)&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Biweekly Contest 55</title>
    <link href="http://yoursite.com/2021/06/27/296/"/>
    <id>http://yoursite.com/2021/06/27/296/</id>
    <published>2021-06-26T23:39:53.046Z</published>
    <updated>2021-06-27T05:29:16.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-55"><a href="#leetcode-biweekly-contest-55" class="headerlink" title="leetcode  biweekly contest 55"></a>leetcode  biweekly contest 55</h1><p>双周赛的题目难度一直不太稳定，要么太简单，要么太难。晚上的题目确实都很简单。<br><img src="https://i.loli.net/2021/06/27/DjQ1vFhtSUCzXge.png" alt></p><h2 id="5780-删除一个元素使数组严格递增"><a href="#5780-删除一个元素使数组严格递增" class="headerlink" title="5780. 删除一个元素使数组严格递增"></a>5780. 删除一个元素使数组严格递增</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 0 开始的整数数组 <code>nums</code> ，如果 恰好 删除 一个 元素后，数组 严格递增 ，那么请你返回<code>true</code> ，否则返回 false 。如果数组本身已经是严格递增的，请你也返回<code>true</code> 。</p><a id="more"></a><p>数组 nums 是 严格递增 的定义为：对于任意下标的 <code>1 &lt;= i &lt; nums.length</code>都满足 <code>nums[i - 1] &lt; nums[i]</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：从 nums 中删除下标 <span class="number">2</span> 处的 <span class="number">10</span> ，得到 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>] 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>] 是严格递增的，所以返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>] 是删除下标 <span class="number">0</span> 处元素后得到的结果。</span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>] 是删除下标 <span class="number">1</span> 处元素后得到的结果。</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>] 是删除下标 <span class="number">2</span> 处元素后得到的结果。</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 是删除下标 <span class="number">3</span> 处元素后得到的结果。</span><br><span class="line">没有任何结果数组是严格递增的，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：删除任意元素后的结果都是 [<span class="number">1</span>,<span class="number">1</span>] 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>] 不是严格递增的，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 已经是严格递增的，所以返回 <span class="literal">true</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= nums.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">1000</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的滑动窗口，如果去掉当前的第`i`个元素，则需要判断条件如下：</span><br><span class="line">+ 前`i<span class="number">-1</span>`个元素为严格递增，从`i+<span class="number">1</span>`开始的元素严格递增。</span><br><span class="line">+ $nums[i+<span class="number">1</span>] &gt; nums[i<span class="number">-1</span>]$</span><br><span class="line"><span class="number">2.</span> 时间复杂度为$O(n)$,空间复杂度为$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> canBeIncreasing(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; left(n);</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; right(n);</span><br><span class="line">        left[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        right[n<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; left[i<span class="number">-1</span>])&#123;</span><br><span class="line">                left[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i+<span class="number">1</span>] &amp;&amp; right[i+<span class="number">1</span>])&#123;</span><br><span class="line">                right[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i+<span class="number">1</span>] &gt; nums[i<span class="number">-1</span>] &amp;&amp; left[i<span class="number">-1</span>] &amp;&amp; right[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5781-删除一个字符串中所有出现的给定子字符串"><a href="#5781-删除一个字符串中所有出现的给定子字符串" class="headerlink" title="5781. 删除一个字符串中所有出现的给定子字符串"></a>5781. 删除一个字符串中所有出现的给定子字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串<code>s</code>和 <code>part</code>，请你对 s 反复执行以下操作直到 所有 子字符串 <code>part</code>都被删除：</p><p>找到<code>s</code> 中 最左边 的子字符串<code>part</code> ，并将它从 <code>s</code> 中删除。<br>请你返回从 <code>s</code> 中删除所有 <code>part</code>子字符串以后得到的剩余字符串。</p><p>一个 子字符串 是一个字符串中连续的字符序列。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"daabcbaabcbc"</span>, <span class="attr">part</span> = <span class="string">"abc"</span></span><br><span class="line">输出：<span class="string">"dab"</span></span><br><span class="line">解释：以下操作按顺序执行：</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"daabcbaabcbc"</span> ，删除下标从 <span class="number">2</span> 开始的 <span class="string">"abc"</span> ，得到 <span class="attr">s</span> = <span class="string">"dabaabcbc"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"dabaabcbc"</span> ，删除下标从 <span class="number">4</span> 开始的 <span class="string">"abc"</span> ，得到 <span class="attr">s</span> = <span class="string">"dababc"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"dababc"</span> ，删除下标从 <span class="number">3</span> 开始的 <span class="string">"abc"</span> ，得到 <span class="attr">s</span> = <span class="string">"dab"</span> 。</span><br><span class="line">此时 s 中不再含有子字符串 <span class="string">"abc"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"axxxxyyyyb"</span>, <span class="attr">part</span> = <span class="string">"xy"</span></span><br><span class="line">输出：<span class="string">"ab"</span></span><br><span class="line">解释：以下操作按顺序执行：</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"axxxxyyyyb"</span> ，删除下标从 <span class="number">4</span> 开始的 <span class="string">"xy"</span> ，得到 <span class="attr">s</span> = <span class="string">"axxxyyyb"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"axxxyyyb"</span> ，删除下标从 <span class="number">3</span> 开始的 <span class="string">"xy"</span> ，得到 <span class="attr">s</span> = <span class="string">"axxyyb"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"axxyyb"</span> ，删除下标从 <span class="number">2</span> 开始的 <span class="string">"xy"</span> ，得到 <span class="attr">s</span> = <span class="string">"axyb"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"axyb"</span> ，删除下标从 <span class="number">1</span> 开始的 <span class="string">"xy"</span> ，得到 <span class="attr">s</span> = <span class="string">"ab"</span> 。</span><br><span class="line">此时 s 中不再含有子字符串 <span class="string">"xy"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>1 &lt;= part.length &lt;= 1000</code></li><li><code>s​​​​​​</code> 和 <code>part</code> `只包小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 栈的应用</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的栈的应用，我们判断当前栈的后<code>n</code>个字符组成的字符串是否与<code>part</code>相等，如果相等则从栈中弹出<code>n</code>个字符。</li><li>时间复杂度为$O(n^{2})$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOccurrences</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> part)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size();</span><br><span class="line">        <span class="keyword">int</span> n = part.size();</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            curr.push_back(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt;= n &amp;&amp; curr.substr(curr.size()-n) == part)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) curr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5782-最大子序列交替和"><a href="#5782-最大子序列交替和" class="headerlink" title="5782. 最大子序列交替和"></a>5782. 最大子序列交替和</h2><p>一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。</p><p>比方说，数组 <code>[4,2,5,3]</code>的交替和为<code>(4 + 5) - (2 + 3) = 4</code>。<br>给你一个数组 <code>nums</code>，请你返回 <code>nums</code>中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。</p><p>一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,2,3,7,2,1,4]</code> 的一个子序列（加粗元素），但是 <code>[2,4,2]</code>不是。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：最优子序列为 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] ，交替和为 (<span class="number">4</span> + <span class="number">5</span>) - <span class="number">2</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：最优子序列为 [<span class="number">8</span>] ，交替和为 <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：最优子序列为 [<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>] ，交替和为 (<span class="number">6</span> + <span class="number">5</span>) - <span class="number">1</span> = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态对话，我们设<code>dp[i][0]</code>表示前<code>i</code>个数中选择奇数个元素的最大交替和，<code>dp[i][1]</code>表示前<code>i</code>个数中选择偶数个元素的最大交替和。</li><li>如果我们选择第<code>i+1</code>个元素加入到子数组中，</li></ol><ul><li>前<code>i+1</code>个元素中选择奇数个元素的子序列，假设选择第<code>i+1</code>个元素加入到子序列中，则$nums[i+1]$在子序列中的下标应该为偶数，则前<code>i</code>个元素中已经选择了偶数个元素，则：<script type="math/tex; mode=display">dp[i+1][0] = max(dp[i][0],dp[i][1] + nums[i+1])</script></li><li>前<code>i+1</code>个元素中选择偶数个元素的子序列，假设选择第<code>i+1</code>个元素加入到子序列中，则$nums[i+1]$在子序列中的下标应该为奇数，则前<code>i</code>个元素中已经选择了奇数个元素，则：<script type="math/tex; mode=display">dp[i+1][1] = max(dp[i][1],dp[i][0] - nums[i+1])</script></li></ul><ol><li>时间复杂度为$O(n)$,空间复杂度为$O(n)$.</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxAlternatingSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">// even</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;       <span class="comment">// odd</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// even</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],nums[i] + dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// odd</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[i][<span class="number">0</span>]);</span><br><span class="line">            ans = max(ans,dp[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5783-设计电影租借系统"><a href="#5783-设计电影租借系统" class="headerlink" title="5783. 设计电影租借系统"></a>5783. 设计电影租借系统</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你有一个电影租借公司和 n 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。</p><p>所有电影用二维整数数组 <code>entries</code> 表示，其中 <code>entries[i] = [shopi, moviei, pricei]</code>表示商店<code>shopi</code>有一份电影 <code>moviei</code> 的拷贝，租借价格为<code>pricei</code> 。每个商店有 至多一份 编号为 <code>moviei</code>的电影拷贝。</p><p>系统需要支持以下操作：</p><ul><li><code>Search</code>：找到拥有指定电影且 未借出 的商店中 最便宜的 5 个 。商店需要按照 价格 升序排序，如果价格相同，则 shopi 较小 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。</li><li>`Rent：从指定商店借出指定电影，题目保证指定电影在指定商店 未借出 。</li><li><code>Drop</code>：在指定商店返还 之前已借出 的指定电影。</li><li><code>Report</code>：返回 最便宜的 5 部已借出电影 （可能有重复的电影 ID），将结果用二维列表 res 返回，其中 res[j] = [shopj, moviej] 表示第 j 便宜的已借出电影是从商店 shopj 借出的电影 moviej 。res 中的电影需要按 价格 升序排序；如果价格相同，则 shopj 较小 的排在前面；如果仍然相同，则 moviej 较小 的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。<br>请你实现 MovieRentingSystem 类：</li><li><code>MovieRentingSystem(int n, int[][] entries)</code>将 MovieRentingSystem 对象用 n 个商店和 entries 表示的电影列表初始化。</li><li><code>List&lt;Integer&gt; search(int movie)</code>如上所述，返回 未借出 指定 movie 的商店列表。</li><li><code>void rent(int shop, int movie)</code> 从指定商店 shop 借出指定电影 movie 。</li><li><code>void drop(int shop, int movie)</code> 在指定商店 shop 返还之前借出的电影 movie 。</li><li><code>List&lt;List&lt;Integer&gt;&gt; report()</code> 如上所述，返回最便宜的 已借出 电影列表。</li><li>注意：测试数据保证 rent 操作中指定商店拥有 未借出 的指定电影，且 drop 操作指定的商店 之前已借出 指定电影。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MovieRentingSystem"</span>, <span class="string">"search"</span>, <span class="string">"rent"</span>, <span class="string">"rent"</span>, <span class="string">"report"</span>, <span class="string">"drop"</span>, <span class="string">"search"</span>]</span><br><span class="line">[[<span class="number">3</span>, [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>]]], [<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>], [], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>], null, null, [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]], null, [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MovieRentingSystem movieRentingSystem = new MovieRentingSystem(<span class="number">3</span>, [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>]]);</span><br><span class="line">movieRentingSystem.search(<span class="number">1</span>);  <span class="comment">// 返回 [1, 0, 2] ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。</span></span><br><span class="line">movieRentingSystem.rent(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 [2,3] 。</span></span><br><span class="line">movieRentingSystem.rent(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 [1] 。</span></span><br><span class="line">movieRentingSystem.report();   <span class="comment">// 返回 [[0, 1], [1, 2]] 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。</span></span><br><span class="line">movieRentingSystem.drop(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 [1,2] 。</span></span><br><span class="line">movieRentingSystem.search(<span class="number">2</span>);  <span class="comment">// 返回 [0, 1] 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= n &lt;= 3 * 105</li><li>1 &lt;= entries.length &lt;= 105</li><li>0 &lt;= shopi &lt; n</li><li>1 &lt;= moviei, pricei &lt;= 104</li><li>每个商店 至多 有一份电影 moviei 的拷贝。</li><li>search，rent，drop 和 report 的调用 总共 不超过 105 次。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/design-movie-rental-system" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-movie-rental-system</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> tree hash</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目确实太长了，但是实际难度很小，感觉只能算<code>5</code>分的中等难度题目，大意就是用<code>hashset</code>保存<code>[shop,movie]</code>对应的价格<code>prices</code>，同时保存每个商店中已有的电影的详细信息，且按照<code>price</code>与<code>shop</code>的顺序进行有序排序，保存每个<code>movie</code>对应的<code>[shop,price]</code>的信息，同时单独保存一张已经出租的<code>movie</code>的有序列表，以上存储都可以用<code>map</code>和<code>set</code>进行实现。</li><li>每次查询时，直接取出有序<code>set</code>中存储的前<code>5</code>个元素即可。</li><li>时间复杂度为$O(mlgn)$,空间复杂度为$O(4*n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> shop;</span><br><span class="line">    <span class="keyword">int</span> movie;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    Node(<span class="keyword">int</span> shop,<span class="keyword">int</span> movie,<span class="keyword">int</span> price)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;shop = shop;</span><br><span class="line">        <span class="keyword">this</span>-&gt;movie = movie;</span><br><span class="line">        <span class="keyword">this</span>-&gt;price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(a.price == b.price)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a.shop == b.shop) <span class="keyword">return</span> a.movie &lt; b.movie;</span><br><span class="line">           <span class="keyword">return</span> a.shop &lt; b.shop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> a.price &lt; b.price;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieRentingSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MovieRentingSystem(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; entries) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;all = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries.size(); ++i)&#123;</span><br><span class="line">            movies[entries[i][<span class="number">1</span>]].insert(Node(entries[i][<span class="number">0</span>],entries[i][<span class="number">1</span>],entries[i][<span class="number">2</span>]));</span><br><span class="line">            shops[entries[i][<span class="number">0</span>]].insert(Node(entries[i][<span class="number">0</span>],entries[i][<span class="number">1</span>],entries[i][<span class="number">2</span>]));</span><br><span class="line">            prices[make_pair(entries[i][<span class="number">0</span>],entries[i][<span class="number">1</span>])] = entries[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; search(<span class="keyword">int</span> movie) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!movies.count(movie)) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">auto</span> it = movies[movie].begin();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> &amp;&amp; it != movies[movie].end(); ++i,it++)&#123;</span><br><span class="line">            ans.push_back(it-&gt;shop);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">(<span class="keyword">int</span> shop, <span class="keyword">int</span> movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> price = prices[make_pair(shop,movie)];</span><br><span class="line">        remove.insert(Node(shop,movie,price));</span><br><span class="line">        movies[movie].erase(Node(shop,movie,price));</span><br><span class="line">        shops[shop].erase(Node(shop,movie,price));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drop</span><span class="params">(<span class="keyword">int</span> shop, <span class="keyword">int</span> movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> price = prices[make_pair(shop,movie)];</span><br><span class="line">        remove.erase(Node(shop,movie,price));</span><br><span class="line">        movies[movie].insert(Node(shop,movie,price));</span><br><span class="line">        shops[shop].insert(Node(shop,movie,price));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; report() &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">auto</span> it = remove.begin();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> &amp;&amp; it != remove.end(); ++i,it++)&#123;</span><br><span class="line">            ans.push_back(&#123;it-&gt;shop,it-&gt;movie&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> all;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;Node,cmp&gt;&gt; movies;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;Node,cmp&gt;&gt; shops;</span><br><span class="line">    <span class="built_in">map</span>&lt;pii,<span class="keyword">int</span>&gt; prices;</span><br><span class="line">    <span class="built_in">set</span>&lt;Node,cmp&gt; remove;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovieRentingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovieRentingSystem* obj = new MovieRentingSystem(n, entries);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;search(movie);</span></span><br><span class="line"><span class="comment"> * obj-&gt;rent(shop,movie);</span></span><br><span class="line"><span class="comment"> * obj-&gt;drop(shop,movie);</span></span><br><span class="line"><span class="comment"> * vector&lt;vector&lt;int&gt;&gt; param_4 = obj-&gt;report();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-55&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-55&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 55&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 55&lt;/h1&gt;&lt;p&gt;双周赛的题目难度一直不太稳定，要么太简单，要么太难。晚上的题目确实都很简单。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/06/27/DjQ1vFhtSUCzXge.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5780-删除一个元素使数组严格递增&quot;&gt;&lt;a href=&quot;#5780-删除一个元素使数组严格递增&quot; class=&quot;headerlink&quot; title=&quot;5780. 删除一个元素使数组严格递增&quot;&gt;&lt;/a&gt;5780. 删除一个元素使数组严格递增&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 0 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; ，如果 恰好 删除 一个 元素后，数组 严格递增 ，那么请你返回&lt;code&gt;true&lt;/code&gt; ，否则返回 false 。如果数组本身已经是严格递增的，请你也返回&lt;code&gt;true&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 246</title>
    <link href="http://yoursite.com/2021/06/20/295/"/>
    <id>http://yoursite.com/2021/06/20/295/</id>
    <published>2021-06-20T03:44:12.301Z</published>
    <updated>2021-06-20T12:16:54.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-246"><a href="#leetcode-contest-246" class="headerlink" title="leetcode  contest 246"></a>leetcode  contest 246</h1><p>本周的周赛题目竟然如此的简单，前三题感觉基本上毫无难度，题目拿到就有思路的那种，最后一题用了个比较恶心的线段树竟然超时了，后面换成暴力的前缀和，竟然过了，最后一题的分数竟然只有<code>5</code>分，可以看出最后一题是多么的简单，感觉是我把题目想复杂了。<br><img src="https://i.loli.net/2021/06/20/vjC6ErtmedKiPng.png" alt></p><h2 id="5788-字符串中的最大奇数"><a href="#5788-字符串中的最大奇数" class="headerlink" title="5788. 字符串中的最大奇数"></a>5788. 字符串中的最大奇数</h2><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>num</code>，表示一个大整数。请你在字符串 <code>num</code>的所有 非空子字符串 中找出 值最大的奇数 ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 “” 。</p><p>子字符串 是字符串中的一个连续的字符序列。</p><p>示例 1：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"52"</span></span><br><span class="line">输出：<span class="string">"5"</span></span><br><span class="line">解释：非空子字符串仅有 <span class="string">"5"</span>、<span class="string">"2"</span> 和 <span class="string">"52"</span> 。<span class="string">"5"</span> 是其中唯一的奇数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"4206"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：在 <span class="string">"4206"</span> 中不存在奇数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"35427"</span></span><br><span class="line">输出：<span class="string">"35427"</span></span><br><span class="line">解释：<span class="string">"35427"</span> 本身就是一个奇数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 105</code></li><li><code>num</code> 仅由数字组成且不含前导零</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/largest-odd-number-in-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-246/problems/largest-odd-number-in-string/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>既然需要找到表示最大的奇书，我们从又往左数，找到第一位为奇数的字符，然后前面的字符串即可，此时找到的字符串即为最大的数。</li><li>时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestOddNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = num.size()<span class="number">-1</span>;i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num[i] - <span class="string">'0'</span>)%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> num.substr(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5789-你完成的完整对局数"><a href="#5789-你完成的完整对局数" class="headerlink" title="5789. 你完成的完整对局数"></a>5789. 你完成的完整对局数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。这意味着，在 HH:00、HH:15、HH:30 和 HH:45 ，将会开始一个新的对局，其中 HH 用一个从 <code>00</code>到 23 的整数表示。游戏中使用 24 小时制的时钟 ，所以一天中最早的时间是 00:00 ，最晚的时间是 23:59 。</p><p>给你两个字符串 <code>startTime</code> 和 <code>finishTime</code>，均符合 <code>&quot;HH:MM&quot;</code> 格式，分别表示你 进入 和 退出 游戏的确切时间，请计算在整个游戏会话期间，你完成的 完整对局的对局数 。</p><p>例如，如果 <code>startTime = &quot;05:20&quot;</code>且 <code>finishTime = &quot;05:59&quot;</code> ，这意味着你仅仅完成从 05:30 到 05:45 这一个完整对局。而你没有完成从 05:15 到 05:30 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 05:45 到 06:00 的完整对局，因为你是在对局结束前退出的游戏。<br>如果 finishTime 早于 startTime ，这表示你玩了个通宵（也就是从 startTime 到午夜，再从午夜到 finishTime）。</p><p>假设你是从 startTime 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 完整对局的对局数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：startTime = <span class="string">"12:01"</span>, finishTime = <span class="string">"12:44"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你完成了从 <span class="number">12</span>:<span class="number">15</span> 到 <span class="number">12</span>:<span class="number">30</span> 的一个完整对局。</span><br><span class="line">你没有完成从 <span class="number">12</span>:<span class="number">00</span> 到 <span class="number">12</span>:<span class="number">15</span> 的完整对局，因为你是在对局开始后的 <span class="number">12</span>:<span class="number">01</span> 进入的游戏。</span><br><span class="line">你没有完成从 <span class="number">12</span>:<span class="number">30</span> 到 <span class="number">12</span>:<span class="number">45</span> 的完整对局，因为你是在对局结束前的 <span class="number">12</span>:<span class="number">44</span> 退出的游戏。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：startTime = <span class="string">"20:00"</span>, finishTime = <span class="string">"06:00"</span></span><br><span class="line">输出：<span class="number">40</span></span><br><span class="line">解释：你完成了从 <span class="number">20</span>:<span class="number">00</span> 到 <span class="number">00</span>:<span class="number">00</span> 的 <span class="number">16</span> 个完整的对局，以及从 <span class="number">00</span>:<span class="number">00</span> 到 <span class="number">06</span>:<span class="number">00</span> 的 <span class="number">24</span> 个完整的对局。</span><br><span class="line"><span class="number">16</span> + <span class="number">24</span> = <span class="number">40</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：startTime = <span class="string">"00:00"</span>, finishTime = <span class="string">"23:59"</span></span><br><span class="line">输出：<span class="number">95</span></span><br><span class="line">解释：除最后一个小时你只完成了 <span class="number">3</span> 个完整对局外，其余每个小时均完成了 <span class="number">4</span> 场完整对局。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>startTime</code> 和 <code>finishTime</code> 的格式为 <code>HH:MM</code></li><li><code>00 &lt;= HH &lt;= 23</code></li><li><code>00 &lt;= MM &lt;= 59</code></li><li><code>startTime</code> 和 <code>finishTime</code> 不相等</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/the-number-of-full-rounds-you-have-played/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-246/problems/the-number-of-full-rounds-you-have-played/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们首先将小时数转换为分钟来计算，我们可以看到观察到每次比赛必须以能被<code>15</code>整除的分钟数起点开局，此时则非常简单，我们对于开始分钟数<code>start</code>对<code>15</code>取模且向上取整，对于结束的分钟数<code>terminal</code>则对<code>15</code>向下取整，然后相减即可得到可以开局的局数。</li><li>对于开始时间大于结束时间的情况，则我们需要将结束时间加上<code>1440</code>即可。</li><li>时间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfRounds</span><span class="params">(<span class="built_in">string</span> startTime, <span class="built_in">string</span> finishTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h1 = (startTime[<span class="number">0</span>] - <span class="string">'0'</span>)*<span class="number">10</span> + startTime[<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> m1 = (startTime[<span class="number">3</span>] - <span class="string">'0'</span>)*<span class="number">10</span> + startTime[<span class="number">4</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> h2 = (finishTime[<span class="number">0</span>] - <span class="string">'0'</span>)*<span class="number">10</span> + finishTime[<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> m2 = (finishTime[<span class="number">3</span>] - <span class="string">'0'</span>)*<span class="number">10</span> + finishTime[<span class="number">4</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> s = h1*<span class="number">60</span> + m1;</span><br><span class="line">        <span class="keyword">int</span> t = h2*<span class="number">60</span> + m2;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; s) t = t + <span class="number">1440</span>;</span><br><span class="line">        <span class="keyword">return</span> t/<span class="number">15</span> - (s+<span class="number">14</span>)/<span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5791-统计子岛屿"><a href="#5791-统计子岛屿" class="headerlink" title="5791. 统计子岛屿"></a>5791. 统计子岛屿</h2><p>给你两个 <code>m x n</code>的二进制矩阵 <code>grid1</code> 和<code>grid2</code>，它们只包含 <code>0</code> （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。</p><p>如果 <code>grid2</code>的一个岛屿，被 <code>grid1</code>的一个岛屿 完全 包含，也就是说 <code>grid2</code>中该岛屿的每一个格子都被<code>grid1</code>中同一个岛屿完全包含，那么我们称 <code>grid2</code>中的这个岛屿为 子岛屿 。</p><p>请你返回 <code>grid2</code>中 子岛屿 的 数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid1 = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]], grid2 = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：如上图所示，左边为 grid1 ，右边为 grid2 。</span><br><span class="line">grid2 中标红的 <span class="number">1</span> 区域是子岛屿，总共有 <span class="number">3</span> 个子岛屿。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid1 = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]], grid2 = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：如上图所示，左边为 grid1 ，右边为 grid2 。</span><br><span class="line">grid2 中标红的 <span class="number">1</span> 区域是子岛屿，总共有 <span class="number">2</span> 个子岛屿。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid1.length == grid2.length</code></li><li><code>n == grid1[i].length == grid2[i].length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 0 要么是 1 。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/count-sub-islands/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-246/problems/count-sub-islands/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较简单两个<code>bfs</code>即可完成。对于第一个<code>grid</code>，此时我们通过<code>bfs</code>对每个岛屿进行标记，即标记某个陆地是属于第几个道路。</li><li>我们对第二个<code>grid</code>也进行<code>bfs</code>，通过<code>bfs</code>将<code>grid2</code>中的岛屿<code>island</code>筛选出来,则此时我们就需要判断<code>island</code>是否属于<code>grid1</code>的某个岛屿的子岛屿，我们则需要判断<code>island</code>中的每个陆地是否同属于同一个岛屿编号。这个用<code>bfs</code>即可完成时间。</li><li>时间复杂度为$O(m<em>n)$,空间复杂度为$O(3</em>m*n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid2.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid2[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit1(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit2(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; idx(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">-1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*bfs*/</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visit1[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid1[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*bfs*/</span></span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">                qu.push(i*col+j);</span><br><span class="line">                visit1[i][j] = <span class="literal">true</span>;</span><br><span class="line">                idx[i][j] = flag;</span><br><span class="line">                <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = curr/col + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = curr%col + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(grid1[x][y] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(visit1[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                        qu.push(x*col+y);</span><br><span class="line">                        visit1[x][y] = <span class="literal">true</span>;</span><br><span class="line">                        idx[x][y] = flag;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;flag&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visit2[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid2[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*bfs*/</span></span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">                qu.push(i*col+j);</span><br><span class="line">                visit2[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> currFlag = idx[i][j];</span><br><span class="line">                <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    <span class="keyword">if</span>(grid1[curr/col][curr%col] == <span class="number">0</span>)&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(idx[curr/col][curr%col] != currFlag)&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = curr/col + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = curr%col + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(grid2[x][y] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(visit2[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                        qu.push(x*col+y);</span><br><span class="line">                        visit2[x][y] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(valid) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5790-查询差绝对值的最小值"><a href="#5790-查询差绝对值的最小值" class="headerlink" title="5790. 查询差绝对值的最小值"></a>5790. 查询差绝对值的最小值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个数组 a 的 差绝对值的最小值 定义为：<code>0 &lt;= i &lt; j &lt; a.length</code> 且 <code>a[i] != a[j]</code> 的 <code>|a[i] - a[j]|</code>的 最小值。如果 a 中所有元素都 相同 ，那么差绝对值的最小值为 -1 。</p><p>比方说，数组 <code>[5,2,3,7,2]</code>差绝对值的最小值是<code>|2 - 3| = 1</code> 。注意答案不为 0 ，因为 a[i] 和 a[j] 必须不相等。<br>给你一个整数数组 nums 和查询数组 queries ，其中<code>queries[i] = [li, ri]</code> 。对于每个查询 i ，计算 子数组<code>nums[li...ri]</code>中 差绝对值的最小值 ，子数组 <code>nums[li...ri] 包含 nums</code> 数组（下标从 0 开始）中下标在 li 和 ri 之间的所有元素（包含 li 和 ri 在内）。</p><p>请你返回 ans 数组，其中 <code>ans[i]</code> 是第 <code>i</code>个查询的答案。</p><p>子数组 是一个数组中连续的一段元素。</p><p>|x| 的值定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-</code>x 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>], queries = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">解释：查询结果如下：</span><br><span class="line">- queries[<span class="number">0</span>] = [<span class="number">0</span>,<span class="number">1</span>]：子数组是 [<span class="number">1</span>,<span class="number">3</span>] ，差绝对值的最小值为 |<span class="number">1</span><span class="number">-3</span>| = <span class="number">2</span> 。</span><br><span class="line">- queries[<span class="number">1</span>] = [<span class="number">1</span>,<span class="number">2</span>]：子数组是 [<span class="number">3</span>,<span class="number">4</span>] ，差绝对值的最小值为 |<span class="number">3</span><span class="number">-4</span>| = <span class="number">1</span> 。</span><br><span class="line">- queries[<span class="number">2</span>] = [<span class="number">2</span>,<span class="number">3</span>]：子数组是 [<span class="number">4</span>,<span class="number">8</span>] ，差绝对值的最小值为 |<span class="number">4</span><span class="number">-8</span>| = <span class="number">4</span> 。</span><br><span class="line">- queries[<span class="number">3</span>] = [<span class="number">0</span>,<span class="number">3</span>]：子数组是 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>] ，差的绝对值的最小值为 |<span class="number">3</span><span class="number">-4</span>| = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">10</span>], queries = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：查询结果如下：</span><br><span class="line">- queries[<span class="number">0</span>] = [<span class="number">2</span>,<span class="number">3</span>]：子数组是 [<span class="number">2</span>,<span class="number">2</span>] ，差绝对值的最小值为 <span class="number">-1</span> ，因为所有元素相等。</span><br><span class="line">- queries[<span class="number">1</span>] = [<span class="number">0</span>,<span class="number">2</span>]：子数组是 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>] ，差绝对值的最小值为 |<span class="number">4</span><span class="number">-5</span>| = <span class="number">1</span> 。</span><br><span class="line">- queries[<span class="number">2</span>] = [<span class="number">0</span>,<span class="number">5</span>]：子数组是 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">10</span>] ，差绝对值的最小值为 |<span class="number">4</span><span class="number">-5</span>| = <span class="number">1</span> 。</span><br><span class="line">- queries[<span class="number">3</span>] = [<span class="number">3</span>,<span class="number">5</span>]：子数组是 [<span class="number">2</span>,<span class="number">7</span>,<span class="number">10</span>] ，差绝对值的最小值为 |<span class="number">7</span><span class="number">-10</span>| = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= queries.length &lt;= 2 * 104</code></li><li><code>0 &lt;= li &lt; ri &lt; nums.length</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/minimum-absolute-difference-queries/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-246/problems/minimum-absolute-difference-queries/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 前缀和</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>刚开始拿到这个题目想的太复杂了，竟然用了最复杂的暴力线段树来解题，结果竟然超时，后来发现还不如用前缀和。题目的关键点在于<code>1 &lt;= nums[i] &lt;= 100</code>，这个数量级很小，则我们利用前缀和统计每个数出现的次数即可，比如$sum[i][j]$表示前<code>i</code>个数中出现数字<code>j</code>的次数。此时我们查询时即可在$O(max(nums))$时间复杂度内找到区间中存在的元素。</li><li>我们知道绝对值最小的元素肯定为两者最近的元素的差，则很容易求出最小的绝对值之差。</li><li>时间复杂度为$O((n+m)<em>max(nums))$,空间复杂度为$O(n</em>max(nums))$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minDifference(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> maxnum = *max_element(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sum(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxnum+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i];</span><br><span class="line">            sum[i+<span class="number">1</span>][nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = sum[queries[i][<span class="number">0</span>]];</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = sum[queries[i][<span class="number">1</span>]+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxnum; ++j)&#123;</span><br><span class="line">                right[j] -= left[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxnum; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right[j] &gt; <span class="number">0</span>) arr.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.push_back(<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> diff = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size(); ++j)&#123;</span><br><span class="line">                    diff = min(diff,arr[j] - arr[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(diff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-246&quot;&gt;&lt;a href=&quot;#leetcode-contest-246&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 246&quot;&gt;&lt;/a&gt;leetcode  contest 246&lt;/h1&gt;&lt;p&gt;本周的周赛题目竟然如此的简单，前三题感觉基本上毫无难度，题目拿到就有思路的那种，最后一题用了个比较恶心的线段树竟然超时了，后面换成暴力的前缀和，竟然过了，最后一题的分数竟然只有&lt;code&gt;5&lt;/code&gt;分，可以看出最后一题是多么的简单，感觉是我把题目想复杂了。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/06/20/vjC6ErtmedKiPng.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5788-字符串中的最大奇数&quot;&gt;&lt;a href=&quot;#5788-字符串中的最大奇数&quot; class=&quot;headerlink&quot; title=&quot;5788. 字符串中的最大奇数&quot;&gt;&lt;/a&gt;5788. 字符串中的最大奇数&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 245</title>
    <link href="http://yoursite.com/2021/06/14/294/"/>
    <id>http://yoursite.com/2021/06/14/294/</id>
    <published>2021-06-14T09:27:18.244Z</published>
    <updated>2021-06-14T12:24:29.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-245"><a href="#leetcode-contest-245" class="headerlink" title="leetcode  contest 245"></a>leetcode  contest 245</h1><p>周赛的题目质量还是一如既往的高，题目质量非常不错，不过还是三道题目的节奏，感觉<code>contest</code>的技巧就是做题速度要快，手速要快，基本上要达到看到题目就有思路那种，才能给<code>hard</code>题目留足思考的时间，只有这样才能达到竞赛的技巧。许多竞赛的选手估计已经训练过非常非常多的题目，难怪最好的<code>IOI</code>选手最好是从初中或者高中就开始训练，思维和速度很重要，基本上需要尽快的训练和固话自己的思维，基本上拿到题目就像肌肉训练一样才可以。</p><a id="more"></a><h2 id="1897-重新分配字符使所有字符串都相等"><a href="#1897-重新分配字符使所有字符串都相等" class="headerlink" title="1897. 重新分配字符使所有字符串都相等"></a>1897. 重新分配字符使所有字符串都相等</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>words</code>（下标 从 0 开始 计数）。</p><p>在一步操作中，需先选出两个 不同 下标 i 和 j，其中 <code>words[i]</code> 是一个非空字符串，接着将<code>words[i]</code> 中的 任一 字符移动到 <code>words[j]</code> 中的 任一 位置上。</p><p>如果执行任意步操作可以使 <code>words</code> 中的每个字符串都相等，返回 <code>true</code>；否则，返回<code>false</code> 。</p><p>示例 1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">words</span> = [<span class="string">"abc"</span>,<span class="string">"aabc"</span>,<span class="string">"bc"</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：将 <span class="keyword">words</span>[<span class="number">1</span>] 中的第一个 <span class="string">'a'</span> 移动到 <span class="keyword">words</span>[<span class="number">2</span>] 的最前面。</span><br><span class="line">使 <span class="keyword">words</span>[<span class="number">1</span>] = <span class="string">"abc"</span> 且 <span class="keyword">words</span>[<span class="number">2</span>] = <span class="string">"abc"</span> 。</span><br><span class="line">所有字符串都等于 <span class="string">"abc"</span> ，所以返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">words</span> = [<span class="string">"ab"</span>,<span class="string">"a"</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：执行操作无法使所有字符串都相等。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 100</code></li><li><code>words[i]</code> 由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/redistribute-characters-to-make-all-strings-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redistribute-characters-to-make-all-strings-equal</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>数据量很小，我们只需要计算统计所有字符的个数，然后计算每个字符的个数是否能对字符串的长度取模为<code>0</code>.</li><li>算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">makeEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w: words)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : w)&#123;</span><br><span class="line">                cnt[c-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]%n != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1898-可移除字符的最大数目"><a href="#1898-可移除字符的最大数目" class="headerlink" title="1898. 可移除字符的最大数目"></a>1898. 可移除字符的最大数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>s</code>和 <code>p</code> ，其中 <code>p</code>是<code>s</code>的一个 子序列 。同时，给你一个元素 互不相同 且下标 从 0 开始 计数的整数数组 <code>removable</code> ，该数组是 s 中下标的一个子集（s 的下标也 从 0 开始 计数）。</p><p>请你找出一个整数 <code>k（0 &lt;= k &lt;= removable.length）</code>，选出 <code>removable</code>中的 前 <code>k</code>个下标，然后从<code>s</code>中移除这些下标对应的<code>k</code> 个字符。整数 k 需满足：在执行完上述步骤后， p 仍然是 s 的一个 子序列 。更正式的解释是，对于每个 <code>0 &lt;= i &lt; k</code>，先标记出位于 <code>s[removable[i]]</code> 的字符，接着移除所有标记过的字符，然后检查 <code>p</code>是否仍然是 <code>s</code> 的一个子序列。</p><p>返回你可以找出的 最大<code>k</code>，满足在移除字符后<code>p</code> 仍然是 <code>s</code> 的一个子序列。</p><p>字符串的一个 子序列 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcacb"</span>, p = <span class="string">"ab"</span>, removable = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：在移除下标 <span class="number">3</span> 和 <span class="number">1</span> 对应的字符后，<span class="string">"abcacb"</span> 变成 <span class="string">"accb"</span> 。</span><br><span class="line"><span class="string">"ab"</span> 是 <span class="string">"accb"</span> 的一个子序列。</span><br><span class="line">如果移除下标 <span class="number">3</span>、<span class="number">1</span> 和 <span class="number">0</span> 对应的字符后，<span class="string">"abcacb"</span> 变成 <span class="string">"ccb"</span> ，那么 <span class="string">"ab"</span> 就不再是 s 的一个子序列。</span><br><span class="line">因此，最大的 k 是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcbddddd"</span>, p = <span class="string">"abcd"</span>, removable = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：在移除下标 <span class="number">3</span> 对应的字符后，<span class="string">"abcbddddd"</span> 变成 <span class="string">"abcddddd"</span> 。</span><br><span class="line"><span class="string">"abcd"</span> 是 <span class="string">"abcddddd"</span> 的一个子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcab"</span>, p = <span class="string">"abc"</span>, removable = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：如果移除数组 removable 的第一个下标，<span class="string">"abc"</span> 就不再是 s 的一个子序列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= p.length &lt;= s.length &lt;= 105</code></li><li><code>0 &lt;= removable.length &lt; s.length</code></li><li><code>0 &lt;= removable[i] &lt; s.length</code></li><li><code>p</code> 是 <code>s</code> 的一个 子字符串</li><li><code>s</code> 和 <code>p</code> 都由小写英文字母组成</li><li><code>removable</code> 中的元素 互不相同</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-removable-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-removable-characters</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>当时这个题目竟然卡壳了很久，常规的做法即为二分查找，想了二十分钟才意识到是二分，常规的我们判断一个字符是另一个字符串的子序列非常简单。最关键的理解为：</li></ol><ul><li>如果移除$removable$ 中的前<code>k</code>个下标后，字符串<code>p</code>依旧是 s 的子序列，那么移除任意前$t$个且满足$t &lt; k$,依旧成立。<br>由此我们即可想到用二分法来测试，知道测试取得最长长度。</li></ul><ol><li>算法空间复杂度为$O(n)$,时间复杂度为$O(nlgn)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp; s,<span class="built_in">string</span> &amp; p,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; removable,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> curr = s;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) curr[removable[i]] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr[i] == p[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == p.size()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> j == p.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumRemovals</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; removable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = min(s.size()-p.size(),removable.size());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(s,p,removable,mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1899-合并若干三元组以形成目标三元组"><a href="#1899-合并若干三元组以形成目标三元组" class="headerlink" title="1899. 合并若干三元组以形成目标三元组"></a>1899. 合并若干三元组以形成目标三元组</h2><p>三元组 是一个由三个整数组成的数组。给你一个二维整数数组 <code>triplets</code> ，其中 <code>triplets[i] = [ai, bi, ci]</code> 表示第 i 个 三元组 。同时，给你一个整数数组 <code>target = [x, y, z]</code>，表示你想要得到的 三元组 。</p><p>为了得到 <code>target</code>，你需要对 <code>triplets</code>执行下面的操作 任意次（可能 零 次）：</p><p>选出两个下标（下标 从 0 开始 计数）<code>i</code> 和 <code>j（i != j）</code>，并 更新 <code>triplets[j]</code> 为 <code>[max(ai, aj), max(bi, bj), max(ci, cj)]</code>。</p><ul><li>例如，<code>triplets[i] = [2, 5, 3]</code> 且<code>triplets[j] = [1, 7, 5]，triplets[j]</code>将会更新为<code>[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]</code>。</li></ul><p>如果通过以上操作我们可以使得目标 三元组 <code>target</code> 成为 <code>triplets</code> 的一个 元素 ，则返回 true ；否则，返回 false 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>]], target = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：执行下述操作：</span><br><span class="line">- 选择第一个和最后一个三元组 [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>]] 。更新最后一个三元组为 [max(<span class="number">2</span>,<span class="number">1</span>), max(<span class="number">5</span>,<span class="number">7</span>), max(<span class="number">3</span>,<span class="number">5</span>)] = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>] 。triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>]]</span><br><span class="line">目标三元组 [<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>] 现在是 triplets 的一个元素。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：triplets = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>]], target = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：目标三元组 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>] 已经是 triplets 的一个元素。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]], target = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：执行下述操作：</span><br><span class="line">- 选择第一个和第三个三元组 [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]] 。更新第三个三元组为 [max(<span class="number">2</span>,<span class="number">1</span>), max(<span class="number">5</span>,<span class="number">2</span>), max(<span class="number">3</span>,<span class="number">5</span>)] = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>] 。triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]] 。</span><br><span class="line">- 选择第三个和第四个三元组 [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]] 。更新第四个三元组为 [max(<span class="number">2</span>,<span class="number">5</span>), max(<span class="number">5</span>,<span class="number">2</span>), max(<span class="number">5</span>,<span class="number">3</span>)] = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>] 。triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]] 。</span><br><span class="line">目标三元组 [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>] 现在是 triplets 的一个元素。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：triplets = [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], target = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法得到 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>] ，因为 triplets 不含 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= triplets.length &lt;= 105</code></li><li><code>triplets[i].length == target.length == 3</code></li><li><code>1 &lt;= ai, bi, ci, x, y, z &lt;= 1000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>数学问题，还是思考的深度不够，竟然这个题目也卡壳了很久。官方题解写的非常清楚。<a href="https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet/solution/he-bing-ruo-gan-san-yuan-zu-yi-xing-chen-8ypf/" target="_blank" rel="noopener">题解</a>.</li><li>题目等价于在在数组钟选择若干个下标$x_{0},x_{1},…,x_{k}$,且$x_{0} \le x_{1} \le …\le x_{k}$,满足最终筛选的三元组$(a,b,c)$为：<script type="math/tex; mode=display">\left\{\begin{aligned}a = max(a_{x_{0}},a_{x_{1}},...,a_{x_{k}}) \\b = max(b_{x_{0}},b_{x_{1}},...,b_{x_{k}}) \\c = max(c_{x_{0}},c_{x_{1}},...,c_{x_{k}}) \\\end{aligned}\right.</script></li><li>对于任意的三元组$(x,y,z)$,如果满足$x &gt; target[0]$，$y &gt; target[1]$，$z &gt; target[2]$我们都不应选择。我们在筛选时只筛选三元组$(x,y,z)$且满足$(x \le target[0],y \le target[1] ,z \le target[2])$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mergeTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triplets, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : triplets)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] &lt;= target[<span class="number">0</span>] &amp;&amp; v[<span class="number">1</span>] &lt;= target[<span class="number">1</span>] &amp;&amp; v[<span class="number">2</span>] &lt;= target[<span class="number">2</span>])&#123;</span><br><span class="line">                a = max(a,v[<span class="number">0</span>]);</span><br><span class="line">                b = max(b,v[<span class="number">1</span>]);</span><br><span class="line">                c = max(c,v[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a == target[<span class="number">0</span>] &amp;&amp; b == target[<span class="number">1</span>] &amp;&amp; c == target[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1900-最佳运动员的比拼回合"><a href="#1900-最佳运动员的比拼回合" class="headerlink" title="1900. 最佳运动员的比拼回合"></a>1900. 最佳运动员的比拼回合</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>n 名运动员参与一场锦标赛，所有运动员站成一排，并根据 最开始的 站位从 <code>1</code>到 <code>n</code>编号（运动员 1 是这一排中的第一个运动员，运动员 2 是第二个运动员，依此类推）。</p><p>锦标赛由多个回合组成（从回合 1 开始）。每一回合中，这一排从前往后数的第 i 名运动员需要与从后往前数的第 i 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。</p><ul><li>例如，当前回合中，运动员 1, 2, 4, 6, 7 站成一排</li><li>运动员 1 需要和运动员 7 比拼</li><li>运动员 2 需要和运动员 6 比拼</li><li>运动员 4 轮空晋级下一回合<br>每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。</li></ul><p>编号为 <code>firstPlayer</code> 和 <code>secondPlayer</code> 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 裁定 谁是这一回合的获胜者。</p><p>给你三个整数 <code>n、firstPlayer</code> 和 <code>secondPlayer</code> 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 最早 回合数和 最晚 回合数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span>, firstPlayer = <span class="number">2</span>, secondPlayer = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">一种能够产生最早回合数的情景是：</span><br><span class="line">回合 <span class="number">1</span>：<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">回合 <span class="number">2</span>：<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span></span><br><span class="line">回合 <span class="number">3</span>：<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">一种能够产生最晚回合数的情景是：</span><br><span class="line">回合 <span class="number">1</span>：<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">回合 <span class="number">2</span>：<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">回合 <span class="number">3</span>：<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">回合 <span class="number">4</span>：<span class="number">2</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, firstPlayer = <span class="number">1</span>, secondPlayer = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：两名最佳运动员 <span class="number">1</span> 和 <span class="number">5</span> 将会在回合 <span class="number">1</span> 进行比拼。</span><br><span class="line">不存在使他们在其他回合进行比拼的可能。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 28</code></li><li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/the-earliest-and-latest-rounds-where-players-compete" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-earliest-and-latest-rounds-where-players-compete</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目感觉比较奇怪了一点，没有双周赛的题目好，本质是递归和穷举,感觉没有做下去的欲望。</li><li>可以参考下官方的<a href="https://leetcode-cn.com/problems/the-earliest-and-latest-rounds-where-players-compete/solution/zui-jia-yun-dong-yuan-de-bi-pin-hui-he-b-lhuo/" target="_blank" rel="noopener">题解</a>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> F[<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>], G[<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp(<span class="keyword">int</span> n, <span class="keyword">int</span> f, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (F[n][f][s]) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;F[n][f][s], G[n][f][s]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f + s == n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// F(n,f,s)=F(n,n+1-s,n+1-f)</span></span><br><span class="line">        <span class="keyword">if</span> (f + s &gt; n + <span class="number">1</span>) &#123;</span><br><span class="line">            tie(F[n][f][s], G[n][f][s]) = dp(n, n + <span class="number">1</span> - s, n + <span class="number">1</span> - f);</span><br><span class="line">            <span class="keyword">return</span> &#123;F[n][f][s], G[n][f][s]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> earlist = INT_MAX, latest = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> n_half = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= n_half) &#123;</span><br><span class="line">            <span class="comment">// 在左侧或者中间</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s - f; ++j) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> [x, y] = dp(n_half, i + <span class="number">1</span>, i + j + <span class="number">2</span>);</span><br><span class="line">                    earlist = min(earlist, x);</span><br><span class="line">                    latest = max(latest, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// s 在右侧</span></span><br><span class="line">            <span class="comment">// s'</span></span><br><span class="line">            <span class="keyword">int</span> s_prime = n + <span class="number">1</span> - s;</span><br><span class="line">            <span class="keyword">int</span> mid = (n - <span class="number">2</span> * s_prime + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s_prime - f; ++j) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> [x, y] = dp(n_half, i + <span class="number">1</span>, i + j + mid + <span class="number">2</span>);</span><br><span class="line">                    earlist = min(earlist, x);</span><br><span class="line">                    latest = max(latest, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;F[n][f][s] = earlist + <span class="number">1</span>, G[n][f][s] = latest + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; earliestAndLatest(<span class="keyword">int</span> n, <span class="keyword">int</span> firstPlayer, <span class="keyword">int</span> secondPlayer) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(F, <span class="number">0</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">        <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// F(n,f,s) = F(n,s,f)</span></span><br><span class="line">        <span class="keyword">if</span> (firstPlayer &gt; secondPlayer) &#123;</span><br><span class="line">            swap(firstPlayer, secondPlayer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [earlist, latest] = dp(n, firstPlayer, secondPlayer);</span><br><span class="line">        <span class="keyword">return</span> &#123;earlist, latest&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-245&quot;&gt;&lt;a href=&quot;#leetcode-contest-245&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 245&quot;&gt;&lt;/a&gt;leetcode  contest 245&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是一如既往的高，题目质量非常不错，不过还是三道题目的节奏，感觉&lt;code&gt;contest&lt;/code&gt;的技巧就是做题速度要快，手速要快，基本上要达到看到题目就有思路那种，才能给&lt;code&gt;hard&lt;/code&gt;题目留足思考的时间，只有这样才能达到竞赛的技巧。许多竞赛的选手估计已经训练过非常非常多的题目，难怪最好的&lt;code&gt;IOI&lt;/code&gt;选手最好是从初中或者高中就开始训练，思维和速度很重要，基本上需要尽快的训练和固话自己的思维，基本上拿到题目就像肌肉训练一样才可以。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly Contest 54</title>
    <link href="http://yoursite.com/2021/06/08/293/"/>
    <id>http://yoursite.com/2021/06/08/293/</id>
    <published>2021-06-08T05:00:13.868Z</published>
    <updated>2021-06-14T09:28:32.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-54"><a href="#leetcode-biweekly-contest-54" class="headerlink" title="leetcode  biweekly contest 54"></a>leetcode  biweekly contest 54</h1><p>双周赛前三题还是模板题，最后一题真心不错，非常经典的表达式求解题目</p><h2 id="5767-检查是否区域内所有整数都被覆盖"><a href="#5767-检查是否区域内所有整数都被覆盖" class="headerlink" title="5767. 检查是否区域内所有整数都被覆盖"></a>5767. 检查是否区域内所有整数都被覆盖</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>ranges</code> 和两个整数<code>left</code>和 <code>right</code>。每个 <code>ranges[i] = [starti, endi]</code> 表示一个从 starti 到 endi 的 闭区间 。</p><a id="more"></a><p>如果闭区间<code>[left, right]</code>内每个整数都被<code>ranges</code> 中 至少一个 区间覆盖，那么请你返回 <code>true</code>，否则返回 <code>false</code>。</p><p>已知区间 <code>ranges[i] = [starti, endi]</code> ，如果整数 <code>x</code> 满足 <code>starti &lt;= x &lt;= endi</code>，那么我们称整数x 被覆盖了。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：ranges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]], left = <span class="number">2</span>, right = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">2</span> 到 <span class="number">5</span> 的每个整数都被覆盖了：</span><br><span class="line">- <span class="number">2</span> 被第一个区间覆盖。</span><br><span class="line">- <span class="number">3</span> 和 <span class="number">4</span> 被第二个区间覆盖。</span><br><span class="line">- <span class="number">5</span> 被第三个区间覆盖。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ranges = [[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">20</span>]], left = <span class="number">21</span>, right = <span class="number">21</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">21</span> 没有被任何一个区间覆盖。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= ranges.length &lt;= 50</code></li><li><code>1 &lt;= starti &lt;= endi &lt;= 50</code></li><li><code>1 &lt;= left &lt;= right &lt;= 50</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>因为数据量很小，所以直接暴力模拟即可。如果数据量非常大，则此时我们需要利用区间合并的技巧。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCovered</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ranges, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">51</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : ranges)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = v[<span class="number">0</span>]; i &lt;= v[<span class="number">1</span>]; ++i) cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5768-找到需要补充粉笔的学生编号"><a href="#5768-找到需要补充粉笔的学生编号" class="headerlink" title="5768. 找到需要补充粉笔的学生编号"></a>5768. 找到需要补充粉笔的学生编号</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一个班级里有 <code>n</code>个学生，编号为 0 到 <code>n - 1</code>。每个学生会依次回答问题，编号为 <code>0</code> 的学生先回答，然后是编号为<code>1</code> 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。</p><p>给你一个长度为 n 且下标从 0 开始的整数数组<code>chalk</code>和一个整数 k 。一开始粉笔盒里总共有<code>k</code>支粉笔。当编号为 <code>i</code>的学生回答问题时，他会消耗 <code>chalk[i]</code>支粉笔。如果剩余粉笔数量 严格小于 <code>chalk[i]</code> ，那么学生 i 需要 补充 粉笔。</p><p>请你返回需要 补充 粉笔的学生 编号 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：chalk = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>], k = <span class="number">22</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：学生消耗粉笔情况如下：</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">5</span> 支粉笔，然后 k = <span class="number">17</span> 。</span><br><span class="line">- 编号为 <span class="number">1</span> 的学生使用 <span class="number">1</span> 支粉笔，然后 k = <span class="number">16</span> 。</span><br><span class="line">- 编号为 <span class="number">2</span> 的学生使用 <span class="number">5</span> 支粉笔，然后 k = <span class="number">11</span> 。</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">5</span> 支粉笔，然后 k = <span class="number">6</span> 。</span><br><span class="line">- 编号为 <span class="number">1</span> 的学生使用 <span class="number">1</span> 支粉笔，然后 k = <span class="number">5</span> 。</span><br><span class="line">- 编号为 <span class="number">2</span> 的学生使用 <span class="number">5</span> 支粉笔，然后 k = <span class="number">0</span> 。</span><br><span class="line">编号为 <span class="number">0</span> 的学生没有足够的粉笔，所以他需要补充粉笔。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：chalk = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>], k = <span class="number">25</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：学生消耗粉笔情况如下：</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">3</span> 支粉笔，然后 k = <span class="number">22</span> 。</span><br><span class="line">- 编号为 <span class="number">1</span> 的学生使用 <span class="number">4</span> 支粉笔，然后 k = <span class="number">18</span> 。</span><br><span class="line">- 编号为 <span class="number">2</span> 的学生使用 <span class="number">1</span> 支粉笔，然后 k = <span class="number">17</span> 。</span><br><span class="line">- 编号为 <span class="number">3</span> 的学生使用 <span class="number">2</span> 支粉笔，然后 k = <span class="number">15</span> 。</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">3</span> 支粉笔，然后 k = <span class="number">12</span> 。</span><br><span class="line">- 编号为 <span class="number">1</span> 的学生使用 <span class="number">4</span> 支粉笔，然后 k = <span class="number">8</span> 。</span><br><span class="line">- 编号为 <span class="number">2</span> 的学生使用 <span class="number">1</span> 支粉笔，然后 k = <span class="number">7</span> 。</span><br><span class="line">- 编号为 <span class="number">3</span> 的学生使用 <span class="number">2</span> 支粉笔，然后 k = <span class="number">5</span> 。</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">3</span> 支粉笔，然后 k = <span class="number">2</span> 。</span><br><span class="line">编号为 <span class="number">1</span> 的学生没有足够的粉笔，所以他需要补充粉笔。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>chalk.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= chalk[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>非常简单的小学数学问题，我们只需找到班级学生发完一轮时所需要的总数<code>sum</code>，然后用<code>k</code>取模<code>sum</code>的余数，然后依次减直到粉笔的数目不够即可。</li><li>算法时间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">chalkReplacer</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chalk, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = accumulate(chalk.begin(),chalk.end(),<span class="number">0L</span>L);</span><br><span class="line">        k = k%sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chalk.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; chalk[i]) <span class="keyword">return</span> i;</span><br><span class="line">            k -= chalk[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5202-最大的幻方"><a href="#5202-最大的幻方" class="headerlink" title="5202. 最大的幻方"></a>5202. 最大的幻方</h2><p>一个 <code>k x k</code> 的 幻方 指的是一个 <code>k x k</code>填满整数的方格阵，且每一行、每一列以及两条对角线的和 全部相等 。幻方中的整数 不需要互不相同 。显然，每个 <code>1 x 1</code> 的方格都是一个幻方。</p><p>给你一个<code>m x n</code> 的整数矩阵 <code>grid</code> ，请你返回矩阵中 最大幻方 的 尺寸 （即边长 k）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最大幻方尺寸为 <span class="number">3</span> 。</span><br><span class="line">每一行，每一列以及两条对角线的和都等于 <span class="number">12</span> 。</span><br><span class="line">- 每一行的和：<span class="number">5</span>+<span class="number">1</span>+<span class="number">6</span> = <span class="number">5</span>+<span class="number">4</span>+<span class="number">3</span> = <span class="number">2</span>+<span class="number">7</span>+<span class="number">3</span> = <span class="number">12</span></span><br><span class="line">- 每一列的和：<span class="number">5</span>+<span class="number">5</span>+<span class="number">2</span> = <span class="number">1</span>+<span class="number">4</span>+<span class="number">7</span> = <span class="number">6</span>+<span class="number">3</span>+<span class="number">3</span> = <span class="number">12</span></span><br><span class="line">- 对角线的和：<span class="number">5</span>+<span class="number">4</span>+<span class="number">3</span> = <span class="number">6</span>+<span class="number">4</span>+<span class="number">2</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">9</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 50</code></li><li><code>1 &lt;= grid[i][j] &lt;= 106</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-magic-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-magic-square</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学暴力 + 前缀和</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的不好，想了一下感觉只能暴力，利用前缀和快速求出矩阵的每一行和每一列的和。我们尝试每一个可能的<code>kxk</code>的矩阵，求出每一行和每一列的值，同时求出每个对角线的值,判断是否相等即可。</li><li>我们每次枚举举证的左上顶点$(x,y)$，同时枚举矩阵的行的长度$k$，则我们可以计算依次计算所有可能的矩阵。我们利用矩阵的行的前缀和和列的前缀和即可快速求出行与列的行。</li><li>时间复杂度为$O(row<em>col</em>(2k+2)<em>k$,空间复杂度为$O(row</em>col)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestMagicSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; sum1(row+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(col+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; sum2(col+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(row+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                sum1[i][j+<span class="number">1</span>] = sum1[i][j] + grid[i][j];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                sum2[i][j+<span class="number">1</span>] = sum2[i][j] + grid[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= min(row,col) &amp;&amp; (i + k &lt;= row) &amp;&amp; (j + k &lt;= col); ++k)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> curr = sum1[i][j+k] - sum1[i][j];</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> dig1 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> dig2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; k; ++l)&#123;</span><br><span class="line">                        <span class="keyword">if</span>((sum1[i+l][j+k] - sum1[i+l][j]) != curr)&#123;</span><br><span class="line">                            valid = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>((sum2[j+l][i+k] - sum2[j+l][i]) != curr)&#123;</span><br><span class="line">                            valid = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        dig1 += grid[i+l][j+l];</span><br><span class="line">                        dig2 += grid[i+l][j+k<span class="number">-1</span>-l];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dig1 != dig2 || dig1 != curr || dig2 != curr) valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                        ans = max(ans,k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5770-反转表达式值的最少操作次数"><a href="#5770-反转表达式值的最少操作次数" class="headerlink" title="5770. 反转表达式值的最少操作次数"></a>5770. 反转表达式值的最少操作次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 有效的 布尔表达式，用字符串 expression 表示。这个字符串包含字符 <code>&#39;1&#39;，&#39;0&#39;，&#39;&amp;&#39;</code>（按位 与 运算），<code>&#39;|&#39;</code>（按位 或 运算），<code>&#39;(&#39;</code>和 ‘)’ 。</p><p>比方说，<code>&quot;()1|1&quot;</code>和 <code>&quot;(1)&amp;()&quot;</code> 不是有效 布尔表达式。而 “1”， <code>&quot;(((1))|(0))&quot;</code>和 <code>&quot;1|(0&amp;(1))&quot;</code>是 有效 布尔表达式。<br>你的目标是将布尔表达式的 值 反转 （也就是将 0 变为 1 ，或者将 1 变为 0），请你返回达成目标需要的 最少操作 次数。</p><p>比方说，如果表达式 <code>expression = &quot;1|1|(0&amp;0)&amp;1&quot;</code>，它的 值 为 <code>1|1|(0&amp;0)&amp;1 = 1|1|0&amp;1 = 1|0&amp;1 = 1&amp;1 = 1</code>。我们想要执行操作将 新的 表达式的值变成 0 。<br>可执行的 操作 如下：</p><ul><li>将一个 <code>&#39;1&#39;</code>变成一个 <code>&#39;0&#39;</code>。</li><li>将一个 <code>&#39;0&#39;</code> 变成一个 <code>&#39;1&#39;</code>。</li><li>将一个 <code>&#39;&amp;&#39;</code>变成一个 <code>&#39;|&#39;</code>。</li><li>将一个 <code>&#39;|&#39;</code>变成一个 <code>&#39;&amp;&#39;</code>。<br>注意：<code>&#39;&amp;&#39;</code> 的 运算优先级 与 ‘|’ 相同 。计算表达式时，括号优先级 最高 ，然后按照 从左到右 的顺序运算。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = <span class="string">"1&amp;(0|1)"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：我们可以将 <span class="string">"1&amp;(0|1)"</span> 变成 <span class="string">"1&amp;(0&amp;1)"</span> ，执行的操作为将一个 '|' 变成一个 '&amp;' ，执行了 <span class="number">1</span> 次操作。</span><br><span class="line">新表达式的值为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = <span class="string">"(0&amp;0)&amp;(0&amp;0&amp;0)"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们可以将 <span class="string">"(0&amp;0)&amp;(0&amp;0&amp;0)"</span> 变成 <span class="string">"(0|1)|(0&amp;0&amp;0)"</span> ，执行了 <span class="number">3</span> 次操作。</span><br><span class="line">新表达式的值为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = <span class="string">"(0|(1|0&amp;1))"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：我们可以将 <span class="string">"(0|(1|0&amp;1))"</span> 变成 <span class="string">"(0|(0|0&amp;1))"</span> ，执行了 <span class="number">1</span> 次操作。</span><br><span class="line">新表达式的值为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= expression.length &lt;= 105</code></li><li><code>expression</code> 只包含 <code>&#39;1&#39;，&#39;0&#39;，&#39;&amp;&#39;，&#39;|&#39;，&#39;(&#39;</code>和 <code>&#39;)&#39;</code></li><li>所有括号都有与之匹配的对应括号。</li><li>不会有空的括号（也就是说 “()” 不是 expression 的子字符串）。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-change-the-final-value-of-expression" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-change-the-final-value-of-expression</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 递归或者栈，动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这道题目非常不错，主要是思考的比较多，代码量实际不是特别大。非常值得思考的题目，我觉得完全可以参考<a href="https://leetcode-cn.com/problems/minimum-cost-to-change-the-final-value-of-expression/solution/zhan-dong-tai-gui-hua-by-lucifer1004-7bsn/" target="_blank" rel="noopener">lucifer1004</a>的答案。</li><li>实际计算过程中，动态规划的转移方程想到了，但是在处理表达式的时候用了个比较耗时的递归，结果超时了。这个题目出的还是相当不错的，我们首先需要处理动态规划的递推公式如下：</li></ol><ul><li>我们设$(p_{0},p_{1})$表示为将当前的操作数$num$变为$(0,1)$的最小操作数，比如：我们如果需要将$0$变为$0$,则最少需要$0$步操作即可，如果将$0$变为$1$,则此时我们需要一步操作<code>0-&gt;1</code>即可，因此此时对于操作数$0$的最小操作序列应该为$(0,1)$,同理对于操作数$1$的最小操作序列应该为$(1,0)$.</li><li>同理我们假设对于操作数$x$的最小操作序列为$(x_{0},x_{1})$,对于$y$的最小操作序列为$(y_{0},y_{1})$,则此时我们应该考虑对于表达式$x\And y$,$x|y$的递推如何处理呢?我们思考如下:</li><li>如果使得$x\And y = 0$,则我们只需要满足$x = 0$或者$y = 0$即可使得表达式$x\And y = 0$，因此使得表达式为<code>0</code>最小操作为应该$min(x_{0},y_{0})$;如果使得$x\And y$的结果为$1$,则我们只需要满足$x = 1$且$y = 1$即可使得表达式$x\And y = 1$，因此使得表达式为<code>1</code>最小操作为应该$x_{1} + y_{1}$.</li><li>如果使得$x|y = 0$,则我们只需要满足$x = 0$且$y = 0$即可使得表达式$x|y = 0$，因此使得表达式为<code>0</code>最小操作为应该$x_{0} + y_{0})$;如果使得$x|y = 1$,则我们只需要满足$x = 1$或$y = 1$即可使得表达式$x|y = 1$，因此使得表达式为<code>1</code>最小操作为应该$min(x_{1},y_{1})$.</li><li>我们同时还需要考虑到将运算符号进行变换时的最小操作，及将<code>&amp;</code>变换为<code>|</code>或者将<code>|</code>变换为<code>&amp;</code>的操作，此时符号变换还需要额外的一次操作。因此综上我们可以知道对于表达式$x\And y$的变换为<code>0</code>的最小操作数应该为：$min(x_{0},y_{0})$，变换为<code>1</code>的最小操作数应该为:$min(x_{1} + y_{1},min(x_{1},y_{1})+1)$.因此该表达式的最小变换序列应该为：<script type="math/tex; mode=display">(min(x_{0},y_{0}),min(x_{1} + y_{1},min(x_{1},y_{1})+1))</script>对于表达式$x|y$的变换为<code>0</code>的最小操作数应该为：$min(x_{0}+y_{0},min(x_{0},y_{0})+1)$，变换为<code>1</code>的最小操作数应该为:$min(x_{1},y_{1})$.因此该表达式的最小变换序列应该为：<script type="math/tex; mode=display">(min(x_{0}+y_{0},min(x_{0},y_{0})+1),min(x_{1},y_{1}))</script></li><li>以上即可动态规划的递归公式部分，对于最后的表达式的返回值我们只需要返回变为<code>0</code>或者<code>1</code>的操作数最大的那部分，应该如果操作数的值本身保持不变，则最小操作数应该为<code>0</code>，如果保持反转则操作数一定是大于<code>0</code>的。</li></ul><ol><li>题目的难点在于如何用两个栈处理符号和操作数的问题，这点确实是快忘记光了，结果导致昨天写了个非常复杂的递归程序，还超时了。还是需要再把基本计算器的题目再练习一下。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperationsToFlip</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">stack</span>&lt;pii&gt; states;</span><br><span class="line">       <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> c : expression)&#123;</span><br><span class="line">           <span class="keyword">if</span>(c == <span class="string">'0'</span> || c== <span class="string">'1'</span> || c == <span class="string">')'</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(c == <span class="string">'0'</span>)&#123;</span><br><span class="line">                   states.push(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'1'</span>)&#123;</span><br><span class="line">                   states.push(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(op.top() == <span class="string">'('</span>)&#123;</span><br><span class="line">                       op.pop();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(!op.empty() &amp;&amp; op.top() != <span class="string">'('</span>)&#123;</span><br><span class="line">                   pii va = states.top();</span><br><span class="line">                   states.pop();</span><br><span class="line">                   pii vb = states.top();</span><br><span class="line">                   states.pop();</span><br><span class="line">                   <span class="keyword">if</span>(op.top() == <span class="string">'&amp;'</span>)&#123;</span><br><span class="line">                       states.push(&#123;min(va.first,vb.first),min(va.second + vb.second,min(va.second,vb.second) + <span class="number">1</span>)&#125;);</span><br><span class="line">                   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op.top() == <span class="string">'|'</span>)&#123;</span><br><span class="line">                       states.push(&#123;min(va.first + vb.first,min(va.first,vb.first) + <span class="number">1</span>),min(va.second,vb.second)&#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">                   op.pop();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               op.push(c);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> max(states.top().first,states.top().second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-54&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-54&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 54&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 54&lt;/h1&gt;&lt;p&gt;双周赛前三题还是模板题，最后一题真心不错，非常经典的表达式求解题目&lt;/p&gt;&lt;h2 id=&quot;5767-检查是否区域内所有整数都被覆盖&quot;&gt;&lt;a href=&quot;#5767-检查是否区域内所有整数都被覆盖&quot; class=&quot;headerlink&quot; title=&quot;5767. 检查是否区域内所有整数都被覆盖&quot;&gt;&lt;/a&gt;5767. 检查是否区域内所有整数都被覆盖&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个二维整数数组 &lt;code&gt;ranges&lt;/code&gt; 和两个整数&lt;code&gt;left&lt;/code&gt;和 &lt;code&gt;right&lt;/code&gt;。每个 &lt;code&gt;ranges[i] = [starti, endi]&lt;/code&gt; 表示一个从 starti 到 endi 的 闭区间 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 MIT 6.S081 Lab1</title>
    <link href="http://yoursite.com/2021/06/07/292/"/>
    <id>http://yoursite.com/2021/06/07/292/</id>
    <published>2021-06-07T12:34:15.843Z</published>
    <updated>2021-06-20T13:17:29.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MIT6-S081"><a href="#MIT6-S081" class="headerlink" title="MIT6.S081"></a>MIT6.S081</h1><p>很早就听说MIT6.S081的课程比较经典了，所以从上周末就开始学习MIT6.S081的<code>lecture</code>,目前刚学习完<code>lecture 1</code>，并且成功完成了<code>lab1</code>，不得不说<code>lab</code>太花费时间了，<code>lab</code>设置的非常好，难度适中，有挑战性与趣味性并存，非常感谢这么好与经典的课程，不过不得不说因为确实平时没有时间，又要照顾家庭，又要上班，只能利用周末和晚上的时间抓紧来学习和完成这些<code>lab</code>的代码了，每次都需要花时间调试代码调试很长时间，目测后面的挑战题目更难。<code>MIT</code>的课程难度一向很大，难怪能够培养出很多非常优秀和出色的工程师。</p><a id="more"></a><ul><li>lab环境：<br>所有的<code>lab</code>都是基于<code>qemu</code>的模拟硬件环境的，它的所有的<code>lab</code>全部更新为基于<code>risc-v</code>的硬件环境，紧跟最新的潮流，不像国内一个<code>8086</code>都还在讲，恨不得一门组成原理用了不知道多少年，目前还在停留在单核的x86时代，目前几乎所有的通用<code>cpu</code>都是基于多核处理器，所有的体系结构都应该更新了。所有的<code>lab</code>都是基于<code>xv6</code>的操作系统，一个非常精简的微小的操作系统。按照<code>lab</code>的提示从网上下载<code>qemu</code>模拟器和<code>risc-v</code>的编译环境，国内尽量将<code>apt-get</code>的源改为阿里或者清华的，很快就能完成下载。</li><li>测试结果：<br><img src="https://i.loli.net/2021/06/07/IQJYxFsA52fdEo3.png" alt></li></ul><h2 id="1-sleep"><a href="#1-sleep" class="headerlink" title="1. sleep"></a>1. sleep</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Implement <span class="keyword">the</span> UNIX program sleep <span class="keyword">for</span> xv6; your sleep should pause <span class="keyword">for</span> <span class="keyword">a</span> user-specified <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">ticks</span>. A <span class="built_in">tick</span> is <span class="keyword">a</span> notion <span class="keyword">of</span> <span class="built_in">time</span> defined <span class="keyword">by</span> <span class="keyword">the</span> xv6 kernel, namely <span class="keyword">the</span> <span class="built_in">time</span> between <span class="literal">two</span> interrupts <span class="built_in">from</span> <span class="keyword">the</span> timer chip. Your solution should be <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">file</span> user/sleep.c.</span><br></pre></td></tr></table></figure><p>实现一个基本的<code>sleep</code>命令，这个基本上就是热身，通过最简单的题目来快速上手，实现一个最简单的程序，没有多少难度。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> wait = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sleep: need parameter error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   wait = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">   sleep(wait);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-pingpong"><a href="#2-pingpong" class="headerlink" title="2. pingpong"></a>2. pingpong</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write <span class="keyword">a</span> program that uses UNIX <span class="keyword">system</span> calls <span class="built_in">to</span> <span class="string">''</span>ping-pong<span class="string">''</span> <span class="keyword">a</span> <span class="keyword">byte</span> between <span class="literal">two</span> processes over <span class="keyword">a</span> pair <span class="keyword">of</span> pipes, <span class="literal">one</span> <span class="keyword">for</span> <span class="keyword">each</span> direction. The parent should <span class="built_in">send</span> <span class="keyword">a</span> <span class="keyword">byte</span> <span class="built_in">to</span> <span class="keyword">the</span> child; <span class="keyword">the</span> child should print <span class="string">"&lt;pid&gt;: received ping"</span>, where &lt;pid&gt; is its <span class="built_in">process</span> ID, <span class="built_in">write</span> <span class="keyword">the</span> <span class="keyword">byte</span> <span class="keyword">on</span> <span class="title">the</span> <span class="title">pipe</span> <span class="title">to</span> <span class="title">the</span> <span class="title">parent</span>, <span class="title">and</span> <span class="title">exit</span>; <span class="title">the</span> <span class="title">parent</span> <span class="title">should</span> <span class="title">read</span> <span class="title">the</span> <span class="title">byte</span> <span class="title">from</span> <span class="title">the</span> <span class="title">child</span>, <span class="title">print</span> <span class="string">"&lt;pid&gt;: received pong"</span>, <span class="title">and</span> <span class="title">exit</span>. <span class="title">Your</span> <span class="title">solution</span> <span class="title">should</span> <span class="title">be</span> <span class="title">in</span> <span class="title">the</span> <span class="title">file</span> <span class="title">user</span>/<span class="title">pingpong</span>.<span class="title">c</span>.</span><br></pre></td></tr></table></figure><p>利用管道实现子进程与父进程的通信，通过这个简单的程序熟悉<code>pipe</code>的使用，不过很坑爹的是这个操作系统的管道不支持双端通信，只支持一端是写，一端是读，这个<code>bug</code>调试了很长时间才发现是这个问题。具体实现方法为：开两个管道，父进程往管道<code>1</code>里写数据，从管道<code>2</code>中读数据，子进程从管道<code>1</code>读数据，从管道<code>2</code>写数据。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> p2[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">"Only 1 argument is needed!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creat a pipe</span></span><br><span class="line">    pipe(p1);</span><br><span class="line">    pipe(p2);</span><br><span class="line">    <span class="comment">// child</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">//read from the parent</span></span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">        read(p1[<span class="number">0</span>],buffer,<span class="number">4</span>);</span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// write a byte to the parent</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received ping\n"</span>,getpid());</span><br><span class="line">        write(p2[<span class="number">1</span>],<span class="string">"pong"</span>, <span class="number">4</span>);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// send a byte</span></span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">        write(p1[<span class="number">1</span>],<span class="string">"ping"</span>,<span class="number">4</span>);</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// receive from child</span></span><br><span class="line">        read(p2[<span class="number">0</span>],buffer,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received pong\n"</span>,getpid());</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-primes"><a href="#3-primes" class="headerlink" title="3. primes"></a>3. primes</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write <span class="keyword">a</span> concurrent <span class="built_in">version</span> <span class="keyword">of</span> prime sieve <span class="keyword">using</span> pipes. This idea is due <span class="built_in">to</span> Doug McIlroy, inventor <span class="keyword">of</span> Unix pipes. The picture halfway down this page <span class="keyword">and</span> <span class="keyword">the</span> surrounding <span class="keyword">text</span> explain how <span class="built_in">to</span> <span class="built_in">do</span> <span class="keyword">it</span>. Your solution should be <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">file</span> user/primes.c.</span><br></pre></td></tr></table></figure><p>利用进程实现素数筛选，不知道为什么实现的很蛋疼。估计还是<code>xv6</code>的文件描述符资源有限不能很好支持多个管道同时读写，因为开的管道过多，资源就卡住了，各种问题不知道有没有人实现快速版本，及子进程同时接受数据也同时开始计算，并同时开始写数据。目前这个的实现很糙，将当前进程筛选的不能被第一个素数整数的数据全部写入管道中，交给子进程去处理，依次这样递归下去即可。这个做法就是跟素数的快速筛查的算法是处理的一模一样的,在$O(n)$的时间复杂度内筛选出所有小于$n$的素数。</p><p><img src="https://i.loli.net/2021/06/08/dtliNxaYBsSP7Fu.gif" alt><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="builtin-name">get</span> a number <span class="keyword">from</span> left neighbor</span><br><span class="line"><span class="builtin-name">print</span> p</span><br><span class="line">loop:</span><br><span class="line">    n = <span class="builtin-name">get</span> a number <span class="keyword">from</span> left neighbor</span><br><span class="line">    <span class="keyword">if</span> (p does <span class="keyword">not</span> divide n)</span><br><span class="line">        send n <span class="keyword">to</span> right neighbor</span><br></pre></td></tr></table></figure><br>需要特殊处理的是父进程需要等待子进程完成后，才能退出。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prime = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pip[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*close p1*/</span></span><br><span class="line">    pipe(pip);</span><br><span class="line">    <span class="keyword">while</span>(read(p[<span class="number">0</span>],&amp;num,<span class="number">4</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(prime == <span class="number">1</span>)&#123;</span><br><span class="line">            prime = num;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"prime %d\n"</span>,prime);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%prime == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            write(pip[<span class="number">1</span>],&amp;num,<span class="number">4</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(pip[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(prime &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            process(pip);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    close(pip[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; ++i)&#123;</span><br><span class="line">        write(p[<span class="number">1</span>],&amp;i,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    process(p);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-find"><a href="#4-find" class="headerlink" title="4. find"></a>4. find</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write a<span class="built_in"> simple </span>version of the UNIX <span class="builtin-name">find</span> program: <span class="builtin-name">find</span> all the files <span class="keyword">in</span> a directory tree with a specific name. Your solution should be <span class="keyword">in</span> the file user/find.c.</span><br></pre></td></tr></table></figure><p>实现一个简单的查找文件名为指定关键字的程序，典型的利用递归查找到子目录下，即可完成所有子目录的查找。这个就是常规的操作。各种处理文件时需要查找相应的库函数，需要小心处理。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/fs.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getname</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">'/'</span>; p--)&#123;&#125;</span><br><span class="line">  <span class="comment">// skip '/'</span></span><br><span class="line">  p++;</span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *path,<span class="keyword">const</span> <span class="keyword">char</span> * filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="keyword">char</span> *curr;</span><br><span class="line">  <span class="keyword">char</span> *fname;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// open the dir</span></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"ls: cannot open %s\n"</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// open stat</span></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"ls: cannot stat %s\n"</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check the current the file is </span></span><br><span class="line">  <span class="keyword">if</span>(st.type != T_DIR)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"the current the file is not dictionary\n"</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//read all the files under the dir</span></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">  p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">  *p++ = <span class="string">'/'</span>;</span><br><span class="line">  <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// skip "." and ".."</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name,<span class="string">"."</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name,<span class="string">".."</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      curr = p;</span><br><span class="line">      memmove(curr, de.name, DIRSIZ);</span><br><span class="line">      curr[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"ls: cannot stat %s\n"</span>, buf);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// printf("current file name is：%s \n",buf);</span></span><br><span class="line">      <span class="comment">// record the current file</span></span><br><span class="line">      <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">        <span class="comment">// we check the current file</span></span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            fname = getname(buf);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fname,filename) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// we check the current dir</span></span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ls: path too long\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            find(buf,filename);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"we need 3 paramters!\n"</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-xargs"><a href="#5-xargs" class="headerlink" title="5. xargs"></a>5. xargs</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write a<span class="built_in"> simple </span>version of the UNIX xargs program: read lines <span class="keyword">from</span> the standard input <span class="keyword">and</span> <span class="builtin-name">run</span> a command <span class="keyword">for</span> each line, supplying the line as arguments <span class="keyword">to</span> the command. Your solution should be <span class="keyword">in</span> the file user/xargs.c.</span><br></pre></td></tr></table></figure><p>实现类似于<code>unix</code>下的<code>xargs</code>操作，这个因为要求的比较低，其实非常容易完成，我们只需要利用<code>fork</code>和<code>exec</code>函数即可完成。我们每次标准输入，在<code>xv6</code>操作系统中，标准输入及时<code>fd 0</code>读取即可，标准输出即为写入<code>fd 1</code>即可，本质来说非常简单。将参数从标准输入读入然后作为附加参数执行<code>xargs</code>后面的程序。简单就是将输入参数进行重写即可。具体可以参考代码实现。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/fs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/param.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">   <span class="keyword">char</span> *args[MAXARG];</span><br><span class="line">   <span class="keyword">char</span> c;</span><br><span class="line">   <span class="keyword">char</span> *p;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">   <span class="built_in">memset</span>(args,<span class="number">0</span>,<span class="keyword">sizeof</span>(args));</span><br><span class="line">   <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"need more parameter!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*read from the file*/</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)&#123;</span><br><span class="line">       args[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">     p = buf;</span><br><span class="line">     <span class="comment">/*read each line from the stand input*/</span></span><br><span class="line">     <span class="keyword">while</span>((n = read(<span class="number">0</span>,&amp;c,<span class="number">1</span>)) &amp;&amp; c != <span class="string">'\n'</span>)&#123;</span><br><span class="line">        *p = c;</span><br><span class="line">        p++;</span><br><span class="line">     &#125;</span><br><span class="line">     *p = <span class="string">'\0'</span>;</span><br><span class="line">     <span class="keyword">if</span>(p != buf)&#123;</span><br><span class="line">        args[argc<span class="number">-1</span>] = buf;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            exec(argv[<span class="number">1</span>],args);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"read error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-challenge-exercises"><a href="#Optional-challenge-exercises" class="headerlink" title="Optional challenge exercises"></a>Optional challenge exercises</h2><p>最后看了后面几个挑战题目也都是非常有意思，后面准备继续将三个挑战题目也完成，总的来说题目质量真心非常不错。</p><ul><li><code>uptime</code>:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write an uptime program that prints the uptime <span class="keyword">in</span> terms of ticks using the uptime<span class="built_in"> system </span>call. (easy)</span><br></pre></td></tr></table></figure><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/fs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/param.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SYS_uptime</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> now = uptime();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"the system has run %d tick.\n"</span>,now);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>regular</code><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Support regular expressions <span class="keyword">in</span> <span class="built_in">name</span> matching <span class="keyword">for</span> find. grep.c has <span class="keyword">some</span> primitive support <span class="keyword">for</span> regular expressions. (easy)</span><br></pre></td></tr></table></figure>直接抄写<code>grep</code>中的<code>reg match</code>函数即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Regexp matcher from Kernighan &amp; Pike,</span></span><br><span class="line"><span class="comment">// The Practice of Programming, Chapter 9.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matchhere</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matchstar</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>*, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">match(<span class="keyword">char</span> *re, <span class="keyword">char</span> *text)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">'^'</span>)</span><br><span class="line">    <span class="keyword">return</span> matchhere(re+<span class="number">1</span>, text);</span><br><span class="line">  <span class="keyword">do</span>&#123;  <span class="comment">// must look at empty string</span></span><br><span class="line">    <span class="keyword">if</span>(matchhere(re, text))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(*text++ != <span class="string">'\0'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchhere: search for re at beginning of text</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matchhere</span><span class="params">(<span class="keyword">char</span> *re, <span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">    <span class="keyword">return</span> matchstar(re[<span class="number">0</span>], re+<span class="number">2</span>, text);</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">'$'</span> &amp;&amp; re[<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">    <span class="keyword">return</span> *text == <span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">if</span>(*text!=<span class="string">'\0'</span> &amp;&amp; (re[<span class="number">0</span>]==<span class="string">'.'</span> || re[<span class="number">0</span>]==*text))</span><br><span class="line">    <span class="keyword">return</span> matchhere(re+<span class="number">1</span>, text+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchstar: search for c*re at beginning of text</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matchstar</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">char</span> *re, <span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;  <span class="comment">// a * matches zero or more instances</span></span><br><span class="line">    <span class="keyword">if</span>(matchhere(re, text))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(*text!=<span class="string">'\0'</span> &amp;&amp; (*text++==c || c==<span class="string">'.'</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>sh</code>:<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The xv6 <span class="built_in">shell</span> (user/sh.c) is just another user program <span class="keyword">and</span> you can improve <span class="keyword">it</span>. It is <span class="keyword">a</span> minimal <span class="built_in">shell</span> <span class="keyword">and</span> lacks many features found <span class="keyword">in</span> real <span class="built_in">shell</span>. For example, modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> <span class="keyword">not</span> print <span class="keyword">a</span> $ when processing <span class="built_in">shell</span> commands <span class="built_in">from</span> <span class="keyword">a</span> <span class="built_in">file</span> (moderate), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> support <span class="built_in">wait</span> (easy), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> support lists <span class="keyword">of</span> commands, separated <span class="keyword">by</span> <span class="string">";"</span> (moderate), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> support sub-shells <span class="keyword">by</span> implementing <span class="string">"("</span> <span class="keyword">and</span> <span class="string">")"</span> (moderate), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> support <span class="literal">tab</span> completion (easy), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> keep <span class="keyword">a</span> history <span class="keyword">of</span> passed <span class="built_in">shell</span> commands (moderate), <span class="keyword">or</span> anything <span class="keyword">else</span> you would like your <span class="built_in">shell</span> <span class="built_in">to</span> <span class="built_in">do</span>. (If you are very ambitious, you may have <span class="built_in">to</span> modify <span class="keyword">the</span> kernel <span class="built_in">to</span> support <span class="keyword">the</span> kernel features you need; xv6 doesn<span class="string">'t support much.)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MIT6-S081&quot;&gt;&lt;a href=&quot;#MIT6-S081&quot; class=&quot;headerlink&quot; title=&quot;MIT6.S081&quot;&gt;&lt;/a&gt;MIT6.S081&lt;/h1&gt;&lt;p&gt;很早就听说MIT6.S081的课程比较经典了，所以从上周末就开始学习MIT6.S081的&lt;code&gt;lecture&lt;/code&gt;,目前刚学习完&lt;code&gt;lecture 1&lt;/code&gt;，并且成功完成了&lt;code&gt;lab1&lt;/code&gt;，不得不说&lt;code&gt;lab&lt;/code&gt;太花费时间了，&lt;code&gt;lab&lt;/code&gt;设置的非常好，难度适中，有挑战性与趣味性并存，非常感谢这么好与经典的课程，不过不得不说因为确实平时没有时间，又要照顾家庭，又要上班，只能利用周末和晚上的时间抓紧来学习和完成这些&lt;code&gt;lab&lt;/code&gt;的代码了，每次都需要花时间调试代码调试很长时间，目测后面的挑战题目更难。&lt;code&gt;MIT&lt;/code&gt;的课程难度一向很大，难怪能够培养出很多非常优秀和出色的工程师。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 244</title>
    <link href="http://yoursite.com/2021/06/06/291/"/>
    <id>http://yoursite.com/2021/06/06/291/</id>
    <published>2021-06-06T13:36:04.088Z</published>
    <updated>2021-06-08T02:24:01.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-244"><a href="#leetcode-contest-244" class="headerlink" title="leetcode  contest 244"></a>leetcode  contest 244</h1><p>周末忙着迁移网络，真心忙的一比，没有时间刷题，特此上来总结一下，赛后还是没有看参考答案，将四道题目全部独立思考出来了。题目质量还是非常的高的，周赛还是经常参加一下，非常锻炼思考能力。</p><h2 id="5776-判断矩阵经轮转后是否一致"><a href="#5776-判断矩阵经轮转后是否一致" class="headerlink" title="5776. 判断矩阵经轮转后是否一致"></a>5776. 判断矩阵经轮转后是否一致</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个大小为 <code>n x n</code> 的二进制矩阵<code>mat</code> 和 <code>target</code> 。现 以 <code>90</code>度顺时针轮转 矩阵 <code>mat</code> 中的元素 若干次 ，如果能够使 <code>mat</code>与 <code>target</code> 一致，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[0,1],[1,0]]</span>, target = <span class="string">[[1,0],[0,1]]</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：顺时针轮转 <span class="number">90</span> 度一次可以使 mat 和 target 一致。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[0,1],[1,1]]</span>, target = <span class="string">[[1,0],[0,1]]</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法通过轮转矩阵中的元素使 equal 与 target 一致。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]], target = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：顺时针轮转 <span class="number">90</span> 度两次可以使 mat 和 target 一致。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == mat.length == target.length</code></li><li><code>n == mat[i].length == target[i].length</code></li><li><code>1 &lt;= n &lt;= 10</code></li><li><code>mat[i][j]</code> 和 <code>target[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  模拟计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们依次计算出四种可能的旋转情况即可，顺时针旋转$90^{。}$,相当于我们先交换行与列，再交换行即可达到旋转。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findRotation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; ++k)&#123;</span><br><span class="line">                    swap(mat[j][k],mat[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col/<span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; row; ++k)&#123;</span><br><span class="line">                    swap(mat[k][j],mat[k][col<span class="number">-1</span>-j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; col; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mat[j][k] != target[j][k])&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5777-使数组元素相等的减少操作次数"><a href="#5777-使数组元素相等的减少操作次数" class="headerlink" title="5777. 使数组元素相等的减少操作次数"></a>5777. 使数组元素相等的减少操作次数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，你的目标是令 <code>nums</code> 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p><p>找出 <code>nums</code> 中的 最大 值。记这个值为 <code>largest</code> 并取其下标 i （下标从 0 开始计数）。如果有多个元素都是最大值，则取最小的 i 。<br>找出 <code>nums</code>中的 下一个最大 值，这个值 严格小于 <code>largest</code> ，记为 <code>nextLargest</code>。<br>将 <code>nums[i]</code> 减少到 <code>nextLargest</code> 。<br>返回使 <code>nums</code>中的所有元素相等的操作次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：需要 <span class="number">3</span> 次操作使 nums 中的所有元素相等：</span><br><span class="line"><span class="number">1.</span> largest = <span class="number">5</span> 下标为 <span class="number">0</span> 。nextLargest = <span class="number">3</span> 。将 nums[<span class="number">0</span>] 减少到 <span class="number">3</span> 。nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>] 。</span><br><span class="line"><span class="number">2.</span> largest = <span class="number">3</span> 下标为 <span class="number">0</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">0</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>] 。</span><br><span class="line"><span class="number">3.</span> largest = <span class="number">3</span> 下标为 <span class="number">2</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">2</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums 中的所有元素已经是相等的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：需要 <span class="number">4</span> 次操作使 nums 中的所有元素相等：</span><br><span class="line"><span class="number">1.</span> largest = <span class="number">3</span> 下标为 <span class="number">4</span> 。nextLargest = <span class="number">2</span> 。将 nums[<span class="number">4</span>] 减少到 <span class="number">2</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line"><span class="number">2.</span> largest = <span class="number">2</span> 下标为 <span class="number">2</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">2</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 。 </span><br><span class="line"><span class="number">3.</span> largest = <span class="number">2</span> 下标为 <span class="number">3</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">3</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] 。 </span><br><span class="line"><span class="number">4.</span> largest = <span class="number">2</span> 下标为 <span class="number">4</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">4</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li><li><code>1 &lt;= nums[i] &lt;= 5 * 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的数学问题，我们知道假设数列排序后，按照无重复按照从小达到排列后的序列为$x_{1},x_{2},x_{3},…,x_{n}$,则我们可以知道最终的序列肯定都会变成$x_{1},x_{1},x_{1},…,x_{1}$,对于任意的$x_{i}$,则我们知道它需要依次变换为$x_{i-1},x_{i-2},…,x_{2},x_{1}$，则需要变换次数总计为$i-1$次，则我们知道需要对于数组中的任意元素，它都需要变换的次数为该元素在数组中的排序的位置。这样就非常简单了，我们依次获取每个元素的排名次数即可，然后即可求出所有的元素的变换次数。</li><li>时间复杂度为$O(n)$,空间复杂度$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reductionOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) cnt[v]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            ans += curr*v.second;</span><br><span class="line">            curr++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5778-使二进制字符串字符交替的最少反转次数"><a href="#5778-使二进制字符串字符交替的最少反转次数" class="headerlink" title="5778. 使二进制字符串字符交替的最少反转次数"></a>5778. 使二进制字符串字符交替的最少反转次数</h2><p>给你一个二进制字符串 s 。你可以按任意顺序执行以下两种操作任意次：</p><ul><li>类型 <code>1</code>：删除 字符串 s 的第一个字符并将它 添加 到字符串结尾。</li><li>类型 <code>2</code> ：选择 字符串 s 中任意一个字符并将该字符 反转 ，也就是如果值为 ‘0’ ，则反转得到 ‘1’ ，反之亦然。<br>请你返回使 s 变成 交替 字符串的前提下， 类型 2 的 最少 操作次数 。</li></ul><p>我们称一个字符串是 交替 的，需要满足任意相邻字符都不同。</p><p>比方说，字符串 <code>&quot;010&quot;</code> 和 <code>&quot;1010&quot;</code>都是交替的，但是字符串 <code>&quot;0100&quot;</code> 不是。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"111000"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：执行第一种操作两次，得到 <span class="attr">s</span> = <span class="string">"100011"</span> 。</span><br><span class="line">然后对第三个和第六个字符执行第二种操作，得到 <span class="attr">s</span> = <span class="string">"101010"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"010"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串已经是交替的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1110"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：对第二个字符执行第二种操作，得到 <span class="attr">s</span> = <span class="string">"1010"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code>要么是 <code>&#39;0&#39;</code> ，要么是 <code>&#39;1&#39;</code> 。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目看上去很复杂，但是我们实际上可以利用前缀和，我们设四个等式如下：</li></ol><ul><li><code>left[0][i]</code>表示将前<code>i</code>位变为首位以<code>0</code>起始，且满足<code>0</code>,<code>1</code>交替时，所需要替换的最小替换次数;</li><li><code>left[1][i]</code>表示将前<code>i</code>位变为首位以<code>1</code>起始，且满足<code>0</code>,<code>1</code>交替时，所需要替换的最小替换次数;</li><li><code>right[0][i]</code>表示从<code>i</code>位至最后一位变为首位以<code>0</code>起始，且满足<code>0</code>,<code>1</code>交替时，所需要替换的最小替换次数;</li><li><code>right[1][i]</code>表示从<code>i</code>位至最后一位变为首位以<code>1</code>起始，且满足<code>0</code>,<code>1</code>交替时，所需要替换的最小替换次数;<br>我们很容易利用前缀和，计算出上述的四个等式的值。</li></ul><ol><li>我们依次计算需要向队尾移动<code>1,2,3,4...n</code>个元素时的最小变换次数，我们知道可以有以下几种情况：</li></ol><ul><li>如果数组的长度$n$为偶数，则我们知道假如我们向队尾移动<code>x</code>个元素，则还剩余<code>n-x</code>个元素，因为$x,n-x$的奇偶性一样，此时则需要满足：如果数组的前<code>n-x</code>个元素以<code>0</code>开头且交替，则末尾的<code>x</code>个元素也必须以<code>0</code>开头且交替;如果数组的前<code>n-x</code>个元素以<code>1</code>开头且交替，则末尾的<code>x</code>个元素也必须以<code>1</code>开头且交替。此时我们可以得到如下等式：<script type="math/tex; mode=display">ans = min(left[1][x] + right[1][x+1],left[0][x] + right[0][x+1]) \\</script></li><li>如果数组的长度$n$为奇数，则我们知道假如我们向队尾移动<code>x</code>个元素，则还剩余<code>n-x</code>个元素，因为$x,n-x$的奇偶性不一样，此时则需要满足：如果数组的前<code>n-x</code>个元素以<code>0</code>开头且交替，则末尾的<code>x</code>个元素也必须以<code>1</code>开头且交替;如果数组的前<code>n-x</code>个元素以<code>1</code>开头且交替，则末尾的<code>x</code>个元素也必须以<code>0</code>开头且交替。此时我们可以得到如下等式：<script type="math/tex; mode=display">ans = min(left[1][x] + right[0][x+1],left[1][x] + right[0][x+1]) \\</script></li></ul><ol><li>我们遍历所有可能的情况，即可得出最小的变换次数。时间复杂度为$O(n)$,空间复杂度$O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> invalid0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> invalid1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start0(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start1(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c0 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) invalid1++;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) invalid0++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) invalid0++;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) invalid1++;</span><br><span class="line">            &#125;</span><br><span class="line">            start0[i+<span class="number">1</span>] = invalid0;</span><br><span class="line">            start1[i+<span class="number">1</span>] = invalid1;</span><br><span class="line">        &#125;      </span><br><span class="line">        ans = min(start0[n],start1[n]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ans = min(ans,start0[i] + start1[n] - start1[i]);</span><br><span class="line">                ans = min(ans,start1[i] + start0[n] - start0[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5779-装包裹的最小浪费空间"><a href="#5779-装包裹的最小浪费空间" class="headerlink" title="5779. 装包裹的最小浪费空间"></a>5779. 装包裹的最小浪费空间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 n 个包裹，你需要把它们装在箱子里，每个箱子装一个包裹。总共有<code>m</code> 个供应商提供 不同尺寸 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 小于等于 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p><p>包裹的尺寸用一个整数数组 <code>packages</code> 表示，其中 <code>packages[i]</code>是第 i 个包裹的尺寸。供应商用二维数组 <code>boxes</code> 表示，其中 <code>boxes[j]</code> 是第 j 个供应商提供的所有箱子尺寸的数组。</p><p>你想要选择 一个供应商 并只使用该供应商提供的箱子，使得 总浪费空间最小 。对于每个装了包裹的箱子，我们定义 浪费的 空间等于 箱子的尺寸 - 包裹的尺寸 。总浪费空间 为 所有 箱子中浪费空间的总和。</p><ul><li>比方说，如果你想要用尺寸数组为 <code>[4,8]</code>的箱子装下尺寸为 <code>[2,3,5]</code>的包裹，你可以将尺寸为 2 和 3 的两个包裹装入两个尺寸为 4 的箱子中，同时把尺寸为 5 的包裹装入尺寸为 8 的箱子中。总浪费空间为 <code>(4-2) + (4-3) + (8-5) = 6</code> 。<br>请你选择 最优 箱子供应商，使得 总浪费空间最小 。如果 无法 将所有包裹放入箱子中，请你返回 -1 。由于答案可能会 很大 ，请返回它对 <code>109 + 7</code> 取余 的结果。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：packages = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], boxes = [[<span class="number">4</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：选择第一个供应商最优，用两个尺寸为 <span class="number">4</span> 的箱子和一个尺寸为 <span class="number">8</span> 的箱子。</span><br><span class="line">总浪费空间为 (<span class="number">4</span><span class="number">-2</span>) + (<span class="number">4</span><span class="number">-3</span>) + (<span class="number">8</span><span class="number">-5</span>) = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：packages = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], boxes = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：没有箱子能装下尺寸为 <span class="number">5</span> 的包裹。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：packages = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>], boxes = [[<span class="number">12</span>],[<span class="number">11</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">5</span>,<span class="number">14</span>]]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：选择第三个供应商最优，用两个尺寸为 <span class="number">5</span> 的箱子，两个尺寸为 <span class="number">10</span> 的箱子和两个尺寸为 <span class="number">14</span> 的箱子。</span><br><span class="line">总浪费空间为 (<span class="number">5</span><span class="number">-3</span>) + (<span class="number">5</span><span class="number">-5</span>) + (<span class="number">10</span><span class="number">-8</span>) + (<span class="number">10</span><span class="number">-10</span>) + (<span class="number">14</span><span class="number">-11</span>) + (<span class="number">14</span><span class="number">-12</span>) = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == packages.length</code></li><li><code>m == boxes.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= m &lt;= 105</code></li><li><code>1 &lt;= packages[i] &lt;= 105</code></li><li><code>1 &lt;= boxes[j].length &lt;= 105</code></li><li><code>1 &lt;= boxes[j][k] &lt;= 105</code></li><li><code>sum(boxes[j].length) &lt;= 105</code></li><li><code>boxes[j]</code> 中的元素 互不相同 。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-space-wasted-from-packaging" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-space-wasted-from-packaging</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找贪心或者双指针</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目本质就是贪心算法，对于每个供应商来说，对于每个<code>package</code>则需要找到刚好最小能够大于等于该元素的箱子。我们首先需要将所有的<code>package</code>进行排序。关键点在于如下：</li></ol><ul><li>我们<code>cost[i]</code>表示第<code>i</code>个供应商刚好能够满足包装前<code>dp[i]</code>个箱子时最小的浪费空间.</li><li>对于第<code>i</code>个包裹，我们肯定优先选择处在以下范围内的箱子是最优解，及越接近$package[i]$的箱子。<script type="math/tex; mode=display">package_{i} \le b_{j} \le b_{j+1} \le ... \le b_{j+k} < package_{i+1}</script></li><li>我们对于所有的供应商的箱子都进行排序，同时标记该箱子属于哪一个供应商，我们每次遍历所有满足大于等于第<code>i</code>个包裹且小于第<code>i+1</code>个包裹的箱子，及满足如下：<script type="math/tex; mode=display">package_{i} \le b_{j} \le b_{j+1} \le ... \le b_{j+k} < package_{i+1}</script>我们可以知道此时的待选的匹配序列为:$(b_{j} \le b_{j+1} \le … \le b_{j+k})$<br>则此时我们依次检查这<code>k</code>个箱子，如果$b_{j+m}$属于第<code>x</code>个供应商,且第<code>x</code>个供应商的箱子此时已经匹配了<code>dp[x]</code>个包裹，且最小浪费为<code>cost[x]</code>;如果<code>dp[x] == i</code>则表示此时已经有更小的箱子匹配了第<code>i</code>个包裹，则我们直接忽略；如果<code>dp[x] &lt; i</code>,则意味着此时$b_{j+m}$应该最佳匹配第$(dp[x]+1,dp[x]+2,…,i)$个箱子,此时我们求出用$b_{j+m}$匹配排序为$(dp[x]+1,dp[x]+2,…,i)$这些箱子的最小浪费，我们可以很容易计算出需要浪费的空间为:<script type="math/tex; mode=display">waste = b_{j+m}*(i-dp[x]) - \sum_{k=dp[x]+1}^{i}package[k] \\</script>此时表示第<code>x</code>个供应商已经最佳匹配了前<code>i</code>个箱子，我们需要更新<code>cost[x]</code>为：<script type="math/tex; mode=display">cost[x] = cost[x] + b_{j+m}*(i-dp[x]) - \sum_{k=dp[x]+1}^{i}package[k]</script></li><li>我们此时刚好可以利用前缀和快速的求出区间和，所有上述表达式还可以继续变换为：<script type="math/tex; mode=display">cost[x] = cost[x] + b_{j+m}*(i-dp[x]) - (sum[i] - sum[dp[x]])</script></li></ul><ol><li>最终所有的计算完成后，我们则需要判断哪些供应商完美匹配了前<code>n</code>个<code>package</code>，同时比较最小的<code>cost</code>.总的时间复杂度为$O(nlgn + mlgm + m + n)$.空间复杂度为$O(m)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minWastedSpace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; packages, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; boxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = packages.size();</span><br><span class="line">        <span class="keyword">int</span> m = boxes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; cost(m,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = LLONG_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*intial*/</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        packages.push_back(INT_MAX);</span><br><span class="line">        sort(packages.begin(),packages.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + packages[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : boxes[i])&#123;</span><br><span class="line">                arr.push_back(make_pair(v,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr &lt; arr.size() &amp;&amp; arr[curr].first &lt; packages[i]) curr++;</span><br><span class="line">            <span class="keyword">while</span>(curr &lt; arr.size() &amp;&amp; arr[curr].first &gt;= packages[i] &amp;&amp; arr[curr].first &lt; packages[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> val = arr[curr].first;</span><br><span class="line">                <span class="keyword">int</span> idx = arr[curr].second;</span><br><span class="line">                <span class="keyword">if</span>(dp[idx] &lt; i)&#123;</span><br><span class="line">                    cost[idx] += (<span class="keyword">long</span> <span class="keyword">long</span>)(i - dp[idx])*val - (sum[i+<span class="number">1</span>] - sum[dp[idx]+<span class="number">1</span>]);</span><br><span class="line">                    dp[idx] = i;</span><br><span class="line">                    <span class="keyword">if</span>(i == n<span class="number">-1</span>) ans = min(ans,cost[idx]);                    </span><br><span class="line">                &#125;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ans == LLONG_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-244&quot;&gt;&lt;a href=&quot;#leetcode-contest-244&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 244&quot;&gt;&lt;/a&gt;leetcode  contest 244&lt;/h1&gt;&lt;p&gt;周末忙着迁移网络，真心忙的一比，没有时间刷题，特此上来总结一下，赛后还是没有看参考答案，将四道题目全部独立思考出来了。题目质量还是非常的高的，周赛还是经常参加一下，非常锻炼思考能力。&lt;/p&gt;&lt;h2 id=&quot;5776-判断矩阵经轮转后是否一致&quot;&gt;&lt;a href=&quot;#5776-判断矩阵经轮转后是否一致&quot; class=&quot;headerlink&quot; title=&quot;5776. 判断矩阵经轮转后是否一致&quot;&gt;&lt;/a&gt;5776. 判断矩阵经轮转后是否一致&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个大小为 &lt;code&gt;n x n&lt;/code&gt; 的二进制矩阵&lt;code&gt;mat&lt;/code&gt; 和 &lt;code&gt;target&lt;/code&gt; 。现 以 &lt;code&gt;90&lt;/code&gt;度顺时针轮转 矩阵 &lt;code&gt;mat&lt;/code&gt; 中的元素 若干次 ，如果能够使 &lt;code&gt;mat&lt;/code&gt;与 &lt;code&gt;target&lt;/code&gt; 一致，返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
