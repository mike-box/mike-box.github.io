<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-21T15:45:16.180Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 233</title>
    <link href="http://yoursite.com/2021/03/20/264/"/>
    <id>http://yoursite.com/2021/03/20/264/</id>
    <published>2021-03-20T15:47:39.102Z</published>
    <updated>2021-03-21T15:45:16.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-233"><a href="#leetcode-contest-233" class="headerlink" title="leetcode contest 233"></a>leetcode contest 233</h1><p>周赛还算三道题的节奏，最后一题太难了，不会做，没有想到会用<code>trie</code>的解法，确实非常巧妙的解法。</p><h2 id="5709-最大升序子数组和"><a href="#5709-最大升序子数组和" class="headerlink" title="5709. 最大升序子数组和"></a>5709. 最大升序子数组和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数组成的数组 <code>nums</code> ，返回 nums 中一个 升序 子数组的最大可能元素和。</p><p>子数组是数组中的一个连续数字序列。</p><p>已知子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，若对所有 <code>i（l &lt;= i &lt; r）</code>，<code>numsi &lt; numsi+1</code>都成立，则称这一子数组为 升序 子数组。注意，大小为 <code>1</code> 的子数组也视作 升序 子数组。</p><a id="more"></a><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-233/problems/maximum-ascending-subarray-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-233/problems/maximum-ascending-subarray-sum/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力滑动窗口即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>求出每个连续升序的子数组，然后求和即可。时间复杂度$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAscendingSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curr = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                curr += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5711-有界数组中指定下标处的最大值"><a href="#5711-有界数组中指定下标处的最大值" class="headerlink" title="5711. 有界数组中指定下标处的最大值"></a>5711. 有界数组中指定下标处的最大值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你三个正整数 <code>n</code>、<code>index</code> 和 <code>maxSum</code> 。你需要构造一个同时满足下述所有条件的数组 <code>nums</code>（下标 从 <code>0</code> 开始 计数）：</p><ul><li><code>nums.length == n</code></li><li><code>nums[i]</code> 是 正整数 ，其中 <code>0 &lt;= i &lt; n</code></li><li><code>abs(nums[i] - nums[i+1]) &lt;= 1</code> ，其中 <code>0 &lt;= i &lt; n-1</code></li><li><code>nums</code>中所有元素之和不超过 <code>maxSum</code></li><li><code>nums[index]</code> 的值被 最大化<br>返回你所构造的数组中的 <code>nums[index]</code> 。</li></ul><p>注意：<code>abs(x)</code> 等于 <code>x</code> 的前提是 <code>x &gt;= 0</code> ；否则，<code>abs(x)</code>等于 <code>-x</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, index = <span class="number">2</span>,  maxSum = <span class="number">6</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：数组 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 和 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, index = <span class="number">1</span>,  maxSum = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= maxSum &lt;= 109</code></li><li><code>0 &lt;= index &lt; n</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找+贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目写的太长，感觉写的太奇怪。首先我们可以按照题目要求，如果给定<code>index</code>处的值为<code>val</code>,则此时我们既可以构造出最小能够满足题意要求的序列可能为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,..,<span class="number">1</span>,<span class="number">2</span>,...,val<span class="number">-1</span>,val,val<span class="number">-1</span>,val<span class="number">-2</span>,...,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>即以<code>index</code>为中心，左右两边分别为差为为<code>1</code>的等差数列，我们可以很容易利用等差数列的求和公式求出左右两边的和，此时:<script type="math/tex; mode=display">minSum = calc(val,index) + val + calc(val,n-1-index)</script>函数$calc(val,index)$表示计算出的最大值为<code>val-1</code>且长度为<code>index</code>的数列的和。<br>如果此时计算的$minSum \le maxSum$我们则认为其符合条件。</li><li>二分查找即为非常简单的操作，时间复杂度为$O(lg(maxV))$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> val,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= val)&#123;</span><br><span class="line">            <span class="keyword">return</span> (val + val - n + <span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (val + <span class="number">1</span>)*val/<span class="number">2</span> + n - val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> maxSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> sum = mid + calc(mid<span class="number">-1</span>,index) + calc(mid<span class="number">-1</span>,n<span class="number">-1</span>-index);</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= maxSum)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5710-积压订单中的订单总数"><a href="#5710-积压订单中的订单总数" class="headerlink" title="5710. 积压订单中的订单总数"></a>5710. 积压订单中的订单总数</h2><p>给你一个二维整数数组 <code>orders</code> ，其中每个 <code>orders[i] = [pricei, amounti, orderTypei]</code>表示有 <code>amounti</code> 笔类型为 <code>orderTypei</code> 、价格为 <code>pricei</code> 的订单。</p><p>订单类型 <code>orderTypei</code> 可以分为两种：</p><ul><li><code>0</code> 表示这是一批采购订单 <code>buy</code></li><li><code>1</code> 表示这是一批销售订单 <code>sell</code><br>注意，<code>orders[i]</code>表示一批共计 <code>amounti</code> 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 <code>i</code>，由 <code>orders[i]</code>表示的所有订单提交时间均早于 <code>orders[i+1]</code>表示的所有订单。</li></ul><p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p><ul><li>如果该订单是一笔采购订单 <code>buy</code> ，则可以查看积压订单中价格 最低 的销售订单 <code>sell</code> 。如果该销售订单 <code>sell</code> 的价格 低于或等于 当前采购订单 <code>buy</code>的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 <code>buy</code> 将会添加到积压订单中。</li><li>反之亦然，如果该订单是一笔销售订单 <code>sell</code> ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单<code>buy</code>的价格 高于或等于 当前销售订单 <code>sell</code>的价格，则匹配并执行这两笔订单，并将采购订单<code>buy</code>从积压订单中删除。否则，销售订单 <code>sell</code> 将会添加到积压订单中。<br>输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 <code>109 + 7</code> 取余的结果。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">15</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">25</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">30</span>,<span class="number">4</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：输入订单后会发生下述情况：</span><br><span class="line">- 提交 <span class="number">5</span> 笔采购订单，价格为 <span class="number">10</span> 。没有销售订单，所以这 <span class="number">5</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">2</span> 笔销售订单，价格为 <span class="number">15</span> 。没有采购订单的价格大于或等于 <span class="number">15</span> ，所以这 <span class="number">2</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">1</span> 笔销售订单，价格为 <span class="number">25</span> 。没有采购订单的价格大于或等于 <span class="number">25</span> ，所以这 <span class="number">1</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">4</span> 笔采购订单，价格为 <span class="number">30</span> 。前 <span class="number">2</span> 笔采购订单与价格最低（价格为 <span class="number">15</span>）的 <span class="number">2</span> 笔销售订单匹配，从积压订单中删除这 <span class="number">2</span> 笔销售订单。第 <span class="number">3</span> 笔采购订单与价格最低的 <span class="number">1</span> 笔销售订单匹配，销售订单价格为 <span class="number">25</span> ，从积压订单中删除这 <span class="number">1</span> 笔销售订单。积压订单中不存在更多销售订单，所以第 <span class="number">4</span> 笔采购订单需要添加到积压订单中。</span><br><span class="line">最终，积压订单中有 <span class="number">5</span> 笔价格为 <span class="number">10</span> 的采购订单，和 <span class="number">1</span> 笔价格为 <span class="number">30</span> 的采购订单。所以积压订单中的订单总数为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="number">7</span>,<span class="number">1000000000</span>,<span class="number">1</span>],[<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">999999995</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">999999984</span></span><br><span class="line">解释：输入订单后会发生下述情况：</span><br><span class="line">- 提交 <span class="number">109</span> 笔销售订单，价格为 <span class="number">7</span> 。没有采购订单，所以这 <span class="number">109</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">3</span> 笔采购订单，价格为 <span class="number">15</span> 。这些采购订单与价格最低（价格为 <span class="number">7</span> ）的 <span class="number">3</span> 笔销售订单匹配，从积压订单中删除这 <span class="number">3</span> 笔销售订单。</span><br><span class="line">- 提交 <span class="number">999999995</span> 笔采购订单，价格为 <span class="number">5</span> 。销售订单的最低价为 <span class="number">7</span> ，所以这 <span class="number">999999995</span> 笔订单添加到积压订单中。</span><br><span class="line">- 提交 <span class="number">1</span> 笔销售订单，价格为 <span class="number">5</span> 。这笔销售订单与价格最高（价格为 <span class="number">5</span> ）的 <span class="number">1</span> 笔采购订单匹配，从积压订单中删除这 <span class="number">1</span> 笔采购订单。</span><br><span class="line">最终，积压订单中有 (<span class="number">1000000000</span><span class="number">-3</span>) 笔价格为 <span class="number">7</span> 的销售订单，和 (<span class="number">999999995</span><span class="number">-1</span>) 笔价格为 <span class="number">5</span> 的采购订单。所以积压订单中的订单总数为 <span class="number">1999999991</span> ，等于 <span class="number">999999984</span> % (<span class="number">109</span> + <span class="number">7</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= orders.length &lt;= 105</li><li>orders[i].length == 3</li><li>1 &lt;= pricei, amounti &lt;= 109</li><li>orderTypei 为 0 或 1</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-orders-in-the-backlog</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目很简单，就是容易出错。题目太长了，感觉应该短点。</li><li>设置积压订单中的<code>buy</code>积压的订单，按照购买价格从高到低进行排列。设置积压订单中的<code>sell</code>积压的订单，按照出售价格从低到高排列。每次当前订单如果为<code>buy</code>定时，则从<code>sell</code>的积压队列中找到出售价格小于等于<code>buy</code>的价格，并同时将积压订单数量进行核减掉。每次当前订单如果为<code>sell</code>定单时，则从<code>buy</code>的积压队列中找到购买价格大于等于<code>sell</code>的价格，并同时将积压订单数量进行核减掉。</li><li>时间复杂度$O(nlgn)$,空间复杂度$O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a, pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp2</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a, pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfBacklogOrders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; orders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = orders.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp1&gt; sell;</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp2&gt; buy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : orders)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">2</span>] == <span class="number">0</span>)&#123;<span class="comment">//buy</span></span><br><span class="line">                <span class="keyword">if</span>(sell.empty())&#123;</span><br><span class="line">                    buy.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!sell.empty() &amp;&amp; sell.top().first &lt;= v[<span class="number">0</span>])&#123;</span><br><span class="line">                        pii curr = sell.top();</span><br><span class="line">                        sell.pop();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(curr.second &lt;= v[<span class="number">1</span>])&#123;</span><br><span class="line">                            v[<span class="number">1</span>] -= curr.second;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            curr.second -= v[<span class="number">1</span>];</span><br><span class="line">                            v[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                            sell.push(curr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(v[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        buy.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//sell</span></span><br><span class="line">                <span class="keyword">if</span>(buy.empty())&#123;</span><br><span class="line">                    sell.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!buy.empty() &amp;&amp; buy.top().first &gt;= v[<span class="number">0</span>])&#123;</span><br><span class="line">                        pii curr = buy.top();</span><br><span class="line">                        buy.pop();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span>(curr.second &lt;= v[<span class="number">1</span>])&#123;</span><br><span class="line">                            v[<span class="number">1</span>] -= curr.second;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            curr.second -= v[<span class="number">1</span>];</span><br><span class="line">                            v[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                            buy.push(curr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(v[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        sell.push(&#123;v[<span class="number">0</span>],v[<span class="number">1</span>]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!buy.empty())&#123;</span><br><span class="line">            ans = (ans + buy.top().second)%mod;</span><br><span class="line">            buy.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">while</span>(!sell.empty())&#123;</span><br><span class="line">            ans = (ans + sell.top().second)%mod;</span><br><span class="line">            sell.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5696-统计异或值在范围内的数对有多少"><a href="#5696-统计异或值在范围内的数对有多少" class="headerlink" title="5696. 统计异或值在范围内的数对有多少"></a>5696. 统计异或值在范围内的数对有多少</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> （下标 从 <code>0</code> 开始 计数）以及两个整数：<code>low</code> 和 <code>high</code>，请返回 漂亮数对 的数目。</p><p>漂亮数对 是一个形如 <code>(i, j)</code> 的数对，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code>且 <code>low &lt;= (nums[i] XOR nums[j]) &lt;= high</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>], low = <span class="number">2</span>, high = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：所有漂亮数对 (i, j) 列出如下：</span><br><span class="line">    - (<span class="number">0</span>, <span class="number">1</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">1</span>] = <span class="number">5</span> </span><br><span class="line">    - (<span class="number">0</span>, <span class="number">2</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">    - (<span class="number">0</span>, <span class="number">3</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">2</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">3</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    - (<span class="number">2</span>, <span class="number">3</span>): nums[<span class="number">2</span>] XOR nums[<span class="number">3</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>], low = <span class="number">5</span>, high = <span class="number">14</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：所有漂亮数对 (i, j) 列出如下：</span><br><span class="line">​​​​​    - (<span class="number">0</span>, <span class="number">2</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">2</span>] = <span class="number">13</span></span><br><span class="line">    - (<span class="number">0</span>, <span class="number">3</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">3</span>] = <span class="number">11</span></span><br><span class="line">    - (<span class="number">0</span>, <span class="number">4</span>): nums[<span class="number">0</span>] XOR nums[<span class="number">4</span>] = <span class="number">8</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">2</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">2</span>] = <span class="number">12</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">3</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">3</span>] = <span class="number">10</span></span><br><span class="line">    - (<span class="number">1</span>, <span class="number">4</span>): nums[<span class="number">1</span>] XOR nums[<span class="number">4</span>] = <span class="number">9</span></span><br><span class="line">    - (<span class="number">2</span>, <span class="number">3</span>): nums[<span class="number">2</span>] XOR nums[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line">    - (<span class="number">2</span>, <span class="number">4</span>): nums[<span class="number">2</span>] XOR nums[<span class="number">4</span>] = <span class="number">5</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">2</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">2</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= low &lt;= high &lt;= <span class="number">2</span> * <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-233/problems/count-pairs-with-xor-in-a-range/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt; 异或</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 核心问题记住异或的时候需要用到`trie`的结构，感觉类似的题目确实非常少碰到，所以不会做。与下列两个题目类似，又一次碰到类似的题目了，我还以为需要用到数位`dp`，实际不需要。</span><br><span class="line">+ [LC421](https:<span class="comment">//leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/) 数组中两个数的最大异或值。</span></span><br><span class="line">+ [LC1707](https:<span class="comment">//leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/) 与数组中元素的最大异或值。</span></span><br><span class="line"><span class="number">2.</span> 我们建立`trie`记录下第`i`为`<span class="number">0</span>`或者`<span class="number">1</span>`的数的个数，我们可以深刻的理解题意，如果满足异或的值小于某个数`key`的话，只需要某一位比`key`的值不同，且为`<span class="number">0</span>`即可。</span><br><span class="line"><span class="number">3.</span> 根据容斥定理，我们只需要找到当前小于`target`的数组元素的个数即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line">struct TrieNode&#123;</span><br><span class="line">    TrieNode *next[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">int</span> cnt;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next[<span class="number">0</span>] = NULL;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next[<span class="number">1</span>] = NULL;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> insertTrie(TrieNode * root,<span class="built_in">int</span> val)&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">int</span> x = (val&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;next[x])&#123;</span><br><span class="line">            node-&gt;next[x] = new TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next[x];</span><br><span class="line">        node-&gt;cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> search(TrieNode * root,<span class="built_in">int</span> num,<span class="built_in">int</span> low)&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">int</span> x = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> y = (low&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">1</span>)&#123; <span class="comment">//当前位不同，则我们找到当前位异或结果为`0`的数目统计。</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[x])&#123;</span><br><span class="line">                ans += node-&gt;next[x]-&gt;cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[<span class="number">1</span>-x];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//当前位相同，我们直接按照相同的位进行查找。</span></span><br><span class="line">            node = node-&gt;next[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> countPairs(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> low, <span class="built_in">int</span> high) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        TrieNode * root = new TrieNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            ans += search(root,nums[i],high+<span class="number">1</span>) - search(root,nums[i],low);</span><br><span class="line">            insertTrie(root,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-233&quot;&gt;&lt;a href=&quot;#leetcode-contest-233&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 233&quot;&gt;&lt;/a&gt;leetcode contest 233&lt;/h1&gt;&lt;p&gt;周赛还算三道题的节奏，最后一题太难了，不会做，没有想到会用&lt;code&gt;trie&lt;/code&gt;的解法，确实非常巧妙的解法。&lt;/p&gt;&lt;h2 id=&quot;5709-最大升序子数组和&quot;&gt;&lt;a href=&quot;#5709-最大升序子数组和&quot; class=&quot;headerlink&quot; title=&quot;5709. 最大升序子数组和&quot;&gt;&lt;/a&gt;5709. 最大升序子数组和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个正整数组成的数组 &lt;code&gt;nums&lt;/code&gt; ，返回 nums 中一个 升序 子数组的最大可能元素和。&lt;/p&gt;&lt;p&gt;子数组是数组中的一个连续数字序列。&lt;/p&gt;&lt;p&gt;已知子数组 &lt;code&gt;[numsl, numsl+1, ..., numsr-1, numsr]&lt;/code&gt;，若对所有 &lt;code&gt;i（l &amp;lt;= i &amp;lt; r）&lt;/code&gt;，&lt;code&gt;numsi &amp;lt; numsi+1&lt;/code&gt;都成立，则称这一子数组为 升序 子数组。注意，大小为 &lt;code&gt;1&lt;/code&gt; 的子数组也视作 升序 子数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 48</title>
    <link href="http://yoursite.com/2021/03/20/263/"/>
    <id>http://yoursite.com/2021/03/20/263/</id>
    <published>2021-03-20T14:27:10.130Z</published>
    <updated>2021-03-21T10:07:04.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-48"><a href="#leetcode-contest-48" class="headerlink" title="leetcode contest 48"></a>leetcode contest 48</h1><p><img src="https://i.loli.net/2021/03/21/mPKJugl2FU1aBon.png" alt><br>又是三道题的节奏，很多题目还是想不出来，只能说太菜了。最后一题简直是模板题目，状态压缩dp，一点意思也没有，竟然卡在第三题上。</p><h2 id="5693-字符串中第二大的数字"><a href="#5693-字符串中第二大的数字" class="headerlink" title="5693. 字符串中第二大的数字"></a>5693. 字符串中第二大的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。</p><a id="more"></a><p>混合字符串 由小写英文字母和数字组成。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"dfa12321afd"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：出现在 s 中的数字包括 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] 。第二大的数字是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc1111"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：出现在 s 中的数字只包含 [<span class="number">1</span>] 。没有第二大的数字。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母和（或）数字。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/second-largest-digit-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/second-largest-digit-in-a-string/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力统计<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                cnt.insert(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = cnt.end();</span><br><span class="line">        it--;</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">return</span> *it - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5694-设计一个验证系统"><a href="#5694-设计一个验证系统" class="headerlink" title="5694. 设计一个验证系统"></a>5694. 设计一个验证系统</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code>时刻之后 <code>timeToLive</code>秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code>（可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p><p>请你实现 <code>AuthenticationManager</code>类：</p><ul><li><code>AuthenticationManager(int timeToLive)</code>构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code>参数。</li><li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code>，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li><li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 未过期 的验证码在 <code>currentTime</code>时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li><li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，未过期 的验证码数目。<br>如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生<code>（renew</code>或者 <code>countUnexpiredTokens</code>操作），过期事件 优先于 其他操作。</li></ul><p>示例 1：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"AuthenticationManager"</span>, <span class="string">"renew"</span>, <span class="string">"generate"</span>, <span class="string">"countUnexpiredTokens"</span>, <span class="string">"generate"</span>, <span class="string">"renew"</span>, <span class="string">"renew"</span>, <span class="string">"countUnexpiredTokens"</span>]</span><br><span class="line">[[<span class="number">5</span>], [<span class="string">"aaa"</span>, <span class="number">1</span>], [<span class="string">"aaa"</span>, <span class="number">2</span>], [<span class="number">6</span>], [<span class="string">"bbb"</span>, <span class="number">7</span>], [<span class="string">"aaa"</span>, <span class="number">8</span>], [<span class="string">"bbb"</span>, <span class="number">10</span>], [<span class="number">15</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">1</span>, null, null, null, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">AuthenticationManager authenticationManager = new AuthenticationManager(<span class="number">5</span>); <span class="comment">// 构造 AuthenticationManager ，设置 timeToLive = 5 秒。</span></span><br><span class="line">authenticationManager.renew(<span class="string">"aaa"</span>, <span class="number">1</span>); <span class="comment">// 时刻 1 时，没有验证码的 tokenId 为 "aaa" ，没有验证码被更新。</span></span><br><span class="line">authenticationManager.generate(<span class="string">"aaa"</span>, <span class="number">2</span>); <span class="comment">// 时刻 2 时，生成一个 tokenId 为 "aaa" 的新验证码。</span></span><br><span class="line">authenticationManager.countUnexpiredTokens(<span class="number">6</span>); <span class="comment">// 时刻 6 时，只有 tokenId 为 "aaa" 的验证码未过期，所以返回 1 。</span></span><br><span class="line">authenticationManager.generate(<span class="string">"bbb"</span>, <span class="number">7</span>); <span class="comment">// 时刻 7 时，生成一个 tokenId 为 "bbb" 的新验证码。</span></span><br><span class="line">authenticationManager.renew(<span class="string">"aaa"</span>, <span class="number">8</span>); <span class="comment">// tokenId 为 "aaa" 的验证码在时刻 7 过期，且 8 &gt;= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。</span></span><br><span class="line">authenticationManager.renew(<span class="string">"bbb"</span>, <span class="number">10</span>); <span class="comment">// tokenId 为 "bbb" 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。</span></span><br><span class="line">authenticationManager.countUnexpiredTokens(<span class="number">15</span>); <span class="comment">// tokenId 为 "bbb" 的验证码在时刻 15 过期，tokenId 为 "aaa" 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= timeToLive &lt;= 108</code></li><li><code>1 &lt;= currentTime &lt;= 108</code></li><li><code>1 &lt;= tokenId.length &lt;= 5</code></li><li><code>tokenId</code> 只包含小写英文字母。</li><li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li><li>所有函数调用中，<code>currentTime</code>的值 严格递增 。</li><li>所有函数的调用次数总共不超过 2000 次。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/design-authentication-manager/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/design-authentication-manager/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力统计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的非常不好，给定的数据量又很小，全部用暴力都可以实现。</li><li>每次<code>generate</code>时记录下生成<code>token</code>的时间，<code>renew</code>时检查是否超时，如果超时则删除，<code>countUnexpiredTokens</code>则直接暴力查找统计，感觉就是送分题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManager</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AuthenticationManager(<span class="keyword">int</span> timeToLive) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;live = timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="built_in">string</span> tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        token[tokenId] = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renew</span><span class="params">(<span class="built_in">string</span> tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!token.count(tokenId)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>((currentTime - token[tokenId])&gt;= live)&#123;</span><br><span class="line">            token.erase(tokenId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        token[tokenId] = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countUnexpiredTokens</span><span class="params">(<span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = token.begin(); it != token.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentTime - it-&gt;second &lt; live)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; token;</span><br><span class="line">    <span class="keyword">int</span> live;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5712-你能构造出连续值的最大数目"><a href="#5712-你能构造出连续值的最大数目" class="headerlink" title="5712. 你能构造出连续值的最大数目"></a>5712. 你能构造出连续值的最大数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3>给你一个长度为<code>n</code>的整数数组 <code>coins</code> ，它代表你拥有的 n 个硬币。第 <code>i</code>个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为<code>x</code>，那么称，你可以 构造 出<code>x</code> 。</li></ol></blockquote><p>请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">2</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">- <span class="number">2</span>：取 [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">3</span>：取 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">4</span>：取 [<span class="number">4</span>]</span><br><span class="line">- <span class="number">5</span>：取 [<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">6</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">7</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">8</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>coins.length == n</code></li><li><code>1 &lt;= n &lt;= 4 * 104</code></li><li><code>1 &lt;= coins[i] &lt;= 4 * 104</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>假设数组中的部分元素能否构成$[0,x]$中的所有整数，此时我们再加入整数$y$,则此时我们知道肯定可以构成的整数范围为$[y,y+x]$,假设满足$y \le x+1$,则我们可以将$[0,x]$与$[y,y+x]$进行合并跟新为新的连续区间为$[0,y+x]$,此时我们即扩大了连续整数的范围。否则如果$y &gt; x+1$则不会对最终的结果产生任何影响。</li><li>我们首先将数组按照升序进行排列，我们每次选取最小的<code>nums[i]</code>看是否能增加当前的选择范围，如果可以增加，则我们将对数据的范围进行扩展长度为$nums[i]$。</li><li>非常喜欢这类思考性质的数学题目，虽然比较难，但是思考的深度非常不错。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(coins.begin(),coins.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coins[i] &lt;= ans + <span class="number">1</span>)&#123;</span><br><span class="line">                ans += coins[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5712-你能构造出连续值的最大数目-1"><a href="#5712-你能构造出连续值的最大数目-1" class="headerlink" title="5712. 你能构造出连续值的最大数目"></a>5712. 你能构造出连续值的最大数目</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>coins</code> ，它代表你拥有的<code>n</code>个硬币。第 <code>i</code>个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。</p><p>请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">2</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：你可以得到以下这些值：</span><br><span class="line">- <span class="number">0</span>：什么都不取 []</span><br><span class="line">- <span class="number">1</span>：取 [<span class="number">1</span>]</span><br><span class="line">- <span class="number">2</span>：取 [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">3</span>：取 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">4</span>：取 [<span class="number">4</span>]</span><br><span class="line">- <span class="number">5</span>：取 [<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">6</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">- <span class="number">7</span>：取 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">从 <span class="number">0</span> 开始，你可以构造出 <span class="number">8</span> 个连续整数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>coins.length == n</code></li><li><code>1 &lt;= n &lt;= 4 * 104</code></li><li><code>1 &lt;= coins[i] &lt;= 4 * 104</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-48/problems/maximum-number-of-consecutive-values-you-can-make/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>标准的模板题，状态压缩<code>dp</code>加上子空间遍历。</li><li>设<code>dp[state]</code>表示当前已经选择的元素的掩码为<code>state</code>时，所能获取到的最大分数。首先我们需要确定的是<code>state</code>中一定包含偶数个元素，我们设然<code>state</code>包含的元素个数为<code>x</code>，我们遍历<code>state</code>的状态子空间<code>prevstate</code>，当且仅当<code>prevstate</code>包含<code>x-2</code>个元素时，此时我们就可以得到<code>dp</code>的递推公式:<script type="math/tex; mode=display">dp[state] = max(dp[state],dp[prevstate] + \frac{x}{2}*dp[prevstate\bigoplus state])</script></li><li>非常典型的状态压缩和子空间遍历。稍微用点技巧的时可以用快速的<code>n&amp;(n-1)</code>的方法来得到数中<code>1</code>的个数。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp[(<span class="number">1</span>&lt;&lt;i)|(<span class="number">1</span>&lt;&lt;j)] = __gcd(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count(i)%<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">0</span>; j = (j<span class="number">-1</span>)&amp;i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count(i) - count(j) == <span class="number">2</span>)&#123;</span><br><span class="line">                    dp[i] = max(dp[i],dp[j] + (count(i)/<span class="number">2</span>)*dp[i^j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>贪心算法：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                arr.push_back(Node(i,j,__gcd(nums[i],nums[j])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](Node &amp; a,Node &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.v &gt; b.v;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[arr[i].x] == <span class="literal">false</span> &amp;&amp; visit[arr[i].y] == <span class="literal">false</span>)&#123;</span><br><span class="line">                res.push_back(arr[i].v);</span><br><span class="line">                visit[arr[i].x] = <span class="literal">true</span>;</span><br><span class="line">                visit[arr[i].y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); ++i)&#123;</span><br><span class="line">            ans += (i+<span class="number">1</span>)*res[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-48&quot;&gt;&lt;a href=&quot;#leetcode-contest-48&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 48&quot;&gt;&lt;/a&gt;leetcode contest 48&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/21/mPKJugl2FU1aBon.png&quot; alt&gt;&lt;br&gt;又是三道题的节奏，很多题目还是想不出来，只能说太菜了。最后一题简直是模板题目，状态压缩dp，一点意思也没有，竟然卡在第三题上。&lt;/p&gt;&lt;h2 id=&quot;5693-字符串中第二大的数字&quot;&gt;&lt;a href=&quot;#5693-字符串中第二大的数字&quot; class=&quot;headerlink&quot; title=&quot;5693. 字符串中第二大的数字&quot;&gt;&lt;/a&gt;5693. 字符串中第二大的数字&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT】 2021 MIT6.824 Lab1</title>
    <link href="http://yoursite.com/2021/03/16/262/"/>
    <id>http://yoursite.com/2021/03/16/262/</id>
    <published>2021-03-16T01:51:21.636Z</published>
    <updated>2021-03-16T03:39:10.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MIT6-824-2021-lab1"><a href="#MIT6-824-2021-lab1" class="headerlink" title="MIT6.824 2021 lab1"></a>MIT6.824 2021 lab1</h1><p>终于在跌跌撞撞中完成了<code>MIT lab1 map-reduce</code>的<code>lab</code>，仔细对比了一下，<code>2021</code>年的<code>lab</code>要比之前的<code>lab</code>要复杂一些，以前的<code>map-reduce lab</code>基本上只是<code>Coordinator</code>对任务进行主动调度，<code>2021</code>的<code>lab</code>会涉及到<code>Coordinator</code>被动接受<code>worker</code>的任务请求，然后进行被动的调度，同时加入了防止任务意外中止的校验，使得系统更加完善和健壮。所有的测试结果如下所示：<br><img src="https://i.loli.net/2021/03/16/2TsRwIzVidc8apv.png" alt><br>所有的代码都放在github上.</p><a id="more"></a><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>按照题目要求实现<code>map-reduce</code>系统，按照<code>lab</code>的要求实现调度器<code>Coordinator</code>和<code>worker</code>的基本功能，<code>lab</code>要求由<code>woker</code>主动向调度器发起任务请求，<code>Coordinator</code>按照当前的任务分配进度为每个<code>worker</code>分配<code>map</code>或者<code>reduce</code>任务，<code>reduce</code>任务必须在所有的<code>map</code>任务都完成后才能开始启动。其中的核心的难点并不是在于<code>map</code>和<code>reduce</code>的实现，难点在于如何做好<code>worker</code>和<code>Coordinator</code>之间的任务分配和调度。</p><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><ul><li><code>Coordinator</code>作为一个<code>rpc server</code>,处理所有从<code>worker</code>发送过来的<code>rpc</code>请求，当然在此也顺便学习了一下<code>go</code>的<code>rpc</code>框架，其实还是挺有意思的，非常方便的消息处理框架，首先我们需要设置好双方进行消息交互的<code>rpc</code>消息格式定义，目前定义如下：<br><code>option</code>请求定义:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OpType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">TaskReq OpType = <span class="literal">iota</span> <span class="comment">//请求分配任务</span></span><br><span class="line">TaskMap               <span class="comment">//分配一个map类型的任务</span></span><br><span class="line">TaskReduce            <span class="comment">//分配一个reduce类型的任务</span></span><br><span class="line">TaskMapDone           <span class="comment">//完成一个map任务</span></span><br><span class="line">TaskReduceDone        <span class="comment">//完成一个reduce任务</span></span><br><span class="line">TaskDone              <span class="comment">//所有任务均已完成</span></span><br><span class="line">TaskWait              <span class="comment">//等待当前任务完成</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><code>rpc</code>请求消息定义:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReqArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">ReqId <span class="keyword">int64</span>    <span class="comment">// timestamp，作为本次请求分配的唯一标识。</span></span><br><span class="line">ReqOp OpType   <span class="comment">// 消息类型</span></span><br><span class="line">ReqTaskId <span class="keyword">int</span>  <span class="comment">// 任务的ID编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>rpc</code>回应消息定义：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplyArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">RepId <span class="keyword">int64</span>   <span class="comment">// timestamp，作为某次请求的唯一标识。</span></span><br><span class="line">RepOp OpType  <span class="comment">//消息类型</span></span><br><span class="line">RepTaskId <span class="keyword">int</span> <span class="comment">//分配的任务ID</span></span><br><span class="line">RepnMap <span class="keyword">int</span>   <span class="comment">//map任务的总数</span></span><br><span class="line">RepnReduce <span class="keyword">int</span> <span class="comment">//reduce任务的总数</span></span><br><span class="line">RepContent <span class="keyword">string</span> <span class="comment">//map任务的文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>Coordinator</code>定义：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">mapTasks <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//待分配的map任务列表</span></span><br><span class="line">reduceTasks <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//待分配的reduce任务列表</span></span><br><span class="line">nReduce <span class="keyword">int</span> <span class="comment">//reduce任务的数量</span></span><br><span class="line">nMap <span class="keyword">int</span>    <span class="comment">//map的任务数量</span></span><br><span class="line">mapRuning []<span class="keyword">int64</span> <span class="comment">//map任务状态</span></span><br><span class="line">reduceRuning []<span class="keyword">int64</span> <span class="comment">//reduce任务状态</span></span><br><span class="line">tasks []<span class="keyword">string</span> <span class="comment">//待处理的文件名称</span></span><br><span class="line">mapCnt <span class="keyword">int</span>   <span class="comment">//当前未完成的map数量</span></span><br><span class="line">reduceCnt <span class="keyword">int</span> <span class="comment">//当前未完成的reduce任务数量</span></span><br><span class="line">taskDone <span class="keyword">bool</span>  <span class="comment">//任务是否全部完成</span></span><br><span class="line">lock *sync.Cond  <span class="comment">//互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Coordinator</code>接受到<code>worker</code>的请求后，根据请求的消息类型进行回应，如果当前的任务已经完成，则直接回应；如果请求的消息为任务请求，则查看是否存在待处理的<code>map</code>任务，如果存在则分发一个<code>map</code>类型的任务，如果<code>map</code>任务都已经下发但是还未全部完成，则通知<code>worker</code>进行等待；如果所有的<code>map</code>任务都已经下发且已经完成，则分配一个<code>reduce</code>类型的任务交给<code>worker</code>进行处理；如果接受的消息为<code>worker</code>通知任务完成，我们会校验该任务的标识，如果校验通过，我们将相应的任务状态设置为已经完成。</li><li>最关键的一点处理，每当<code>Coordinator</code>分配一个任务后，就会启动一个定时器任务，该定时器任务会在<code>10s</code>后检查该任务的状态是否已经完成，如果未完成，则将该任务再次进入到待分配列表中。</li><li>关键的临界区处理，这点我处理的不太好，为了图简单，直接在所有的存在竞争的数据访问处都用的互斥锁锁，其实也可以试试用<code>go</code>的<code>atmoic</code>来定义某些关键数据类型，后面如果需要改进的话重点放在临界区访问的控制上。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">c.lock.L.Lock()</span><br><span class="line">allDone := c.taskDone </span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">if</span> allDone &#123; <span class="comment">//检验当前所有任务的状态，如果已经全部完成则直接返回</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskDone</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> args.ReqOp&#123;</span><br><span class="line"><span class="keyword">case</span> TaskReq: <span class="comment">//任务请求</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.mapTasks) &gt; <span class="number">0</span> &#123; <span class="comment">//如果存在待分配的map任务，则分配一个任务给当前的worker</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskMap</span><br><span class="line">reply.RepTaskId = &lt;-c.mapTasks</span><br><span class="line">reply.RepnMap = c.nMap</span><br><span class="line">reply.RepContent = c.tasks[reply.RepTaskId]</span><br><span class="line">reply.RepnReduce = c.nReduce</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line">c.mapRuning[reply.RepTaskId] = args.ReqId <span class="comment">//记录当前任务请求的标识</span></span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="keyword">int</span>)</span></span>&#123; <span class="comment">// 10s后检查该任务是否完成，如果未完成则将该任务再次进入待分配列表</span></span><br><span class="line">time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.mapRuning[taskId] != <span class="number">1</span>&#123;</span><br><span class="line">c.mapTasks&lt;-taskId</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c.mapCnt--</span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line">&#125;(reply.RepTaskId)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(c.mapTasks) == <span class="number">0</span> &#123;</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line">mapCurr := c.mapCnt</span><br><span class="line">reduceCurr := c.reduceCnt</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  mapCurr &gt; <span class="number">0</span> &#123; <span class="comment">// map任务全部分配，但是并未全部完成，此时需要通知worker进行等待</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskWait</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.reduceTasks) &gt; <span class="number">0</span> &#123;<span class="comment">// 如果存在待分配的reduce任务，则分配一个任务给当前的worker</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskReduce</span><br><span class="line">reply.RepTaskId = &lt;-c.reduceTasks</span><br><span class="line">reply.RepnMap = c.nMap</span><br><span class="line">reply.RepnReduce = c.nReduce</span><br><span class="line">c.lock.L.Lock()</span><br><span class="line">c.reduceRuning[reply.RepTaskId] = args.ReqId</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">time.Sleep(<span class="number">10</span>*time.Second) <span class="comment">//  10s后检查该任务是否完成，如果未完成则将该任务再次进入待分配列表</span></span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.reduceRuning[taskId] != <span class="number">1</span>&#123;</span><br><span class="line">c.reduceTasks&lt;-taskId</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c.reduceCnt--</span><br><span class="line"><span class="keyword">if</span> c.reduceCnt == <span class="number">0</span>&#123;</span><br><span class="line">c.taskDone = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line">&#125;(reply.RepTaskId)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> reduceCurr &gt; <span class="number">0</span> &#123; <span class="comment">// reduce任务全部分配，但是并未全部完成，此时需要通知worker进行等待</span></span><br><span class="line">reply.RepId = args.ReqId</span><br><span class="line">reply.RepOp = TaskWait</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> TaskMapDone: <span class="comment">// map任务完成，将该任务的状态置为完成</span></span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.mapRuning[args.ReqTaskId] == args.ReqId &#123;</span><br><span class="line">c.mapRuning[args.ReqTaskId] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">case</span> TaskReduceDone: <span class="comment">// reduce任务完成，将该任务的状态置为完成</span></span><br><span class="line">c.lock.L.Lock()</span><br><span class="line"><span class="keyword">if</span> c.reduceRuning[args.ReqTaskId] == args.ReqId&#123;</span><br><span class="line">c.reduceRuning[args.ReqTaskId] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><code>worker</code>的处理就简单许多，主要是<code>map</code>处理和<code>reduce</code>处理，这个基本上可以参考<code>lab</code>给定的<code>mrsequential</code>代码即可，此时我们主要对<code>map</code>进行处理产生中间文件交给<code>reduce</code>处理即可。</li><li><code>map</code>:从文件种读取所有的<code>key-value</code>数据，然后根据<code>hash</code>值写入不同的文件即可，当然这里的优化完全可以按照hash值进行排序，这样可以一次性将hash值相同的元素写入同一个文件，避免每次写入时写入不同的文件，从而可以加快处理速度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// process a map task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startMapTask</span><span class="params">(timestamp <span class="keyword">int64</span>,reply * ReplyArgs,mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line">ifile, err := os.Open(reply.RepContent)</span><br><span class="line"><span class="keyword">defer</span> ifile.Close()</span><br><span class="line"><span class="comment">// read content from the file</span></span><br><span class="line">content, err := ioutil.ReadAll(ifile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"can not read %v"</span>, reply.RepContent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intermediate := mapf(reply.RepContent, <span class="keyword">string</span>(content)) <span class="comment">// map任务处理</span></span><br><span class="line">ofile := <span class="built_in">make</span>([]*os.File,reply.RepnReduce)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.RepnReduce; i++ &#123;</span><br><span class="line">ofname := <span class="string">"mr-"</span> + strconv.Itoa(reply.RepTaskId) + <span class="string">"-"</span> + strconv.Itoa(i)</span><br><span class="line">ofile[i], _ = os.Create(ofname)</span><br><span class="line"><span class="keyword">defer</span> ofile[i].Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,kv := <span class="keyword">range</span> intermediate&#123; <span class="comment">// 根据key的hash值写入相应的中间文件</span></span><br><span class="line">reduceId := ihash(kv.Key)%reply.RepnReduce</span><br><span class="line">enc := json.NewEncoder(ofile[reduceId])</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span>(err != <span class="literal">nil</span>)&#123;</span><br><span class="line">log.Fatalf(<span class="string">"can not read %v"</span>, ofile[reduceId])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//notice the server task finished</span></span><br><span class="line">args := ReqArgs&#123;&#125; <span class="comment">// 向Coordinator回应本次任务处理完成</span></span><br><span class="line">args.ReqId = timestamp</span><br><span class="line">args.ReqOp = TaskMapDone</span><br><span class="line">args.ReqTaskId = reply.RepTaskId</span><br><span class="line">nextreply := ReplyArgs&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> call(<span class="string">"Coordinator.Request"</span>, &amp;args, &amp;nextreply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>reduce</code>:从文件种读取所有的<code>key hash</code>值相同的数据，然后根据<code>key</code>进行排序，将相同的<code>key</code>的元素进行<code>reduce</code>处理，处理完成后结果写入到目标文件种，全部完成后通知<code>Coordinator</code>本次任务完成。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/ process a reduce task</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startReduceTask</span><span class="params">(timestamp <span class="keyword">int64</span>,reply * ReplyArgs,reducef <span class="keyword">func</span>(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// we check every intermediate map task file</span></span><br><span class="line">kva := []KeyValue&#123;&#125; </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.RepnMap; i++ &#123; <span class="comment">//读取所有的中间文件</span></span><br><span class="line">ifilename := <span class="string">"mr-"</span> + strconv.Itoa(i) + <span class="string">"-"</span> + strconv.Itoa(reply.RepTaskId)</span><br><span class="line">ifile, err := os.Open(ifilename)</span><br><span class="line"><span class="keyword">defer</span> ifile.Close()</span><br><span class="line"><span class="comment">// open file error</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">"Open File Error."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read all intermediate data from the file</span></span><br><span class="line">dec := json.NewDecoder(ifile)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; </span><br><span class="line">kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//store intermediate data to the out file</span></span><br><span class="line">sort.Sort(ByKey(kva)) <span class="comment">//排序</span></span><br><span class="line"><span class="comment">// write to the target file</span></span><br><span class="line">ofilename := <span class="string">"mr-out-"</span> + strconv.Itoa(reply.RepTaskId)</span><br><span class="line"><span class="comment">//fmt.Println("out file %v",ofilename)</span></span><br><span class="line">ofile,err := os.Create(ofilename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">"Creat Open File Error."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ofile.Close()</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(kva) &#123; <span class="comment">//按照相同的key进行分配，并进行reduce处理</span></span><br><span class="line">j := i + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="built_in">len</span>(kva) &amp;&amp; kva[j].Key == kva[i].Key &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">values := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">values = <span class="built_in">append</span>(values, kva[k].Value)</span><br><span class="line">&#125;</span><br><span class="line">output := reducef(kva[i].Key, values)</span><br><span class="line"><span class="comment">// this is the correct format for each line of Reduce output.</span></span><br><span class="line">fmt.Fprintf(ofile, <span class="string">"%v %v\n"</span>, kva[i].Key, output)</span><br><span class="line">i = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//notice the server task finished</span></span><br><span class="line">args := ReqArgs&#123;&#125; <span class="comment">// 向Coordinator回应本次任务处理完成</span></span><br><span class="line">args.ReqId = timestamp</span><br><span class="line">args.ReqOp = TaskReduceDone</span><br><span class="line">args.ReqTaskId = reply.RepTaskId</span><br><span class="line">nextreply := ReplyArgs&#123;&#125;</span><br><span class="line"><span class="keyword">return</span> call(<span class="string">"Coordinator.Request"</span>, &amp;args, &amp;nextreply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h3>根据<code>paper</code>中的描述如下：<br><img src="https://i.loli.net/2021/03/16/GQntKroZga4NE6j.png" alt></li></ul><ol><li>假设有 <code>M</code> 个 <code>map</code>   操作， <code>n</code> 个 <code>reduce</code>  操作， 那么<code>master</code>一共要安排<code>M +N</code> 个<code>worker</code>任务 。</li><li>每个 <code>map</code> 操作将生成  <code>n</code>个文件，<code>map</code>过程一共产生  <code>m*n</code> 个文件.</li><li><code>map</code> 操作完成后的数据是以文件的形式存储的.<br>实际处理过程：首先将 文档分成  <code>m</code>份，每一份调用一个 <code>map</code> 函数操作并生成 <code>n</code>个文件  。所有 <code>map</code>操作完成后进行 <code>reduce</code>操作，对于 每个 <code>reduce</code> 操作，从上一步生成 的<code>m*n</code> 个文件中选取对应的<code>m</code>个文件 进行<code>reduce</code> 操作，完成后将结果写入$n_{i}$ 中。 所有 <code>reduce</code> 操作完成后将 <code>n</code>个临时文件合并成最终的 <code>output</code> 文件<br><img src="https://i.loli.net/2021/03/16/W2GvcPOLAkXbtMH.png" alt><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MIT6-824-2021-lab1&quot;&gt;&lt;a href=&quot;#MIT6-824-2021-lab1&quot; class=&quot;headerlink&quot; title=&quot;MIT6.824 2021 lab1&quot;&gt;&lt;/a&gt;MIT6.824 2021 lab1&lt;/h1&gt;&lt;p&gt;终于在跌跌撞撞中完成了&lt;code&gt;MIT lab1 map-reduce&lt;/code&gt;的&lt;code&gt;lab&lt;/code&gt;，仔细对比了一下，&lt;code&gt;2021&lt;/code&gt;年的&lt;code&gt;lab&lt;/code&gt;要比之前的&lt;code&gt;lab&lt;/code&gt;要复杂一些，以前的&lt;code&gt;map-reduce lab&lt;/code&gt;基本上只是&lt;code&gt;Coordinator&lt;/code&gt;对任务进行主动调度，&lt;code&gt;2021&lt;/code&gt;的&lt;code&gt;lab&lt;/code&gt;会涉及到&lt;code&gt;Coordinator&lt;/code&gt;被动接受&lt;code&gt;worker&lt;/code&gt;的任务请求，然后进行被动的调度，同时加入了防止任务意外中止的校验，使得系统更加完善和健壮。所有的测试结果如下所示：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/03/16/2TsRwIzVidc8apv.png&quot; alt&gt;&lt;br&gt;所有的代码都放在github上.&lt;/p&gt;
    
    </summary>
    
    
      <category term="公开课" scheme="http://yoursite.com/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
      <category term="MIT" scheme="http://yoursite.com/tags/MIT/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 232</title>
    <link href="http://yoursite.com/2021/03/14/261/"/>
    <id>http://yoursite.com/2021/03/14/261/</id>
    <published>2021-03-14T08:17:04.714Z</published>
    <updated>2021-03-14T09:18:34.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-232"><a href="#leetcode-contest-232" class="headerlink" title="leetcode contest 232"></a>leetcode contest 232</h1><p>本周的周赛题目还是质量非常高的，最后两道题目的解法还是非常有意思的题目，虽然解法很简单，但是非常值得深入思考的题目，特别是第三题，给人印象深刻。</p><h2 id="5701-仅执行一次字符串交换能否使两个字符串相等"><a href="#5701-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="5701. 仅执行一次字符串交换能否使两个字符串相等"></a>5701. 仅执行一次字符串交换能否使两个字符串相等</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。</p><a id="more"></a><p>如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"bank"</span>, <span class="built_in">s2</span> = <span class="string">"kanb"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：例如，交换 <span class="built_in">s2</span> 中的第一个和最后一个字符可以得到 <span class="string">"bank"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"attack"</span>, <span class="attr">s2</span> = <span class="string">"defend"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：一次字符串交换无法使两个字符串相等</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"kelb"</span>, <span class="attr">s2</span> = <span class="string">"kelb"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：两个字符串已经相等，所以不需要进行字符串交换</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s1</span> = <span class="string">"abcd"</span>, <span class="attr">s2</span> = <span class="string">"dcba"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= s1.length, s2.length &lt;= 100</li><li>s1.length == s2.length</li><li>s1 和 s2 仅由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-one-string-swap-can-make-strings-equal</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>如果仅要求交换一次就可完成两个字符串的相等排列，我们即判断字符串是否只有两个字符不同，然后判断是否相等。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areAlmostEqual</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[i])&#123;</span><br><span class="line">                diff.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(diff.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(diff.size() != <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1[diff[<span class="number">0</span>]] == s2[diff[<span class="number">1</span>]] &amp;&amp; s1[diff[<span class="number">1</span>]] == s2[diff[<span class="number">0</span>]])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5702-找出星型图的中心节点"><a href="#5702-找出星型图的中心节点" class="headerlink" title="5702. 找出星型图的中心节点"></a>5702. 找出星型图的中心节点</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有一个无向的 星型 图，由 <code>n</code>个编号从 <code>1</code>到 <code>n</code>的节点组成。星型图有一个 中心 节点，并且恰有 <code>n - 1</code>条边将中心节点与其他每个节点连接起来。</p><p>给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示在节点 <code>ui</code> 和 <code>vi</code> 之间存在一条边。请你找出并返回 <code>edges</code> 所表示星型图的中心节点。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如上图所示，节点 <span class="number">2</span> 与其他每个节点都相连，所以节点 <span class="number">2</span> 是中心节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>3 &lt;= n &lt;= 105</li><li>edges.length == n - 1</li><li>edges[i].length == 2</li><li>1 &lt;= ui, vi &lt;= n</li><li>ui != vi</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-center-of-star-graph" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-center-of-star-graph</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 图论</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>此题非常简单，我们只需要判断是否存在度为<code>n-1</code>的顶点即可，非常简单的实现即可，简单的有点离谱。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCenter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            degree[v[<span class="number">0</span>]<span class="number">-1</span>]++;</span><br><span class="line">            degree[v[<span class="number">1</span>]<span class="number">-1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree[i] == n<span class="number">-1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5703-最大平均通过率"><a href="#5703-最大平均通过率" class="headerlink" title="5703. 最大平均通过率"></a>5703. 最大平均通过率</h2><p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 <code>classes</code> ，其中 <code>classes[i] = [passi, totali]</code> ，表示你提前知道了第 <code>i</code> 个班级总共有 <code>totali</code>个学生，其中只有 <code>passi</code>个学生可以通过考试。</p><p>给你一个整数 <code>extraStudents</code> ，表示额外有 <code>extraStudents</code>个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 <code>extraStudents</code>个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。</p><p>一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。</p><p>请你返回在安排这 <code>extraStudents</code>个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 <code>10-5</code>以内的结果都会视为正确结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：classes = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>]], extraStudents = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0.78333</span></span><br><span class="line">解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (<span class="number">3</span>/<span class="number">4</span> + <span class="number">3</span>/<span class="number">5</span> + <span class="number">2</span>/<span class="number">2</span>) / <span class="number">3</span> = <span class="number">0.78333</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：classes = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">9</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">10</span>]], extraStudents = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0.53485</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= classes.length &lt;= 105</code></li><li><code>classes[i].length == 2</code></li><li><code>1 &lt;= passi &lt;= totali &lt;= 105</code></li><li><code>1 &lt;= extraStudents &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-average-pass-ratio</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始这个题目，自己想的太复杂了，后来相明白了，就是非常简单的贪心算法。</li><li>我们设总通过班级通过率之和为$tot$,如果我们想增加最大平均通过率，本质就是如何使得总的班级通过率之和最大。此时我们就需要思考如何分配增加人数，我们根据贪心策略则优先将通过的学生分配给增加的通过率最大的班级即可，这样即保证最终得到的通过率之和最大。</li><li>我们可以通过数学计算得出每增加一个学生，该班级的通过率增加的多少，我们设该班级原有的总人数为$n$,通过考试的人数为$m$,如果增加$1$人后，则增加的通过率为：<script type="math/tex; mode=display">\frac{m+1}{n+1} - \frac{m}{n}</script>我们按照贪心策略，每次为增加的通过率最大的班级分配一个学生即可,我们用优先级队列，每次弹出最优策略的班级，然后给其增加$1$个学生，然后再将其放入队列。时间复杂度为$O(mlgn)$,其中$m$为增加的学生人数，$n$为班级的数目。空间复杂度为$O(n)$.</li><li>我们同时也可以得到策略可以知道，不断给某个班级增加人数，那么它增加的通过率实际上是递减的。<script type="math/tex; mode=display">\frac{m+1}{n+1} - \frac{m}{n} > \frac{m+2}{n+2} - \frac{m+1}{n+1}</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">double</span> p;</span><br><span class="line">    Node(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">double</span> p)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Node &amp; a,Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.p &lt; b.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = classes.size();</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">auto</span> diff = [&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>(x+<span class="number">1</span>)/(y+<span class="number">1</span>) - <span class="keyword">double</span>(x)/y;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : classes)&#123;</span><br><span class="line">            pq.push(Node(v[<span class="number">0</span>],v[<span class="number">1</span>],diff(v[<span class="number">0</span>],v[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; extraStudents; ++i)&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            curr.m++;</span><br><span class="line">            curr.n++;</span><br><span class="line">            curr.p = diff(curr.m,curr.n);</span><br><span class="line">            pq.push(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> tot = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            tot += <span class="keyword">double</span>(curr.m)/curr.n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tot/n;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;tuple&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> diff = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(x + <span class="number">1</span>) / (y + <span class="number">1</span>) - (<span class="keyword">double</span>)x / y;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c: classes) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = c[<span class="number">0</span>], y = c[<span class="number">1</span>];</span><br><span class="line">            ans += (<span class="keyword">double</span>)x / y;</span><br><span class="line">            q.emplace(diff(x, y), x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> _ = <span class="number">0</span>; _ &lt; extraStudents; ++_) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [d, x, y] = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans += d;</span><br><span class="line">            q.emplace(diff(x + <span class="number">1</span>, y + <span class="number">1</span>), x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / classes.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5704-好子数组的最大分数"><a href="#5704-好子数组的最大分数" class="headerlink" title="5704. 好子数组的最大分数"></a>5704. 好子数组的最大分数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> （下标从 0 开始）和一个整数 <code>k</code>。<br>一个子数组 <code>(i, j)</code> 的 分数 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code>。一个 好 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。<br>请你返回 好 子数组的最大可能 分数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：最优子数组的左右端点下标是 (<span class="number">1</span>, <span class="number">5</span>) ，分数为 min(<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>) * (<span class="number">5</span><span class="number">-1</span>+<span class="number">1</span>) = <span class="number">3</span> * <span class="number">5</span> = <span class="number">15</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：最优子数组的左右端点下标是 (<span class="number">0</span>, <span class="number">4</span>) ，分数为 min(<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>) * (<span class="number">4</span><span class="number">-0</span>+<span class="number">1</span>) = <span class="number">4</span> * <span class="number">5</span> = <span class="number">20</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 104</code></li><li><code>0 &lt;= k &lt; nums.length</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>双指针或者二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目还是非常不错的，但是总体来说本题比起之前的题目都偏简单。</li><li>我们可以求出有的以索引$k$为结尾的连续子字符串的最小数的前缀$left$，我们同时也可以求出所有以索引$k$为结尾的连续子字符串的最小数的后缀$right$。我们设$left[i]$表示子数组$[i,k]$的最小值，$right[j]$表示子数组$[k,j]$的最小值,我们可以很明显的看出$left$数组为递减，而$right$数组为递减.</li><li>我们可以固定目标子数组的起始索引为$i$,子数组的结束索引为$k$,满足$0 \le i \le k$，此时很容易求出数组索引$[i,k]$之间的最小元素为$left[i]$,而此时我们则去查找满足以$k$为起始索引的连续子数组，且子数组的最小值大于等于$left[i]$的最大长度,我们依次遍历用双指针所有可能的$i$即可;</li><li>此时我们可以固定目标子数组起始索引为$k$,结束索引为$j$,满足$k \le j \le n-1$，此时很容易求出数组索引$[k,j]$之间的最小元素为$right[j]$,而此时我们则去查找满足以$k$为结尾索引的连续子数组，且子数组的最小值大于等于$right[j]$的最大长度,我们依次遍历用双指针所有可能的$j$即可;</li><li>时间复杂度为$O(n)$,空间复杂度为$O(n)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = nums[k];</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        curr = nums[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            curr = min(curr,nums[i]);</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(arr.begin(),arr.end());</span><br><span class="line">        curr = nums[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k+<span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr = min(curr,nums[i]);</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &gt; arr[r]) r--;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">                ans = max(ans,arr[l]*(r-l+<span class="number">1</span>));</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt; arr[r]) l++;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">                ans = max(ans,arr[r]*(r-l+<span class="number">1</span>));</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-232&quot;&gt;&lt;a href=&quot;#leetcode-contest-232&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 232&quot;&gt;&lt;/a&gt;leetcode contest 232&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，最后两道题目的解法还是非常有意思的题目，虽然解法很简单，但是非常值得深入思考的题目，特别是第三题，给人印象深刻。&lt;/p&gt;&lt;h2 id=&quot;5701-仅执行一次字符串交换能否使两个字符串相等&quot;&gt;&lt;a href=&quot;#5701-仅执行一次字符串交换能否使两个字符串相等&quot; class=&quot;headerlink&quot; title=&quot;5701. 仅执行一次字符串交换能否使两个字符串相等&quot;&gt;&lt;/a&gt;5701. 仅执行一次字符串交换能否使两个字符串相等&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你长度相等的两个字符串 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 231</title>
    <link href="http://yoursite.com/2021/03/07/260/"/>
    <id>http://yoursite.com/2021/03/07/260/</id>
    <published>2021-03-07T13:17:33.864Z</published>
    <updated>2021-03-08T03:19:29.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-231"><a href="#leetcode-contest-231" class="headerlink" title="leetcode contest 231"></a>leetcode contest 231</h1><p>本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。周赛的题目质量就是非常高，非常喜欢这种有思考的题目。</p><h2 id="5697-检查二进制字符串字段"><a href="#5697-检查二进制字符串字段" class="headerlink" title="5697. 检查二进制字符串字段"></a>5697. 检查二进制字符串字段</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 <code>s</code> ，该字符串 不含前导零 。</p><a id="more"></a><p>如果 s 最多包含 一个由连续的 <code>&#39;1&#39;</code> 组成的字段 ，返回 <code>true​​​</code> 。否则，返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1001"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：字符串中的 <span class="number">1</span> 没有形成一个连续字段。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"110"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]​​​​</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li><li><code>s[0]</code> 为 <code>&#39;1&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力搜索即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOnesSegment</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'1'</span>) i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'0'</span>) i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5698-构成特定和需要添加的最少元素"><a href="#5698-构成特定和需要添加的最少元素" class="headerlink" title="5698. 构成特定和需要添加的最少元素"></a>5698. 构成特定和需要添加的最少元素</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，和两个整数 <code>limit</code> 与<code>goal</code>。数组 <code>nums</code> 有一条重要属性：<code>abs(nums[i]) &lt;= limit</code> 。</p><p>返回使数组元素总和等于 <code>goal</code> 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 <code>abs(nums[i]) &lt;= limit</code> 这一属性。</p><p>注意，如果 <code>x &gt;= 0</code> ，那么 <code>abs(x)</code> 等于 <code>x</code> ；否则，等于 <code>-x</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>], limit = <span class="number">3</span>, goal = <span class="number">-4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：可以将 <span class="number">-2</span> 和 <span class="number">-3</span> 添加到数组中，数组的元素总和变为 <span class="number">1</span> - <span class="number">1</span> + <span class="number">1</span> - <span class="number">2</span> - <span class="number">3</span> = <span class="number">-4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-10</span>,<span class="number">9</span>,<span class="number">1</span>], limit = <span class="number">100</span>, goal = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= limit &lt;= 106</code></li><li><code>-limit &lt;= nums[i] &lt;= limit</code></li><li><code>-109 &lt;= goal &lt;= 109</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质为贪心算法，首先我们求出目标数组的和$sum$与$goal$之间的差距，题目中要求增加绝对值不大于等于<code>limit</code>的元素，我们则利用贪心法，每次增加绝对值最大的元素即可，这样即可使得增加的元素最少。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) sum += v;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">abs</span>(goal - sum) + limit - <span class="number">1</span>)/limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5699-从第一个节点出发到最后一个节点的受限路径数"><a href="#5699-从第一个节点出发到最后一个节点的受限路径数" class="headerlink" title="5699. 从第一个节点出发到最后一个节点的受限路径数"></a>5699. 从第一个节点出发到最后一个节点的受限路径数</h2><p>现有一个加权无向连通图。给你一个正整数 <code>n</code>，表示图中有 <code>n</code> 个节点，并按从 <code>1</code> 到 <code>n</code> 给节点编号；另给你一个数组 <code>edges</code> ，其中每个 <code>edges[i] = [ui, vi, weighti]</code> 表示存在一条位于节点 <code>ui</code>和 <code>vi</code> 之间的边，这条边的权重为 <code>weighti</code> 。</p><p>从节点 <code>start</code> 出发到节点 end 的路径是一个形如 <code>[z0, z1, z2, ..., zk]</code> 的节点序列，满足<code>z0 = start 、zk = end</code> 且在所有符合<code>0 &lt;= i &lt;= k-1</code> 的节点 <code>zi</code> 和 <code>zi+1</code>之间存在一条边。</p><p>路径的距离定义为这条路径上所有边的权重总和。用 <code>distanceToLastNode(x)</code>表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 <code>distanceToLastNode(zi) &gt; distanceToLastNode(zi+1)</code> 的一条路径，其中 <code>0 &lt;= i &lt;= k-1</code>。</p><p>返回从节点 1 出发到节点 <code>n</code> 的 受限路径数 。由于数字可能很大，请返回对 <code>109 + 7</code> 取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">5</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">3</span> --&gt; <span class="number">5</span></span><br><span class="line"><span class="number">3</span>) <span class="number">1</span> --&gt; <span class="number">3</span> --&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：<span class="number">1</span> --&gt; <span class="number">3</span> --&gt; <span class="number">7</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>n - 1 &lt;= edges.length &lt;= 4 * 104</code></li><li><code>edges[i].length == 3</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li><code>1 &lt;= weighti &lt;= 105</code></li><li>任意两个节点之间至多存在一条边</li><li>任意两个节点之间至少存在一条路径</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 迪杰斯特拉算法 + dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们需要求出所有点到节点<code>end</code>的最小距离，这个解法很多，经典的<code>dijistra</code>算法即可解决。</li><li>我们则需要求出所有的受限路径，按照题目的要求，首先路径中满足<code>distanceToLastNode(zi) &gt; distanceToLastNode(zi+1)</code>，则此时我们很容易联想到将所有的路径按照<code>distanceToLastNode</code>的大小进行排序，此时我们即可利用<code>dp</code>的特性，因为前面的数一定比后面的数小。此时我们可以设$dp[n] = 1$,按照所有排序的顺序依次对该顶点的邻接节点进行依次遍历。</li><li>时间复杂度为$O(nlgn + n + 2n)$，空间复杂度为$O(n)$.</li><li>另一种解法则为<code>dfs</code>我们也可以很快求出，但是还是感觉太复杂，只贴代码不讲原理了。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>dp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRestrictedPaths</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,INT_MAX);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">1</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">0</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        qu.push(make_pair(n<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">        dist[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.first])&#123;</span><br><span class="line">                <span class="keyword">int</span> x = v.first;</span><br><span class="line">                <span class="keyword">int</span> d = v.second;</span><br><span class="line">                <span class="keyword">if</span>(curr.second + d &lt; dist[x])&#123;</span><br><span class="line">                    dist[x] = curr.second + d;</span><br><span class="line">                    qu.push(make_pair(x,dist[x]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) arr[i] = i;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> dist[a] &lt; dist[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        dp[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[arr[i]])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[v.first] &gt; <span class="number">0</span> &amp;&amp; dist[arr[i]] &gt; dist[v.first])&#123;</span><br><span class="line">                    dp[arr[i]] = (dp[arr[i]] + dp[v.first])%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>dfs<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; dist,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; graph,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp; count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == dist.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count[curr] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v.first;</span><br><span class="line">            <span class="keyword">if</span>(dist[curr] &lt;= dist[x] || count[x] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(count[x] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                count[curr] = (count[x] + count[curr])%MOD;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count[x] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(x,dist,graph,count);</span><br><span class="line">                <span class="keyword">if</span>(count[x] &gt; <span class="number">0</span>) count[curr] = (count[curr] + count[x])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRestrictedPaths</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,INT_MAX);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">1</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]<span class="number">-1</span>].push_back(make_pair(v[<span class="number">0</span>]<span class="number">-1</span>,v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        qu.push(make_pair(n<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">        dist[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.first])&#123;</span><br><span class="line">                <span class="keyword">int</span> x = v.first;</span><br><span class="line">                <span class="keyword">int</span> d = v.second;</span><br><span class="line">                <span class="keyword">if</span>(curr.second + d &lt; dist[x])&#123;</span><br><span class="line">                    dist[x] = curr.second + d;</span><br><span class="line">                    qu.push(make_pair(x,dist[x]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; count(n,<span class="number">0</span>);</span><br><span class="line">        count[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">0</span>,dist,graph,count);</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>]%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5700-使所有区间的异或结果为零"><a href="#5700-使所有区间的异或结果为零" class="headerlink" title="5700. 使所有区间的异或结果为零"></a>5700. 使所有区间的异或结果为零</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k​​​​​</code> 。区间 <code>[left, right]（left &lt;= right）</code>的 异或结果 是对下标位于 <code>left</code>和 <code>right</code>（包括 <code>left</code> 和 <code>right</code> ）之间所有元素进行 <code>XOR</code> 运算的结果：<br><code>nums[left] XOR nums[left+1] XOR ... XOR nums[right]</code>。</p><p>返回数组中 要更改的最小元素数 ，以使所有长度为 <code>k</code> 的区间异或结果等于零。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将数组 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>] 修改为 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将数组 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>] 修改为 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将数组[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>] 修改为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 2000</code><br>​+ ​​​​​<code>0 &lt;= nums[i] &lt; 210</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学 + dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们我们可以得出以下推论<script type="math/tex; mode=display">nums[i] \bigoplus nums[i+1] \bigoplus ... \bigoplus nums[i+k-1] = 0 \\nums[i+1] \bigoplus nums[i+1] \bigoplus ... \bigoplus nums[i+k] = 0</script>通过上述我们可以发现$nums[i]  = nums[i+k]$.因此我们可以优先筛选$nums[i],nums[i+k],nums[i+2k]…$中频次最高的数。</li><li>仔细思考以下，我们如何让前$k$个元素异或的结果为<code>0</code>,我们可以设<code>dp</code>递推公式，例如<code>dp[i][val]</code>,表示前前<code>i</code>个元素异或的结果为$val$的最小替换数次数。则我们遇到第<code>i+1</code>个元素时，如果要使的前<code>i+1</code>个元素为<code>x</code>时，此时第<code>i+1</code>个元素有两种选择：</li></ol><ul><li>从选择一个全新的并且未在当前待选元素中出现过的，我们设前<code>i</code>个元素变为某个特定的值的最小替换次数为<code>dp[y]</code>, 此时我们需要将前<code>i+1</code>个元素的最小变化次数则为$dp[i+1][x] = sz[i+1] + dp[i][y]$,而此时需满足第<code>i+1</code>个元素的选择为$nums[i+1] = x\bigoplus y$.</li><li>从待选元素中选择一个值为$s$,则此时需要增加的替换最小次数为$dp[i][x\bigoplus s] + sz[i+1] - freq[i+1][s]$，此时我们将计算待选元素第<code>i+1</code>个分组中的$s$的统计统计次数，并计算第<code>i+1</code>个不等于$s$的次数。</li></ul><ol><li>总的来说感觉还是非常需要想像的一个<code>dp</code>，题目还是非常难的。自己都想了一个小时，才想明白这个题目。非常难思考的动态规划题目。题目太难了，确实不太会。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minChanges</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; cnt(k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sz[i%k]++;</span><br><span class="line">            cnt[i%k][nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1025</span>,<span class="number">-2000</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = *max_element(dp.begin(),dp.end());</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextdp(<span class="number">1025</span>,hi);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;<span class="number">10</span>); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y] : cnt[i])&#123;</span><br><span class="line">                    nextdp[j^x] = max(nextdp[j^x],dp[j] + y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = nextdp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n - dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-231&quot;&gt;&lt;a href=&quot;#leetcode-contest-231&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 231&quot;&gt;&lt;/a&gt;leetcode contest 231&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。周赛的题目质量就是非常高，非常喜欢这种有思考的题目。&lt;/p&gt;&lt;h2 id=&quot;5697-检查二进制字符串字段&quot;&gt;&lt;a href=&quot;#5697-检查二进制字符串字段&quot; class=&quot;headerlink&quot; title=&quot;5697. 检查二进制字符串字段&quot;&gt;&lt;/a&gt;5697. 检查二进制字符串字段&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个二进制字符串 &lt;code&gt;s&lt;/code&gt; ，该字符串 不含前导零 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 47</title>
    <link href="http://yoursite.com/2021/03/07/259/"/>
    <id>http://yoursite.com/2021/03/07/259/</id>
    <published>2021-03-07T13:17:21.442Z</published>
    <updated>2021-03-07T14:25:25.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-47"><a href="#leetcode-biweekly-contest-47" class="headerlink" title="leetcode biweekly contest 47"></a>leetcode biweekly contest 47</h1><p>本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。本周的状态真差，每次都是3题，<code>hard</code>难度没能做出来。</p><h2 id="5680-找到最近的有相同-X-或-Y-坐标的点"><a href="#5680-找到最近的有相同-X-或-Y-坐标的点" class="headerlink" title="5680. 找到最近的有相同 X 或 Y 坐标的点"></a>5680. 找到最近的有相同 X 或 Y 坐标的点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数 <code>x</code> 和 <code>y</code> ，表示你在一个笛卡尔坐标系下的 <code>(x, y)</code>处。同时，在同一个坐标系下给你一个数组 <code>points</code> ，其中 <code>points[i] = [ai, bi]</code>表示在 <code>(ai, bi)</code> 处有一个点。当一个点与你所在的位置有相同的 <code>x</code> 坐标或者相同的 <code>y</code> 坐标时，我们称这个点是 有效的 。</p><a id="more"></a><p>请返回距离你当前位置 曼哈顿距离 最近的 有效 点的下标（下标从 0 开始）。如果有多个最近的有效点，请返回下标 最小 的一个。如果没有有效点，请返回 -1 。</p><p>两个点 <code>(x1, y1)</code> 和<code>(x2, y2)</code> 之间的 曼哈顿距离 为 <code>abs(x1 - x2) + abs(y1 - y2)</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">3</span>, y = <span class="number">4</span>, points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：所有点中，[<span class="number">3</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">4</span>] 是有效点。有效点中，[<span class="number">2</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">4</span>] 距离你当前位置的曼哈顿距离最小，都为 <span class="number">1</span> 。[<span class="number">2</span>,<span class="number">4</span>] 的下标最小，所以返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">3</span>, y = <span class="number">4</span>, points = [[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">提示：答案可以与你当前所在位置坐标相同。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = <span class="number">3</span>, y = <span class="number">4</span>, points = [[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：没有有效点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= points.length &lt;= 104</code></li><li><code>points[i].length == 2</code></li><li><code>1 &lt;= x, y, ai, bi &lt;= 104</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力搜索即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nearestValidPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> dist = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] == x || points[i][<span class="number">1</span>] == y)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-x) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-y) &lt; dist)&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    dist = <span class="built_in">abs</span>(points[i][<span class="number">0</span>]-x) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5681-判断一个数字是否可以表示成三的幂的和"><a href="#5681-判断一个数字是否可以表示成三的幂的和" class="headerlink" title="5681. 判断一个数字是否可以表示成三的幂的和"></a>5681. 判断一个数字是否可以表示成三的幂的和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> ，如果你可以将 <code>n</code>表示成若干个不同的三的幂之和，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p><p>对于一个整数 <code>y</code> ，如果存在整数 <code>x</code> 满足 <code>y == 3x</code> ，我们称这个整数 <code>y</code> 是三的幂。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">12</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">12</span> = <span class="number">31</span> + <span class="number">32</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">91</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">91</span> = <span class="number">30</span> + <span class="number">32</span> + <span class="number">34</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">21</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>`1 &lt;= n &lt;= 107<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/check-if-number-is-a-sum-of-powers-of-three" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-number-is-a-sum-of-powers-of-three</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 位图暴力搜索或者<code>dfs</code></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>由于题目中给定的目标<code>n</code>的最大值为$10^{7}$,我们可以通过计算得知，最大的数可能为$3^{16} = 43,046,721$，因次我们很容易计算出所有的$3$的幂，通过暴力穷举所有的组合数即可。</li><li>我们用$32$位整数的图表示即可，通过暴力遍历出所有的组合数，整体的时间复杂度为$O(17*3^{16})$,可以计算出在允许的时间复杂度范围内。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>暴力<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPowersOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)&#123;</span><br><span class="line">            arr[i] = <span class="built_in">pow</span>(<span class="number">3</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>&lt;&lt;<span class="number">17</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">17</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr += arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>找规律<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPowersOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">3</span> == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5682-所有子字符串美丽值之和"><a href="#5682-所有子字符串美丽值之和" class="headerlink" title="5682. 所有子字符串美丽值之和"></a>5682. 所有子字符串美丽值之和</h2><p>一个字符串的 美丽值 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。</p><p>比方说，<code>&quot;abaacc&quot;</code>的美丽值为 <code>3 - 1 = 2</code>。<br>给你一个字符串 <code>s</code> ，请你返回它所有子字符串的 美丽值 之和。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabcb"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：美丽值不为零的字符串包括 [<span class="string">"aab"</span>,<span class="string">"aabc"</span>,<span class="string">"aabcb"</span>,<span class="string">"abcb"</span>,<span class="string">"bcb"</span>] ，每一个字符串的美丽值都为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabcbaa"</span></span><br><span class="line">输出：<span class="number">17</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-beauty-of-all-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-beauty-of-all-substrings</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash统计或者暴力统计</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>枚举所有的子串，然后统计所有子串的字符的频数，然后计算出最多的和最少的字符的个数，即求出美丽值，感觉不需要什么技巧。时间复杂度为$O(26*n^{2})$,空间复杂度为$O(26)$.</li><li>另一种方法是只快速统计频次，可以用有序<code>hash</code>保存当前所有字符的频次，每次取出最大的频次和最小的频次即可。时间复杂度为$O(lg26 * n^{2})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beautySum</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; freq;</span><br><span class="line">            cnt[s[i]-<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">            freq[cnt[s[i]-<span class="string">'a'</span>]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[s[j]-<span class="string">'a'</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> prev = cnt[s[j]-<span class="string">'a'</span>];</span><br><span class="line">                    freq[prev]--;</span><br><span class="line">                    <span class="keyword">if</span>(freq[prev] == <span class="number">0</span>) freq.erase(prev);</span><br><span class="line">                    cnt[s[j]-<span class="string">'a'</span>]++;</span><br><span class="line">                    freq[cnt[s[j]-<span class="string">'a'</span>]]++;</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt[s[j]-<span class="string">'a'</span>]++;</span><br><span class="line">                    freq[cnt[s[j]-<span class="string">'a'</span>]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += (freq.rbegin()-&gt;first - freq.begin()-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>暴力统统计<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 出现最大次数 - 最小最小次数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calcDiff</span><span class="params">(<span class="keyword">int</span> *cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = fmax(max, cnt[i]);</span><br><span class="line">            min = fmin(min, cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beautySum</span><span class="params">(<span class="keyword">char</span> * s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 枚举所有子串, 计算其字母出现次数, 计算美丽值 */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; len; j++) &#123;</span><br><span class="line">                cnt[s[j] - <span class="string">'a'</span>]++;</span><br><span class="line">                res += calcDiff(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5683-统计点对的数目"><a href="#5683-统计点对的数目" class="headerlink" title="5683. 统计点对的数目"></a>5683. 统计点对的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个无向图，无向图由整数 n  ，表示图中节点的数目，和 edges 组成，其中 edges[i] = [ui, vi] 表示 ui 和 vi 之间有一条无向边。同时给你一个代表查询的整数数组 queries 。</p><p>第 j 个查询的答案是满足如下条件的点对 (a, b) 的数目：</p><p>a &lt; b<br>cnt 是与 a 或者 b 相连的边的数目，且 cnt 严格大于 queries[j] 。<br>请你返回一个数组 answers ，其中 answers.length == queries.length 且 answers[j] 是第 j 个查询的答案。</p><p>请注意，图中可能会有 重复边 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">1</span>]], queries = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">解释：每个点对中，与至少一个点相连的边的数目如上图所示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>]], queries = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">10</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 2 * 104</code></li><li><code>1 &lt;= edges.length &lt;= 105</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li><code>1 &lt;= queries.length &lt;= 20</code></li><li><code>0 &lt;= queries[j] &lt; edges.length</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-pairs-of-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-pairs-of-nodes</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 容斥问题，经典的双指针</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目拿到以后我们首先看到不太好做，既然题目要求求出所有符合要求的点对的组合数目，很明显的我们首先需要求出所有顶点的度数，后面我们再分情况讨论。</li><li>我们可以知道如果有一个$query = x$,此时要求我们求出组合点的非重合的度数大于$x$的组合数目，这里就对组合$(ea,eb)$需要分为两种情况来讨论。</li></ol><ul><li>$(ea,eb)$不相邻，则此时我们很容易求出与点对$(ea,eb)$相邻的边数为$degree[a] + degree[b]$, 则此时我们已经知道所有顶点的度数，如何求出数组中其两个元素的值大于等于$x$的组合数目有多少，这是个经典的双指针问题，或者我们也可以用二分查找的方法解决。<script type="math/tex; mode=display">f(ea,eb) = degree[a] + degree[b]</script></li><li>$(ea,eb)$相邻，则此时我们就需要把相邻的边重复计算的次数减掉。此时的判断条件则为<script type="math/tex; mode=display">degree[a] + degree[b] > x \\f(ea,eb) = degree[a] + degree[b] - edges[a][b] > x</script></li></ul><ol><li>根据容斥原理，则首先我们找到所有可能的组合，然后我们再减去可能重复计算的组合数，即可得到最终的结果。题目整体还是非常好的题目，非常值得思考。双指针的时间复杂度为$O(n<em>m)$,二分查找的时间复杂度为$O(m</em>n*lgn)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countPairs(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(n,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;pii,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            v[<span class="number">0</span>]--;</span><br><span class="line">            v[<span class="number">1</span>]--;</span><br><span class="line">            degree[v[<span class="number">0</span>]]++;</span><br><span class="line">            degree[v[<span class="number">1</span>]]++;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] &gt; v[<span class="number">1</span>]) swap(v[<span class="number">0</span>],v[<span class="number">1</span>]);</span><br><span class="line">            cnt[make_pair(v[<span class="number">0</span>],v[<span class="number">1</span>])]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = degree;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : queries)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = n<span class="number">-1</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; i &amp;&amp; arr[i] + arr[j] &gt; x) j--;</span><br><span class="line">                curr += n - <span class="number">1</span> - max(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*remove the repeat edges*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = v.first.first;</span><br><span class="line">                <span class="keyword">int</span> b = v.first.second;</span><br><span class="line">                <span class="keyword">if</span>(degree[a] + degree[b] &gt; x &amp;&amp; (degree[a] + degree[b] - v.second) &lt;= x) curr--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.emplace_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>二分查找</li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-47&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-47&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 47&quot;&gt;&lt;/a&gt;leetcode biweekly contest 47&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。本周的状态真差，每次都是3题，&lt;code&gt;hard&lt;/code&gt;难度没能做出来。&lt;/p&gt;&lt;h2 id=&quot;5680-找到最近的有相同-X-或-Y-坐标的点&quot;&gt;&lt;a href=&quot;#5680-找到最近的有相同-X-或-Y-坐标的点&quot; class=&quot;headerlink&quot; title=&quot;5680. 找到最近的有相同 X 或 Y 坐标的点&quot;&gt;&lt;/a&gt;5680. 找到最近的有相同 X 或 Y 坐标的点&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个整数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ，表示你在一个笛卡尔坐标系下的 &lt;code&gt;(x, y)&lt;/code&gt;处。同时，在同一个坐标系下给你一个数组 &lt;code&gt;points&lt;/code&gt; ，其中 &lt;code&gt;points[i] = [ai, bi]&lt;/code&gt;表示在 &lt;code&gt;(ai, bi)&lt;/code&gt; 处有一个点。当一个点与你所在的位置有相同的 &lt;code&gt;x&lt;/code&gt; 坐标或者相同的 &lt;code&gt;y&lt;/code&gt; 坐标时，我们称这个点是 有效的 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 230</title>
    <link href="http://yoursite.com/2021/03/01/257/"/>
    <id>http://yoursite.com/2021/03/01/257/</id>
    <published>2021-03-01T04:28:34.667Z</published>
    <updated>2021-03-02T02:19:54.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-230"><a href="#leetcode-contest-230" class="headerlink" title="leetcode contest 230"></a>leetcode contest 230</h1><p>本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。</p><h2 id="1773-统计匹配检索规则的物品数量"><a href="#1773-统计匹配检索规则的物品数量" class="headerlink" title="1773. 统计匹配检索规则的物品数量"></a>1773. 统计匹配检索规则的物品数量</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>items</code> ，其中<code>items[i] = [typei, colori, namei]</code>，描述第 i 件物品的类型、颜色以及名称。</p><a id="more"></a><p>另给你一条由两个字符串 <code>ruleKey</code> 和 <code>ruleValue</code> 表示的检索规则。</p><p>如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：</p><ul><li><code>ruleKey == &quot;type&quot;</code> 且 <code>ruleValue == typei</code> 。</li><li><code>ruleKey == &quot;color&quot;</code> 且 <code>ruleValue == colori</code>。</li><li><code>ruleKey == &quot;name&quot;</code> 且 <code>ruleValue == namei</code> 。<br>统计并返回 匹配检索规则的物品数量 。</li></ul><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="string">"phone"</span>,<span class="string">"blue"</span>,<span class="string">"pixel"</span>],[<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"lenovo"</span>],[<span class="string">"phone"</span>,<span class="string">"gold"</span>,<span class="string">"iphone"</span>]], ruleKey = <span class="string">"color"</span>, ruleValue = <span class="string">"silver"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只有一件物品匹配检索规则，这件物品是 [<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"lenovo"</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="string">"phone"</span>,<span class="string">"blue"</span>,<span class="string">"pixel"</span>],[<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"phone"</span>],[<span class="string">"phone"</span>,<span class="string">"gold"</span>,<span class="string">"iphone"</span>]], ruleKey = <span class="string">"type"</span>, ruleValue = <span class="string">"phone"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：只有两件物品匹配检索规则，这两件物品分别是 [<span class="string">"phone"</span>,<span class="string">"blue"</span>,<span class="string">"pixel"</span>] 和 [<span class="string">"phone"</span>,<span class="string">"gold"</span>,<span class="string">"iphone"</span>] 。注意，[<span class="string">"computer"</span>,<span class="string">"silver"</span>,<span class="string">"phone"</span>] 未匹配检索规则。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= items.length &lt;= 104</code></li><li><code>1 &lt;= typei.length, colori.length, namei.length, ruleValue.length &lt;= 10</code></li><li><code>ruleKey 等于 &quot;type&quot;、&quot;color&quot; 或 &quot;name&quot;</code></li><li>所有字符串仅由小写字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-items-matching-a-rule/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-items-matching-a-rule/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题，直接暴力即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力搜索即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; items, <span class="built_in">string</span> ruleKey, <span class="built_in">string</span> ruleValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : items)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ruleKey == <span class="string">"type"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[<span class="number">0</span>] == ruleValue) ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ruleKey == <span class="string">"color"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[<span class="number">1</span>] == ruleValue) ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ruleKey == <span class="string">"name"</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[<span class="number">2</span>] == ruleValue) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1774-最接近目标价格的甜点成本"><a href="#1774-最接近目标价格的甜点成本" class="headerlink" title="1774. 最接近目标价格的甜点成本"></a>1774. 最接近目标价格的甜点成本</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你打算做甜点，现在需要购买配料。目前共有 <code>n</code>种冰激凌基料和 <code>m</code> 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><ul><li>必须选择 一种 冰激凌基料。</li><li>可以添加 一种或多种 配料，也可以不添加任何配料。</li><li>每种类型的配料 最多两份 。<br>给你以下三个输入：<br><code>baseCosts</code> ，一个长度为 <code>n</code> 的整数数组，其中每个 <code>baseCosts[i]</code>表示第 <code>i</code> 种冰激凌基料的价格。<br><code>toppingCosts</code>，一个长度为 <code>m</code>的整数数组，其中每个 <code>toppingCosts[i]</code> 表示 一份 第 <code>i</code> 种冰激凌配料的价格。<br><code>target</code> ，一个整数，表示你制作甜点的目标价格。<br>你希望自己做的甜点总成本尽可能接近目标价格 <code>target</code>。</li></ul><p>返回最接近 <code>target</code> 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">1</span>,<span class="number">7</span>], toppingCosts = [<span class="number">3</span>,<span class="number">4</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：考虑下面的方案组合（所有下标均从 <span class="number">0</span> 开始）：</span><br><span class="line">- 选择 <span class="number">1</span> 号基料：成本 <span class="number">7</span></span><br><span class="line">- 选择 <span class="number">1</span> 份 <span class="number">0</span> 号配料：成本 <span class="number">1</span> x <span class="number">3</span> = <span class="number">3</span></span><br><span class="line">- 选择 <span class="number">0</span> 份 <span class="number">1</span> 号配料：成本 <span class="number">0</span> x <span class="number">4</span> = <span class="number">0</span></span><br><span class="line">总成本：<span class="number">7</span> + <span class="number">3</span> + <span class="number">0</span> = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">2</span>,<span class="number">3</span>], toppingCosts = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">100</span>], target = <span class="number">18</span></span><br><span class="line">输出：<span class="number">17</span></span><br><span class="line">解释：考虑下面的方案组合（所有下标均从 <span class="number">0</span> 开始）：</span><br><span class="line">- 选择 <span class="number">1</span> 号基料：成本 <span class="number">3</span></span><br><span class="line">- 选择 <span class="number">1</span> 份 <span class="number">0</span> 号配料：成本 <span class="number">1</span> x <span class="number">4</span> = <span class="number">4</span></span><br><span class="line">- 选择 <span class="number">2</span> 份 <span class="number">1</span> 号配料：成本 <span class="number">2</span> x <span class="number">5</span> = <span class="number">10</span></span><br><span class="line">- 选择 <span class="number">0</span> 份 <span class="number">2</span> 号配料：成本 <span class="number">0</span> x <span class="number">100</span> = <span class="number">0</span></span><br><span class="line">总成本：<span class="number">3</span> + <span class="number">4</span> + <span class="number">10</span> + <span class="number">0</span> = <span class="number">17</span> 。不存在总成本为 <span class="number">18</span> 的甜点制作方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">3</span>,<span class="number">10</span>], toppingCosts = [<span class="number">2</span>,<span class="number">5</span>], target = <span class="number">9</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：可以制作总成本为 <span class="number">8</span> 和 <span class="number">10</span> 的甜点。返回 <span class="number">8</span> ，因为这是成本更低的方案。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：baseCosts = [<span class="number">10</span>], toppingCosts = [<span class="number">1</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == baseCosts.length</code></li><li><code>m == toppingCosts.length</code></li><li><code>1 &lt;= n, m &lt;= 10</code></li><li><code>1 &lt;= baseCosts[i], toppingCosts[i] &lt;= 104</code></li><li><code>1 &lt;= target &lt;= 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/closest-dessert-cost" target="_blank" rel="noopener">https://leetcode-cn.com/problems/closest-dessert-cost</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力搜索</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>由于题目中给定的数据量很小，我们则可以用3进制的状态掩码来表示配料的组合，因为每种配料只有三种状态，分别为<code>0,1,2</code>.</li><li>然后分别遍历每种基料和配料的所有组合即可求出接近的值。时间复杂度为$O(n*3^{n})$,空间复杂度为$O(3^{n})$.</li><li>另一种解法，将其转化为背包问题，限定每种配料的数量为<code>2</code>,也可以转化为<code>0,1</code>背包问题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; baseCosts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; toppingCosts, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = baseCosts.size();</span><br><span class="line">        <span class="keyword">int</span> m = toppingCosts.size();</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(mask,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = i/<span class="built_in">pow</span>(<span class="number">3</span>,j);</span><br><span class="line">                cost += (x%<span class="number">3</span>)*toppingCosts[j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(baseCosts[j] + dp[i] - target) &lt; <span class="built_in">abs</span>(ans-target))&#123;</span><br><span class="line">                    ans = baseCosts[j] + dp[i];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(baseCosts[j] + dp[i] - target) == <span class="built_in">abs</span>(ans-target) &amp;&amp; (baseCosts[j] + dp[i]) &lt; ans)&#123;</span><br><span class="line">                    ans = baseCosts[j] + dp[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1775-通过最少操作次数使数组的和相等"><a href="#1775-通过最少操作次数使数组的和相等" class="headerlink" title="1775. 通过最少操作次数使数组的和相等"></a>1775. 通过最少操作次数使数组的和相等</h2><p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 1 和 6）。</p><p>每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。</p><p>请你返回使 <code>nums1</code>中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], nums2 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以通过 <span class="number">3</span> 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 <span class="number">0</span> 开始。</span><br><span class="line">- 将 nums2[<span class="number">0</span>] 变为 <span class="number">6</span> 。 nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], nums2 = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将 nums1[<span class="number">5</span>] 变为 <span class="number">1</span> 。 nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>], nums2 = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将 nums1[<span class="number">2</span>] 变为 <span class="number">2</span> 。 nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>], nums2 = [<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], nums2 = [<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">6</span>,<span class="number">6</span>], nums2 = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以通过 <span class="number">3</span> 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 <span class="number">0</span> 开始。</span><br><span class="line">- 将 nums1[<span class="number">0</span>] 变为 <span class="number">2</span> 。 nums1 = [<span class="number">2</span>,<span class="number">6</span>], nums2 = [<span class="number">1</span>] 。</span><br><span class="line">- 将 nums1[<span class="number">1</span>] 变为 <span class="number">2</span> 。 nums1 = [<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">1</span>] 。</span><br><span class="line">- 将 nums2[<span class="number">0</span>] 变为 <span class="number">4</span> 。 nums1 = [<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">4</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们设数组<code>nums1</code>的和为$s_{1}$,数组<code>nums2</code>的和为$s_{2}$,假设有$s_{1} &lt; s_{2}$,则此时我们如果想要使得变换步数最小，则此时我们需要尽可能的将$num1$中的元素变大，将数组$nums2$中的元素变小。可以实际参考<a href="https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations/solution/tong-guo-zui-shao-cao-zuo-ci-shu-shi-shu-o8no/" target="_blank" rel="noopener">zerotrac</a>的解法，写的非常详细。我们知道：</li></ol><ul><li>可以将数组$nums1$中的每个元素变大，每个元素$x$变大的变化量为$6-x$,$x\in[1,6]$;</li><li>可以将数组$nums2$中的每个元素变小，每个元素$x$变小的变化量为$x-1$,$x\in[1,6]$;</li></ul><ol><li>我们设$diff = abs(s_{1} -s_{2})$,则此时我们可以应当尽可能的使得元素变大或者变小的变化量之和大于等于$diff$,且尽可能的使用最少的元素的变化量，此时我们可以利用贪心法，每次从最大的变化量中选择，直到选择的变化量之和满足$sum_{c} \ge diff$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1) s1 += v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2) s2 += v;</span><br><span class="line">        <span class="keyword">if</span>(s1 &gt; s2) <span class="keyword">return</span> minOperations(nums2,nums1);</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="built_in">abs</span>(s1 - s2);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1) cnt[<span class="number">6</span>-v]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2) cnt[v<span class="number">-1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(diff &gt; <span class="number">0</span> &amp;&amp; cnt[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                diff -= i;</span><br><span class="line">                cnt[i]--;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(diff &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5692-车队-II"><a href="#5692-车队-II" class="headerlink" title="5692. 车队 II"></a>5692. 车队 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在一条单车道上有 <code>n</code>辆车，它们朝着同样的方向行驶。给你一个长度为 <code>n</code> 的数组 <code>cars</code> ，其中 <code>cars[i] = [positioni, speedi]</code> ，它表示：</p><p><code>positioni</code> 是第 <code>i</code>辆车和道路起点之间的距离（单位：米）。题目保证 <code>positioni &lt; positioni+1</code> 。<br><code>speedi</code> 是第 <code>i</code> 辆车的初始速度（单位：米/秒）。<br>简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 最慢 一辆车的速度。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 i 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 <code>answer[i]</code> 为 -1 。答案精度误差需在 <code>10-5</code>以内。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cars = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">7</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">1.00000</span>,<span class="number">-1.00000</span>,<span class="number">3.00000</span>,<span class="number">-1.00000</span>]</span><br><span class="line">解释：经过恰好 <span class="number">1</span> 秒以后，第一辆车会与第二辆车相遇，并形成一个 <span class="number">1</span> m/s 的车队。经过恰好 <span class="number">3</span> 秒以后，第三辆车会与第四辆车相遇，并形成一个 <span class="number">2</span> m/s 的车队。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cars = [[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">3</span>],[<span class="number">9</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="number">2.00000</span>,<span class="number">1.00000</span>,<span class="number">1.50000</span>,<span class="number">-1.00000</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= cars.length &lt;= 105</code></li><li><code>1 &lt;= positioni, speedi &lt;= 106</code></li><li><code>positioni &lt; positioni+1</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/car-fleet-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/car-fleet-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>优先级队列或者栈</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目的思路还是非常好的，对于算法的思考方面来说还算是一个非常好的题目，对于具体的解法有两种解法，首先需要我们重点思考以下几个重要的结论，对于第<code>i</code>辆车来说，它左边的$i-1$辆车的最终合并后的最大时速肯定不会超过第<code>i</code>辆车，所以我们可以看到最终的车辆的运行速度肯定有以下结论:<script type="math/tex; mode=display">speed[j] \le speed[i] \qquad if (j  < i)</script>我们依次排列车辆的$a,b,c$,假设$b$车与$c$车相遇的时间比$a$车与$c$车相遇的时间要早，则我们可以知道$a$车与$b$车相遇的时候，这是与$a$相遇的车应该是$b,c$合并的车队，此时$a$车与$b$车相遇的时间即等于$a$车与$c$车相遇的时间。我们计算第<code>i</code>辆车与第<code>j</code>辆车的相遇时间一般为:<script type="math/tex; mode=display">\frac{p_{j}-p_{i}}{speed_{i}-speed_{j}}</script></li><li>单调栈的解法：因为我们知道$1$的结论，对于第<code>i</code>辆车来说，它左边的$i-1$辆车的最终合并后的最大时速肯定不会超过第<code>i</code>辆车，所以无论前<code>i-1</code>辆车的如何合并与否并不影响第<code>i</code>辆车与第<code>i+1</code>辆车相遇的时间。因此我们知道第<code>i</code>辆车的与合并的时间只与其后$[i+1,n]$的车辆相关，则我们可以利用栈的特性，每次第<code>i</code>车时，它会查看后面$[i+1,n]$车的状态，因此我们利用栈的功能。</li><li>优先级队列模拟：</li></ol><ul><li>我们将所有的车辆全部编为车队，$left[i]$表示以第<code>i</code>辆车为结尾的车队的最左侧的车辆的编号，因此$(left[i],i)$代表从$left[i]$到$i$的车队。</li><li>我们设$x &lt; y$,以我们每次将可能会相遇的车队$(left[x],x),(x+1,y)$，计算前后车队相遇的时间并进入优先级队列，每次从队列中取出最早相遇的车队，并将两个车队合并，则我们可以知道车队$(left[x],x),(x+1,y)$合并后的车队则为$(left[x],y)$,并同时将$(left[x],x)$从所有的车队中移除，因为我们知道以$y$为结尾的车队与后车相遇的时间不会受到前$y$辆车的合并的影响。</li><li>同时我们需要计算车队$(left[left[x]-1],left[x]-1)$与后车$left[x]$相遇的时间，并更新队列。如此就可以不断模拟，想法还是非常有意思的。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>优先级队列模拟<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> t;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    Node(<span class="keyword">double</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a, Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.t &gt; b.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; getCollisionTimes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cars) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = cars.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans(n,<span class="number">-1.0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; remove(n,<span class="literal">false</span>);</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[i] = i;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; cars[i][<span class="number">1</span>] &lt; cars[i<span class="number">-1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                pq.push(Node(<span class="number">1.0</span>*(cars[i][<span class="number">0</span>] - cars[i<span class="number">-1</span>][<span class="number">0</span>])/(cars[i<span class="number">-1</span>][<span class="number">1</span>]-cars[i][<span class="number">1</span>]),i<span class="number">-1</span>,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(remove[curr.x] || remove[curr.y]) <span class="keyword">continue</span>;</span><br><span class="line">            left[curr.y] = left[curr.x];</span><br><span class="line">            remove[curr.x] = <span class="literal">true</span>;</span><br><span class="line">            ans[curr.x] = curr.t;</span><br><span class="line">            <span class="keyword">if</span>(left[curr.x] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> prev = left[curr.x] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cars[prev][<span class="number">1</span>] &gt; cars[curr.y][<span class="number">1</span>])&#123;</span><br><span class="line">                    pq.push(Node(<span class="number">1.0</span>*(cars[curr.y][<span class="number">0</span>]-cars[prev][<span class="number">0</span>])/(cars[prev][<span class="number">1</span>]-cars[curr.y][<span class="number">1</span>]),prev,curr.y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>栈<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; getCollisionTimes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cars) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = cars.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans(n,<span class="number">-1.0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = cars[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> s = cars[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = cars[st.top()][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> s1 = cars[st.top()][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> j = st.top();</span><br><span class="line">                <span class="keyword">if</span>(s &lt;= s1 || (ans[j] &gt; <span class="number">0</span> &amp;&amp; <span class="number">1.0</span>*(p1-p)/(s-s1) &gt; ans[j]))&#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">                ans[i] = <span class="number">1.0</span>*(cars[st.top()][<span class="number">0</span>]-p)/(s-cars[st.top()][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-230&quot;&gt;&lt;a href=&quot;#leetcode-contest-230&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 230&quot;&gt;&lt;/a&gt;leetcode contest 230&lt;/h1&gt;&lt;p&gt;本周的周赛题目还是质量非常高的，解法非常有特点和思考余地，非常喜欢这类带有思考性质的题目，可以仔细的品味这种深入思考的过程。&lt;/p&gt;&lt;h2 id=&quot;1773-统计匹配检索规则的物品数量&quot;&gt;&lt;a href=&quot;#1773-统计匹配检索规则的物品数量&quot; class=&quot;headerlink&quot; title=&quot;1773. 统计匹配检索规则的物品数量&quot;&gt;&lt;/a&gt;1773. 统计匹配检索规则的物品数量&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;items&lt;/code&gt; ，其中&lt;code&gt;items[i] = [typei, colori, namei]&lt;/code&gt;，描述第 i 件物品的类型、颜色以及名称。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言编程范式</title>
    <link href="http://yoursite.com/2021/02/23/258/"/>
    <id>http://yoursite.com/2021/02/23/258/</id>
    <published>2021-02-23T01:39:54.829Z</published>
    <updated>2021-03-02T02:54:41.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-语言学习"><a href="#go-语言学习" class="headerlink" title="go 语言学习"></a>go 语言学习</h1><p>最近因为学习MIT 6.824的课程，顺便把<code>go</code>语言的相关语法知识也学习了一遍，总共花了约<code>1</code>个星期，总的来说还是非常新颖的一门语言，非常喜欢学习新的知识和技巧。</p><h2 id="go-语言简介"><a href="#go-语言简介" class="headerlink" title="go 语言简介"></a>go 语言简介</h2><h2 id="go-语言的部分特性"><a href="#go-语言的部分特性" class="headerlink" title="go 语言的部分特性"></a>go 语言的部分特性</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><h3 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h3><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><h3 id="fucntional-options"><a href="#fucntional-options" class="headerlink" title="fucntional options"></a>fucntional options</h3><a id="more"></a><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><h3 id="pipe-line"><a href="#pipe-line" class="headerlink" title="pipe line"></a>pipe line</h3><h3 id="relect"><a href="#relect" class="headerlink" title="relect"></a>relect</h3><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h3><h3 id="go-rpc"><a href="#go-rpc" class="headerlink" title="go rpc"></a>go rpc</h3><h3 id><a href="#" class="headerlink" title=" "></a> </h3><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;go-语言学习&quot;&gt;&lt;a href=&quot;#go-语言学习&quot; class=&quot;headerlink&quot; title=&quot;go 语言学习&quot;&gt;&lt;/a&gt;go 语言学习&lt;/h1&gt;&lt;p&gt;最近因为学习MIT 6.824的课程，顺便把&lt;code&gt;go&lt;/code&gt;语言的相关语法知识也学习了一遍，总共花了约&lt;code&gt;1&lt;/code&gt;个星期，总的来说还是非常新颖的一门语言，非常喜欢学习新的知识和技巧。&lt;/p&gt;&lt;h2 id=&quot;go-语言简介&quot;&gt;&lt;a href=&quot;#go-语言简介&quot; class=&quot;headerlink&quot; title=&quot;go 语言简介&quot;&gt;&lt;/a&gt;go 语言简介&lt;/h2&gt;&lt;h2 id=&quot;go-语言的部分特性&quot;&gt;&lt;a href=&quot;#go-语言的部分特性&quot; class=&quot;headerlink&quot; title=&quot;go 语言的部分特性&quot;&gt;&lt;/a&gt;go 语言的部分特性&lt;/h2&gt;&lt;h3 id=&quot;struct&quot;&gt;&lt;a href=&quot;#struct&quot; class=&quot;headerlink&quot; title=&quot;struct&quot;&gt;&lt;/a&gt;struct&lt;/h3&gt;&lt;h3 id=&quot;interface&quot;&gt;&lt;a href=&quot;#interface&quot; class=&quot;headerlink&quot; title=&quot;interface&quot;&gt;&lt;/a&gt;interface&lt;/h3&gt;&lt;h3 id=&quot;slice&quot;&gt;&lt;a href=&quot;#slice&quot; class=&quot;headerlink&quot; title=&quot;slice&quot;&gt;&lt;/a&gt;slice&lt;/h3&gt;&lt;h3 id=&quot;defer&quot;&gt;&lt;a href=&quot;#defer&quot; class=&quot;headerlink&quot; title=&quot;defer&quot;&gt;&lt;/a&gt;defer&lt;/h3&gt;&lt;h3 id=&quot;chan&quot;&gt;&lt;a href=&quot;#chan&quot; class=&quot;headerlink&quot; title=&quot;chan&quot;&gt;&lt;/a&gt;chan&lt;/h3&gt;&lt;h3 id=&quot;error&quot;&gt;&lt;a href=&quot;#error&quot; class=&quot;headerlink&quot; title=&quot;error&quot;&gt;&lt;/a&gt;error&lt;/h3&gt;&lt;h3 id=&quot;fucntional-options&quot;&gt;&lt;a href=&quot;#fucntional-options&quot; class=&quot;headerlink&quot; title=&quot;fucntional options&quot;&gt;&lt;/a&gt;fucntional options&lt;/h3&gt;
    
    </summary>
    
    
      <category term="技术学习" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="go 语言" scheme="http://yoursite.com/tags/go-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 229</title>
    <link href="http://yoursite.com/2021/02/22/256/"/>
    <id>http://yoursite.com/2021/02/22/256/</id>
    <published>2021-02-22T00:38:27.241Z</published>
    <updated>2021-03-01T04:31:37.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-229"><a href="#leetcode-contest-229" class="headerlink" title="leetcode contest 229"></a>leetcode contest 229</h1><p>本周的周赛的题目确实出乎意外的简单，竟然全部都<code>AK</code>了，排名还可以，竟然排名<code>52</code>名.<br><img src="https://i.loli.net/2021/02/22/YPfB63l2RzmX7rE.png" alt></p><h2 id="5685-交替合并字符串"><a href="#5685-交替合并字符串" class="headerlink" title="5685. 交替合并字符串"></a>5685. 交替合并字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。<br>返回 合并后的字符串 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"abc"</span>, word2 = <span class="string">"pqr"</span></span><br><span class="line">输出：<span class="string">"apbqcr"</span></span><br><span class="line">解释：字符串合并情况如下所示：</span><br><span class="line">word1：  <span class="selector-tag">a</span>   <span class="selector-tag">b</span>   c</span><br><span class="line">word2：    <span class="selector-tag">p</span>   <span class="selector-tag">q</span>   r</span><br><span class="line">合并后：  <span class="selector-tag">a</span> <span class="selector-tag">p</span> <span class="selector-tag">b</span> <span class="selector-tag">q</span> c r</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"ab"</span>, word2 = <span class="string">"pqrs"</span></span><br><span class="line">输出：<span class="string">"apbqrs"</span></span><br><span class="line">解释：注意，word2 比 word1 长，<span class="string">"rs"</span> 需要追加到合并后字符串的末尾。</span><br><span class="line">word1：  <span class="selector-tag">a</span>   <span class="selector-tag">b</span> </span><br><span class="line">word2：    <span class="selector-tag">p</span>   <span class="selector-tag">q</span>   r   s</span><br><span class="line">合并后：  <span class="selector-tag">a</span> <span class="selector-tag">p</span> <span class="selector-tag">b</span> <span class="selector-tag">q</span>   r   s</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"abcd"</span>, word2 = <span class="string">"pq"</span></span><br><span class="line">输出：<span class="string">"apbqcd"</span></span><br><span class="line">解释：注意，word1 比 word2 长，<span class="string">"cd"</span> 需要追加到合并后字符串的末尾。</span><br><span class="line">word1：  a   b   c   d</span><br><span class="line">word2：    p   q </span><br><span class="line">合并后：  a p b q c   d</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= word1.length, word2.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `word1` 和 `word2` 由小写英文字母组成</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址</span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/merge-strings-alternately</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;   简单问题,直接暴力或者前缀和什么的</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 双指针交替将字符加入到目标字符串中即可。</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> mergeAlternately(<span class="keyword">string</span> word1, <span class="keyword">string</span> word2) &#123;</span><br><span class="line">        <span class="keyword">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; word1.size() &amp;&amp; l2 &lt; word2.size())&#123;</span><br><span class="line">            ans.push_back(word1[l1++]);</span><br><span class="line">            ans.push_back(word2[l2++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 &lt; word1.size())&#123;</span><br><span class="line">            ans = ans + word1.substr(l1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 &lt; word2.size())&#123;</span><br><span class="line">            ans = ans + word2.substr(l2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5686-移动所有球到每个盒子所需的最小操作数"><a href="#5686-移动所有球到每个盒子所需的最小操作数" class="headerlink" title="5686. 移动所有球到每个盒子所需的最小操作数"></a>5686. 移动所有球到每个盒子所需的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有 n 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code>，其中 <code>boxes[i]</code> 的值为 ‘0’ 表示第 i 个盒子是 空 的，而 <code>boxes[i]</code>的值为 ‘1’ 表示盒子里有 一个 小球。</p><p>在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p><p>返回一个长度为<code>n</code> 的数组 <code>answer</code>，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 最小 操作数。</p><p>每个 <code>answer[i]</code> 都需要根据盒子的 初始状态 进行计算。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：boxes = <span class="string">"110"</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：每个盒子对应的最小操作数如下：</span><br><span class="line"><span class="number">1</span>) 第 <span class="number">1</span> 个盒子：将一个小球从第 <span class="number">2</span> 个盒子移动到第 <span class="number">1</span> 个盒子，需要 <span class="number">1</span> 步操作。</span><br><span class="line"><span class="number">2</span>) 第 <span class="number">2</span> 个盒子：将一个小球从第 <span class="number">1</span> 个盒子移动到第 <span class="number">2</span> 个盒子，需要 <span class="number">1</span> 步操作。</span><br><span class="line"><span class="number">3</span>) 第 <span class="number">3</span> 个盒子：将一个小球从第 <span class="number">1</span> 个盒子移动到第 <span class="number">3</span> 个盒子，需要 <span class="number">2</span> 步操作。将一个小球从第 <span class="number">2</span> 个盒子移动到第 <span class="number">3</span> 个盒子，需要 <span class="number">1</span> 步操作。共计 <span class="number">3</span> 步操作。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：boxes = <span class="string">"001011"</span></span><br><span class="line">输出：[<span class="number">11</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == boxes.length</code></li><li><code>1 &lt;= n &lt;= 2000</code></li><li><code>boxes[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力或者前缀和</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>双层循环暴力解法很简单，只需要判断所有的小球与当前的位置<code>i</code>之间的距离之和求出即可，时间复杂度为$O(N^{2})$，如果题目中给定的数量级过大时，则$O(N^{2})$肯定会超时.</li><li>前缀和后缀和的求法，我们设<code>left[i]</code>表示将前 <code>i</code>个盒子的球移动到第<code>i</code>个盒子所需要的操作步数，我们设<code>sumleft[i]</code>表示前<code>i</code>个盒子的球的总数目；<code>right[i]</code>代表将位置<code>i</code>以后的球全部移动到第<code>i</code>个盒子的最小移动步数，我们设<code>sumright[i]</code>代表所有大于等于<code>i</code>位置的盒子的球的总数目，则我们可以知道：<script type="math/tex; mode=display">left[i] = left[i-1] + sumleft[i-1] \\right[i] = right[i-1] + sumright[i-1] \\answer[i] = left[i] + right[i] \\</script></li><li>时间复杂度为$O(N)$,空间复杂度为$O(N)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minOperations(<span class="built_in">string</span> boxes) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = boxes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                left[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left[i] = left[i<span class="number">-1</span>] + sum;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += boxes[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n<span class="number">-1</span>)&#123;</span><br><span class="line">                right[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right[i] = right[i+<span class="number">1</span>] + sum;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += boxes[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                ans[i]  = right[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n<span class="number">-1</span>)&#123;</span><br><span class="line">                ans[i]  = left[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i] = left[i] + right[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5687-执行乘法运算的最大分数"><a href="#5687-执行乘法运算的最大分数" class="headerlink" title="5687. 执行乘法运算的最大分数"></a>5687. 执行乘法运算的最大分数</h2><p>给你两个长度分别 <code>n</code> 和 <code>m</code>的整数数组 <code>nums</code> 和 <code>multipliers</code> ，其中 <code>n &gt;= m</code>，数组下标 从<code>1</code>开始 计数。</p><p>初始时，你的分数为 0 。你需要执行恰好 m 步操作。在第 i 步操作（从 1 开始 计数）中，需要：</p><p>选择数组 <code>nums</code>开头处或者末尾处 的整数 x 。<br>你获得 <code>multipliers[i] * x</code>分，并累加到你的分数中。<br>将 x 从数组 nums 中移除。<br>在执行 m 步操作后，返回 最大 分数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], multipliers = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">解释：一种最优解决方案如下：</span><br><span class="line">- 选择末尾处的整数 <span class="number">3</span> ，[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，得 <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span> 分，累加到分数中。</span><br><span class="line">- 选择末尾处的整数 <span class="number">2</span> ，[<span class="number">1</span>,<span class="number">2</span>] ，得 <span class="number">2</span> * <span class="number">2</span> = <span class="number">4</span> 分，累加到分数中。</span><br><span class="line">- 选择末尾处的整数 <span class="number">1</span> ，[<span class="number">1</span>] ，得 <span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span> 分，累加到分数中。</span><br><span class="line">总分数为 <span class="number">9</span> + <span class="number">4</span> + <span class="number">1</span> = <span class="number">14</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-5</span>,<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>], multipliers = [<span class="number">-10</span>,<span class="number">-5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">102</span></span><br><span class="line">解释：一种最优解决方案如下：</span><br><span class="line">- 选择开头处的整数 <span class="number">-5</span> ，[<span class="number">-5</span>,<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>] ，得 <span class="number">-5</span> * <span class="number">-10</span> = <span class="number">50</span> 分，累加到分数中。</span><br><span class="line">- 选择开头处的整数 <span class="number">-3</span> ，[<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>] ，得 <span class="number">-3</span> * <span class="number">-5</span> = <span class="number">15</span> 分，累加到分数中。</span><br><span class="line">- 选择开头处的整数 <span class="number">-3</span> ，[<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>] ，得 <span class="number">-3</span> * <span class="number">3</span> = <span class="number">-9</span> 分，累加到分数中。</span><br><span class="line">- 选择末尾处的整数 <span class="number">1</span> ，[<span class="number">-2</span>,<span class="number">7</span>,<span class="number">1</span>] ，得 <span class="number">1</span> * <span class="number">4</span> = <span class="number">4</span> 分，累加到分数中。</span><br><span class="line">- 选择末尾处的整数 <span class="number">7</span> ，[<span class="number">-2</span>,<span class="number">7</span>] ，得 <span class="number">7</span> * <span class="number">6</span> = <span class="number">42</span> 分，累加到分数中。</span><br><span class="line">总分数为 <span class="number">50</span> + <span class="number">15</span> - <span class="number">9</span> + <span class="number">4</span> + <span class="number">42</span> = <span class="number">102</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>m == multipliers.length</code></li><li><code>1 &lt;= m &lt;= 103</code></li><li><code>m &lt;= n &lt;= 105</code></li><li><code>-1000 &lt;= nums[i], multipliers[i] &lt;= 1000</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-from-performing-multiplication-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-from-performing-multiplication-operations</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的<code>dp</code>解法，我们设<code>dp[i][j]</code>表示前<code>i</code>个数中有<code>j</code>个数是从<code>nums</code>数组中左边进行选取，有<code>i-j</code>个数是从<code>nums</code>数组中右边进行选取的所得到的最大结果，则我们可以知道递推公式如下：<script type="math/tex; mode=display">dp[i][j] = max(dp[i-1][j] + nums[n-(i-j)]*multipliers[i-1],dp[i-1][j-1] + nums[j-1]*multipliers[i-1]);</script>要么第<code>i</code>个数从左边取，要么第<code>i</code>个数从右边取，</li></ol><ul><li>假设第<code>i</code>个数从数组左边取的话，则表示当前肯定已经从左边去了<code>j-1</code>个数，则此时我们需要从数组左边选取第<code>j</code>个数即为<code>nums[j-1]</code>与<code>multipliers[i-1]</code>进行相乘，我们可以知道此时递推关系如下：<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1] + nums[j-1]*multipliers[i-1]</script></li><li>假设第<code>i</code>个数从数组右边取的话，则表示当前肯定已经从左边去了<code>j</code>个数，则此时我们需要从数组的右边选取，我们知道当前右边已经选取了<code>i-1-j</code>个数，则此时我们需要选取右边第<code>i-j</code>个数即为<code>nums[n-(i-j)]</code>，则我们可以知道此时递推关系如下：<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1] + nums[n-(i-j)]*multipliers[i-1]</script></li></ul><ol><li>时间复杂度为$O(N^{2})$,空间复杂度为$O(N^{2})$,当然我们可以继续优化空间复杂度为$O(N)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; multipliers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = multipliers.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[n-i]*multipliers[i<span class="number">-1</span>];</span><br><span class="line">            dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>] + nums[i<span class="number">-1</span>]*multipliers[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j] + nums[n-(i-j)]*multipliers[i<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + nums[j<span class="number">-1</span>]*multipliers[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[m][i]);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5688-由子序列构造的最长回文串的长度"><a href="#5688-由子序列构造的最长回文串的长度" class="headerlink" title="5688. 由子序列构造的最长回文串的长度"></a>5688. 由子序列构造的最长回文串的长度</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> ，请你按下述方法构造一个字符串：</p><ul><li>从 <code>word1</code> 中选出某个 非空 子序列 <code>subsequence1</code> 。</li><li>从 <code>word2</code> 中选出某个 非空 子序列 <code>subsequence2</code> 。<br>连接两个子序列 <code>subsequence1 + subsequence2</code>，得到字符串。<br>返回可按上述方法构造的最长 回文串 的 长度 。如果无法构造回文串，返回 0 。</li></ul><p>字符串 <code>s</code> 的一个 子序列 是通过从 s 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。</p><p>回文串 是正着读和反着读结果一致的字符串。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">"cacb"</span>, <span class="attr">word2</span> = <span class="string">"cbba"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：从 word1 中选出 <span class="string">"ab"</span> ，从 word2 中选出 <span class="string">"cba"</span> ，得到回文串 <span class="string">"abcba"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">"ab"</span>, <span class="attr">word2</span> = <span class="string">"ab"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：从 word1 中选出 <span class="string">"ab"</span> ，从 word2 中选出 <span class="string">"a"</span> ，得到回文串 <span class="string">"aba"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"aa"</span>, word2 = <span class="string">"bb"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无法按题面所述方法构造回文串，所以返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 1000</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximize-palindrome-length-from-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximize-palindrome-length-from-subsequences</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p><code>dp</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>拿到题目的时候首先想到的就是求字符串的最长的回文子串，这个解法非常经典的<code>dp</code>，一般都能先到出来，本题的重点在于如何选择的字串都为非空。</li><li>首先我们想到的是将字符串<code>1</code>和字符串<code>2</code>进行合并，然后求出最大的回文子串，但是如何确定目标回文串的两端横跨两个字符串，其实原理很简单，我们只需要判断目标回文字符串的两端的字符位置即可.我们设字符串<code>1</code>的长度为<code>l1</code>，字符串<code>2</code>的长度为<code>l2</code>，则此时我们只需要判断最左边的字符的位置是否在<code>[0,l1)</code>之间，最右边的字符是否在<code>[l1,l1+l2)</code>之间，即满足如下条件:<script type="math/tex; mode=display">0 \le C_{l} < l1 \\l1 \le C_{r} < l1+l2</script></li><li>求字符串的最大回文子串的长度很简单，用<code>dp</code>实现即可：<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j-1],dp[i+1][j]) \\dp[i][j] = dp[i+1][j-1] + 2 \qquad if(s[i] == s[j])</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = word1 + word2;</span><br><span class="line">        <span class="keyword">int</span> l1 = word1.size();</span><br><span class="line">        <span class="keyword">int</span> l2 = word2.size();</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">1</span>));            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j+i &lt; n; ++j)&#123;</span><br><span class="line">                dp[j][j+i] = max(dp[j][j+i<span class="number">-1</span>],dp[j+<span class="number">1</span>][j+i]);</span><br><span class="line">                <span class="keyword">if</span>(s[j] == s[j+i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                        dp[j][j+i] = <span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[j][j+i] = max(dp[j][j+i],dp[j+<span class="number">1</span>][j+i<span class="number">-1</span>] + <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; l1 &amp;&amp; (j+i) &gt;= l1)&#123;</span><br><span class="line">                        ans = max(ans,dp[j][j+i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-229&quot;&gt;&lt;a href=&quot;#leetcode-contest-229&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 229&quot;&gt;&lt;/a&gt;leetcode contest 229&lt;/h1&gt;&lt;p&gt;本周的周赛的题目确实出乎意外的简单，竟然全部都&lt;code&gt;AK&lt;/code&gt;了，排名还可以，竟然排名&lt;code&gt;52&lt;/code&gt;名.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/22/YPfB63l2RzmX7rE.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5685-交替合并字符串&quot;&gt;&lt;a href=&quot;#5685-交替合并字符串&quot; class=&quot;headerlink&quot; title=&quot;5685. 交替合并字符串&quot;&gt;&lt;/a&gt;5685. 交替合并字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt; 。请你从 &lt;code&gt;word1&lt;/code&gt; 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。&lt;br&gt;返回 合并后的字符串 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 46</title>
    <link href="http://yoursite.com/2021/02/18/255/"/>
    <id>http://yoursite.com/2021/02/18/255/</id>
    <published>2021-02-18T03:50:37.013Z</published>
    <updated>2021-02-20T16:28:52.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-46"><a href="#leetcode-biweekly-contest-46" class="headerlink" title="leetcode biweekly contest 46"></a>leetcode biweekly contest 46</h1><p>本周双周赛的题目确实出乎意外的简单，最后一题<code>hard</code>难度竟然暴力<code>dfs</code>搞定，意外的进入了前<code>100</code>.<br><img src="https://i.loli.net/2021/02/21/4qkwW1O5ChIxrb9.png" alt></p><h2 id="5668-最长的美好子字符串"><a href="#5668-最长的美好子字符串" class="headerlink" title="5668. 最长的美好子字符串"></a>5668. 最长的美好子字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>当一个字符串 <code>s</code> 包含的每一种字母的大写和小写形式 同时 出现在 <code>s</code> 中，就称这个字符串 s 是 美好 字符串。比方说，<code>&quot;abABB&quot;</code>是美好字符串，因为 <code>&#39;A&#39;</code>和<code>&#39;a&#39;</code>同时出现了，且 <code>&#39;B&#39;</code> 和 <code>&#39;b&#39;</code>也同时出现了。然而，<code>&quot;abA&quot;</code>不是美好字符串因为 <code>&#39;b&#39;</code>出现了，而 <code>&#39;B&#39;</code>没有出现。</p><a id="more"></a><p>给你一个字符串 s ，请你返回 <code>s</code> 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"YazaAay"</span></span><br><span class="line">输出：<span class="string">"aAa"</span></span><br><span class="line">解释：<span class="string">"aAa"</span> 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。</span><br><span class="line"><span class="string">"aAa"</span> 是最长的美好子字符串。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"Bb"</span></span><br><span class="line">输出：<span class="string">"Bb"</span></span><br><span class="line">解释：<span class="string">"Bb"</span> 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"c"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：没有美好子字符串。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"dDzeE"</span></span><br><span class="line">输出：<span class="string">"dD"</span></span><br><span class="line">解释：<span class="string">"dD"</span> 和 <span class="string">"eE"</span> 都是最长美好子字符串。</span><br><span class="line">由于有多个美好子字符串，返回 <span class="string">"dD"</span> ，因为它出现得最早。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code>只包含大写和小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题,直接暴力或者前缀和什么的</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力求出每个连续的子字符串是否符合美好字符串即可，分别记录所有的大写字母和小写字符的统计次数。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestNiceSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> maxN = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum[<span class="number">101</span>][<span class="number">26</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; arr1(<span class="number">26</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; arr2(<span class="number">26</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] &gt;= <span class="string">'a'</span> &amp;&amp; s[j] &lt;= <span class="string">'z'</span>) arr1[s[j]-<span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[j] &gt;= <span class="string">'A'</span> &amp;&amp; s[j] &lt;= <span class="string">'Z'</span>) arr2[s[j]-<span class="string">'A'</span>] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!arr1[k] &amp;&amp; !arr2[k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!arr1[k])&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!arr2[k])&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; maxN)&#123;</span><br><span class="line">                        ans = s.substr(i,j-i+<span class="number">1</span>);</span><br><span class="line">                        maxN = j - i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5669-通过连接另一个数组的子数组得到一个数组"><a href="#5669-通过连接另一个数组的子数组得到一个数组" class="headerlink" title="5669. 通过连接另一个数组的子数组得到一个数组"></a>5669. 通过连接另一个数组的子数组得到一个数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的二维整数数组<code>groups</code>，同时给你一个整数数组 <code>nums</code> 。</p><p>你是否可以从 <code>nums</code> 中选出 <code>n</code> 个 不相交 的子数组，使得第 <code>i</code> 个子数组与 <code>groups[i]</code> （下标从 0 开始）完全相同，且如果<code>i &gt; 0</code>，那么第 <code>(i-1)</code>个子数组在 <code>nums</code>中出现的位置在第 i 个子数组前面。（也就是说，这些子数组在 <code>nums</code> 中出现的顺序需要与 groups 顺序相同）</p><p>如果你可以找出这样的 <code>n</code>个子数组，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>如果不存在下标为 <code>k</code>的元素 <code>nums[k]</code>属于不止一个子数组，就称这些子数组是 不相交 的。子数组指的是原数组中连续元素组成的一个序列。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：groups = [[<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>],[<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>]], nums = [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：你可以分别在 nums 中选出第 <span class="number">0</span> 个子数组 [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>] 和第 <span class="number">1</span> 个子数组 [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">0</span>] 。</span><br><span class="line">这两个子数组是不相交的，因为它们没有任何共同的元素。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：groups = [[<span class="number">10</span>,<span class="number">-2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]], nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">-2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：选择子数组 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">-2</span>] 和 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">-2</span>] 是不正确的，因为它们出现的顺序与 groups 中顺序不同。</span><br><span class="line">[<span class="number">10</span>,<span class="number">-2</span>] 必须出现在 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 之前。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：groups = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]], nums = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：选择子数组 [<span class="number">7</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">7</span>] 和 [<span class="number">7</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">7</span>] 是不正确的，因为它们不是不相交子数组。</span><br><span class="line">它们有一个共同的元素 nums[<span class="number">4</span>] （下标从 <span class="number">0</span> 开始）。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>groups.length == n</code></li><li><code>1 &lt;= n &lt;= 103</code></li><li><code>1 &lt;= groups[i].length, sum(groups[i].length) &lt;= 103</code></li><li><code>1 &lt;= nums.length &lt;= 103</code></li><li><code>-107 &lt;= groups[i][j], nums[k] &lt;= 107</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-46/problems/form-array-by-concatenating-subarrays-of-another-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-46/problems/form-array-by-concatenating-subarrays-of-another-array/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力双指针即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>一个指针<code>l1</code>指向<code>group</code>,另一个指针<code>l2</code>指向<code>nums</code>,我们判断当前l2指向的<code>group</code>数组是否满足当前<code>l2</code>指针指向的与<code>group[l1]</code>数组长度相等的连续子数组，如果相等我们将两个指针变换为：<code>l2 = l2 + len(group[l1])</code>,<code>l1 = l1 + 1</code>;如果不相等我们则将指针<code>l2</code>变换为<code>l2 = l2 + 1</code>.</li><li>最终判定指针<code>l1</code>是否等于<code>n</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canChoose</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; groups, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = groups.size();</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; n &amp;&amp; l2 &lt; m)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; groups[l1].size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>((l2 + i) &gt;= m || groups[l1][i] != nums[l2+i])&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                l2 = l2 + groups[l1].size();</span><br><span class="line">                l1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5671-地图中的最高点"><a href="#5671-地图中的最高点" class="headerlink" title="5671. 地图中的最高点"></a>5671. 地图中的最高点</h2><p>给你一个大小为 <code>m x n</code>的整数矩阵 <code>isWater</code> ，它代表了一个由 陆地 和 水域 单元格组成的地图。</p><ul><li>如果 <code>isWater[i][j] == 0</code>，格子 <code>(i, j)</code>是一个 陆地 格子。</li><li>如果 <code>isWater[i][j] == 1</code> ，格子 <code>(i, j)</code> 是一个 水域 格子。<br>你需要按照如下规则给每个单元格安排高度：</li></ul><p>每个格子的高度都必须是非负的。<br>如果一个格子是是 水域 ，那么它的高度必须为 0 。<br>任意相邻的格子高度差 至多 为 <code>1</code> 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）<br>找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。<br>请你返回一个大小为 <code>m x n</code>的整数矩阵 <code>height</code> ，其中<code>height[i][j]</code>是格子<code>(i, j)</code> 的高度。如果有多种解法，请返回 任意一个 。</p><p>示例 1：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：isWater = <span class="string">[[0,1],[0,0]]</span></span><br><span class="line">输出：<span class="string">[[1,0],[2,1]]</span></span><br><span class="line">解释：上图展示了给各个格子安排的高度。</span><br><span class="line">蓝色格子是水域格，绿色格子是陆地格。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：isWater = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">解释：所有安排方案中，最高可行高度为 <span class="number">2</span> 。</span><br><span class="line">任意安排方案中，只要最高高度为 <span class="number">2</span> 且符合上述规则的，都为可行方案。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == isWater.length</code></li><li><code>n == isWater[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>isWater[i][j]</code> 要么是 <code>0</code> ，要么是 <code>1</code>。</li><li>至少有 <code>1</code>个水域格子。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的<code>bfs</code>我们知道水域的高度肯定为<code>0</code>,那么紧挨着水域的格子最大为<code>1</code>,则紧紧挨着<code>1</code>的陆地最大也只能为<code>2</code>，依次下去，我们可以推出紧挨着高度为<code>n</code>的陆地的最大高度也只能为<code>n+1</code>。所以典型的层次的<code>bfs</code>。</li><li>我们将水域的高度初始化为<code>0</code>，同时将其进入队列，每次出队列时将周边为进行紧挨着的四个陆地设置为当前格子的高度加<code>1</code>。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; highestPeak(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isWater) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = isWater.size();</span><br><span class="line">        <span class="keyword">int</span> col = isWater[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isWater[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    qu.push(i*col+j);</span><br><span class="line">                    ans[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = (curr/col) + d[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = (curr%col) + d[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans[x][y] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    ans[x][y] = ans[curr/col][curr%col] + <span class="number">1</span>;</span><br><span class="line">                    qu.push(x*col+y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5670-互质树"><a href="#5670-互质树" class="headerlink" title="5670. 互质树"></a>5670. 互质树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 n 个节点的树（也就是一个无环连通无向图），节点编号从 0 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条边，每个节点有一个值。树的 根节点 为 0 号点。</p><p>给你一个整数数组 nums 和一个二维数组 edges 来表示这棵树。<code>nums[i]</code>表示第 i 个点的值，<code>edges[j] = [uj, vj]</code>表示节点 uj 和节点 vj 在树中有一条边。</p><p>当 <code>gcd(x, y) == 1</code> ，我们称两个数 x 和 y 是 互质的 ，其中 <code>gcd(x, y)</code> 是 x 和 y 的 最大公约数 。</p><p>从节点 i 到 根 最短路径上的点都是节点 i 的祖先节点。一个节点 不是 它自己的祖先节点。</p><p>请你返回一个大小为 n 的数组 <code>ans</code>，其中 <code>ans[i]</code>是离节点 i 最近的祖先节点且满足 <code>nums[i]</code>和 <code>nums[ans[i]]</code> 是 互质的 ，如果不存在这样的祖先节点，<code>ans[i]</code> 为 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：上图中，每个节点的值在括号中表示。</span><br><span class="line">- 节点 <span class="number">0</span> 没有互质祖先。</span><br><span class="line">- 节点 <span class="number">1</span> 只有一个祖先节点 <span class="number">0</span> 。它们的值是互质的（gcd(<span class="number">2</span>,<span class="number">3</span>) == <span class="number">1</span>）。</span><br><span class="line">- 节点 <span class="number">2</span> 有两个祖先节点，分别是节点 <span class="number">1</span> 和节点 <span class="number">0</span> 。节点 <span class="number">1</span> 的值与它的值不是互质的（gcd(<span class="number">3</span>,<span class="number">3</span>) == <span class="number">3</span>）但节点 <span class="number">0</span> 的值是互质的(gcd(<span class="number">2</span>,<span class="number">3</span>) == <span class="number">1</span>)，所以节点 <span class="number">0</span> 是最近的符合要求的祖先节点。</span><br><span class="line">- 节点 <span class="number">3</span> 有两个祖先节点，分别是节点 <span class="number">1</span> 和节点 <span class="number">0</span> 。它与节点 <span class="number">1</span> 互质（gcd(<span class="number">3</span>,<span class="number">2</span>) == <span class="number">1</span>），所以节点 <span class="number">1</span> 是离它最近的符合要求的祖先节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">15</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>nums.length == n</code></li><li><code>1 &lt;= nums[i] &lt;= 50</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[j].length == 2</code></li><li><code>0 &lt;= uj, vj &lt; n</code></li><li><code>uj != vj</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-46/problems/tree-of-coprimes/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-46/problems/tree-of-coprimes/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p><code>DFS</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目感觉很怪异，不过最关键的在于<code>1 &lt;= nums[i] &lt;= 50</code>，存在这一条我们就可以使用暴力<code>dfs</code>了。</li><li><code>dfs</code>时保存当前节点的所有祖先节点的值，并存放该值的最大深度和节点编号，遍历到当前节点时，我们通过遍历其所有的祖先节点的值，并找到最大的深度且与当前节点的值为互质的即可，本质上没有多少难度，可以用<code>map</code>或者数组保存祖先节点的值均可。唯一需要注意的是，我们每次在更新节点祖先的值时，如果当前节点的值已经与祖先节点重复时，我们在遍历完成<code>dfs</code>遍历当前节点的所有的孩子节点后，要进行恢复。</li><li>时间复杂度为$O(max(nums)<em>N)$,空间复杂度为$O(2</em>N)$,感觉没有多少技巧和难度可言。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> curr,<span class="keyword">int</span> depth,<span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; graph,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,pii&gt; &amp; fa,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; ret)</span></span>&#123;</span><br><span class="line">        ret[curr] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : fa)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second.first &gt; dis &amp;&amp; __gcd(v.first,arr[curr]) == <span class="number">1</span>)&#123;</span><br><span class="line">                ret[curr] = v.second.second;</span><br><span class="line">                dis = v.second.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pii last;</span><br><span class="line">        <span class="keyword">bool</span> repeat = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(fa.count(arr[curr]))&#123;</span><br><span class="line">            repeat = <span class="literal">true</span>;</span><br><span class="line">            last = fa[arr[curr]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fa[arr[curr]] = make_pair(depth,curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == root) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(curr,v,depth+<span class="number">1</span>,graph,fa,ret);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(repeat)&#123;</span><br><span class="line">            fa[arr[curr]] = last;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fa.erase(arr[curr]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getCoprimes(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,pii&gt; fa;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        arr = nums;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].insert(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].insert(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,graph,fa,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-46&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-46&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 46&quot;&gt;&lt;/a&gt;leetcode biweekly contest 46&lt;/h1&gt;&lt;p&gt;本周双周赛的题目确实出乎意外的简单，最后一题&lt;code&gt;hard&lt;/code&gt;难度竟然暴力&lt;code&gt;dfs&lt;/code&gt;搞定，意外的进入了前&lt;code&gt;100&lt;/code&gt;.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/21/4qkwW1O5ChIxrb9.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5668-最长的美好子字符串&quot;&gt;&lt;a href=&quot;#5668-最长的美好子字符串&quot; class=&quot;headerlink&quot; title=&quot;5668. 最长的美好子字符串&quot;&gt;&lt;/a&gt;5668. 最长的美好子字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;当一个字符串 &lt;code&gt;s&lt;/code&gt; 包含的每一种字母的大写和小写形式 同时 出现在 &lt;code&gt;s&lt;/code&gt; 中，就称这个字符串 s 是 美好 字符串。比方说，&lt;code&gt;&amp;quot;abABB&amp;quot;&lt;/code&gt;是美好字符串，因为 &lt;code&gt;&amp;#39;A&amp;#39;&lt;/code&gt;和&lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt;同时出现了，且 &lt;code&gt;&amp;#39;B&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt;也同时出现了。然而，&lt;code&gt;&amp;quot;abA&amp;quot;&lt;/code&gt;不是美好字符串因为 &lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt;出现了，而 &lt;code&gt;&amp;#39;B&amp;#39;&lt;/code&gt;没有出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 228</title>
    <link href="http://yoursite.com/2021/02/14/254/"/>
    <id>http://yoursite.com/2021/02/14/254/</id>
    <published>2021-02-14T05:59:22.942Z</published>
    <updated>2021-02-14T07:18:04.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-228"><a href="#leetcode-contest-228" class="headerlink" title="leetcode  contest 228"></a>leetcode  contest 228</h1><p>本周的周赛题目确实都非常简单，第四题竟然暴力就能过了，完全只能算是<code>mid</code>难度的题目，不过竟然第三题没有想出用二分查找的方法来解题。<br><img src="https://i.loli.net/2021/02/14/IyFxT79gj8OYsRG.png" alt></p><h2 id="5676-生成交替二进制字符串的最少操作数"><a href="#5676-生成交替二进制字符串的最少操作数" class="headerlink" title="5676. 生成交替二进制字符串的最少操作数"></a>5676. 生成交替二进制字符串的最少操作数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个仅由字符<code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串<code>s</code>。一步操作中，你可以将任一 ‘0’ 变成 ‘1’ ，或者将 ‘1’ 变成 ‘0’ 。</p><a id="more"></a><p>交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>&quot;010&quot;</code>是交替字符串，而字符串 <code>&quot;0100&quot;</code>不是。</p><p>返回使 <code>s</code> 变成 交替字符串 所需的 最少 操作数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"0100"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：如果将最后一个字符变为 '<span class="number">1</span>' ，s 就变成 <span class="string">"0101"</span> ，即符合交替字符串定义。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"10"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：s 已经是交替字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1111"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：需要 <span class="number">2</span> 步操作得到 <span class="string">"0101"</span> 或 <span class="string">"1010"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s[i]</code> 是 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>两种<code>0</code>,<code>1</code>交替的方式分别计算替换次数，返回最小的替换次数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]-<span class="string">'0'</span>)%<span class="number">2</span> != (i%<span class="number">2</span>))&#123;</span><br><span class="line">                l1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> min(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5677-统计同构子字符串的数目"><a href="#5677-统计同构子字符串的数目" class="headerlink" title="5677. 统计同构子字符串的数目"></a>5677. 统计同构子字符串的数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，返回 <code>s</code>中 同构子字符串 的数目。由于答案可能很大，只需返回对 <code>109 + 7</code>取余 后的结果。<br>同构字符串 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。<br>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abbcccaa"</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：同构子字符串如下所列：</span><br><span class="line"><span class="string">"a"</span>   出现 <span class="number">3</span> 次。</span><br><span class="line"><span class="string">"aa"</span>  出现 <span class="number">1</span> 次。</span><br><span class="line"><span class="string">"b"</span>   出现 <span class="number">2</span> 次。</span><br><span class="line"><span class="string">"bb"</span>  出现 <span class="number">1</span> 次。</span><br><span class="line"><span class="string">"c"</span>   出现 <span class="number">3</span> 次。</span><br><span class="line"><span class="string">"cc"</span>  出现 <span class="number">2</span> 次。</span><br><span class="line"><span class="string">"ccc"</span> 出现 <span class="number">1</span> 次。</span><br><span class="line"><span class="number">3</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">13</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"xy"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：同构子字符串是 <span class="string">"x"</span> 和 <span class="string">"y"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"zzzzz"</span></span><br><span class="line">输出：<span class="number">15</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 由小写字符串组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-homogenous-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-number-of-homogenous-substrings</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>求出连续相同字符子串的长度<code>n</code>,次数可能的异构子字符串的数目为$\frac{n*(n+1)}{2}$.</li><li>求出所有连续相同字符串的所有异构子字符串即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countHomogenous</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == s[curr]) i++;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> m = i - curr;</span><br><span class="line">            ans = (ans + m*(m+<span class="number">1</span>)/<span class="number">2</span>)%mod;</span><br><span class="line">            curr = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5678-袋子里最少数目的球"><a href="#5678-袋子里最少数目的球" class="headerlink" title="5678. 袋子里最少数目的球"></a>5678. 袋子里最少数目的球</h2><p>给你一个整数数组 <code>nums</code> ，其中 <code>nums[i]</code>表示第 i 个袋子里球的数目。同时给你一个整数 <code>maxOperations</code> 。</p><p>你可以进行如下操作至多 <code>maxOperations</code> 次：</p><ul><li>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。</li><li><ul><li>比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。<br>你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。<br>请你返回进行上述操作后的最小开销。</li></ul></li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>], maxOperations = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">- 将装有 <span class="number">9</span> 个球的袋子分成装有 <span class="number">6</span> 个和 <span class="number">3</span> 个球的袋子。[<span class="number">9</span>] -&gt; [<span class="number">6</span>,<span class="number">3</span>] 。</span><br><span class="line">- 将装有 <span class="number">6</span> 个球的袋子分成装有 <span class="number">3</span> 个和 <span class="number">3</span> 个球的袋子。[<span class="number">6</span>,<span class="number">3</span>] -&gt; [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>] 。</span><br><span class="line">装有最多球的袋子里装有 <span class="number">3</span> 个球，所以开销为 <span class="number">3</span> 并返回 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>], maxOperations = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 将装有 <span class="number">8</span> 个球的袋子分成装有 <span class="number">4</span> 个和 <span class="number">4</span> 个球的袋子。[<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将装有 <span class="number">4</span> 个球的袋子分成装有 <span class="number">2</span> 个和 <span class="number">2</span> 个球的袋子。[<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将装有 <span class="number">4</span> 个球的袋子分成装有 <span class="number">2</span> 个和 <span class="number">2</span> 个球的袋子。[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>] 。</span><br><span class="line">- 将装有 <span class="number">4</span> 个球的袋子分成装有 <span class="number">2</span> 个和 <span class="number">2</span> 个球的袋子。[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line">装有最多球的袋子里装有 <span class="number">2</span> 个球，所以开销为 <span class="number">2</span> 并返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">17</span>], maxOperations = <span class="number">2</span></span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= maxOperations, nums[i] &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>直接计算的话，感觉这个算法很难写。我们反而利用二分查找的办法很容易实现。</li><li>直接确定测试最终的目表数为<code>x</code>，则次数若要将数<code>n</code>分为划分为全部小于<code>x</code>的整数，则最少需要$\frac{n-1}{x}$次操作，则此时我们每次测试当前可能的最少操作数是否能够满足<code>maxOperations</code>，如果所有需要的操作数小于等于<code>maxOperations</code>，则表示一定可以变换成功，否则则不可能切分成功。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v: nums) curr += (v<span class="number">-1</span>)/mid;</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; maxOperations)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5679-一个图中连通三元组的最小度数"><a href="#5679-一个图中连通三元组的最小度数" class="headerlink" title="5679. 一个图中连通三元组的最小度数"></a>5679. 一个图中连通三元组的最小度数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个无向图，整数 <code>n</code> 表示图中节点的数目，<code>edges</code> 数组表示图中的边，其中 <code>edges[i] = [ui, vi]</code>，表示 <code>ui</code> 和 <code>vi</code>之间有一条无向边。<br>一个 连通三元组 指的是 三个 节点组成的集合且这三个点之间 两两 有边。<br>连通三元组的度数 是所有满足此条件的边的数目：一个顶点在三元组内，而另一个顶点不在三元组内。<br>请你返回所有连通三元组中度数的 最小值 ，如果图中没有连通三元组，那么返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：只有一个三元组 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 。构成度数的边在上图中已被加粗。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">7</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：有 <span class="number">3</span> 个三元组：</span><br><span class="line"><span class="number">1</span>) [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]，度数为 <span class="number">0</span> 。</span><br><span class="line"><span class="number">2</span>) [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]，度数为 <span class="number">2</span> 。</span><br><span class="line"><span class="number">3</span>) [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]，度数为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 400</code></li><li><code>edges[i].length == 2</code></li><li><code>1 &lt;= edges.length &lt;= n * (n-1) / 2</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li>图中没有重复的边。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>刚开始想了半天没有特别好的办法来判别是否为三元组，后来只能硬着头皮试了下暴力,时间复杂度为$O(n^{3})$,竟然过了，感觉太出乎意料了，这种时间复杂度的情况下竟然通过了，不过可以试试计算最大的数据量大概如下：<script type="math/tex; mode=display">T(n) = \sum_{i=1}^{n}\frac{(n-1)*(n-2)}{2} \\= \sum_{i=1}^{n}(\frac{n^{2}}{2} - \frac{3n}{2} + 1) \\= \frac{n*(n+1)*(2n+1)}{12} - \frac{3n*(n+1)}{4} + n</script>如果当<code>n</code>取最大值<code>400</code>时，上述的时间复杂度约为:<script type="math/tex; mode=display">T(400) = 10706700 - 120300 + 400 = 10,586,800</script>感觉时间复杂度应该是卡在边缘地带，但是<code>lc</code>时间判别竟然过了，没有超时。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTrioDegree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; degree(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; graph(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            edges[i][<span class="number">0</span>]--;</span><br><span class="line">            edges[i][<span class="number">1</span>]--;</span><br><span class="line">            degree[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">            degree[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]][edges[i][<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]][edges[i][<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* three */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!graph[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(graph[i][j] &amp;&amp; graph[j][k]&amp;&amp;graph[i][k])&#123;</span><br><span class="line">                        ans = min(ans,degree[i] + degree[j] + degree[k] - <span class="number">6</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ans == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-228&quot;&gt;&lt;a href=&quot;#leetcode-contest-228&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 228&quot;&gt;&lt;/a&gt;leetcode  contest 228&lt;/h1&gt;&lt;p&gt;本周的周赛题目确实都非常简单，第四题竟然暴力就能过了，完全只能算是&lt;code&gt;mid&lt;/code&gt;难度的题目，不过竟然第三题没有想出用二分查找的方法来解题。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/14/IyFxT79gj8OYsRG.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5676-生成交替二进制字符串的最少操作数&quot;&gt;&lt;a href=&quot;#5676-生成交替二进制字符串的最少操作数&quot; class=&quot;headerlink&quot; title=&quot;5676. 生成交替二进制字符串的最少操作数&quot;&gt;&lt;/a&gt;5676. 生成交替二进制字符串的最少操作数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个仅由字符&lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;1&amp;#39;&lt;/code&gt; 组成的字符串&lt;code&gt;s&lt;/code&gt;。一步操作中，你可以将任一 ‘0’ 变成 ‘1’ ，或者将 ‘1’ 变成 ‘0’ 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 227</title>
    <link href="http://yoursite.com/2021/02/07/253/"/>
    <id>http://yoursite.com/2021/02/07/253/</id>
    <published>2021-02-07T09:16:17.932Z</published>
    <updated>2021-02-14T15:18:42.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-227"><a href="#leetcode-contest-227" class="headerlink" title="leetcode  contest 227"></a>leetcode  contest 227</h1><p>周赛的题目还是挺难的，竟然只做出来了三道题目，最后一题还是没有能够做出来。</p><h2 id="5672-检查数组是否经排序和轮转得到"><a href="#5672-检查数组是否经排序和轮转得到" class="headerlink" title="5672. 检查数组是否经排序和轮转得到"></a>5672. 检查数组是否经排序和轮转得到</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code> 。<code>nums</code> 的源数组中，所有元素与 <code>nums</code>相同，但按非递减顺序排列。</p><p>如果 <code>nums</code> 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 <code>true</code>；否则，返回 <code>false</code> 。</p><a id="more"></a><p>源数组中可能存在 重复项 。</p><p>注意：我们称数组 <code>A</code> 在轮转 <code>x</code> 个位置后得到长度相同的数组 B ，当它们满足<code>A[i] == B[(i+x) % A.length]</code>，其中 % 为取余运算。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 为有序的源数组。</span><br><span class="line">可以轮转 x = <span class="number">3</span> 个位置，使新数组从值为 <span class="number">3</span> 的元素开始：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：源数组无法经轮转得到 nums 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 为有序的源数组。</span><br><span class="line">可以轮转 x = <span class="number">0</span> 个位置（即不轮转）得到 nums 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 为有序的源数组。</span><br><span class="line">轮转任意个位置都可以得到 nums 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>] 为有序的源数组。</span><br><span class="line">可以轮转 x = <span class="number">5</span> 个位置，使新数组从值为 <span class="number">2</span> 的元素开始：[<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-array-is-sorted-and-rotated" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-array-is-sorted-and-rotated</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>判断数字的连续大小问题，如果数组的前半部分连续升序和后半部分连续升序，即可判断该数组可以通过旋转得到目标数组。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            mid = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mid == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &lt; n <span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5673-移除石子的最大得分"><a href="#5673-移除石子的最大得分" class="headerlink" title="5673. 移除石子的最大得分"></a>5673. 移除石子的最大得分</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你正在玩一个单人游戏，面前放置着大小分别为 <code>a</code>​​​​​​、<code>b</code> 和 <code>c</code>​​​​​​ 的 三堆 石子。</p><p>每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。</p><p>给你三个整数 <code>a</code> 、<code>b</code> 和 <code>c</code> ，返回可以得到的 最大分数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">2</span>, b = <span class="number">4</span>, c = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：石子起始状态是 (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>) ，最优的一组操作是：</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">总分：<span class="number">6</span> 分 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">4</span>, b = <span class="number">4</span>, c = <span class="number">6</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：石子起始状态是 (<span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>) ，最优的一组操作是：</span><br><span class="line">- 从第一和第二堆取，石子状态现在是 (<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">- 从第一和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">- 从第二和第三堆取，石子状态现在是 (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">总分：<span class="number">7</span> 分 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：a = <span class="number">1</span>, b = <span class="number">8</span>, c = <span class="number">8</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：最优的一组操作是连续从第二和第三堆取 <span class="number">8</span> 回合，直到将它们取空。</span><br><span class="line">注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= a, b, c &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-from-removing-stones/solution/tan-xin-you-xian-dui-lie-by-sheeeeeeep-t-awzc/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-from-removing-stones/solution/tan-xin-you-xian-dui-lie-by-sheeeeeeep-t-awzc/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质为数学问题，首先我们将<code>a</code>,<code>b</code>,<code>c</code>按照大小进行排序，我们来分为两种情况看待：</li></ol><ul><li><code>a+b &lt;= c</code>: 则此时我们可以知道最多的得分肯定为$min(a+b,c)$;</li><li><code>a+b &gt; c</code>: 此时我们需要思考一下，我们可以将<code>a,b，c</code>总的组合种进行每次减<code>2</code>操作，总的结果肯定应该等于$\frac{a+b+c}{2}$;<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = a + b + c;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        arr.push_back(a);</span><br><span class="line">        arr.push_back(b);</span><br><span class="line">        arr.push_back(c);</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>] + arr[<span class="number">1</span>] &lt;= arr[<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>] + arr[<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sum/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5674-构造字典序最大的合并字符串"><a href="#5674-构造字典序最大的合并字符串" class="headerlink" title="5674. 构造字典序最大的合并字符串"></a>5674. 构造字典序最大的合并字符串</h2><p>给你两个字符串 <code>word1</code> 和 <code>word2</code>。你需要按下述方式构造一个新字符串 <code>merge</code> ：如果 <code>word1</code> 或 <code>word2</code> 非空，选择 下面选项之一 继续操作：</p><ul><li>如果 <code>word1</code> 非空，将 <code>word1</code>中的第一个字符附加到 <code>merge</code> 的末尾，并将其从<code>word1</code>中移除。<br>例如，<code>word1 = &quot;abc&quot;</code> 且 <code>merge = &quot;dv&quot;</code> ，在执行此选项操作之后，<code>word1 = &quot;bc&quot;</code> ，同时 <code>merge = &quot;dva&quot;</code>。<br>如果 <code>word2</code> 非空，将 <code>word2</code>中的第一个字符附加到<code>merge</code>的末尾，并将其从 <code>word2</code>中移除。</li><li>例如，<code>word2 = &quot;abc&quot;</code>且 <code>merge = &quot;&quot;</code>，在执行此选项操作之后，<code>word2 = &quot;bc&quot;</code> ，同时 <code>merge = &quot;a&quot;</code>。<br>返回你可以构造的字典序 最大 的合并字符串 <code>merge</code>。</li></ul><p>长度相同的两个字符串 a 和 b 比较字典序大小，如果在 a 和 b 出现不同的第一个位置，a 中字符在字母表中的出现顺序位于 b 中相应字符之后，就认为字符串 a 按字典序比字符串 b 更大。例如，<code>&quot;abcd&quot;</code>按字典序比 <code>&quot;abcc&quot;</code> 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 d 在字母表中的出现顺序位于 c 之后。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">"cabaa"</span>, <span class="attr">word2</span> = <span class="string">"bcaaa"</span></span><br><span class="line">输出：<span class="string">"cbcabaaaaa"</span></span><br><span class="line">解释：构造字典序最大的合并字符串，可行的一种方法如下所示：</span><br><span class="line">- 从 word1 中取第一个字符：<span class="attr">merge</span> = <span class="string">"c"</span>，<span class="attr">word1</span> = <span class="string">"abaa"</span>，<span class="attr">word2</span> = <span class="string">"bcaaa"</span></span><br><span class="line">- 从 word2 中取第一个字符：<span class="attr">merge</span> = <span class="string">"cb"</span>，<span class="attr">word1</span> = <span class="string">"abaa"</span>，<span class="attr">word2</span> = <span class="string">"caaa"</span></span><br><span class="line">- 从 word2 中取第一个字符：<span class="attr">merge</span> = <span class="string">"cbc"</span>，<span class="attr">word1</span> = <span class="string">"abaa"</span>，<span class="attr">word2</span> = <span class="string">"aaa"</span></span><br><span class="line">- 从 word1 中取第一个字符：<span class="attr">merge</span> = <span class="string">"cbca"</span>，<span class="attr">word1</span> = <span class="string">"baa"</span>，<span class="attr">word2</span> = <span class="string">"aaa"</span></span><br><span class="line">- 从 word1 中取第一个字符：<span class="attr">merge</span> = <span class="string">"cbcab"</span>，<span class="attr">word1</span> = <span class="string">"aa"</span>，<span class="attr">word2</span> = <span class="string">"aaa"</span></span><br><span class="line">- 将 word1 和 word2 中剩下的 <span class="number">5</span> 个 a 附加到 merge 的末尾。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">word1</span> = <span class="string">"abcabc"</span>, <span class="attr">word2</span> = <span class="string">"abdcaba"</span></span><br><span class="line">输出：<span class="string">"abdcabcabcaba"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 3000</code></li><li><code>word1</code> 和 <code>word2</code>仅由小写英文组成</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-merge-of-two-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-merge-of-two-strings/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目刚开始写错了，首先我们分析一下，采用双指针<code>l1,l2</code>分别指向字符串<code>word1</code>和字符串<code>word2</code>，如果当前字符满足$word1[l1] &gt; word2[l2]$,则我们将<code>l1 + 1</code>；如果当前满足$word1[l1] &lt; word2[l2]$,则此时我们将<code>l2 + 1</code>；如果满足$word1[l1] = word2[l2]$时，此时我们到底是选择<code>l1 + 1</code>还是<code>l2+1</code>,这个是值得思考的问题。</li><li>此时我们根据贪心算法，选择剩余的字符串的字典序最大的优先选择，解法很简单，但是感觉证明还是挺难的，不过后来还是仔细思考了一下，想通了这个题目如何证明通过此贪心法得到的结果即为最优解，可以通过反证法即可。</li><li>时间复杂度为$O(n^{2})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestMerge</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; word1.size() &amp;&amp; l2 &lt; word2.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.substr(l1) &gt; word2.substr(l2))&#123;</span><br><span class="line">                ans.push_back(word1[l1]);</span><br><span class="line">                l1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(word2[l2]);</span><br><span class="line">                l2++;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; word1.size())&#123;</span><br><span class="line">            ans.push_back(word1[l1]);</span><br><span class="line">            l1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 &lt; word2.size())&#123;</span><br><span class="line">            ans.push_back(word2[l2]);</span><br><span class="line">            l2++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1755-最接近目标值的子序列和"><a href="#1755-最接近目标值的子序列和" class="headerlink" title="1755. 最接近目标值的子序列和"></a>1755. 最接近目标值的子序列和</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 和一个目标值<code>goal</code> 。<br>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 sum ，你需要 最小化绝对差 <code>abs(sum - goal)</code> 。<br>返回 <code>abs(sum - goal)</code> 可能的 最小值 。<br>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">-7</span>,<span class="number">3</span>,<span class="number">5</span>], goal = <span class="number">6</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：选择整个数组作为选出的子序列，元素和为 <span class="number">6</span> 。</span><br><span class="line">子序列和与目标值相等，所以绝对差为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">-9</span>,<span class="number">15</span>,<span class="number">-2</span>], goal = <span class="number">-5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：选出子序列 [<span class="number">7</span>,<span class="number">-9</span>,<span class="number">-2</span>] ，元素和为 <span class="number">-4</span> 。</span><br><span class="line">绝对差为 abs(<span class="number">-4</span> - (<span class="number">-5</span>)) = abs(<span class="number">1</span>) = <span class="number">1</span> ，是可能的最小值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], goal = <span class="number">-7</span></span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 40</code></li><li><code>-107 &lt;= nums[i] &lt;= 107</code></li><li><code>-109 &lt;= goal &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/closest-subsequence-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/closest-subsequence-sum</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们假如直接通过暴力求解的话，则可以知道算法的时间复杂度为$O(2^{n})$,此时根据题目中的数据量来看必然会超时，此时我们就需要另辟蹊径去降低时间复杂度。</li><li>我们可以将数据分为长度相等的前后两部分，则此时我们首先可以根据位图来求出前半部分数组的所有的可能的和的组合，我们将前半部分的所有子序列的和按照大小进行排序，则此时我们可以进行遍历后半部分的所有子序列的组合$rsum[i]$时，则我们在前半部分的和中搜索最接近$goal - rsum[i]$的两个数$lowerx,upperx$,则此时我们通过筛选则能够筛选出所有的最可能接近的组合。</li><li>空间复杂度为$O(2^{\frac{n}{2}})$,时间复杂度为$O((\frac{n}{2})^{2}*2^{\frac{n}{2}}$，在此数据量的前提下，时间限制基本可以接受。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">abs</span>(goal);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*left half*/</span></span><br><span class="line">        left.insert(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) sum += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            left.insert(sum);</span><br><span class="line">            ans = min(ans,<span class="built_in">abs</span>(sum-goal));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*right half*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;(n-m)); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) sum += nums[j+m];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> x = goal - sum;</span><br><span class="line">            <span class="keyword">auto</span> it = left.lower_bound(x);</span><br><span class="line">            <span class="keyword">if</span>(it == left.end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(*it + sum - goal));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == left.begin())&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(*it + sum - goal));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(*it + sum - goal));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(*it + sum - goal));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-227&quot;&gt;&lt;a href=&quot;#leetcode-contest-227&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 227&quot;&gt;&lt;/a&gt;leetcode  contest 227&lt;/h1&gt;&lt;p&gt;周赛的题目还是挺难的，竟然只做出来了三道题目，最后一题还是没有能够做出来。&lt;/p&gt;&lt;h2 id=&quot;5672-检查数组是否经排序和轮转得到&quot;&gt;&lt;a href=&quot;#5672-检查数组是否经排序和轮转得到&quot; class=&quot;headerlink&quot; title=&quot;5672. 检查数组是否经排序和轮转得到&quot;&gt;&lt;/a&gt;5672. 检查数组是否经排序和轮转得到&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;code&gt;nums&lt;/code&gt; 的源数组中，所有元素与 &lt;code&gt;nums&lt;/code&gt;相同，但按非递减顺序排列。&lt;/p&gt;&lt;p&gt;如果 &lt;code&gt;nums&lt;/code&gt; 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 45</title>
    <link href="http://yoursite.com/2021/02/06/252/"/>
    <id>http://yoursite.com/2021/02/06/252/</id>
    <published>2021-02-06T15:27:41.693Z</published>
    <updated>2021-02-07T05:04:46.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-45"><a href="#leetcode-biweekly-contest-45" class="headerlink" title="leetcode  biweekly contest 45"></a>leetcode  biweekly contest 45</h1><p>双周赛的题目质量还是非常不错的，终于又能<code>ak</code>一次，还是不错的，不过题目整体来说还是偏简单，不是特别有区分度，前三题全部都是水题，最后一题也是常规的<code>dp</code>题目。<br><img src="https://i.loli.net/2021/02/07/5E18o69BkrIameK.png" alt></p><h2 id="5657-唯一元素的和"><a href="#5657-唯一元素的和" class="headerlink" title="5657. 唯一元素的和"></a>5657. 唯一元素的和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。数组中唯一元素是那些只出现 恰好一次 的元素。</p><a id="more"></a><p>请你返回 <code>nums</code>中唯一元素的 和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：唯一元素为 [<span class="number">1</span>,<span class="number">3</span>] ，和为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有唯一元素，和为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：唯一元素为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，和为 <span class="number">15</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/sum-of-unique-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-45/problems/sum-of-unique-elements/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力遍历，签到题目<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">101</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            count[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] == <span class="number">1</span>) ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5658-任意子数组和的绝对值的最大值"><a href="#5658-任意子数组和的绝对值的最大值" class="headerlink" title="5658. 任意子数组和的绝对值的最大值"></a>5658. 任意子数组和的绝对值的最大值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。一个子数组 <code>[numsl, numsl+1, ..., numsr-1, numsr]</code>的 和的绝对值 为 <code>abs(numsl + numsl+1 + ... + numsr-1 + numsr)</code> 。</p><p>请你找出 <code>nums</code>中 和的绝对值 最大的任意子数组（可能为空），并返回该 最大值 。</p><p><code>abs(x)</code> 定义如下：</p><ul><li>如果 x 是负整数，那么 <code>abs(x) = -x</code> 。</li><li>如果 x 是非负整数，那么<code>abs(x) = x</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：子数组 [<span class="number">2</span>,<span class="number">3</span>] 和的绝对值最大，为 abs(<span class="number">2</span>+<span class="number">3</span>) = abs(<span class="number">5</span>) = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">-5</span>,<span class="number">1</span>,<span class="number">-4</span>,<span class="number">3</span>,<span class="number">-2</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：子数组 [<span class="number">-5</span>,<span class="number">1</span>,<span class="number">-4</span>] 和的绝对值最大，为 abs(<span class="number">-5</span>+<span class="number">1</span><span class="number">-4</span>) = abs(<span class="number">-8</span>) = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/maximum-absolute-sum-of-any-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-45/problems/maximum-absolute-sum-of-any-subarray/</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 前缀和的变形</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>我们记录下前<code>i</code>项的所有前缀和的最小值和最大值为<code>maxpresum[i]</code>,<code>minpresum[i]</code>,则我们对数组进行遍历，遍历到第<code>i+1</code>时我们测试<script type="math/tex; mode=display">ans = max(ans,max(abs(presum[i+1]-maxpresum[i]),abs(presum[i+1]-minpresum[i])))</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAbsoluteSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line">        pre.insert(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += nums[i];</span><br><span class="line">            ans = max(ans,<span class="built_in">abs</span>(curr - *pre.begin()));</span><br><span class="line">            ans = max(ans,<span class="built_in">abs</span>(curr - *pre.rbegin()));</span><br><span class="line">            pre.insert(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5659-删除字符串两端相同字符后的最短长度"><a href="#5659-删除字符串两端相同字符后的最短长度" class="headerlink" title="5659. 删除字符串两端相同字符后的最短长度"></a>5659. 删除字符串两端相同字符后的最短长度</h2><p>给你一个只包含字符 ‘a’，’b’ 和 ‘c’ 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次：</p><ul><li>选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。</li><li>选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。</li><li>前缀和后缀在字符串中任意位置都不能有交集。</li><li>前缀和后缀包含的所有字符都要相同。</li><li>同时删除前缀和后缀。<br>请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"ca"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你没法删除任何一个字符，所以字符串长度仍然保持不变。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"cabaabac"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最优操作序列为：</span><br><span class="line">- 选择前缀 <span class="string">"c"</span> 和后缀 <span class="string">"c"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"abaaba"</span> 。</span><br><span class="line">- 选择前缀 <span class="string">"a"</span> 和后缀 <span class="string">"a"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"baab"</span> 。</span><br><span class="line">- 选择前缀 <span class="string">"b"</span> 和后缀 <span class="string">"b"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"aa"</span> 。</span><br><span class="line">- 选择前缀 <span class="string">"a"</span> 和后缀 <span class="string">"a"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">""</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"aabccabba"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最优操作序列为：</span><br><span class="line">- 选择前缀 <span class="string">"aa"</span> 和后缀 <span class="string">"a"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"bccabb"</span> 。</span><br><span class="line">- 选择前缀 <span class="string">"b"</span> 和后缀 <span class="string">"bb"</span> 并删除它们，得到 <span class="attr">s</span> = <span class="string">"cca"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li>s 只包含字符 ‘a’，’b’ 和 ‘c’ </li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/minimum-length-of-string-after-deleting-similar-ends/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-45/problems/minimum-length-of-string-after-deleting-similar-ends/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 双指针</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>记录下所有连续相同的字符和相同字符的长度，采用双指针，判断首尾的字符是否相等，如果相等则分别减去其长度，否则则终止。</li><li>需要特殊处理的是如果只剩下一个字符，则此时只能返回<code>1</code>。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLength</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = i;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == s[curr]) i++;</span><br><span class="line">            arr.push_back(make_pair(s[curr],i-curr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = arr.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l].first == arr[r].first)&#123;</span><br><span class="line">                ans -= arr[l].second;</span><br><span class="line">                ans -= arr[r].second;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[l].second == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5660-最多可以参加的会议数目"><a href="#5660-最多可以参加的会议数目" class="headerlink" title="5660. 最多可以参加的会议数目"></a>5660. 最多可以参加的会议数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>events</code> 数组，其中 <code>events[i] = [startDayi, endDayi, valuei]</code> ，表示第 i 个会议在 <code>startDayi</code> 天开始，第 endDayi 天结束，如果你参加这个会议，你能得到价值 <code>valuei</code> 。同时给你一个整数 k 表示你能参加的最多会议数目。</p><p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 完整 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p><p>请你返回能得到的会议价值 最大和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：选择绿色的活动会议 <span class="number">0</span> 和 <span class="number">1</span>，得到总价值和为 <span class="number">4</span> + <span class="number">3</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>]], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：参加会议 <span class="number">2</span> ，得到价值和为 <span class="number">10</span> 。</span><br><span class="line">你没法再参加别的会议了，因为跟会议 <span class="number">2</span> 有重叠。你 不 需要参加满 k 个会议。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：尽管会议互不重叠，你只能参加 <span class="number">3</span> 个会议，所以选择价值最大的 <span class="number">3</span> 个会议。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= events.length</code></li><li><code>1 &lt;= k * events.length &lt;= 106</code></li><li><code>1 &lt;= startDayi &lt;= endDayi &lt;= 109</code></li><li><code>1 &lt;= valuei &lt;= 106</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-45/problems/maximum-number-of-events-that-can-be-attended-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-45/problems/maximum-number-of-events-that-can-be-attended-ii/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>依然为经典的<code>dp</code>,不过要稍微复杂点，我们首先要按照会议结束的时间的先后进行排序，我们设<code>dp[i][j]</code>表示从前<code>i</code>个会议中选取<code>j</code>个会议召开的最大价值。首先我们知道如果不选则第<code>i</code>个会议时，则加递推公式为:<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j],dp[i-1][min(i-1,j)])</script></li><li>假如选择第<code>i</code>个会议时，则我们知道已经选择的前<code>j-1</code>个会议的结束时间都必须小于第<code>i</code>个会议的起始时间才可以，则此时我们可以利用二分查找很快的找到小于第<code>i</code>个会议起始时间$start_{i}$的最大索引<code>x</code>，则此时的递推公式为:<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j],dp[x][min(x,j-1)] + events[i][2])</script></li><li>我们最终返回<code>dp[n][k]</code>即为所需的最大值，空间复杂度为$O(nk)$,时间复杂度为$O(nklgn)$<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>结束时间排序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = events.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        sort(events.begin(),events.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr.push_back(events[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*initial*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][min(i<span class="number">-1</span>,j)];</span><br><span class="line">                <span class="keyword">int</span> idx = upper_bound(arr.begin(),arr.end(),events[i<span class="number">-1</span>][<span class="number">0</span>]<span class="number">-1</span>) - arr.begin() - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[idx+<span class="number">1</span>][min(idx+<span class="number">1</span>,j<span class="number">-1</span>)] + events[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>开始时间排序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 依然为经典的`dp`,不过要稍微复杂点，我们首先要按照会议结束的时间的先后进行排序，我们设`dp[i][j]`表示从前`i`个会议中选取`j`个会议召开的最大价值。首先我们知道如果不选则第`i`个会议时，则加递推公式为:</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][min(i<span class="number">-1</span>,j)])</span><br><span class="line">$$</span><br><span class="line"><span class="number">2.</span> 假如选择第`i`个会议时，则我们知道已经选择的前`j<span class="number">-1</span>`个会议的结束时间都必须小于第`i`个会议的起始时间才可以，则此时我们可以利用二分查找很快的找到小于第`i`个会议起始时间$start_&#123;i&#125;$的最大索引`x`，则此时的递推公式为:</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = max(dp[i][j],dp[x][min(x,j<span class="number">-1</span>)] + events[i][<span class="number">2</span>])</span><br><span class="line">$$</span><br><span class="line"><span class="number">3.</span> 按照会议开始时间排序的解法类似第`<span class="number">2</span>`种。</span><br><span class="line"><span class="number">4.</span> 我们最终返回`dp[n][k]`即为所需的最大值，空间复杂度为$O(nk)$,时间复杂度为$O(nklgn)$</span><br><span class="line">+ 结束时间排序:</span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxValue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = events.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        sort(events.begin(),events.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr.push_back(events[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*initial*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][min(i<span class="number">-1</span>,j)];</span><br><span class="line">                <span class="keyword">int</span> idx = upper_bound(arr.begin(),arr.end(),events[i<span class="number">-1</span>][<span class="number">0</span>]<span class="number">-1</span>) - arr.begin() - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[idx+<span class="number">1</span>][min(idx+<span class="number">1</span>,j<span class="number">-1</span>)] + events[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>开始时间排序:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = events.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        sort(events.begin(),events.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) arr.push_back(events[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; j &lt;= (n-i); ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][min(j,n-i<span class="number">-1</span>)];</span><br><span class="line">                <span class="keyword">int</span> idx = upper_bound(arr.begin(),arr.end(),events[i][<span class="number">1</span>]) - arr.begin();</span><br><span class="line">                dp[i][j] = max(dp[i][j],dp[idx][min(n-idx,j<span class="number">-1</span>)] + events[i][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-45&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-45&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 45&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 45&lt;/h1&gt;&lt;p&gt;双周赛的题目质量还是非常不错的，终于又能&lt;code&gt;ak&lt;/code&gt;一次，还是不错的，不过题目整体来说还是偏简单，不是特别有区分度，前三题全部都是水题，最后一题也是常规的&lt;code&gt;dp&lt;/code&gt;题目。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/07/5E18o69BkrIameK.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5657-唯一元素的和&quot;&gt;&lt;a href=&quot;#5657-唯一元素的和&quot; class=&quot;headerlink&quot; title=&quot;5657. 唯一元素的和&quot;&gt;&lt;/a&gt;5657. 唯一元素的和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。数组中唯一元素是那些只出现 恰好一次 的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【CSAPP】 Lab4</title>
    <link href="http://yoursite.com/2021/02/05/251/"/>
    <id>http://yoursite.com/2021/02/05/251/</id>
    <published>2021-02-05T03:28:45.045Z</published>
    <updated>2021-02-17T04:12:45.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-lab4-archlab"><a href="#CSAPP-lab4-archlab" class="headerlink" title="CSAPP lab4 archlab"></a>CSAPP lab4 archlab</h1><p><code>lab</code>真心难，这一章的体系结构部分还是真心很难，总共分为<code>parta、partb、partc</code>三部分，三部分都还挺难的，<code>parta,partb</code>部分还算比较容易,<code>partc</code>部分真心还是挺难的，需要仔细了解和学习相关知识。自我感觉学习还是非常有成效的，特别是之前做过《from nand to tetris》部分的课程还是有非常大的帮助，通过课程的学习对于体系结构和底层的汇编指令都有了一个初步的入门和学习。<br>首先需要了解一下<code>y86</code>的指令集如下:<br><img src="https://i.loli.net/2021/02/05/bVG6Wa9runO8DpR.png" alt><br><img src="https://i.loli.net/2021/02/05/3aZrcPGX2u7gM4Q.png" alt><br>基本上目前教材中已经给出的指令与指令详细的描述和指令字上如上图所示。</p><a id="more"></a><ul><li>有4个整数操作指令。对应表中的OPq，分别是addq, subq, andq, xorq。它们只对寄存器数据操作，同时还会设置条件码。</li><li>这里有7个跳转指令，就是图中的jXX。根据条件码来设置分支条件并进行跳转，分支条件和X86-64一样。</li><li>有6个条件传送指令，图示的cmovXX，这些指令格式和寄存器-寄存器传送指令一样，但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。</li><li>call指令和ret指令同X86-64一致，pushq和popq亦是如此</li><li>halt指令终止程序运行，并将状态码设置为HLT。<br>其中关于流水线的部分感觉过于晦涩，可以参考CSDN的中文翻译，质量很不错。<br><a href="https://blog.csdn.net/weixin_39997311/article/details/110458772" target="_blank" rel="noopener">处理器体系结构</a><h2 id="parta"><a href="#parta" class="headerlink" title="parta"></a>parta</h2>Write a Y86-64 program sum.ys that iteratively sums the elements of a linked list. Your program should<br>consist of some code that sets up the stack structure, invokes a function, and then halts. In this case,<br>the function should be Y86-64 code for a function (sum list) that is functionally equivalent to the C<br>sum list function in Figure 1. Test your program using the following three-element list:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linked list element */</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">typedef</span> struct ELE &#123;</span><br><span class="line"><span class="number">3</span> long val;</span><br><span class="line"><span class="number">4</span> struct ELE *next;</span><br><span class="line"><span class="number">5</span> &#125; *list_ptr;</span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="comment">/* sum_list - Sum the elements of a linked list */</span></span><br><span class="line"><span class="number">8</span> long sum_list(list_ptr ls)</span><br><span class="line"><span class="number">9</span> &#123;</span><br><span class="line"><span class="number">10</span> long val = <span class="number">0</span>;</span><br><span class="line"><span class="number">11</span> <span class="keyword">while</span> (ls) &#123;</span><br><span class="line"><span class="number">12</span> val += ls-&gt;val;</span><br><span class="line"><span class="number">13</span> ls = ls-&gt;next;</span><br><span class="line"><span class="number">14</span> &#125;</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span> val;</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="comment">/* rsum_list - Recursive version of sum_list */</span></span><br><span class="line"><span class="number">19</span> long rsum_list(list_ptr ls)</span><br><span class="line"><span class="number">20</span> &#123;</span><br><span class="line"><span class="number">21</span> <span class="keyword">if</span> (!ls)</span><br><span class="line"><span class="number">22</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">24</span> long val = ls-&gt;val;</span><br><span class="line"><span class="number">25</span> long rest = rsum_list(ls-&gt;next);</span><br><span class="line"><span class="number">26</span> <span class="keyword">return</span> val + rest;</span><br><span class="line"><span class="number">27</span> &#125;</span><br><span class="line"><span class="number">28</span> &#125;</span><br><span class="line"><span class="number">29</span></span><br><span class="line"><span class="number">30</span> <span class="comment">/* copy_block - Copy src to dest and return xor checksum of src */</span></span><br><span class="line"><span class="number">31</span> long copy_block(long *src, long *dest, long len)</span><br><span class="line"><span class="number">32</span> &#123;</span><br><span class="line"><span class="number">33</span> long result = <span class="number">0</span>;</span><br><span class="line"><span class="number">34</span> <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">35</span> long val = *src++;</span><br><span class="line"><span class="number">36</span> *dest++ = val;</span><br><span class="line"><span class="number">37</span> result ˆ= val;</span><br><span class="line"><span class="number">38</span> len--;</span><br><span class="line"><span class="number">39</span> &#125;</span><br><span class="line"><span class="number">40</span> <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">41</span> &#125;</span><br></pre></td></tr></table></figure>针对上述的三个函数<code>sum_list</code>,<code>rsum_list</code>,<code>copy_block</code>这三个函数用<code>y86</code>的汇编实现出来，并完成通过测试用例。</li><li><code>sum_list</code>: 这个函数实现起来非常简单，我们直接用常规的几个指令即可完成，无非是有一个<code>loop</code>和判断条件。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin code-yso */</span></span><br><span class="line"><span class="comment">/* $begin code-ysa */</span></span><br><span class="line"># Execution begins at address <span class="number">0</span> </span><br><span class="line">.pos <span class="number">0</span> </span><br><span class="line">init:irmovl Stack, %esp  # Set up <span class="built_in">stack</span> pointer  </span><br><span class="line">irmovl Stack, %ebp  # Set up base pointer   </span><br><span class="line">call Main# Execute main program</span><br><span class="line">halt# Terminate program </span><br><span class="line"></span><br><span class="line"># Sample linked <span class="built_in">list</span></span><br><span class="line">    .align <span class="number">4</span></span><br><span class="line">ele1:   </span><br><span class="line">    .<span class="keyword">long</span> <span class="number">0x00a</span></span><br><span class="line">    .<span class="keyword">long</span> ele2</span><br><span class="line">ele2:   </span><br><span class="line">    .<span class="keyword">long</span> <span class="number">0x0b0</span></span><br><span class="line">    .<span class="keyword">long</span> ele3</span><br><span class="line">ele3:   </span><br><span class="line">    .<span class="keyword">long</span> <span class="number">0xc00</span></span><br><span class="line">    .<span class="keyword">long</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Main:pushl %ebp </span><br><span class="line">rrmovl %esp,%ebp</span><br><span class="line">irmovl ele1,%edx</span><br><span class="line">pushl %edx      # Push linklist head</span><br><span class="line">call sum_list# Sum(<span class="built_in">array</span>, <span class="number">4</span>)</span><br><span class="line">rrmovl %ebp,%esp</span><br><span class="line">popl %ebp</span><br><span class="line">ret </span><br><span class="line"></span><br><span class="line">sum_list:   pushl %ebp</span><br><span class="line">rrmovl %esp,%ebp</span><br><span class="line">    mrmovl <span class="number">8</span>(%ebp),%ebx <span class="meta"># eax = header, move list header to the register;</span></span><br><span class="line">    irmovl $<span class="number">0</span>,%eax            <span class="meta"># sum = 0;</span></span><br><span class="line">    irmovl <span class="number">4</span>,%ecx</span><br><span class="line">Loop:   mrmovl (%ebx),%esi<span class="meta"># get val</span></span><br><span class="line">    addl %esi,%eax</span><br><span class="line">addl %ecx,%ebx          <span class="meta"># list = list-&gt;next;</span></span><br><span class="line">    mrmovl (%ebx),%edx</span><br><span class="line">    rrmovl %edx,%ebx</span><br><span class="line">    andl   %ebx,%ebx</span><br><span class="line">    jne Loop</span><br><span class="line">End:rrmovl %ebp,%esp</span><br><span class="line">popl %ebp</span><br><span class="line">    ret</span><br><span class="line">    .pos <span class="number">0x200</span></span><br><span class="line">Stack:# The <span class="built_in">stack</span> goes here</span><br></pre></td></tr></table></figure>运行结果如下：<br><img src="https://i.loli.net/2021/02/05/hmSgNG5c9UrzIOl.png" alt></li><li><code>rsum_list</code>: 这个链表遍历是用递归实现的，因此稍微复杂一些，因为用到递归则寄存器<code>esi</code>存在重入的风险，因此此时我们则需要降每次取出的<code>val</code>压入到栈中，待到当前的函数调用结束后，再降其从栈中弹出上一次计算的值，与函数返回的值进行相加即可得到本次函数返回值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin code-yso */</span></span><br><span class="line"><span class="comment">/* $begin code-ysa */</span></span><br><span class="line"># Execution begins at address <span class="number">0</span> </span><br><span class="line">.pos <span class="number">0</span> </span><br><span class="line">init:irmovl Stack, %esp  # Set up <span class="built_in">stack</span> pointer  </span><br><span class="line">irmovl Stack, %ebp  # Set up base pointer   </span><br><span class="line">call Main# Execute main program</span><br><span class="line">halt# Terminate program </span><br><span class="line"></span><br><span class="line"># Sample linked <span class="built_in">list</span></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">ele1:</span><br><span class="line">    .<span class="keyword">long</span> <span class="number">0x00a</span></span><br><span class="line">    .<span class="keyword">long</span> ele2</span><br><span class="line">ele2:</span><br><span class="line">    .<span class="keyword">long</span> <span class="number">0x0b0</span></span><br><span class="line">    .<span class="keyword">long</span> ele3</span><br><span class="line">ele3:</span><br><span class="line">    .<span class="keyword">long</span> <span class="number">0xc00</span></span><br><span class="line">    .<span class="keyword">long</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Main:pushl %ebp </span><br><span class="line">rrmovl %esp,%ebp</span><br><span class="line">irmovl ele1,%edx</span><br><span class="line">pushl %edx      # Push linklist head</span><br><span class="line">call rsum_list# Sum(<span class="built_in">array</span>, <span class="number">4</span>)</span><br><span class="line">rrmovl %ebp,%esp</span><br><span class="line">popl %ebp</span><br><span class="line">ret </span><br><span class="line"></span><br><span class="line">rsum_list:   pushl %ebp</span><br><span class="line">rrmovl %esp,%ebp</span><br><span class="line">    mrmovl <span class="number">8</span>(%ebp),%ebx <span class="meta"># ebx = header, move list header to the register;</span></span><br><span class="line">    xorl   %eax,%eax        <span class="meta"># eax = 0 </span></span><br><span class="line">    andl   %ebx,%ebx        <span class="meta"># ebx = 0 </span></span><br><span class="line">    je End</span><br><span class="line">    pushl  %esi             <span class="meta"># esi = val</span></span><br><span class="line">    mrmovl (%ebx),%esi<span class="meta"># get val</span></span><br><span class="line">    mrmovl <span class="number">4</span>(%ebx),%edx<span class="meta"># get val    </span></span><br><span class="line">    pushl  %edx</span><br><span class="line">    call   rsum_list</span><br><span class="line">    popl   %edx     </span><br><span class="line">    addl   %esi,%eax</span><br><span class="line">    popl   %esi</span><br><span class="line">End:rrmovl %ebp,%esp</span><br><span class="line">popl %ebp</span><br><span class="line">    ret</span><br><span class="line">    .pos <span class="number">0x200</span></span><br><span class="line">Stack:# The <span class="built_in">stack</span> goes here</span><br></pre></td></tr></table></figure>运行结果如下:<br><img src="https://i.loli.net/2021/02/05/TjNknOHeFzC7pYb.png" alt></li><li><code>copy_block</code>: 这个就更简单了，就是基本的拷贝和复制，用好几种寻址方式即可。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/* $begin code-yso */</span><br><span class="line">/* $begin code-ysa */</span><br><span class="line"><span class="comment"># Execution begins at address 0 </span></span><br><span class="line">.pos <span class="number">0</span> </span><br><span class="line">init:irmovl Stack, %esp  <span class="comment"># Set up stack pointer  </span></span><br><span class="line">irmovl Stack, %ebp  <span class="comment"># Set up base pointer   </span></span><br><span class="line">call Main<span class="comment"># Execute main program</span></span><br><span class="line">halt<span class="comment"># Terminate program </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source block</span></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">src:</span><br><span class="line">    .long <span class="number">0x00a</span></span><br><span class="line">    .long <span class="number">0x0b0</span></span><br><span class="line">    .long <span class="number">0xc00</span></span><br><span class="line"><span class="comment"># Destination block</span></span><br><span class="line">dest:</span><br><span class="line">    .long <span class="number">0x111</span></span><br><span class="line">    .long <span class="number">0x222</span></span><br><span class="line">    .long <span class="number">0x333</span></span><br><span class="line"></span><br><span class="line">Main:pushl %ebp </span><br><span class="line">rrmovl %esp,%ebp</span><br><span class="line">    irmovl $<span class="number">3</span>,%edx</span><br><span class="line">pushl %edx      <span class="comment"># Push linklist head</span></span><br><span class="line">    irmovl dest,%edx</span><br><span class="line">    pushl %edx</span><br><span class="line">    irmovl src,%edx</span><br><span class="line">    pushl %edx</span><br><span class="line">call copy_block<span class="comment"># Sum(array, 4)</span></span><br><span class="line">rrmovl %ebp,%esp</span><br><span class="line">popl %ebp</span><br><span class="line">ret </span><br><span class="line"></span><br><span class="line">copy_block:   pushl %ebp</span><br><span class="line">rrmovl %esp,%ebp</span><br><span class="line">    mrmovl <span class="number">8</span>(%ebp),%ebx <span class="comment"># ebx = src ;</span></span><br><span class="line">    mrmovl <span class="number">12</span>(%ebp),%ecx <span class="comment"># ecx = dst ;</span></span><br><span class="line">    mrmovl <span class="number">16</span>(%ebp),%edx <span class="comment"># edx = len;</span></span><br><span class="line">    xorl   %eax,%eax</span><br><span class="line">    andl   %edx,%edx</span><br><span class="line">    jle  End</span><br><span class="line">Loop:    mrmovl (%ebx),%esi<span class="comment"># get src</span></span><br><span class="line">    rmmovl %esi,(%ecx)  <span class="comment"># dst = src</span></span><br><span class="line">    xorl   %esi,%eax    <span class="comment"># result = result^vald</span></span><br><span class="line">    irmovl $<span class="number">4</span>,%esi</span><br><span class="line">    addl   %esi,%ebx    <span class="comment"># dst++</span></span><br><span class="line">    addl   %esi,%ecx    <span class="comment"># src++</span></span><br><span class="line">    irmovl $<span class="number">-1</span>,%esi    </span><br><span class="line">    addl   %esi,%edx    <span class="comment"># len--</span></span><br><span class="line">    jg Loop</span><br><span class="line">End:rrmovl %ebp,%esp</span><br><span class="line">popl %ebp</span><br><span class="line">    ret</span><br><span class="line">    .pos <span class="number">0x200</span></span><br><span class="line">Stack:<span class="comment"># The stack goes here</span></span><br></pre></td></tr></table></figure>运行结果如下：<br><img src="https://i.loli.net/2021/02/05/HhVydEMFLgYsBvG.png" alt><h2 id="partb"><a href="#partb" class="headerlink" title="partb"></a>partb</h2>Your task in Part B is to extend the SEQ processor to support the iaddq, described in Homework problems<br>4.51 and 4.52. To add this instructions, you will modify the file seq-full.hcl, which implements the<br>version of SEQ described in the CS:APP3e textbook. In addition, it contains declarations of some constants<br>that you will need for your solution.<br>这部分需要你在<code>seq</code>处理器中实现<code>leave</code>和<code>iaddl</code>指令。我们知道按照<code>seq</code>的指令执行过程一般分为:<br><code>fetch</code>,<code>decode</code>,<code>Execute</code>,<code>Memory</code>,<code>Write back</code>,<code>PC update</code>等几个阶段，每个阶段都需要设置不同的标志位。因为在<code>y86</code>的指令集中为变长指令，所有的指令集都可可能是<h3 id="iaddl"><a href="#iaddl" class="headerlink" title="iaddl"></a>iaddl</h3></li><li><code>iaddl</code>指令：即实现立即数与寄存器的值进行相加，结果存储在寄存器中。指令形式如下：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iaddl C,rB</span><br><span class="line">rB = C + rB</span><br></pre></td></tr></table></figure>指令的翻译过程为:<br>| stage|iaddl V,rB|<br>|—-|——|<br>|fetch|icode:ifun ← M1[PC]<br>rA:rB ← M1[PC + 1] <br>valC ← M4[PC + 2]<br>valP ← PC + 6|<br>|decode|valB ← R[rb]|<br>|Execute|valE ← valC + valB|<br>|Memory||<br>|Write back|r[rb] ← valE|<br>|PC update|PC ← valP|<h3 id="leave"><a href="#leave" class="headerlink" title="leave:"></a>leave:</h3></li><li><code>leave</code>指令的翻译就较为复杂，首先我们来看一下<code>leave</code>指令的实际执行过程<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl <span class="built_in">%ebp</span>,<span class="built_in">%esp</span></span><br><span class="line">popl <span class="built_in">%ebp</span></span><br></pre></td></tr></table></figure>首先将当前的基值寄存器中的值写入到栈寄存器，然后将栈顶的数据写入到基质寄存器中，然后栈寄存器加<code>4</code>，实际我们可以如下翻译:<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">%ebp</span>_new = (<span class="built_in">%esp</span>_odd)</span><br><span class="line"><span class="built_in">%esp</span>_new = <span class="built_in">%esp</span>_odd + <span class="number">4</span></span><br></pre></td></tr></table></figure>指令的翻译过程为:<br>| stage|leave|<br>|—-|——|<br>|fetch|icode:ifun ← M1[PC]<br>valP ← PC + 1|<br>|decode|valA ← R[%esp]|<br>|Execute|valE ← 4 + valA|<br>|Memory|valM ← M4[valA]|<br>|Write back|R[%esp] ← valE<br>R[%ebp] ← valM|<br>|PC update|PC ← valP|<br>即将当前基址寄存器中的数据写入到栈寄存器中，感觉还是挺不容易理解的，对于指令的翻译过程其实蛮有意思的，需要对<code>HCL</code>语言有基本的熟悉过程即可。就是几个阶段的数据要弄清楚即可，必须寻址阶段的地址非常有必要的学习，还有<code>ALU</code>的使用，写会操作等等。<h2 id="partc"><a href="#partc" class="headerlink" title="partc"></a>partc</h2>You will be working in directory sim/pipe in this part.<br>The ncopy function in Figure 2 copies a len-element integer array src to a non-overlapping dst, returning a count of the number of positive integers contained in src. Figure 3 shows the baseline Y86-64<br>version of ncopy. The file pipe-full.hcl contains a copy of the HCL code for PIPE, along with a<br>declaration of the constant value IIADDQ.<br>Your task in Part C is to modify ncopy.ys and pipe-full.hcl with the goal of making ncopy.ys<br>run as fast as possible.<br>You will be handing in two files: pipe-full.hcl and ncopy.ys. Each file should begin with a header<br><code>partc</code>部分需要对<code>ncopy</code>这段程序翻译后的汇编程序进行流水线优化，从而达到加速效果。根据提示，主要优化方法为将循环进行展开，命令即可进行流水线化，从而节省运行时间。目前对于这个程序主要有两部分可以进行优化，一是尽量避免流水线的数据冒险和控制冒险，二是尽量对循环进行展开，从而可以优化指令，减少运行的指令数。本章对于流水线的深度部分讲的原理还是非常深刻的，特别是对于流水线的运行以及加速原理讲的非常浅显易懂，如因为自己并不是处理器架构方面的资深工程师，对这一部分还是有许多很模糊的概念需要弄明白。</li><li>流水线的基本原理：常规的运行模式我们称之为<code>RTC</code>模式(run to complete)，即从头开始执行到尾然后再开始下一条指令的执行。经典的<code>rtc</code>模式即每条指令执行完成上述的五个阶段<code>fetch、decode、Execute、Memory、Write back</code>之后,跟新<code>pc</code>后，<code>cpu</code>再开始执行下一条指令。因此每条指令需要等待前一条指令的五个阶段全部执行完成后，才开始进入<code>fetch</code>阶段，而流水线的原理则是利用缓存，每个阶段的计算结果完成后先进入缓冲区，再由缓冲区送入到下一个阶段，这样每当当前的<code>stage</code>的结果送入缓存后，我们即可将下一条指令送入到本次的<code>stage</code>中,具体的每个<code>stage</code>的详细处理细节可以参考章节<code>4.3.4</code>。<br>RTC模式：<br><img src="https://i.loli.net/2021/02/17/RuCqaGJYIUv4ntE.jpg" alt><br>Pipeline模式:<br>通过在每个stage处都加入缓存即可实现流水线，因为有缓存的存在，此时我们可以将上一个<code>stage</code>的结果临时存放在缓存中，此时当前的<code>stage</code>即可进行下一条指令，待后一个<code>stage</code>完成后，我们将其从缓存中取出临时结果放入到下一个<code>stage</code>中。如果需要实现<code>pipeline</code>则缓存一定是必须的。<br><img src="https://i.loli.net/2021/02/17/D42VmicUvkaqeX7.jpg" alt><br><img src="https://i.loli.net/2021/02/17/rj5STc6HEfYmq3v.png" alt></li><li>流水的加速比的计算：假设每条指令几个阶段<code>fetch、decode、Execute、Memory、Write back</code>的耗时分别为$t_{0},t_{1},t_{2},t_{3},t_{4}$,则执行一条完整的指令的执行时间为:<script type="math/tex; mode=display">T = t_{0} + t_{1} + t_{2} + t_{3} + t_{4} = \sum_{i=0}^{n}t_{i}</script>如果按照<code>rtc</code>模式的执行的话，如果执行<code>n</code>条指令则需要的总时间为$t = N*T$，如果采用流水线时，则如果执行<code>N</code>条指令则需要的总时间约为:<script type="math/tex; mode=display">t = (n*t_{max}) + (N-1)*t_{max}</script>其中<code>n</code>代表此流水线有<code>n</code>个<code>stage</code>,$t_{max}$代表<code>n</code>个<code>stage</code>中耗时最长的<code>stage</code>.<br>则加速比的计算公式为:<script type="math/tex; mode=display">S = \frac{t_{rtc}}{t_{pipeline}} = \frac{(n*t_{max}) + (N-1)*t_{max}}{N*\sum_{i=0}^{n}t_{i}}</script><img src="https://i.loli.net/2021/02/17/vBbzhYdHaOFiWge.png" alt></li><li>流水线的数据冒险：在流水线的实际运行中某些关联指令可能存在问题，比如下一条指令必须用到上一条指令的运算结果，则此时就出现了数据错误，因为下一条指令在<code>decode</code>阶段时，可能某个寄存器的值还没有在上一个指令中完成更新，则此时计算时肯定存在错误。比如执行以下指令时，如果严格按照执行<code>rrmoveq</code>指令时，此时可能<code>rdx</code>寄存器还未完成跟新，因为第三条在执行<code>decode</code>阶段时，此时第二条指令还在<code>excute</code>阶段，还未到<code>写回</code>阶段，则此时直接读取<code>%rdx</code>寄存器时的值可能是未知的，因此这就意味着风险，此时我们必须将流水线暂停几个<code>stage</code>等待寄存器<code>%rdx</code>完成更新后，我们再执行第三条指令。<br><img src="https://i.loli.net/2021/02/17/v2YHpi4lb9V15rI.png" alt><br>则此时我们需要插入两个空指令等待第二条指令完成<code>写回</code>阶段后，我们即可进行<code>decode</code>阶段。<br><img src="https://i.loli.net/2021/02/17/TtlyzMXK5LJBZsI.png" alt></li><li>流水线的控制冒险：我们知道正常的指令跳转地址为该指令执行完成后，紧挨着的下一条指令，一般情况下我们在取指令阶段即同时预先完成下一条指令地址的更新，但是由于部分指令中存在条件跳转指令，则此时之前在<code>fectch</code>阶段更新的指令地址可能会失效，我们此时就需要重新填入更新的指令地址，则此时我们需要进行指令取消，即在流水线中中止此时已经执行的指令。<br><img src="https://i.loli.net/2021/02/17/o4X2AfaFgLl9Q3w.png" alt><h3 id="unrolling-loop"><a href="#unrolling-loop" class="headerlink" title="unrolling loop"></a>unrolling loop</h3>我们可以参考第<code>5</code>章的优化技术，即对循环进行展开，循环展开的好处有两点，一是可以充分的利用<code>cache</code>，另一方面可以有效的避免数据冒险，即相邻的指令使用同一个寄存器。<br>对于<code>partc</code>部分，主要针对原有的程序进行了如下优化：</li></ul><ol><li>对于循环进行展开，每次我们每次读取<code>4</code>个字节，对每个字节进行分别读取和转存，同时尽可能的避免相邻的指令读取和存储同一个寄存器，从而避免气泡和空指令，从而来加速流水线的执行，由于本课程的工具的限制，本来有<code>15</code>个通用的寄存器，但是不知道为什么它提供的工具竟然不允许用<code>%r8~%r14</code>这<code>5</code>个寄存器。</li><li>使用<code>partb</code>部分的<code>iaddl</code>指令，即可以用一条指令完成之前用三条指令实现。</li><li>感觉本章的许多细节部分还是糊里糊涂，不是特别清楚，只能等待后续有实际的应用场景后再结合实际来研究细节的话，效果才能更好。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">##################################################################</span><br><span class="line"><span class="meta"># ncopy.ys - Copy a src block of len ints to dst.</span></span><br><span class="line"># Return the number of positive ints (&gt;0) contained in src.</span><br><span class="line">#</span><br><span class="line"># Include your name <span class="keyword">and</span> ID here.</span><br><span class="line">#</span><br><span class="line"># Describe how <span class="keyword">and</span> why you modified the baseline code.</span><br><span class="line">#</span><br><span class="line">##################################################################</span><br><span class="line"># Do <span class="keyword">not</span> modify <span class="keyword">this</span> portion</span><br><span class="line"># Function prologue.</span><br><span class="line">ncopy:pushl %ebp# Save old frame pointer</span><br><span class="line">rrmovl %esp,%ebp# Set up <span class="keyword">new</span> frame pointer</span><br><span class="line">pushl %esi# Save callee-save regs</span><br><span class="line">pushl %ebx</span><br><span class="line">pushl %edi</span><br><span class="line">mrmovl <span class="number">8</span>(%ebp),%ebx# src</span><br><span class="line">mrmovl <span class="number">16</span>(%ebp),%edx# len</span><br><span class="line">mrmovl <span class="number">12</span>(%ebp),%ecx# dst</span><br><span class="line"></span><br><span class="line">##################################################################</span><br><span class="line"># You can modify <span class="keyword">this</span> portion</span><br><span class="line"># Loop header</span><br><span class="line">xorl %eax,%eax# count = <span class="number">0</span>;</span><br><span class="line">iaddl $<span class="number">-4</span> , %edx      <span class="meta"># len = len - 4</span></span><br><span class="line">andl %edx,%edx<span class="meta"># len &lt;= 0?</span></span><br><span class="line">jle Remain    <span class="meta"># <span class="meta-keyword">if</span> so, goto Done:</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># loop unrolling </span></span><br><span class="line">Loop:  </span><br><span class="line">mrmovl (%ebx),%esi      <span class="meta"># read val from src</span></span><br><span class="line">mrmovl <span class="number">4</span>(%ebx), %edi    <span class="meta"># read val from src</span></span><br><span class="line">rmmovl %esi, (%ecx)# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">andl %esi, %esi</span><br><span class="line">jle Nop1</span><br><span class="line">iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop1:</span><br><span class="line">rmmovl %edi, <span class="number">4</span>(%ecx)# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">andl %edi, %edi</span><br><span class="line">jle Nop2</span><br><span class="line">iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop2:</span><br><span class="line">iaddl  $<span class="number">-4</span>, %edx        <span class="meta"># len = len - 4</span></span><br><span class="line">mrmovl <span class="number">8</span>(%ebx),%esi      <span class="meta"># read val from src</span></span><br><span class="line">mrmovl <span class="number">12</span>(%ebx), %edi    <span class="meta"># read val from src</span></span><br><span class="line">rmmovl %esi, <span class="number">8</span>(%ecx)# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">andl %esi, %esi</span><br><span class="line">jle Nop3</span><br><span class="line">iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop3:</span><br><span class="line">rmmovl %edi, <span class="number">12</span>(%ecx)# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">andl %edi, %edi</span><br><span class="line">jle Nop4</span><br><span class="line">iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop4:</span><br><span class="line">iaddl  $<span class="number">16</span>, %ebx</span><br><span class="line">iaddl  $<span class="number">16</span>, %ecx</span><br><span class="line">andl   %edx,%edx        <span class="meta"># len &gt; 0 ? </span></span><br><span class="line">jg Loop<span class="meta"># <span class="meta-keyword">if</span> so, goto Loop:</span></span><br><span class="line"></span><br><span class="line">###############<span class="meta">#left element######################################</span></span><br><span class="line">Remain:</span><br><span class="line">iaddl  $<span class="number">4</span>, %edx</span><br><span class="line">andl  %edx,%edx</span><br><span class="line">jle   Done</span><br><span class="line">Nxloop:</span><br><span class="line">mrmovl (%ebx),%esi      <span class="meta"># read val from src</span></span><br><span class="line">iaddl $<span class="number">4</span>,%ebx</span><br><span class="line">iaddl $<span class="number">-1</span>,%edx</span><br><span class="line">rmmovl %esi, (%ecx)# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">iaddl $<span class="number">4</span>,%ecx</span><br><span class="line">andl %esi, %esi</span><br><span class="line">jle Nop5</span><br><span class="line">iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop5:</span><br><span class="line">andl  %edx,%edx</span><br><span class="line">jg Nxloop</span><br><span class="line"></span><br><span class="line">##################################################################</span><br><span class="line"># Do <span class="keyword">not</span> modify the following section of code</span><br><span class="line"># Function epilogue.</span><br><span class="line">Done:</span><br><span class="line">popl %edi               # Restore callee-save registers</span><br><span class="line">popl %ebx</span><br><span class="line">popl %esi</span><br><span class="line">rrmovl %ebp, %esp</span><br><span class="line">popl %ebp</span><br><span class="line">ret</span><br><span class="line">##################################################################</span><br><span class="line"># Keep the following label at the end of your function</span><br><span class="line">End:</span><br><span class="line"># <span class="comment">/* $end ncopy-ys */</span></span><br></pre></td></tr></table></figure>最终的运行的<code>bechmark</code>的结果<code>CPE</code>竟然为<code>1.41</code>，感觉不可思议，应该还是部分地方处理有点问题，不过最终的细节还需要后面仔细的考虑和学习，部分细节也没有更多的时间去思考了，不过由于本身自己并不是做处理器加速的，这块的理论需要很深厚的理论基础，当然作为科普了解一下基本的内容和原理来说还是非常不错的。<br><img src="https://i.loli.net/2021/02/17/TjHPEe7ftI5dr4x.png" alt><br>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSAPP-lab4-archlab&quot;&gt;&lt;a href=&quot;#CSAPP-lab4-archlab&quot; class=&quot;headerlink&quot; title=&quot;CSAPP lab4 archlab&quot;&gt;&lt;/a&gt;CSAPP lab4 archlab&lt;/h1&gt;&lt;p&gt;&lt;code&gt;lab&lt;/code&gt;真心难，这一章的体系结构部分还是真心很难，总共分为&lt;code&gt;parta、partb、partc&lt;/code&gt;三部分，三部分都还挺难的，&lt;code&gt;parta,partb&lt;/code&gt;部分还算比较容易,&lt;code&gt;partc&lt;/code&gt;部分真心还是挺难的，需要仔细了解和学习相关知识。自我感觉学习还是非常有成效的，特别是之前做过《from nand to tetris》部分的课程还是有非常大的帮助，通过课程的学习对于体系结构和底层的汇编指令都有了一个初步的入门和学习。&lt;br&gt;首先需要了解一下&lt;code&gt;y86&lt;/code&gt;的指令集如下:&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/05/bVG6Wa9runO8DpR.png&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/02/05/3aZrcPGX2u7gM4Q.png&quot; alt&gt;&lt;br&gt;基本上目前教材中已经给出的指令与指令详细的描述和指令字上如上图所示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="代码实现" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Atcoder】 Abc  190</title>
    <link href="http://yoursite.com/2021/01/31/250/"/>
    <id>http://yoursite.com/2021/01/31/250/</id>
    <published>2021-01-31T06:22:30.605Z</published>
    <updated>2021-02-03T02:10:38.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="abc-contest-190"><a href="#abc-contest-190" class="headerlink" title="abc  contest 190"></a>abc  contest 190</h1><h2 id="C-Bowls-and-Dishes"><a href="#C-Bowls-and-Dishes" class="headerlink" title="C - Bowls and Dishes"></a>C - Bowls and Dishes</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/01/31/ehj8xNS1EoHfCT7.png" alt></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc190/tasks/abc190_c" target="_blank" rel="noopener">https://atcoder.jp/contests/abc190/tasks/abc190_c</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  回溯遍历</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>因为所有的人都有两种选择，我们直接遍历所有的摆放方法，然后求出每种状态下的得分，即可求出最高的得分。我们用<code>mask</code>来标识状态，如果第<code>i</code>为<code>1</code>则表示第<code>i</code>个<code>people</code>选择第<code>1</code>种摆法，否则则表示第<code>i</code>个<code>people</code>选择第<code>2</code>种摆法。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;sz[find(x)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; y1) swap(x1,y1);</span><br><span class="line">        parent[y1] = x1;</span><br><span class="line">        sz[x1] += sz[y1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; conditions(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;        </span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;conditions[i].first&gt;&gt;conditions[i].second;</span><br><span class="line">        conditions[i].first--;</span><br><span class="line">        conditions[i].second--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; peoples(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;peoples[i].first&gt;&gt;peoples[i].second;</span><br><span class="line">        peoples[i].first--;</span><br><span class="line">        peoples[i].second--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span>&lt;&lt;k); ++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                test[peoples[j].first] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                test[peoples[j].second] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(test[conditions[j].first]&amp;&amp;test[conditions[j].second])&#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,curr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><a id="more"></a><h2 id="D-Staircase-Sequences"><a href="#D-Staircase-Sequences" class="headerlink" title="D - Staircase Sequences"></a>D - Staircase Sequences</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/01/31/s8CFuLDmlz65ZHw.png" alt></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc190/tasks/abc190_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc190/tasks/abc190_d</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质为小学奥数，我们知道如果一个数可以被分解为等差数列则我们可以满足如下<script type="math/tex; mode=display">n = \frac{x*(a + a + x - 1)}{2} = \frac{x*(2a + x - 1)}{2}</script>则表示<code>n</code>一定可以被分解为长度为<code>x</code>的阶差为<code>1</code>的等差数列。<br>$ n = x*y$,如果<code>y</code>可以继续分解为$y = \frac{2a+x-1}{2}$<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;sz[find(x)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; y1) swap(x1,y1);</span><br><span class="line">        parent[y1] = x1;</span><br><span class="line">        sz[x1] += sz[y1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    n = n*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x*x &lt;= n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%x == <span class="number">0</span>)&#123;</span><br><span class="line">            cnt.insert(x);</span><br><span class="line">            cnt.insert(n/x);</span><br><span class="line">        &#125;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        <span class="keyword">int</span> rem = n/v;</span><br><span class="line">        <span class="keyword">if</span>((rem - v + <span class="number">1</span>)%<span class="number">2</span> == <span class="number">0</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="E-Magical-Ornament"><a href="#E-Magical-Ornament" class="headerlink" title="E - Magical Ornament"></a>E - Magical Ornament</h2><p><img src="https://i.loli.net/2021/02/03/lyhtnMaNmCTKfci.png" alt></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc190/tasks/abc190_e" target="_blank" rel="noopener">https://atcoder.jp/contests/abc190/tasks/abc190_e</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目难度还是非常值得思考的地方。我们首先可以通过<code>bfs</code>求出选中的<code>k</code>个节点之间的最短距离，这个很容易实现。</li><li>然后我们设递推公式$dp[mask][i]$当前已经访问过的节点状态为<code>mask</code>表示的位图且以<code>i</code>为结尾的最小长度。<script type="math/tex; mode=display">dp[mask][i] = min(dp[mask][i],dp[mask^(1<<i)][j] + dist[i][j])</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;sz[find(x)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; y1) swap(x1,y1);</span><br><span class="line">        parent[y1] = x1;</span><br><span class="line">        sz[x1] += sz[y1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; allowed(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;allowed[i].first&gt;&gt;allowed[i].second;</span><br><span class="line">        edges[allowed[i].first].insert(allowed[i].second);</span><br><span class="line">        edges[allowed[i].second].insert(allowed[i].first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gems;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;gems[i];</span><br><span class="line">        cnt[gems[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bfs*/</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(k,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k,<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">        qu.push(gems[i]);</span><br><span class="line">        visited.insert(gems[i]);</span><br><span class="line">        adj[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;curr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(curr))&#123;</span><br><span class="line">                adj[i][cnt[curr]] = step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges[curr])&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">                qu.push(v);</span><br><span class="line">                visited.insert(v);</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*encode*/</span></span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">1</span>&lt;&lt;k,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k,INT_MAX));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        dp[<span class="number">1</span>&lt;&lt;i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> stat = <span class="number">1</span>; stat &lt; (<span class="number">1</span>&lt;&lt;k); ++stat)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stat&amp;(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stat&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                        dp[stat][i] = min(dp[stat][i],dp[stat^(<span class="number">1</span>&lt;&lt;i)][j] + adj[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        ans = min(ans,dp[(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == INT_MAX)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;abc-contest-190&quot;&gt;&lt;a href=&quot;#abc-contest-190&quot; class=&quot;headerlink&quot; title=&quot;abc  contest 190&quot;&gt;&lt;/a&gt;abc  contest 190&lt;/h1&gt;&lt;h2 id=&quot;C-Bowls-and-Dishes&quot;&gt;&lt;a href=&quot;#C-Bowls-and-Dishes&quot; class=&quot;headerlink&quot; title=&quot;C - Bowls and Dishes&quot;&gt;&lt;/a&gt;C - Bowls and Dishes&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/31/ehj8xNS1EoHfCT7.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc190/tasks/abc190_c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://atcoder.jp/contests/abc190/tasks/abc190_c&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;  回溯遍历&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;因为所有的人都有两种选择，我们直接遍历所有的摆放方法，然后求出每种状态下的得分，即可求出最高的得分。我们用&lt;code&gt;mask&lt;/code&gt;来标识状态，如果第&lt;code&gt;i&lt;/code&gt;为&lt;code&gt;1&lt;/code&gt;则表示第&lt;code&gt;i&lt;/code&gt;个&lt;code&gt;people&lt;/code&gt;选择第&lt;code&gt;1&lt;/code&gt;种摆法，否则则表示第&lt;code&gt;i&lt;/code&gt;个&lt;code&gt;people&lt;/code&gt;选择第&lt;code&gt;2&lt;/code&gt;种摆法。&lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;set&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unordered_set&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; pair&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; pii;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dsu&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; parent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; sz;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Dsu(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;parent = &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;sz = &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;parent[i] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;sz[i] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(x != parent[x])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            x = parent[x];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;-&amp;gt;sz[find(x)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;unite&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x1 = find(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y1 = find(y);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(x1 &amp;gt; y1) swap(x1,y1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        parent[y1] = x1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sz[x1] += sz[y1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;slove&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,m,k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ans = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;pii&amp;gt; conditions(m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; m; ++i)&amp;#123;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;&amp;gt;&amp;gt;conditions[i].first&amp;gt;&amp;gt;conditions[i].second;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        conditions[i].first--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        conditions[i].second--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;&amp;gt;&amp;gt;k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;pii&amp;gt; peoples(k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; k; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;&amp;gt;&amp;gt;peoples[i].first&amp;gt;&amp;gt;peoples[i].second;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        peoples[i].first--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        peoples[i].second--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i &amp;lt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;k); ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; test(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; k; ++j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i&amp;amp;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;j))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                test[peoples[j].first] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                test[peoples[j].second] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; curr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; m; ++j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(test[conditions[j].first]&amp;amp;&amp;amp;test[conditions[j].second])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                curr++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ans = max(ans,curr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    slove();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 226</title>
    <link href="http://yoursite.com/2021/01/31/249/"/>
    <id>http://yoursite.com/2021/01/31/249/</id>
    <published>2021-01-31T04:18:44.705Z</published>
    <updated>2021-01-31T05:53:01.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-226"><a href="#leetcode-contest-226" class="headerlink" title="leetcode  contest 226"></a>leetcode  contest 226</h1><p>今天的题目真心太简单了，<code>ak</code>的人数都接近500人了，可见题目的难度非常小，特别是最后一题基本上可以看作是<code>mid</code>难度。</p><h2 id="5654-盒子中小球的最大数量"><a href="#5654-盒子中小球的最大数量" class="headerlink" title="5654. 盒子中小球的最大数量"></a>5654. 盒子中小球的最大数量</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 <code>infinity</code> 。</p><a id="more"></a><p>你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 <code>1 + 0 = 1</code>的盒子。</p><p>给你两个整数 <code>lowLimit</code> 和 <code>highLimit</code> ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：lowLimit = <span class="number">1</span>, highLimit = <span class="number">10</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">盒子编号：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> ...</span><br><span class="line">小球数量：<span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>  <span class="number">0</span>  ...</span><br><span class="line">编号 <span class="number">1</span> 的盒子放有最多小球，小球数量为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：lowLimit = <span class="number">5</span>, highLimit = <span class="number">15</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">盒子编号：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> ...</span><br><span class="line">小球数量：<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>  <span class="number">0</span>  ...</span><br><span class="line">编号 <span class="number">5</span> 和 <span class="number">6</span> 的盒子放有最多小球，每个盒子中的小球数量都是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：lowLimit = <span class="number">19</span>, highLimit = <span class="number">28</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">盒子编号：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> ...</span><br><span class="line">小球数量：<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span>  <span class="number">0</span>  <span class="number">0</span>  ...</span><br><span class="line">编号 <span class="number">10</span> 的盒子放有最多小球，小球数量为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= lowLimit &lt;= highLimit &lt;= 105</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-225/problems/latest-time-by-replacing-hidden-digits/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-225/problems/latest-time-by-replacing-hidden-digits/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接遍历即可，算法复杂度为$O(nlgn)$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBalls</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a; i &lt;= b; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> x = to_string(i);</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : x)&#123;</span><br><span class="line">                curr += c - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[curr]++;</span><br><span class="line">            ans = max(ans,cnt[curr]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5665-从相邻元素对还原数组"><a href="#5665-从相邻元素对还原数组" class="headerlink" title="5665. 从相邻元素对还原数组"></a>5665. 从相邻元素对还原数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>存在一个由 n 个不同元素组成的整数数组 <code>nums</code>，但你已经记不清具体内容。好在你还记得 <code>nums</code>中的每一对相邻元素。</p><p>给你一个二维整数数组 <code>adjacentPairs</code> ，大小为 <code>n - 1</code>，其中每个 <code>adjacentPairs[i] = [ui, vi]</code> 表示元素 <code>ui</code>和 <code>vi</code> 在<code>nums</code>中相邻。</p><p>题目数据保证所有由元素 <code>nums[i]</code> 和 <code>nums[i+1]</code> 组成的相邻元素对都存在于 <code>adjacentPairs</code> 中，存在形式可能是 <code>[nums[i]</code>, <code>nums[i+1]]</code> ，也可能是 <code>[nums[i+1], nums[i]]</code> 。这些相邻元素对可以 按任意顺序 出现。</p><p>返回 原始数组 <code>nums</code> 。如果存在多种解答，返回 其中任意一个 即可。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：adjacentPairs = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：数组的所有相邻元素对都在 adjacentPairs 中。</span><br><span class="line">特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：adjacentPairs = [[<span class="number">4</span>,<span class="number">-2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">-3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="number">-2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">-3</span>]</span><br><span class="line">解释：数组中可能存在负数。</span><br><span class="line">另一种解答是 [<span class="number">-3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">-2</span>] ，也会被视作正确答案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：adjacentPairs = <span class="string">[[100000,-100000]]</span></span><br><span class="line">输出：[<span class="number">100000</span>,<span class="number">-100000</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>nums.length == n</code></li><li><code>adjacentPairs.length == n - 1</code></li><li><code>adjacentPairs[i].length == 2</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>-105 &lt;= nums[i], ui, vi &lt;= 105</code></li><li>题目数据保证存在一些以 <code>adjacentPairs</code>作为元素对的数组 <code>nums</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-226/problems/restore-the-array-from-adjacent-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-226/problems/restore-the-array-from-adjacent-pairs/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 树的遍历</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质我们可以采用树的遍历即可，节点之间的相邻关系即等于有边相连，我们从度为<code>1</code>的顶点开始遍历即可得到满足要求的数组。</li><li>统计每个节点的度，每个节点的度最大为<code>2</code>,从度为<code>1</code>的节点开始遍历即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; restoreArray(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : A)&#123;</span><br><span class="line">            cnt[v[<span class="number">0</span>]].insert(v[<span class="number">1</span>]);</span><br><span class="line">            cnt[v[<span class="number">1</span>]].insert(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                start = v.first;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans.push_back(start);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> neg =  *(cnt[start].begin());</span><br><span class="line">            ans.push_back(neg);</span><br><span class="line">            cnt[start].erase(neg);</span><br><span class="line">            cnt[neg].erase(start);</span><br><span class="line">            start = neg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5667-你能在你最喜欢的那天吃到你最喜欢的糖果吗？"><a href="#5667-你能在你最喜欢的那天吃到你最喜欢的糖果吗？" class="headerlink" title="5667. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？"></a>5667. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</h2><p>给你一个下标从 0 开始的正整数数组 <code>candiesCount</code> ，其中 <code>candiesCount[i]</code> 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 <code>queries</code> ，其中 <code>queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]</code> 。</p><p>你按照如下规则进行一场游戏：</p><ul><li>你从第 0 天开始吃糖果。</li><li>你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。</li><li>在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。</li><li>请你构建一个布尔型数组 <code>answer</code> ，满足 <code>answer.length == queries.length</code> 。<code>answer[i]</code> 为 <code>true</code>的条件是：在每天吃 不超过 <code>dailyCapi</code>颗糖果的前提下，你可以在第 <code>favoriteDayi</code>天吃到第 <code>favoriteTypei</code>类糖果；否则<code>answer[i]</code>为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</li></ul><p>请你返回得到的数组 <code>answer</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candiesCount = [<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>], queries = [[<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">13</span>,<span class="number">1000000000</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>]</span><br><span class="line">提示：</span><br><span class="line"><span class="number">1</span>- 在第 <span class="number">0</span> 天吃 <span class="number">2</span> 颗糖果(类型 <span class="number">0</span>），第 <span class="number">1</span> 天吃 <span class="number">2</span> 颗糖果（类型 <span class="number">0</span>），第 <span class="number">2</span> 天你可以吃到类型 <span class="number">0</span> 的糖果。</span><br><span class="line"><span class="number">2</span>- 每天你最多吃 <span class="number">4</span> 颗糖果。即使第 <span class="number">0</span> 天吃 <span class="number">4</span> 颗糖果（类型 <span class="number">0</span>），第 <span class="number">1</span> 天吃 <span class="number">4</span> 颗糖果（类型 <span class="number">0</span> 和类型 <span class="number">1</span>），你也没办法在第 <span class="number">2</span> 天吃到类型 <span class="number">4</span> 的糖果。换言之，你没法在每天吃 <span class="number">4</span> 颗糖果的限制下在第 <span class="number">2</span> 天吃到第 <span class="number">4</span> 类糖果。</span><br><span class="line"><span class="number">3</span>- 如果你每天吃 <span class="number">1</span> 颗糖果，你可以在第 <span class="number">13</span> 天吃到类型 <span class="number">2</span> 的糖果。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：candiesCount = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>], queries = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">10</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">10</span>,<span class="number">100</span>],[<span class="number">4</span>,<span class="number">100</span>,<span class="number">30</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= candiesCount.length &lt;= 105</code></li><li><code>1 &lt;= candiesCount[i] &lt;= 105</code></li><li><code>1 &lt;= queries.length &lt;= 105</code></li><li><code>queries[i].length == 3</code></li><li><code>0 &lt;= favoriteTypei &lt; candiesCount.length</code></li><li><code>0 &lt;= favoriteDayi &lt;= 109</code></li><li><code>1 &lt;= dailyCapi &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day" target="_blank" rel="noopener">https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数题目</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目看似简单实际还是需要一定的思考的，首先根据题目中约束条件<code>1</code>和条件<code>2</code>自然而然想到前前缀和的问题。主要的思考就是在前缀和上，因为题目要求吃第<code>i</code>种糖果时要求第<code>i-1</code>糖果吃完，因此我们可以推理到如果吃第<code>i</code>种糖果，则前<code>i-1</code>种糖果必然全部吃完。</li><li>给定的<code>[favoriteTypei, favoriteDayi, dailyCapi]</code>,要求在<code>favoriteDayi</code>中按照给定条件能够吃到<code>favoriteTypei</code>的糖果。</li></ol><ul><li>首先我们考虑下限的问题，即满足前<code>favoriteDayi</code>一定满足每天都能够吃到糖果，因此满足条件$sum[favoriteTypei] \ge favoriteDayi$，这样才能满足从<code>0</code>到<code>favoriteDayi-1</code>天都能够至少吃到糖果.</li><li>再次考虑上限的问题，即每天以<code>dailyCapi</code>的最大量来吃糖果，保证第<code>favoriteDayi</code>能够吃到<code>favoriteTypei</code>，则我们要求$sum[favoriteTypei-1] &lt; favoriteDayi*dailyCapi$,这样可以保证第<code>favoriteDayi</code>天必然可以吃到<code>favoriteTypei</code>类型的糖果。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; canEat(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candiesCount, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = candiesCount.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; sum(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + candiesCount[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> type = queries[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> day = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> cap = queries[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> maxeat = cap*(day+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mineat = day + <span class="number">1</span>;            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(sum[type]+<span class="number">1</span> &lt;= maxeat &amp;&amp; sum[type+<span class="number">1</span>] &gt;= mineat)&#123;</span><br><span class="line">                ans.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5666-回文串分割-IV"><a href="#5666-回文串分割-IV" class="headerlink" title="5666. 回文串分割 IV"></a>5666. 回文串分割 IV</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，如果可以将它分割成三个 非空 回文子字符串，那么返回 <code>true</code>，否则返回 <code>false</code>。</p><p>当一个字符串正着读和反着读是一模一样的，就称其为 回文字符串 。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"abcbdd"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="string">"abcbdd"</span> = <span class="string">"a"</span> + <span class="string">"bcb"</span> + <span class="string">"dd"</span>，三个子字符串都是回文的。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"bcbddxy"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：s 没办法被分割成 <span class="number">3</span> 个回文子字符串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 2000</code></li><li><code>s​​​​​​</code> 只包含小写英文字母。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-partitioning-iv</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>回文串的问题，首先我们求出区间<code>[i,j]</code>是否为回文字符串，其次我们同时遍历<code>i</code>与<code>j</code>即可求出所有的<code>i,j</code>组合即可，即可判断是否满足题目要求，时间复杂度为$O(n^{2})$,空间复杂度为$O(n^{2})$。</li><li>求<code>[i,j]</code>是否为回文字符串,我们可以用经典的<code>dp</code>的解法：<script type="math/tex; mode=display">dp[i][j] = dp[i+1][j-1] \qquad (if \quad s[i] == s[j]) \\dp[i][j] = false \qquad (if \quad s[i] \neq s[j])</script></li><li>我们同时判断三个区间<code>[0,i-1],[i,j],[j+1,n-1]</code>是否同时满足为回文字符串时即可满足题意要求。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPartitioning</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j+i &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == s[j+i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                        dp[j][j+i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[j][j+i] = dp[j+<span class="number">1</span>][j+i<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j][j+i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[<span class="number">0</span>][i<span class="number">-1</span>]&amp;&amp;dp[i][j]&amp;&amp;dp[j+<span class="number">1</span>][n<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-226&quot;&gt;&lt;a href=&quot;#leetcode-contest-226&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 226&quot;&gt;&lt;/a&gt;leetcode  contest 226&lt;/h1&gt;&lt;p&gt;今天的题目真心太简单了，&lt;code&gt;ak&lt;/code&gt;的人数都接近500人了，可见题目的难度非常小，特别是最后一题基本上可以看作是&lt;code&gt;mid&lt;/code&gt;难度。&lt;/p&gt;&lt;h2 id=&quot;5654-盒子中小球的最大数量&quot;&gt;&lt;a href=&quot;#5654-盒子中小球的最大数量&quot; class=&quot;headerlink&quot; title=&quot;5654. 盒子中小球的最大数量&quot;&gt;&lt;/a&gt;5654. 盒子中小球的最大数量&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 &lt;code&gt;infinity&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Build a Computer】 Project 12</title>
    <link href="http://yoursite.com/2021/01/28/248/"/>
    <id>http://yoursite.com/2021/01/28/248/</id>
    <published>2021-01-28T03:35:34.552Z</published>
    <updated>2021-01-29T01:38:32.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="build-a-computer-week-12"><a href="#build-a-computer-week-12" class="headerlink" title="build a computer week 12"></a>build a computer week 12</h1><p>终于完成了<code>build a computer</code>系列的最后几章了，最终所有的<code>project</code>全部都通过了。<br><img src="https://i.loli.net/2021/01/28/CnAQqULTpxglm31.png" alt><br>真心感觉这个过程比较艰难，这个<code>project</code>是该系列课程里面最后的一个<code>toy project</code>了，主要部分为一个非常简单的<code>OS</code>系统的源代码的实现，其实代码实现并不难，因为大部分算法都可以在网上找到，但是细节处理非常容易出错，写代码很爽，也就3天的时间完成了大概也就将近<code>1000</code>行的代码，但是调试确实花了非常多的时间来完成，主要是因为部分细节确实实现比较坑爹，不太好弄，但是终于还是调通和实现了，感觉这种业务代码的实现也就是搬砖的活，还是写算法，刷题来的爽，因为算法的大部分问题思考的时间很多，写代码实际上非常容易实现，现在越来越喜欢类似的深度思考，需要花时间来解决的数学和技术难题，而不是拼命搬砖。所有的实现代码最终放在<code>github</code>上，<a href="https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects/12" target="_blank" rel="noopener">p12-jackos</a>.<br>终于完成全部的<code>build a modern computer</code>系列课程了，课程真的是太有趣了，我想做事有始有终，以前给自己定的<code>flag</code>是一定要完成这个课程，陆陆续续刷了大概有<code>6</code>个月的时间，才把整个系列的<code>part1,part2</code>课程完成了。本课程最有意思的是该课程讲出了计算机模型的本质，非常推荐国外这种化繁为简的教育理念和教育方法，通过现象可以看到本质，只需要实现最基本的<code>OS</code>的核心，非常低的门槛就可以将学生代入计算机的伟大世界中，了解计算的本质和基本原理，真心替两位教授点赞，看到资料介绍，本课程陆陆续续开发了近五年才最终完成了如此精品的课程。我想兴趣才是最好的老师，虽然学习这门课程花了很大的精力和很多的时间，但是学习完成之后，仍然会对本课程回味许多。</p><a id="more"></a><h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>本章节的<code>project</code>主要是实现操作系统的部分核心内容，俗称造轮子。本次需要造的轮子如下：</p><ul><li><code>Math</code>:数学计算部分，包含最基本的乘法，除法，开方，乘方，取模运算等;</li><li><code>String</code>: 字符串部分，主要包括字符类的基本功能，字符串转换，等等基本操作;</li><li><code>Array</code>: 数组的管理，数组的管理，主要包括数组构造和删除；</li><li><code>Output</code>: 字符或者数字的输出模块；</li><li><code>Screen</code>: 最基本的图形显示部分，包含最基本的图形显示部分，比如像素、直线、圆、矩形的显示；</li><li><code>Keyboard</code>:键盘的输入读取控制。</li><li><code>Memory</code>: 基本的内存管理部分。</li><li><code>Sys</code>：系统管理，包括系统的初始化和完成。<br><img src="https://i.loli.net/2021/01/28/mfrJ7Wb1PyUiIq9.png" alt><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3>整个<code>math</code>部分完成了乘法、除法、开方、乘方、取模、取绝对值运算，其中最难的还是乘法和除法以及开方的实现。<br><img src="https://i.loli.net/2021/01/28/vyblfnmK31guXMx.png" alt></li></ul><ol><li><code>multiply</code>:乘法利用了二进位的特定来进行实现，实现其实比较简单，算法时间复杂度为$O(lgn)$，每次测试二进制位<code>i</code>是否为<code>1</code>，如果为<code>1</code>，则减去相应的值即可，利用位运算非常容易实现。<br><img src="https://i.loli.net/2021/01/28/cpmYKZBMQbFkiEn.png" alt></li><li><code>divide</code>: 除法部分稍微复杂点，我们提前减去利用算法的特性实现即可，时间复杂度为$O(lgn)$.<br><img src="https://i.loli.net/2021/01/28/ToXsZj1rQmayYvi.png" alt></li><li><code>sqrt</code>: 开方的实现方法有很多种，这个实现思路就很多了，最简单的利用二分查找实现即可，还可以利用牛顿法，或者逼近法，课程中给出的解法则利用左右边界的逼近法。<script type="math/tex; mode=display">y^{2} \le x \le (y+1)^{2}</script></li></ol><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>本节实现了非常简单的内存管理模块，堆的管理实现比较简单，也没有太大的难度，常见的两种办法为<code>first fit</code>和<code>best fit</code>,关于具体的内存管理的实现算法有许多成熟的论文或者开源的代码可以参考，不过基本上也没有什么太大的难度。在本章中是实现了简单的<code>first fit</code>算法，简单的链表实现即可，对于老鸟来说非常简单的实现，当然对于快速的缓存来说一般都是采用将内存划分为固定字节的块，避免繁琐的查找。<br><img src="https://i.loli.net/2021/01/28/1rsp7wxVLHeylhz.png" alt><br><img src="https://i.loli.net/2021/01/28/kh9UtOiQRc6uvSB.png" alt></p><h3 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h3><p>该小节实现了基本的图形显示界面的实现，比如实现了最基本的矩形，圆形，点，直线的代码实现。<br><img src="https://i.loli.net/2021/01/28/h4vZjAI1onYqGwx.png" alt></p><ul><li><code>pixel</code>:对于点的实现比较简单，由于内存的字长为<code>16</code>位，我们直接采用<code>16</code>位掩码的方式，来快速的对显存部分实现读取和写入。</li><li><code>line</code>：<code>line</code>的部分就实现稍微复杂点，如果我们直接利用求斜率的方法则需要用到除法和乘法，非常耗时。在此利用加法和减法来实现快速的判别实现直线的点的计算。当然实现的过程中我们需要将直线分为3中类型，</li><li><ul><li>水平直线：即与<code>x</code>轴平行的直线，此时我们即可以快速的利用显存的<code>16</code>位带宽，一次性可以写入连续的<code>16</code>位，来加速写入显存的速率。</li></ul></li><li><ul><li>垂直直线: 此时的无法计算斜率，但是我们只需要连续填入即可，利用基本的几何知识即可实现。</li></ul></li><li><ul><li>普通直线: 我们则利用如下算法来实现相关代码，非常巧妙的加减法判断即可。<br><img src="https://i.loli.net/2021/01/28/YHGrcOXL9e6Iu4T.png" alt></li></ul></li><li><code>rectangle</code>:此时我们则利用画水平线的方式，快速的实现即可。</li><li><code>circle</code>:画圆的方式则比较容易实现，就是快速的画水平直线即可,当然如下的算法可以稍微改进一下，每次画两条直线，即可减少开方的计算，毕竟开方的计算非常耗时。<br><img src="https://i.loli.net/2021/01/28/HuoG85sIwB1qbWJ.png" alt><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3>输出部分主要为整个系统的字符输出和显示。整个系统中给所有的字符完成一种最基本的字符定义和类型，从中我们可以窥探到字符集的实现。本质为我们将每一种字符都进行位图编辑，每次输出字符时，我们显示该字符的实际的位图即可，这个起始非常容易实现。<br><img src="https://i.loli.net/2021/01/28/NwFfqjALMDPCeiT.png" alt></li><li><code>printChar</code>：打印字符的实现，所有的字符都采用<code>11x8</code>的位图来实现，因此非常的简单。我们每次输出字符时只需要定位到相应的起始位置，在显存中写入该字符的位图即可。</li><li><code>printInt</code>:这个即将整形转换为字符串，然后再输出即可，比较麻烦的地方是处理负数的问题。<h3 id="Keyboard"><a href="#Keyboard" class="headerlink" title="Keyboard"></a>Keyboard</h3>读取和控制键盘，对键盘的输入进行读取和显示，这部分的实现起始非常简单，从键盘的<code>i/o</code>地址出，读取写入的字符然后显示相应的字符即可。<br><img src="https://i.loli.net/2021/01/28/gbOKMwFhPq5a1G3.png" alt></li><li><code>keypressed</code>：从键盘读取一个输入字符，判断读取的循环即可<br><img src="https://i.loli.net/2021/01/28/ksChF6jzmga7V9S.png" alt><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><code>string</code>的处理则非常简单，因为只需要基本的函数即可，没啥太大难度，也没有多少难点需要阐述的。<br><img src="https://i.loli.net/2021/01/28/dsfGmeUJn6jvxlO.png" alt></li></ul><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><code>array</code>部分就更简单了，申请<code>size</code>长度的数组即为从堆中申请相应长度的空间即可。<br><img src="https://i.loli.net/2021/01/28/CYkLzUNxcr9fVQ5.png" alt></p><h3 id="Sys"><a href="#Sys" class="headerlink" title="Sys"></a>Sys</h3><p><code>sys</code>系统部分，主要重点需要注意的为系统初始化部分，题目中给的完全可能是错误的，首先第一个需要初始化的应该是<code>memory</code>部分，因为其他模块都可能需要用到<code>memory</code>部分的功能。具体的初始流程如下即可：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> void init<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> <span class="module-access"><span class="module"><span class="identifier">Memory</span>.</span></span>init<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>init<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="module-access"><span class="module"><span class="identifier">Screen</span>.</span></span>init<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="module-access"><span class="module"><span class="identifier">Output</span>.</span></span>init<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="module-access"><span class="module"><span class="identifier">Keyboard</span>.</span></span>init<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="module-access"><span class="module"><span class="identifier">Main</span>.</span></span>main<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="module-access"><span class="module"><span class="identifier">Sys</span>.</span></span>halt<span class="literal">()</span>;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>起始总的来说，这个<code>project</code>相比其他几个<code>project</code>都容易许多，但是许多需要注意的细节：</p><ul><li>对于数学的部分：这部分需要非常快速的效率来实现，所以非常需要快的数学方法来化简直接的方法，从而提高效率，否则后续容易出现程序执行效率不高的问题。</li><li>对于图形部分的实现，如何继续改进则需要仔细的思考，特别是圆形的实现还需要非常多的优化。</li><li>其余的部分感觉基本上就是<code>cround</code>，没有特别多的理论需要思考和实现的。</li></ul><h2 id="project-1"><a href="#project-1" class="headerlink" title="project"></a>project</h2><p>本周的<code>project</code>感觉还是非常复杂的<code>project</code>，虽然很简单，但是要不出错还是需要非常注意细节的实现。<br>代码实现：<a href="https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects/12" target="_blank" rel="noopener">poj12</a>.</p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;build-a-computer-week-12&quot;&gt;&lt;a href=&quot;#build-a-computer-week-12&quot; class=&quot;headerlink&quot; title=&quot;build a computer week 12&quot;&gt;&lt;/a&gt;build a computer week 12&lt;/h1&gt;&lt;p&gt;终于完成了&lt;code&gt;build a computer&lt;/code&gt;系列的最后几章了，最终所有的&lt;code&gt;project&lt;/code&gt;全部都通过了。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/01/28/CnAQqULTpxglm31.png&quot; alt&gt;&lt;br&gt;真心感觉这个过程比较艰难，这个&lt;code&gt;project&lt;/code&gt;是该系列课程里面最后的一个&lt;code&gt;toy project&lt;/code&gt;了，主要部分为一个非常简单的&lt;code&gt;OS&lt;/code&gt;系统的源代码的实现，其实代码实现并不难，因为大部分算法都可以在网上找到，但是细节处理非常容易出错，写代码很爽，也就3天的时间完成了大概也就将近&lt;code&gt;1000&lt;/code&gt;行的代码，但是调试确实花了非常多的时间来完成，主要是因为部分细节确实实现比较坑爹，不太好弄，但是终于还是调通和实现了，感觉这种业务代码的实现也就是搬砖的活，还是写算法，刷题来的爽，因为算法的大部分问题思考的时间很多，写代码实际上非常容易实现，现在越来越喜欢类似的深度思考，需要花时间来解决的数学和技术难题，而不是拼命搬砖。所有的实现代码最终放在&lt;code&gt;github&lt;/code&gt;上，&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects/12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;p12-jackos&lt;/a&gt;.&lt;br&gt;终于完成全部的&lt;code&gt;build a modern computer&lt;/code&gt;系列课程了，课程真的是太有趣了，我想做事有始有终，以前给自己定的&lt;code&gt;flag&lt;/code&gt;是一定要完成这个课程，陆陆续续刷了大概有&lt;code&gt;6&lt;/code&gt;个月的时间，才把整个系列的&lt;code&gt;part1,part2&lt;/code&gt;课程完成了。本课程最有意思的是该课程讲出了计算机模型的本质，非常推荐国外这种化繁为简的教育理念和教育方法，通过现象可以看到本质，只需要实现最基本的&lt;code&gt;OS&lt;/code&gt;的核心，非常低的门槛就可以将学生代入计算机的伟大世界中，了解计算的本质和基本原理，真心替两位教授点赞，看到资料介绍，本课程陆陆续续开发了近五年才最终完成了如此精品的课程。我想兴趣才是最好的老师，虽然学习这门课程花了很大的精力和很多的时间，但是学习完成之后，仍然会对本课程回味许多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="build a computer" scheme="http://yoursite.com/categories/build-a-computer/"/>
    
    
      <category term="coursera" scheme="http://yoursite.com/tags/coursera/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 225</title>
    <link href="http://yoursite.com/2021/01/24/247/"/>
    <id>http://yoursite.com/2021/01/24/247/</id>
    <published>2021-01-24T04:28:56.610Z</published>
    <updated>2021-01-29T01:21:09.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-225"><a href="#leetcode-contest-225" class="headerlink" title="leetcode  contest 225"></a>leetcode  contest 225</h1><p>最近周赛的题目都挺难，最后一题还是不会，基本上就是三道的水平。越来越觉得刷题需要靠智商，智商决定上限，智商太低，无论怎么刷都很难提高了。智商高则会思考的越深入，解答问题速度也会越快，解答越快也就越能够给后面的题目留下更多的思考时间，这样才能提高通过率。</p><h2 id="5661-替换隐藏数字得到的最晚时间"><a href="#5661-替换隐藏数字得到的最晚时间" class="headerlink" title="5661. 替换隐藏数字得到的最晚时间"></a>5661. 替换隐藏数字得到的最晚时间</h2><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>time</code> ，格式为 <code>hh:mm</code>（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。<br>有效的时间为 <code>00:00</code>到 <code>23:59</code>之间的所有时间，包括 <code>00:00</code> 和 <code>23:59</code> 。<br>替换 <code>time</code> 中隐藏的数字，返回你可以得到的最晚有效时间。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：time = <span class="string">"2?:?0"</span></span><br><span class="line">输出：<span class="string">"23:50"</span></span><br><span class="line">解释：以数字 '<span class="number">2</span>' 开头的最晚一小时是 <span class="number">23</span> ，以 '<span class="number">0</span>' 结尾的最晚一分钟是 <span class="number">50</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">time</span> = <span class="string">"0?:3?"</span></span><br><span class="line">输出：<span class="string">"09:39"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">time</span> = <span class="string">"1?:22"</span></span><br><span class="line">输出：<span class="string">"19:22"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>time</code> 的格式为 <code>hh:mm</code></li><li>题目数据保证你可以由输入的字符串生成有效的时间</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-225/problems/latest-time-by-replacing-hidden-digits/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-225/problems/latest-time-by-replacing-hidden-digits/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>全部遍历即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maximumTime</span><span class="params">(<span class="built_in">string</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">"00:00"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*hour*/</span></span><br><span class="line">        <span class="keyword">if</span>(time[<span class="number">0</span>] == <span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(time[<span class="number">1</span>] == <span class="string">'?'</span>)&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = <span class="string">'2'</span>;</span><br><span class="line">                ans[<span class="number">1</span>] = <span class="string">'3'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(time[<span class="number">1</span>] &gt; <span class="string">'3'</span>)&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = <span class="string">'1'</span>;</span><br><span class="line">                ans[<span class="number">1</span>] = time[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[<span class="number">0</span>] = <span class="string">'2'</span>;</span><br><span class="line">                ans[<span class="number">1</span>] = time[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = time[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(time[<span class="number">1</span>] == <span class="string">'?'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(time[<span class="number">0</span>] == <span class="string">'2'</span>)&#123;</span><br><span class="line">                    ans[<span class="number">1</span>] = <span class="string">'3'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans[<span class="number">1</span>] = <span class="string">'9'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[<span class="number">1</span>] = time[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*minute*/</span></span><br><span class="line">        <span class="keyword">if</span>(time[<span class="number">3</span>] == <span class="string">'?'</span>)&#123;</span><br><span class="line">            ans[<span class="number">3</span>] = <span class="string">'5'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[<span class="number">3</span>] = time[<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(time[<span class="number">4</span>] == <span class="string">'?'</span>)&#123;</span><br><span class="line">            ans[<span class="number">4</span>] = <span class="string">'9'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[<span class="number">4</span>] = time[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5662-满足三条件之一需改变的最少字符数"><a href="#5662-满足三条件之一需改变的最少字符数" class="headerlink" title="5662. 满足三条件之一需改变的最少字符数"></a>5662. 满足三条件之一需改变的最少字符数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>a</code>和 <code>b</code> ，二者均由小写字母组成。一步操作中，你可以将 a 或 b 中的 任一字符 改变为 任一小写字母 。</p><p>操作的最终目标是满足下列三个条件 之一 ：</p><ul><li><code>a</code> 中的 每个字母 在字母表中 严格小于 <code>b</code> 中的 每个字母 。</li><li><code>b</code> 中的 每个字母 在字母表中 严格小于 <code>a</code> 中的 每个字母 。</li><li><code>a</code> 和 <code>b</code> 都 由 同一个 字母组成。<br>返回达成目标所需的 最少 操作数。</li></ul><p>示例 1：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">a</span> = <span class="string">"aba"</span>, <span class="selector-tag">b</span> = <span class="string">"caa"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：满足每个条件的最佳方案分别是：</span><br><span class="line"><span class="number">1</span>) 将 <span class="selector-tag">b</span> 变为 <span class="string">"ccc"</span>，<span class="number">2</span> 次操作，满足 <span class="selector-tag">a</span> 中的每个字母都小于 <span class="selector-tag">b</span> 中的每个字母；</span><br><span class="line"><span class="number">2</span>) 将 <span class="selector-tag">a</span> 变为 <span class="string">"bbb"</span> 并将 <span class="selector-tag">b</span> 变为 <span class="string">"aaa"</span>，<span class="number">3</span> 次操作，满足 <span class="selector-tag">b</span> 中的每个字母都小于 <span class="selector-tag">a</span> 中的每个字母；</span><br><span class="line"><span class="number">3</span>) 将 <span class="selector-tag">a</span> 变为 <span class="string">"aaa"</span> 并将 <span class="selector-tag">b</span> 变为 <span class="string">"aaa"</span>，<span class="number">2</span> 次操作，满足 <span class="selector-tag">a</span> 和 <span class="selector-tag">b</span> 由同一个字母组成。</span><br><span class="line">最佳的方案只需要 <span class="number">2</span> 次操作（满足条件 <span class="number">1</span> 或者条件 <span class="number">3</span>）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">a</span> = <span class="string">"dabadd"</span>, <span class="selector-tag">b</span> = <span class="string">"cda"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：满足条件 <span class="number">1</span> 的最佳方案是将 <span class="selector-tag">b</span> 变为 <span class="string">"eee"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= a.length, b.length &lt;= 105</code></li><li><code>a</code> 和 <code>b</code>只由小写字母组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-225/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-225/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 三种情况分别遍历</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>首先统计字符串<code>a</code>和字符串<code>b</code>中所有的不同字符的个数。</li><li>将两个字符串变为相等时最小的变换次数：我们遍历<code>26</code>个字母进行依次替换，求得最小的替换次数:<script type="math/tex; mode=display">replace[i] = (la - cnta[i] + lb - cntb[i]) 。</script></li><li>将两个字符串变为<code>a &lt; b</code>的最小变换次数：我们依次遍历<code>x</code>从<code>a</code>到<code>y</code>，此时变换的次数为：字符串<code>a</code>全部变成小于等于<code>x</code>的替换次数加上字符串<code>b</code>全部变为大于<code>x</code>的替换次数:<script type="math/tex; mode=display">replace = l1 - suma[x] + sumb[x]</script></li><li>将两个字符串变为<code>a &gt; b</code>的最小变换次数：我们依次遍历<code>x</code>从<code>a</code>到<code>y</code>，此时变换的次数为：字符串<code>a</code>全部变成大于<code>x</code>的替换次数加上字符串<code>b</code>全部变为小于等于<code>x</code>的替换次数:<script type="math/tex; mode=display">replace = l2 - sumb[x] + suma[x]</script>其中<code>suma[x]</code>代表字符串<code>a</code>小于等于<code>x</code>的数量，<code>sumb[x]</code>代表字符串<code>b</code>中小于等于<code>x</code>的字符数量。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCharacters</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = a.size();</span><br><span class="line">        <span class="keyword">int</span> l2 = b.size();</span><br><span class="line">        <span class="keyword">int</span> ans = max(l1,l2);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnta(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cntb(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : a) cnta[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : b) cntb[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">/*same*/</span></span><br><span class="line">            ans = min(ans,l1-cnta[i]+l2-cntb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> prea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; ++i)&#123;</span><br><span class="line">            prea += cnta[i];</span><br><span class="line">            preb += cntb[i];</span><br><span class="line">            ans = min(ans,l1-prea + preb);</span><br><span class="line">            ans = min(ans,l2-preb + prea);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5663-找出第-K-大的异或坐标值"><a href="#5663-找出第-K-大的异或坐标值" class="headerlink" title="5663. 找出第 K 大的异或坐标值"></a>5663. 找出第 K 大的异或坐标值</h2><p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code>由非负整数组成。</p><p>矩阵中坐标 <code>(a, b)</code> 的 值 可由对所有满足 <code>0 &lt;= i &lt;= a &lt; m</code> 且 <code>0 &lt;= j &lt;= b &lt; n</code> 的元素 <code>matrix[i][j]</code>（下标从 0 开始计数）执行异或运算得到。</p><p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（<code>k</code>的值从<code>1</code>开始计数）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">6</span>]], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：坐标 (<span class="number">0</span>,<span class="number">1</span>) 的值是 <span class="number">5</span> XOR <span class="number">2</span> = <span class="number">7</span> ，为最大的值。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">6</span>]], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：坐标 (<span class="number">0</span>,<span class="number">0</span>) 的值是 <span class="number">5</span> = <span class="number">5</span> ，为第 <span class="number">2</span> 大的值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">6</span>]], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：坐标 (<span class="number">1</span>,<span class="number">0</span>) 的值是 <span class="number">5</span> XOR <span class="number">1</span> = <span class="number">4</span> ，为第 <span class="number">3</span> 大的值。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">6</span>]], k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：坐标 (<span class="number">1</span>,<span class="number">1</span>) 的值是 <span class="number">5</span> XOR <span class="number">2</span> XOR <span class="number">1</span> XOR <span class="number">6</span> = <span class="number">0</span> ，为第 <span class="number">4</span> 大的值。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 106</code></li><li><code>1 &lt;= k &lt;= m * n</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-225/problems/find-kth-largest-xor-coordinate-value/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-225/problems/find-kth-largest-xor-coordinate-value/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP + 优先级队列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先l利用动态规划来求坐标的值<code>(x,y)</code>，设<code>dp[i][j]</code>代表坐标<code>(i,j)</code>处的值，我们可以知道如下递推公式：<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j] \bigoplus dp[i][j-1] \bigoplus dp[i-1][j-1] \bigoplus matrix[i][j]</script></li><li>利用优先级队列求出第<code>k</code>个最大的元素，非常常见和简单的题目，熟悉动态规划非常容易实现。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]^dp[i][j<span class="number">-1</span>]^dp[i<span class="number">-1</span>][j<span class="number">-1</span>]^matrix[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                pq.push(dp[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(pq.size() &gt; k) pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pq.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5664-放置盒子"><a href="#5664-放置盒子" class="headerlink" title="5664. 放置盒子"></a>5664. 放置盒子</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一个立方体房间，其长度、宽度和高度都等于 <code>n</code> 个单位。请你在房间里放置 <code>n</code> 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：</p><ul><li>你可以把盒子放在地板上的任何地方。</li><li>如果盒子 <code>x</code> 需要放置在盒子 <code>y</code>的顶部，那么盒子 <code>y</code> 竖直的四个侧面都 必须 与另一个盒子或墙相邻。<br>给你一个整数 n ，返回接触地面的盒子的 最少 可能数量。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：上图是 <span class="number">3</span> 个盒子的摆放位置。</span><br><span class="line">这些盒子放在房间的一角，对应左侧位置。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：上图是 <span class="number">3</span> 个盒子的摆放位置。</span><br><span class="line">这些盒子放在房间的一角，对应左侧位置。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上图是 <span class="number">10</span> 个盒子的摆放位置。</span><br><span class="line">这些盒子放在房间的一角，对应后方位置。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-44/problems/count-ways-to-make-array-with-product/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-44/problems/count-ways-to-make-array-with-product/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题,类似于小学奥数</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目虽然不是很难，但是如何严格的证明感觉很难，这类题目实际需要严格的证明才能证明结论是对的。首先中文的题目翻译错误，不是竖直的边而应该翻译为竖直的四个平面。</li><li>仔细看了下解答，发现只有部分解答是比较靠谱和清晰的。根据贪心法，最优的放置法肯定为每层按照等差数列来放置盒子是最优解法。比如第一层放置的数量为$l(1) = \frac{k<em>(k+1)}{2}$,则第二层可以放置的盒子最多为$l(2) = \frac{k</em>(k-1)}{2}$,二者的差值刚好为<code>k</code>。</li><li>首先我们按照贪心法将可能最大的等差数列放置方法进行放置，即每次都按照等差数列的形式来放置，规则如下：<script type="math/tex; mode=display">L(1) = \frac{k*(k+1)}{2} \\L(2) = \frac{k*(k-1)}{2} \\... \\L(k-1) = 3 \\L(k) = 1 \\</script></li><li>此时我们将剩余的盒子则按照等差数列依次向上进行堆叠，因为我们可以推出一下推论，如果第<code>k</code>层增加放置<code>x</code>个盒子时，则第<code>k+1</code>层最多可以增加放置<code>x-1</code>个盒子，刚好也能成为等差数列。按照能够组成的等差序列的最大值刚好可以覆盖掉剩余的盒子，则此时底面积的盒子为最小值。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumBoxes</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># ---------- 二分计算可以堆放的最大层数 ----------</span></span><br><span class="line">        left, right = <span class="number">1</span>, n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * (mid + <span class="number">1</span>) * (mid + <span class="number">2</span>) // <span class="number">6</span> &lt; n:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        left -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        cell = left * (left + <span class="number">1</span>) * (left + <span class="number">2</span>) // <span class="number">6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算当前占地面积（即最下层的盒子数量）</span></span><br><span class="line">        area = (<span class="number">1</span> + left) * left // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ---------- 二分计算还需要继续放置的砖块 ----------</span></span><br><span class="line">        target = n - cell</span><br><span class="line">        left, right = <span class="number">0</span>, target</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * (mid + <span class="number">1</span>) // <span class="number">2</span> &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> area + left</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-225&quot;&gt;&lt;a href=&quot;#leetcode-contest-225&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 225&quot;&gt;&lt;/a&gt;leetcode  contest 225&lt;/h1&gt;&lt;p&gt;最近周赛的题目都挺难，最后一题还是不会，基本上就是三道的水平。越来越觉得刷题需要靠智商，智商决定上限，智商太低，无论怎么刷都很难提高了。智商高则会思考的越深入，解答问题速度也会越快，解答越快也就越能够给后面的题目留下更多的思考时间，这样才能提高通过率。&lt;/p&gt;&lt;h2 id=&quot;5661-替换隐藏数字得到的最晚时间&quot;&gt;&lt;a href=&quot;#5661-替换隐藏数字得到的最晚时间&quot; class=&quot;headerlink&quot; title=&quot;5661. 替换隐藏数字得到的最晚时间&quot;&gt;&lt;/a&gt;5661. 替换隐藏数字得到的最晚时间&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】  Leetcode Biweekly Contest 44</title>
    <link href="http://yoursite.com/2021/01/24/246/"/>
    <id>http://yoursite.com/2021/01/24/246/</id>
    <published>2021-01-24T00:49:05.288Z</published>
    <updated>2021-01-25T05:09:25.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-44"><a href="#leetcode-biweekly-contest-44" class="headerlink" title="leetcode  biweekly contest 44"></a>leetcode  biweekly contest 44</h1><p>最近双周赛的题目都挺难，基本上就是三道的水平。</p><h2 id="5645-找到最高海拔"><a href="#5645-找到最高海拔" class="headerlink" title="5645. 找到最高海拔"></a>5645. 找到最高海拔</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有一个自行车手打算进行一场公路骑行，这条路线总共由 <code>n + 1</code>个不同海拔的点组成。自行车手从海拔为 <code>0</code> 的点 <code>0</code>开始骑行。</p><p>给你一个长度为 <code>n</code>的整数数组 <code>gain</code>，其中 <code>gain[i]</code> 是点 <code>i</code> 和点 <code>i + 1</code>的 净海拔高度差<code>（0 &lt;= i &lt; n）</code>。请你返回 最高点的海拔 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：gain = [<span class="number">-5</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">-7</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：海拔高度依次为 [<span class="number">0</span>,<span class="number">-5</span>,<span class="number">-4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-6</span>] 。最高海拔为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：gain = [<span class="number">-4</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：海拔高度依次为 [<span class="number">0</span>,<span class="number">-4</span>,<span class="number">-7</span>,<span class="number">-9</span>,<span class="number">-10</span>,<span class="number">-6</span>,<span class="number">-3</span>,<span class="number">-1</span>] 。最高海拔为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == gain.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>-100 &lt;= gain[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-44/problems/find-the-highest-altitude/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-44/problems/find-the-highest-altitude/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  简单问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力遍历即可，当前的海拔等于前<code>i</code>项的前缀和。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestAltitude</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : gain)&#123;</span><br><span class="line">            curr = curr + v;</span><br><span class="line">            ans = max(ans,curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5646-需要教语言的最少人数"><a href="#5646-需要教语言的最少人数" class="headerlink" title="5646. 需要教语言的最少人数"></a>5646. 需要教语言的最少人数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>在一个由 m 个用户组成的社交网络里，我们获取到一些用户之间的好友关系。两个用户之间可以相互沟通的条件是他们都掌握同一门语言。</p><p>给你一个整数 <code>n</code> ，数组<code>languages</code> 和数组 <code>friendships</code> ，它们的含义如下：</p><ul><li>总共有 <code>n</code> 种语言，编号从 1 到 n 。</li><li><code>languages[i]</code> 是第 i 位用户掌握的语言集合。</li><li><code>friendships[i] = [u​​​​​​i​​​, v​​​​​​i]</code>表示 u​​​​​​​​​​​i​​​​​ 和 vi 为好友关系。<br>你可以选择 一门 语言并教会一些用户，使得所有好友之间都可以相互沟通。请返回你 最少 需要教会多少名用户。</li></ul><p>请注意，好友关系没有传递性，也就是说如果 x 和 y 是好友，且 y 和 z 是好友， x 和 z 不一定是好友。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, languages = [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]], friendships = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你可以选择教用户 <span class="number">1</span> 第二门语言，也可以选择教用户 <span class="number">2</span> 第一门语言。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, languages = [[<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>]], friendships = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：教用户 <span class="number">1</span> 和用户 <span class="number">3</span> 第三门语言，需要教 <span class="number">2</span> 名用户。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 500</code></li><li><code>languages.length == m</code></li><li><code>1 &lt;= m &lt;= 500</code></li><li><code>1 &lt;= languages[i].length &lt;= n</code></li><li><code>1 &lt;= languages[i][j] &lt;= n</code></li><li><code>1 &lt;= u​​​​​​i &lt; v​​​​​​i &lt;= languages.length</code></li><li><code>1 &lt;= friendships.length &lt;= 500</code></li><li>所有的好友关系 <code>(u​​​​​i, v​​​​​​i)</code> 都是唯一的。</li><li><code>languages[i]</code> 中包含的值互不相同。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-44/problems/minimum-number-of-people-to-teach/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-44/problems/minimum-number-of-people-to-teach/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力遍历即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目的难度差不多可以到第三题了，反而第三题比第二题简单一些。</li><li>首先我们统计出每种语言中包含哪些成员，我们可以很方便的查找某个成员是否已经学会该语言。</li><li>我们接下来，遍历所有的朋友关系，并尝试学习一种语言。首先我们需要求出哪些成员关系是不需要学习新的语言就可以直接进行沟通，此时只需要判断处于朋友关系的两个成员是否在同一个语言中，我们可以用<code>hashtable</code>在<code>O(1)</code>的时间复杂度内求出。</li><li>此时尝试遍历每一种可能的语言，尝试遍历每一种语言时，如果两个成员关系已经可以沟通我们直接跳过，如果不能沟通我们则进行尝试对两个成员都学习该语言，并统计新学习该语言的成员个数。</li><li>全部用<code>hash</code>即可，空间复杂度为$O(n^2)$,时间复杂度为$O(n^2)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTeachings</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> m = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*languages*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : A[i<span class="number">-1</span>])&#123;</span><br><span class="line">                arr[v].insert(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*comminucate*/</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; valid(B.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j].count(B[i][<span class="number">0</span>])&amp;&amp;arr[j].count(B[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                    valid[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid[j])&#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(!arr[i].count(B[j][<span class="number">0</span>]))&#123;</span><br><span class="line">                    arr[i].insert(B[j][<span class="number">0</span>]);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!arr[i].count(B[j][<span class="number">1</span>]))&#123;</span><br><span class="line">                    arr[i].insert(B[j][<span class="number">1</span>]);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans,count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5647-解码异或后的排列"><a href="#5647-解码异或后的排列" class="headerlink" title="5647. 解码异或后的排列"></a>5647. 解码异或后的排列</h2><p>给你一个整数数组 <code>perm</code>，它是前 <code>n</code>个正整数的排列，且 <code>n</code> 是个 奇数 。</p><p>它被加密成另一个长度为 <code>n - 1</code>的整数数组 encoded ，满足<code>encoded[i] = perm[i] XOR perm[i + 1]</code>。比方说，如果<code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code>。</p><p>给你 <code>encoded</code>数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：encoded = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：如果 perm = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，那么 encoded = [<span class="number">1</span> XOR <span class="number">2</span>,<span class="number">2</span> XOR <span class="number">3</span>] = [<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：encoded = [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= n &lt; 105</code></li><li><code>n</code> 是奇数。</li><li><code>encoded.length == n - 1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-44/problems/decode-xored-permutation/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-44/problems/decode-xored-permutation/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>此题的关键点在于题目给定的数据为前<code>n</code>个正整数的全排列，此时我们很容易求出当前前<code>n</code>个数的异或的结果,也即该数组所有数的和。<script type="math/tex; mode=display">xorsum = 1\bigoplus 2 \bigoplus 3...n</script></li><li>我们仔细观察一下题目，前后进行异或后的数组中：<script type="math/tex; mode=display">encoded[i] = perm[i] \bigoplus perm[i + 1]</script>我们可以观察此数组中，长度为<code>m</code>的数组，下标为奇数项的元素的进行异或操作的结果为：<script type="math/tex; mode=display">oddxor = encoded[1]\bigoplus encoded[3]\bigoplus encoded[5]\bigoplus .... encoded[m-1] \\= perm[1] \bigoplus perm[2] \bigoplus perm[3] \bigoplus perm[4] \bigoplus perm[5] \bigoplus perm[6]...perm[n-2] \bigoplus perm[n-1]</script>下标为偶数项的元素的进行异或操作的结果为：<script type="math/tex; mode=display">oddxor = encoded[0]\bigoplus encoded[2]\bigoplus encoded[4]\bigoplus .... encoded[m-2] \\= perm[0] \bigoplus perm[1] \bigoplus perm[2] \bigoplus perm[3] \bigoplus perm[4] \bigoplus perm[5]...perm[n-3] \bigoplus perm[n-2]</script></li><li>知道上述的关系我们可以知道<code>encoded</code>数组的偶数项进行异或即等于原数组的后<code>n-1</code>项进行异或，<code>encoded</code>数组的奇数数项进行异或即等于原数组的前<code>n-1</code>项进行异或，我们此时已经知道数组中<code>n</code>项元素异或的结果，则很容易求出<code>perm[0]</code>或者<code>perm[n-1]</code>,如果能够求出某项元素，我们则很容易求出<code>perm</code>数组的所有元素。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; decode(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; encoded) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = encoded.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum = sum^i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; encoded.size(); i = i+<span class="number">2</span>) sum = sum^encoded[i];</span><br><span class="line">        ans.push_back(sum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; encoded.size(); ++i)&#123;</span><br><span class="line">            ans.push_back(ans[i]^encoded[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5648-生成乘积数组的方案数"><a href="#5648-生成乘积数组的方案数" class="headerlink" title="5648. 生成乘积数组的方案数"></a>5648. 生成乘积数组的方案数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [ni, ki]</code>。第 <code>i</code> 个查询 <code>queries[i]</code>要求构造长度为 <code>ni</code>、每个元素都是正整数的数组，且满足所有元素的乘积为 <code>ki</code>，请你找出有多少种可行的方案。由于答案可能会很大，方案数需要对 <code>109 + 7</code> 取余 。</p><p>请你返回一个整数数组 <code>answer</code>，满足 <code>answer.length == queries.length</code>，其中 <code>answer[i]</code>是第 <code>i</code> 个查询的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">5</span>,<span class="number">1</span>],[<span class="number">73</span>,<span class="number">660</span>]]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">1</span>,<span class="number">50734910</span>]</span><br><span class="line">解释：每个查询之间彼此独立。</span><br><span class="line">[<span class="number">2</span>,<span class="number">6</span>]：总共有 <span class="number">4</span> 种方案得到长度为 <span class="number">2</span> 且乘积为 <span class="number">6</span> 的数组：[<span class="number">1</span>,<span class="number">6</span>]，[<span class="number">2</span>,<span class="number">3</span>]，[<span class="number">3</span>,<span class="number">2</span>]，[<span class="number">6</span>,<span class="number">1</span>]。</span><br><span class="line">[<span class="number">5</span>,<span class="number">1</span>]：总共有 <span class="number">1</span> 种方案得到长度为 <span class="number">5</span> 且乘积为 <span class="number">1</span> 的数组：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]。</span><br><span class="line">[<span class="number">73</span>,<span class="number">660</span>]：总共有 <span class="number">1050734917</span> 种方案得到长度为 <span class="number">73</span> 且乘积为 <span class="number">660</span> 的数组。<span class="number">1050734917</span> 对 <span class="number">109</span> + <span class="number">7</span> 取余得到 <span class="number">50734910</span> 。</span><br></pre></td></tr></table></figure><br>示例 2 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= queries.length &lt;= 104</code></li><li><code>1 &lt;= ni, ki &lt;= 104</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/cat-and-mouse-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cat-and-mouse-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学+组合数</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>初看这个题目，知道大致思路但是不太明白该如何解答，后来看了解答才了解到其中蕴含的数学原理，确实是非常不错的数学题目。</li><li>先了解如下原理：假设$k$为一个素数<code>p</code>的幂，则将<code>k</code>分解为长度为<code>n</code>的乘积，有多少种组合办法，该如何实现：<script type="math/tex; mode=display">k = p^{y}</script>假设我们构造长度为<code>n</code>的序列为$x_{0},x_{1},x_{2},…,x_{n-1}$,则此时：<script type="math/tex; mode=display">y = \sum_{i=0}^{n-1}x_{i} \\\alpha = [p^{x_{0}},p^{x_{1}},p^{x_{2}}...p^{x_{n-1}}]</script>刚好构造出的$\alpha$序列对应一种可能的组合数。等价于我们将<code>y</code>个重复的球放进<code>n</code>个格子中有多少种放法，本质为重复组合数，<a href="https://blog.csdn.net/codeswarrior/article/details/81145407" target="_blank" rel="noopener">简单证明</a>，则此时总共有如下中放置方法:<script type="math/tex; mode=display">v = C_{n+r-1}^{r}</script></li><li>按照上述思路，我们求出整数<code>k</code>的所有质因子的可能的组合数，假设整数<code>k</code>有<code>m</code>个质因子，分别为$p_{0},p_{1},p_{2}…p_{m-1}$.则此时：<script type="math/tex; mode=display">k = \prod_{i=0}^{m-1}p_{i}^{y_{i}}</script>假设每个质因子$pi$的分解长度为$k$的序列为$\alpha_{i}$,则我们可以知道如下：<script type="math/tex; mode=display">\alpha_{0} = [p_{0}^{x_{0}},p_{0}^{x_{1}},p_{0}^{x_{2}}...p_{0}^{x_{n-1}}] \\\alpha_{1} =  [p_{1}^{y_{0}},p_{1}^{y_{1}},p_{1}^{y_{2}}...p_{1}^{y_{n-1}}] \\\alpha_{2} =  [p_{2}^{z_{0}},p_{2}^{z_{1}},p_{2}^{z_{2}}...p_{2}^{z_{n-1}}] \\.... \\\alpha_{m-1} =  [p_{m-1}^{t_{0}},p_{m-1}^{t_{1}},p_{m-1}^{t_{2}}...p_{m-1}^{t_{n-1}}] \\k = [p_{0}^{x_{0}}*p_{1}^{y_{0}}*p_{2}^{z_{0}}...,...,..]</script>此时<code>k</code>的分解的总数刚好等于所有质因子可能的分解数的乘积。</li><li>有了上述理论后，写代码自然而然就是很顺利的过程了，但是本质是思考的方法和思路非常重要，题目感觉就是数学题目，要有深厚的数学知识才能做出这道题目来。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> C[MAXN][<span class="number">21</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; waysToFillArray(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span>(C));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; ++i) C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i) C[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span> &amp;&amp; j &lt; i; ++j)&#123;</span><br><span class="line">                C[i][j] = (C[i<span class="number">-1</span>][j<span class="number">-1</span>] + C[i<span class="number">-1</span>][j])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : queries)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = v[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> k = v[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tot = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= k; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k%i == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span>(k%i == <span class="number">0</span>)&#123;</span><br><span class="line">                        k = k/i;</span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    tot = (tot*C[n+cnt<span class="number">-1</span>][cnt])%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                tot = (tot*C[n][<span class="number">1</span>])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tot);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-44&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-44&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 44&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 44&lt;/h1&gt;&lt;p&gt;最近双周赛的题目都挺难，基本上就是三道的水平。&lt;/p&gt;&lt;h2 id=&quot;5645-找到最高海拔&quot;&gt;&lt;a href=&quot;#5645-找到最高海拔&quot; class=&quot;headerlink&quot; title=&quot;5645. 找到最高海拔&quot;&gt;&lt;/a&gt;5645. 找到最高海拔&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;有一个自行车手打算进行一场公路骑行，这条路线总共由 &lt;code&gt;n + 1&lt;/code&gt;个不同海拔的点组成。自行车手从海拔为 &lt;code&gt;0&lt;/code&gt; 的点 &lt;code&gt;0&lt;/code&gt;开始骑行。&lt;/p&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt;的整数数组 &lt;code&gt;gain&lt;/code&gt;，其中 &lt;code&gt;gain[i]&lt;/code&gt; 是点 &lt;code&gt;i&lt;/code&gt; 和点 &lt;code&gt;i + 1&lt;/code&gt;的 净海拔高度差&lt;code&gt;（0 &amp;lt;= i &amp;lt; n）&lt;/code&gt;。请你返回 最高点的海拔 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】  周赛224场</title>
    <link href="http://yoursite.com/2021/01/18/244/"/>
    <id>http://yoursite.com/2021/01/18/244/</id>
    <published>2021-01-18T01:58:59.575Z</published>
    <updated>2021-01-18T05:29:46.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-weekly-contest-224"><a href="#leetcode-weekly-contest-224" class="headerlink" title="leetcode  weekly contest 224"></a>leetcode  weekly contest 224</h1><p>本周的题目最后一题好像很难，只做出来了前三题，想通了之后就特别简单。</p><h2 id="1725-可以形成最大正方形的矩形数目"><a href="#1725-可以形成最大正方形的矩形数目" class="headerlink" title="1725. 可以形成最大正方形的矩形数目"></a>1725. 可以形成最大正方形的矩形数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [li, wi]</code> 表示第 <code>i</code> 个矩形的长度为 <code>li</code> 、宽度为 <code>wi</code> 。</p><a id="more"></a><p>如果存在 k 同时满足 <code>k &lt;= li</code> 和 <code>k &lt;= wi</code> ，就可以将第 <code>i</code>个矩形切成边长为 <code>k</code>的正方形。例如，矩形<code>[4,6]</code>可以切成边长最大为 4 的正方形。</p><p>设 <code>maxLen</code>为可以从矩形数组 <code>rectangles</code> 切分得到的 最大正方形 的边长。</p><p>返回可以切出边长为 <code>maxLen</code> 的正方形的矩形 数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[<span class="number">5</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">9</span>],[<span class="number">5</span>,<span class="number">12</span>],[<span class="number">16</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：能从每个矩形中切出的最大正方形边长分别是 [<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>] 。</span><br><span class="line">最大正方形的边长为 <span class="number">5</span> ，可以由 <span class="number">3</span> 个矩形切分得到。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">7</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= rectangles.length &lt;= 1000</code></li><li><code>rectangles[i].length == 2</code></li><li><code>1 &lt;= li, wi &lt;= 109</code></li><li><code>li != wi</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  异或</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>贪心算法，直接<code>hash</code>统计最大的矩形的数目即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodRectangles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = rectangles.size();</span><br><span class="line">        <span class="keyword">int</span> col = rectangles[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : rectangles)&#123;</span><br><span class="line">            cnt[min(v[<span class="number">0</span>],v[<span class="number">1</span>])]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt.rbegin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1726-同积元组"><a href="#1726-同积元组" class="headerlink" title="1726. 同积元组"></a>1726. 同积元组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 不同 正整数组成的数组 nums ，请你返回满足 <code>a * b = c * d</code>的元组 <code>(a, b, c, d)</code> 的数量。其中 <code>a、b、c</code>和 <code>d</code>都是<code>nums</code>中的元素，且 <code>a != b != c != d</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：存在 <span class="number">8</span> 个满足题意的元组：</span><br><span class="line">(<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>) , (<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>) , (<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) , (<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>) , (<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>) , (<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>) , (<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：存在 <span class="number">16</span> 个满足题意的元组：</span><br><span class="line">(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>) , (<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>) , (<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>) , (<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">10</span>) , (<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">1</span>) , (<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">10</span>) , (<span class="number">5</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>) , (<span class="number">2</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">4</span>) , (<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>) , (<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">10</span>) , (<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>) , (<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">10</span>) , (<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="number">40</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code>中的所有元素 互不相同</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/tuple-with-same-product" target="_blank" rel="noopener">https://leetcode-cn.com/problems/tuple-with-same-product</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排列组合,数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中的关键点在于所有元素的数字都各不相同，我们求出所有的可能的两个数的积即可。</li><li>我们统计所有可能的两个数的积的数量，利用排列组合抽样,假设某个积$x$的组合数量为$n$.则按照题意要求，满足四个数的乘积相等，且积为$x$的可能组合数为:<script type="math/tex; mode=display">count(x) = 8*C_{n}^{2} = 4*(n-1)*n</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tupleSameProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                cnt[nums[i]*nums[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                ans += v.second*(v.second<span class="number">-1</span>)*<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1727-重新排列后的最大子矩阵"><a href="#1727-重新排列后的最大子矩阵" class="headerlink" title="1727. 重新排列后的最大子矩阵"></a>1727. 重新排列后的最大子矩阵</h2><p>给你一个二进制矩阵 <code>matrix</code> ，它的大小为 <code>m x n</code>，你可以将 <code>matrix</code> 中的 列 按任意顺序重新排列。</p><p>请你返回最优方案下将 <code>matrix</code> 重新排列后，全是<code>1</code> 的子矩阵面积。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你可以按照上图方式重新排列矩阵的每一列。</span><br><span class="line">最大的全 <span class="number">1</span> 子矩阵是上图中加粗的部分，面积为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你可以按照上图方式重新排列矩阵的每一列。</span><br><span class="line">最大的全 <span class="number">1</span> 子矩阵是上图中加粗的部分，面积为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：由于你只能整列整列重新排布，所以没有比面积为 <span class="number">2</span> 更大的全 <span class="number">1</span> 子矩形。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：由于矩阵中没有 <span class="number">1</span> ，没有任何全 <span class="number">1</span> 的子矩阵，所以面积为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>matrix[i][j]</code> 要么是 0 ，要么是 1 。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口和贪心法枚举</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先直接求肯定不可能，我们仔细思索一下，我们以第<code>i</code>行为矩形的最下册的边，且以<code>(i,j)</code>为右下定点的可能待选矩形中的最大面积是多少？我们可以枚举所有右下顶点为<code>(i,j)</code>的矩形，选择最大的即可。</li><li>通过上述思路的思考，我们是否可以转变下思路，求每个出第<code>i</code>列的连续的<code>1</code>的最大窗口。比如<code>dp[i][j]</code>则代表，第<code>j</code>列，且以第<code>i</code>行为结尾的最长连续的<code>1</code>的数目，实际上也为矩形的高度。</li><li>如下图所示，我们将所有以<code>i</code>行为结尾且宽度为<code>1</code>的矩形按照高度从高到底排列，进行排列。此时我们即可以枚举以第<code>i</code>行为结尾的所有可能的最大的矩形的数目。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|</span><br><span class="line">|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">cnt[i] = max(cnt[i],dp[i][k]*(k+1)_{k=0}^{col-1})</script></li><li>空间复杂度可以优化到$O(n)$,时间复杂度为$O(nlg(n))$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSubmatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt(row+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*inntial*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j])&#123;</span><br><span class="line">                    cnt[i+<span class="number">1</span>][j] = cnt[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt[i+<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i+<span class="number">1</span>][j] &gt; <span class="number">0</span>) dp.push_back(cnt[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            sort(dp.begin(),dp.end(),[&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp; a, <span class="keyword">const</span> <span class="keyword">int</span> &amp; b)&#123;</span><br><span class="line">                <span class="keyword">return</span> a &gt; b;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp.size(); ++j)&#123;</span><br><span class="line">                ans = max(ans,dp[j]*(j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1728-猫和老鼠-II"><a href="#1728-猫和老鼠-II" class="headerlink" title="1728. 猫和老鼠 II"></a>1728. 猫和老鼠 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。</p><p>它们所处的环境设定是一个 rows x cols 的方格 grid ，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。</p><ul><li>玩家由字符 ‘C’ （代表猫）和 ‘M’ （代表老鼠）表示。</li><li>地板由字符 ‘.’ 表示，玩家可以通过这个格子。</li><li>墙用字符 ‘#’ 表示，玩家不能通过这个格子。</li><li>食物用字符 ‘F’ 表示，玩家可以通过这个格子。</li><li><p>字符 ‘C’ ， ‘M’ 和 ‘F’ 在 grid 中都只会出现一次。<br>猫和老鼠按照如下规则移动：</p></li><li><p>老鼠 先移动 ，然后两名玩家轮流移动。</p></li><li>每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，他们不能跳过墙也不能跳出 grid 。</li><li>catJump 和 mouseJump 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。</li><li>它们可以停留在原地。</li><li>老鼠可以跳跃过猫的位置。<br>游戏有 4 种方式会结束：</li><li>如果猫跟老鼠处在相同的位置，那么猫获胜。</li><li>如果猫先到达食物，那么猫获胜。</li><li>如果老鼠先到达食物，那么老鼠获胜。</li><li>如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。<br>给你 <code>rows x cols</code> 的矩阵 grid 和两个整数 <code>catJump</code>和 <code>mouseJump</code> ，双方都采取最优策略，如果老鼠获胜，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</li></ul><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">grid</span> = [<span class="string">"####F"</span>,<span class="string">"#C..."</span>,<span class="string">"M...."</span>], <span class="attr">catJump</span> = <span class="number">1</span>, <span class="attr">mouseJump</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：猫无法抓到老鼠，也没法比老鼠先到达食物。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">grid</span> = [<span class="string">"M.C...F"</span>], <span class="attr">catJump</span> = <span class="number">1</span>, <span class="attr">mouseJump</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">grid</span> = [<span class="string">"M.C...F"</span>], <span class="attr">catJump</span> = <span class="number">1</span>, <span class="attr">mouseJump</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">grid</span> = [<span class="string">"C...#"</span>,<span class="string">"...#F"</span>,<span class="string">"....#"</span>,<span class="string">"M...."</span>], <span class="attr">catJump</span> = <span class="number">2</span>, <span class="attr">mouseJump</span> = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">grid</span> = [<span class="string">".M..."</span>,<span class="string">"..#.."</span>,<span class="string">"#..#."</span>,<span class="string">"C#.#."</span>,<span class="string">"...#F"</span>], <span class="attr">catJump</span> = <span class="number">3</span>, <span class="attr">mouseJump</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>rows == grid.length</code></li><li><code>cols = grid[i].length</code></li><li><code>1 &lt;= rows, cols &lt;= 8</code></li><li><code>grid[i][j]</code> 只包含字符 <code>&#39;C&#39; ，&#39;M&#39; ，&#39;F&#39; ，&#39;.&#39; 和 &#39;#&#39;</code> 。</li><li><code>grid</code> 中只包含一个<code>&#39;C&#39; ，&#39;M&#39; 和 &#39;F&#39;</code>。</li><li><code>1 &lt;= catJump, mouseJump &lt;= 8</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/cat-and-mouse-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cat-and-mouse-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> NP + 暴力记忆化DFS搜索</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本质为<code>np</code>问题，方法还是暴力搜索加剪枝，毫无技巧性可言。</li><li>用<code>dfs</code>暴力搜索即可，遍历所有可能的状态。$dp[round][cx][cy][mx][my][curr]$表示在第<code>round</code>次操作，且此时猫在坐标<code>(cx,cy)</code>,老鼠在<code>(mx,my)</code>时，且当前移动为<code>curr</code>时，是否会输赢。</li><li>通过记忆式搜索，本质跟玩石子游戏没有差多少，不过状态和剪枝稍微麻烦点，不太喜欢这类题目。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cx, cy, mx, my, fx, fy;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">8</span>][<span class="number">8</span>][<span class="number">8</span>][<span class="number">8</span>][<span class="number">2</span>]; <span class="comment">// 0 cat win  1 mouse win</span></span><br><span class="line">    <span class="keyword">int</span> cj, mj;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; G;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> turn, <span class="keyword">int</span> mx, <span class="keyword">int</span> my, <span class="keyword">int</span> cx, <span class="keyword">int</span> cy, <span class="keyword">int</span> who)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cache = dp[turn][mx][my][cx][cy][who];</span><br><span class="line">        <span class="keyword">if</span> (cache &gt;= <span class="number">0</span>) <span class="keyword">return</span> cache;</span><br><span class="line">        <span class="keyword">if</span> (turn == <span class="number">65</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mx == fx &amp;&amp; my == fy) <span class="keyword">return</span> cache = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cx == fx &amp;&amp; cy == fy) <span class="keyword">return</span> cache = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mx == cx &amp;&amp; my == cy) <span class="keyword">return</span> cache = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (who == <span class="number">0</span>) &#123; <span class="comment">// mouse</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dir=<span class="number">0</span>;dir&lt;<span class="number">4</span>;dir++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mj;i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx, ny;</span><br><span class="line">                    nx = mx + dx[dir] * i;</span><br><span class="line">                    ny = my + dy[dir] * i;</span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt; n - <span class="number">1</span> || ny &lt; <span class="number">0</span> || ny &gt; m - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (G[nx][ny] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(turn, nx, ny, cx, cy, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">                        <span class="keyword">return</span> dp[turn][mx][my][cx][cy][who] = <span class="number">1</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[turn][mx][my][cx][cy][who] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// cat</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dir=<span class="number">0</span>;dir&lt;<span class="number">4</span>;dir++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cj;i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx, ny;</span><br><span class="line">                    nx = cx + dx[dir] * i;</span><br><span class="line">                    ny = cy + dy[dir] * i;</span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt; n - <span class="number">1</span> || ny &lt; <span class="number">0</span> || ny &gt; m - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (G[nx][ny] == <span class="string">'#'</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(turn + <span class="number">1</span>, mx, my, nx, ny, <span class="number">0</span>) == <span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">return</span> dp[turn][mx][my][cx][cy][who] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[turn][mx][my][cx][cy][who] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMouseWin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; grid, <span class="keyword">int</span> catJump, <span class="keyword">int</span> mouseJump)</span> </span>&#123;</span><br><span class="line">        G = grid;</span><br><span class="line">        cj = catJump;</span><br><span class="line">        mj = mouseJump;</span><br><span class="line">        n = grid.size();</span><br><span class="line">        m = grid[<span class="number">0</span>].length();</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'C'</span>) cx = i, cy = j;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'M'</span>) mx = i, my = j;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'F'</span>) fx = i, fy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, mx, my, cx, cy, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-weekly-contest-224&quot;&gt;&lt;a href=&quot;#leetcode-weekly-contest-224&quot; class=&quot;headerlink&quot; title=&quot;leetcode  weekly contest 224&quot;&gt;&lt;/a&gt;leetcode  weekly contest 224&lt;/h1&gt;&lt;p&gt;本周的题目最后一题好像很难，只做出来了前三题，想通了之后就特别简单。&lt;/p&gt;&lt;h2 id=&quot;1725-可以形成最大正方形的矩形数目&quot;&gt;&lt;a href=&quot;#1725-可以形成最大正方形的矩形数目&quot; class=&quot;headerlink&quot; title=&quot;1725. 可以形成最大正方形的矩形数目&quot;&gt;&lt;/a&gt;1725. 可以形成最大正方形的矩形数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;rectangles&lt;/code&gt; ，其中 &lt;code&gt;rectangles[i] = [li, wi]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个矩形的长度为 &lt;code&gt;li&lt;/code&gt; 、宽度为 &lt;code&gt;wi&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
