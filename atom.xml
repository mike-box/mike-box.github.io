<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-28T14:42:20.599Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>298</title>
    <link href="http://yoursite.com/2021/06/28/298/"/>
    <id>http://yoursite.com/2021/06/28/298/</id>
    <published>2021-06-28T14:42:20.599Z</published>
    <updated>2021-06-28T14:42:20.599Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 247</title>
    <link href="http://yoursite.com/2021/06/27/297/"/>
    <id>http://yoursite.com/2021/06/27/297/</id>
    <published>2021-06-27T05:29:11.848Z</published>
    <updated>2021-06-27T14:11:53.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-247"><a href="#leetcode-contest-247" class="headerlink" title="leetcode  contest  247"></a>leetcode  contest  247</h1><p>周赛的题目质量一向非常高，非常喜欢这类难度适中的题目，稍微带点思考，但并不是特别难的题目。不过还是三题的节奏，第三题竟然没有做出来。</p><h2 id="5797-两个数对之间的最大乘积差"><a href="#5797-两个数对之间的最大乘积差" class="headerlink" title="5797. 两个数对之间的最大乘积差"></a>5797. 两个数对之间的最大乘积差</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>两个数对<code>(a, b)</code> 和 <code>(c, d)</code>之间的 乘积差 定义为 <code>(a * b) - (c * d)</code> 。</p><a id="more"></a><ul><li>例如，<code>(5, 6)</code> 和 <code>(2, 7)</code> 之间的乘积差是 <code>(5 * 6) - (2 * 7) = 16</code> 。</li></ul><p>给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对<code>(nums[w], nums[x])</code> 和 <code>(nums[y], nums[z])</code>之间的 乘积差 取到 最大值 。</p><p>返回以这种方式取得的乘积差中的 最大值 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">34</span></span><br><span class="line">解释：可以选出下标为 <span class="number">1</span> 和 <span class="number">3</span> 的元素构成第一个数对 (<span class="number">6</span>, <span class="number">7</span>) 以及下标 <span class="number">2</span> 和 <span class="number">4</span> 构成第二个数对 (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">乘积差是 (<span class="number">6</span> * <span class="number">7</span>) - (<span class="number">2</span> * <span class="number">4</span>) = <span class="number">34</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">64</span></span><br><span class="line">解释：可以选出下标为 <span class="number">3</span> 和 <span class="number">6</span> 的元素构成第一个数对 (<span class="number">9</span>, <span class="number">8</span>) 以及下标 <span class="number">1</span> 和 <span class="number">5</span> 构成第二个数对 (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">乘积差是 (<span class="number">9</span> * <span class="number">8</span>) - (<span class="number">2</span> * <span class="number">4</span>) = <span class="number">64</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>4 &lt;= nums.length &lt;= 104</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的数学问题，我们知道成绩差的最大值肯定为最大的两数之积减去最小的两数之积。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProductDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[n<span class="number">-1</span>]*nums[n<span class="number">-2</span>] - nums[<span class="number">0</span>]*nums[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5798-循环轮转矩阵"><a href="#5798-循环轮转矩阵" class="headerlink" title="5798. 循环轮转矩阵"></a>5798. 循环轮转矩阵</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>m x n</code>的整数矩阵 <code>grid​​​</code> ，其中 <code>m</code> 和 <code>n</code> 都是 偶数 ；另给你一个整数 k 。</p><p>矩阵由若干层组成，如下图所示，每种颜色代表一层：<br>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 逆时针 方向的相邻元素。轮转示例如下：<br>返回执行 <code>k</code>次循环轮转操作后的矩阵。</p><p>示例 1：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[40,10],[30,20]]</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[10,20],[40,30]]</span></span><br><span class="line">解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]], k = <span class="number">2</span></span><br><span class="line">输出：[[<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>],[<span class="number">2</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">16</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">15</span>],[<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">14</span>]]</span><br><span class="line">解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 50</code></li><li><code>m</code> 和 <code>n</code> 都是 偶数</li><li><code>1 &lt;= grid[i][j] &lt;= 5000</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/cyclically-rotating-a-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cyclically-rotating-a-grid</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们按照层次分别进行模拟旋转即可，这个就是找规律。取出每一层的数据，然后进行向左偏移$k$位即可。</li><li>时间复杂度位$O(2*n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rotateGrid(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> level = min(row/<span class="number">2</span>,col/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copy;</span><br><span class="line">            <span class="comment">/*up*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; col-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*right*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; row-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[j][col-i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*bottom*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                arr.push_back(grid[row<span class="number">-1</span>-i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*left*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = row<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                arr.push_back(grid[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*rotate*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.size(); ++j)&#123;</span><br><span class="line">                copy.push_back(arr[(j+k)%arr.size()]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">             <span class="comment">/*up*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; col-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                ans[i][j] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*right*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; row-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                ans[j][col-i<span class="number">-1</span>] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*bottom*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                ans[row<span class="number">-1</span>-i][j] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*left*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = row<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                ans[j][i] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5799-最美子字符串的数目"><a href="#5799-最美子字符串的数目" class="headerlink" title="5799. 最美子字符串的数目"></a>5799. 最美子字符串的数目</h2><p>如果某个字符串中 至多一个 字母出现 奇数 次，则称其为 最美 字符串。</p><p>例如，<code>&quot;ccjjc&quot;</code> 和 <code>&quot;abab&quot;</code>都是最美字符串，但 <code>&quot;ab&quot;</code>不是。<br>给你一个字符串 <code>word</code> ，该字符串由前十个小写英文字母组成（’a’ 到 ‘j’）。请你返回 <code>word</code> 中 最美非空子字符串 的数目。如果同样的子字符串在 <code>word</code>中出现多次，那么应当对 每次出现 分别计数。</p><p>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"aba"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：<span class="number">4</span> 个最美子字符串如下所示：</span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"b"</span></span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"aba"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"aabb"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：<span class="number">9</span> 个最美子字符串如下所示：</span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"aa"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"aab"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"aabb"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"abb"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"b"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"bb"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"b"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"he"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">2</span> 个最美子字符串如下所示：</span><br><span class="line">- <span class="string">"he"</span> -&gt; <span class="string">"h"</span></span><br><span class="line">- <span class="string">"he"</span> -&gt; <span class="string">"e"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 105</code></li><li><code>word</code>由从 <code>&#39;a&#39;</code>到 <code>&#39;j&#39;</code> 的小写英文字母组成<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/number-of-wonderful-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-wonderful-substrings</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 前缀和 + 状态压缩<code>dp</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>这个题目出的非常不错，我们设状态二进制<code>mask</code>，如果<code>mask</code>的第<code>i</code>位为<code>1</code>则表示字母<code>&#39;a&#39; + i</code>的数目为奇数，如果<code>mask</code>的第<code>i</code>位为<code>0</code>则表示字母<code>&#39;a&#39; + i</code>的数目为偶数。则我们可以字符统计的前缀和，如果状态<code>mask</code>相等的前缀之间的连续子字符串一定每个字符的个数均为偶数。</li><li>题目还给出另一个要求，至多存在一个字符的数目为奇数，则我们可以知道，如果两个前缀之间的某个字符的奇偶性相反，则这两个前缀之间的连续子字符串的该字符的个数一定为奇数，则我们依次尝试假设每一个字符可能为奇数，进行尝试即可。</li><li>时间复杂度为$O(m*n)$,空间复杂度为$2^{m}$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wonderfulSubstrings</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = word.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">1024</span>,<span class="number">0</span>);</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            mask = mask^(<span class="number">1</span>&lt;&lt;(word[i] - <span class="string">'a'</span>));</span><br><span class="line">            ans += cnt[mask];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)&#123;</span><br><span class="line">                ans += cnt[mask^(<span class="number">1</span>&lt;&lt;j)];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[mask]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5204-统计为蚁群构筑房间的不同顺序"><a href="#5204-统计为蚁群构筑房间的不同顺序" class="headerlink" title="5204. 统计为蚁群构筑房间的不同顺序"></a>5204. 统计为蚁群构筑房间的不同顺序</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你是一只蚂蚁，负责为蚁群构筑 <code>n</code>间编号从<code>0</code>到 <code>n-1</code>的新房间。给你一个 下标从 <code>0</code>开始 且长度为 n 的整数数组 <code>prevRoom</code>作为扩建计划。其中，<code>prevRoom[i]</code>表示在构筑房间 i 之前，你必须先构筑房间 <code>prevRoom[i]</code>，并且这两个房间必须 直接 相连。房间 0 已经构筑完成，所以 <code>prevRoom[0] = -1</code>。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 <code>0</code>可以访问到每个房间。</p><p>你一次只能构筑 一个 房间。你可以在 已经构筑好的 房间之间自由穿行，只要这些房间是 相连的 。如果房间 <code>prevRoom[i]</code> 已经构筑完成，那么你就可以构筑房间 <code>i</code>。</p><p>返回你构筑所有房间的 不同顺序的数目 。由于答案可能很大，请返回对<code>109 + 7</code>取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prevRoom = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：仅有一种方案可以完成所有房间的构筑：<span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：prevRoom = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">6</span> 种不同顺序：</span><br><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">3</span> → <span class="number">2</span> → <span class="number">4</span></span><br><span class="line"><span class="number">0</span> → <span class="number">2</span> → <span class="number">4</span> → <span class="number">1</span> → <span class="number">3</span></span><br><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span> → <span class="number">3</span> → <span class="number">4</span></span><br><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span> → <span class="number">4</span> → <span class="number">3</span></span><br><span class="line"><span class="number">0</span> → <span class="number">2</span> → <span class="number">1</span> → <span class="number">3</span> → <span class="number">4</span></span><br><span class="line"><span class="number">0</span> → <span class="number">2</span> → <span class="number">1</span> → <span class="number">4</span> → <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == prevRoom.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>prevRoom[0] == -1</code></li><li>对于所有的 <code>1 &lt;= i &lt; n</code> ，都有 <code>0 &lt;= prevRoom[i] &lt; n</code></li><li>题目保证所有房间都构筑完成后，从房间 <code>0</code>可以访问到每个房间</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-ways-to-build-rooms-in-an-ant-colony" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-ways-to-build-rooms-in-an-ant-colony</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp ，排列组合，乘法逆元</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目除了乘法逆元的数学知识以外，我觉题目本身不难，即为非常容易理解的排列组合。但是觉得这个题目还是出的很好，质量很高，非常适合拿来面试。题目主要要求，构造的拓扑排序的方案数目，我们按照拓扑排序的方式来构造序列即可。</li><li>需要的基础知识为：</li></ol><ul><li>排列数的基本方式，我们知道有$a_{0}$个物品$0$,$a_{1}$个物品$1$,…,$a_{n}$个物品$n$,如果我们需要将这$n$类物品排成一列，则方案数为：<script type="math/tex; mode=display">\frac{(a_{0} + a_{1} + a_{2} + ... + a_{n})!}{a_{0}!.a_{1}!...a_{n}!}</script></li><li>乘法逆元：<script type="math/tex; mode=display">(\frac{b}{a})\mod m ≡ (b * a^{-1} \mod m) \\a*a^{-1} ≡ (1 \mod m) \\a^{-1} ≡ a^{m-2}</script></li></ul><ol><li>设以<code>x</code>为<code>root</code>节点的子树的节点个数为$cnt[x]$,子数的可能的排序方法数为$dp[x]$，则我们可以知道以<code>q</code>为<code>root</code>的树的孩子节点分别为:$p_{1},p_{2},…,p_{k}$,则我们知道根据排列组合可以知道如下：<script type="math/tex; mode=display">cnt[q] = 1 + \sum_{i=1}^{k}p_{i} \\dp[q] = \frac{(p_{1} + p_{2} + p_{3} + ... + p_{k})!}{p_{1}.!p_{2}!...p_{k}!} * \prod_{i=1}^{k}dp[p_{i}]\\= (p_{1} + p_{2} + p_{3} + ... + p_{k})!\prod_{i=1}^{k}((p_{i}!)^{-1}*dp[pi])</script></li><li>算法时间复杂度为$O(32*n)$,空间复杂度为$O(n)$.</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i != <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ret = (ret*curr)%mod;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToBuildRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prevRoom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prevRoom.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; fac(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; inv(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fac[i] = (fac[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">            inv[i] = fastpow(fac[i],mod<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            next[prevRoom[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         function&lt;long long(int)&gt; dfs = [&amp;](int u)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : next[u])&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> curr = dfs(v);</span><br><span class="line">                ret = ((ret*curr)%mod*inv[cnt[v]])%mod;</span><br><span class="line">                cnt[u] += cnt[v];</span><br><span class="line">            &#125;</span><br><span class="line">            ret = (ret*fac[cnt[u]])%mod;</span><br><span class="line">            cnt[u]++;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-247&quot;&gt;&lt;a href=&quot;#leetcode-contest-247&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  247&quot;&gt;&lt;/a&gt;leetcode  contest  247&lt;/h1&gt;&lt;p&gt;周赛的题目质量一向非常高，非常喜欢这类难度适中的题目，稍微带点思考，但并不是特别难的题目。不过还是三题的节奏，第三题竟然没有做出来。&lt;/p&gt;&lt;h2 id=&quot;5797-两个数对之间的最大乘积差&quot;&gt;&lt;a href=&quot;#5797-两个数对之间的最大乘积差&quot; class=&quot;headerlink&quot; title=&quot;5797. 两个数对之间的最大乘积差&quot;&gt;&lt;/a&gt;5797. 两个数对之间的最大乘积差&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;两个数对&lt;code&gt;(a, b)&lt;/code&gt; 和 &lt;code&gt;(c, d)&lt;/code&gt;之间的 乘积差 定义为 &lt;code&gt;(a * b) - (c * d)&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Biweekly Contest 55</title>
    <link href="http://yoursite.com/2021/06/27/296/"/>
    <id>http://yoursite.com/2021/06/27/296/</id>
    <published>2021-06-26T23:39:53.046Z</published>
    <updated>2021-06-27T05:29:16.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-55"><a href="#leetcode-biweekly-contest-55" class="headerlink" title="leetcode  biweekly contest 55"></a>leetcode  biweekly contest 55</h1><p>双周赛的题目难度一直不太稳定，要么太简单，要么太难。晚上的题目确实都很简单。<br><img src="https://i.loli.net/2021/06/27/DjQ1vFhtSUCzXge.png" alt></p><h2 id="5780-删除一个元素使数组严格递增"><a href="#5780-删除一个元素使数组严格递增" class="headerlink" title="5780. 删除一个元素使数组严格递增"></a>5780. 删除一个元素使数组严格递增</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 0 开始的整数数组 <code>nums</code> ，如果 恰好 删除 一个 元素后，数组 严格递增 ，那么请你返回<code>true</code> ，否则返回 false 。如果数组本身已经是严格递增的，请你也返回<code>true</code> 。</p><a id="more"></a><p>数组 nums 是 严格递增 的定义为：对于任意下标的 <code>1 &lt;= i &lt; nums.length</code>都满足 <code>nums[i - 1] &lt; nums[i]</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：从 nums 中删除下标 <span class="number">2</span> 处的 <span class="number">10</span> ，得到 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>] 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>] 是严格递增的，所以返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>] 是删除下标 <span class="number">0</span> 处元素后得到的结果。</span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>] 是删除下标 <span class="number">1</span> 处元素后得到的结果。</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>] 是删除下标 <span class="number">2</span> 处元素后得到的结果。</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 是删除下标 <span class="number">3</span> 处元素后得到的结果。</span><br><span class="line">没有任何结果数组是严格递增的，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：删除任意元素后的结果都是 [<span class="number">1</span>,<span class="number">1</span>] 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>] 不是严格递增的，所以返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 已经是严格递增的，所以返回 <span class="literal">true</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= nums.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">1000</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的滑动窗口，如果去掉当前的第`i`个元素，则需要判断条件如下：</span><br><span class="line">+ 前`i<span class="number">-1</span>`个元素为严格递增，从`i+<span class="number">1</span>`开始的元素严格递增。</span><br><span class="line">+ $nums[i+<span class="number">1</span>] &gt; nums[i<span class="number">-1</span>]$</span><br><span class="line"><span class="number">2.</span> 时间复杂度为$O(n)$,空间复杂度为$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> canBeIncreasing(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; left(n);</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; right(n);</span><br><span class="line">        left[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        right[n<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; left[i<span class="number">-1</span>])&#123;</span><br><span class="line">                left[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i+<span class="number">1</span>] &amp;&amp; right[i+<span class="number">1</span>])&#123;</span><br><span class="line">                right[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i+<span class="number">1</span>] &gt; nums[i<span class="number">-1</span>] &amp;&amp; left[i<span class="number">-1</span>] &amp;&amp; right[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5781-删除一个字符串中所有出现的给定子字符串"><a href="#5781-删除一个字符串中所有出现的给定子字符串" class="headerlink" title="5781. 删除一个字符串中所有出现的给定子字符串"></a>5781. 删除一个字符串中所有出现的给定子字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串<code>s</code>和 <code>part</code>，请你对 s 反复执行以下操作直到 所有 子字符串 <code>part</code>都被删除：</p><p>找到<code>s</code> 中 最左边 的子字符串<code>part</code> ，并将它从 <code>s</code> 中删除。<br>请你返回从 <code>s</code> 中删除所有 <code>part</code>子字符串以后得到的剩余字符串。</p><p>一个 子字符串 是一个字符串中连续的字符序列。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"daabcbaabcbc"</span>, <span class="attr">part</span> = <span class="string">"abc"</span></span><br><span class="line">输出：<span class="string">"dab"</span></span><br><span class="line">解释：以下操作按顺序执行：</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"daabcbaabcbc"</span> ，删除下标从 <span class="number">2</span> 开始的 <span class="string">"abc"</span> ，得到 <span class="attr">s</span> = <span class="string">"dabaabcbc"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"dabaabcbc"</span> ，删除下标从 <span class="number">4</span> 开始的 <span class="string">"abc"</span> ，得到 <span class="attr">s</span> = <span class="string">"dababc"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"dababc"</span> ，删除下标从 <span class="number">3</span> 开始的 <span class="string">"abc"</span> ，得到 <span class="attr">s</span> = <span class="string">"dab"</span> 。</span><br><span class="line">此时 s 中不再含有子字符串 <span class="string">"abc"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"axxxxyyyyb"</span>, <span class="attr">part</span> = <span class="string">"xy"</span></span><br><span class="line">输出：<span class="string">"ab"</span></span><br><span class="line">解释：以下操作按顺序执行：</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"axxxxyyyyb"</span> ，删除下标从 <span class="number">4</span> 开始的 <span class="string">"xy"</span> ，得到 <span class="attr">s</span> = <span class="string">"axxxyyyb"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"axxxyyyb"</span> ，删除下标从 <span class="number">3</span> 开始的 <span class="string">"xy"</span> ，得到 <span class="attr">s</span> = <span class="string">"axxyyb"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"axxyyb"</span> ，删除下标从 <span class="number">2</span> 开始的 <span class="string">"xy"</span> ，得到 <span class="attr">s</span> = <span class="string">"axyb"</span> 。</span><br><span class="line">- <span class="attr">s</span> = <span class="string">"axyb"</span> ，删除下标从 <span class="number">1</span> 开始的 <span class="string">"xy"</span> ，得到 <span class="attr">s</span> = <span class="string">"ab"</span> 。</span><br><span class="line">此时 s 中不再含有子字符串 <span class="string">"xy"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>1 &lt;= part.length &lt;= 1000</code></li><li><code>s​​​​​​</code> 和 <code>part</code> `只包小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 栈的应用</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的栈的应用，我们判断当前栈的后<code>n</code>个字符组成的字符串是否与<code>part</code>相等，如果相等则从栈中弹出<code>n</code>个字符。</li><li>时间复杂度为$O(n^{2})$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOccurrences</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> part)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size();</span><br><span class="line">        <span class="keyword">int</span> n = part.size();</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            curr.push_back(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt;= n &amp;&amp; curr.substr(curr.size()-n) == part)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) curr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5782-最大子序列交替和"><a href="#5782-最大子序列交替和" class="headerlink" title="5782. 最大子序列交替和"></a>5782. 最大子序列交替和</h2><p>一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。</p><p>比方说，数组 <code>[4,2,5,3]</code>的交替和为<code>(4 + 5) - (2 + 3) = 4</code>。<br>给你一个数组 <code>nums</code>，请你返回 <code>nums</code>中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。</p><p>一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,2,3,7,2,1,4]</code> 的一个子序列（加粗元素），但是 <code>[2,4,2]</code>不是。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：最优子序列为 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] ，交替和为 (<span class="number">4</span> + <span class="number">5</span>) - <span class="number">2</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：最优子序列为 [<span class="number">8</span>] ，交替和为 <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：最优子序列为 [<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>] ，交替和为 (<span class="number">6</span> + <span class="number">5</span>) - <span class="number">1</span> = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态对话，我们设<code>dp[i][0]</code>表示前<code>i</code>个数中选择奇数个元素的最大交替和，<code>dp[i][1]</code>表示前<code>i</code>个数中选择偶数个元素的最大交替和。</li><li>如果我们选择第<code>i+1</code>个元素加入到子数组中，</li></ol><ul><li>前<code>i+1</code>个元素中选择奇数个元素的子序列，假设选择第<code>i+1</code>个元素加入到子序列中，则$nums[i+1]$在子序列中的下标应该为偶数，则前<code>i</code>个元素中已经选择了偶数个元素，则：<script type="math/tex; mode=display">dp[i+1][0] = max(dp[i][0],dp[i][1] + nums[i+1])</script></li><li>前<code>i+1</code>个元素中选择偶数个元素的子序列，假设选择第<code>i+1</code>个元素加入到子序列中，则$nums[i+1]$在子序列中的下标应该为奇数，则前<code>i</code>个元素中已经选择了奇数个元素，则：<script type="math/tex; mode=display">dp[i+1][1] = max(dp[i][1],dp[i][0] - nums[i+1])</script></li></ul><ol><li>时间复杂度为$O(n)$,空间复杂度为$O(n)$.</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxAlternatingSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = nums[<span class="number">0</span>]; <span class="comment">// even</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;       <span class="comment">// odd</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">// even</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],nums[i] + dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// odd</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[i][<span class="number">0</span>]);</span><br><span class="line">            ans = max(ans,dp[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5783-设计电影租借系统"><a href="#5783-设计电影租借系统" class="headerlink" title="5783. 设计电影租借系统"></a>5783. 设计电影租借系统</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你有一个电影租借公司和 n 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。</p><p>所有电影用二维整数数组 <code>entries</code> 表示，其中 <code>entries[i] = [shopi, moviei, pricei]</code>表示商店<code>shopi</code>有一份电影 <code>moviei</code> 的拷贝，租借价格为<code>pricei</code> 。每个商店有 至多一份 编号为 <code>moviei</code>的电影拷贝。</p><p>系统需要支持以下操作：</p><ul><li><code>Search</code>：找到拥有指定电影且 未借出 的商店中 最便宜的 5 个 。商店需要按照 价格 升序排序，如果价格相同，则 shopi 较小 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。</li><li>`Rent：从指定商店借出指定电影，题目保证指定电影在指定商店 未借出 。</li><li><code>Drop</code>：在指定商店返还 之前已借出 的指定电影。</li><li><code>Report</code>：返回 最便宜的 5 部已借出电影 （可能有重复的电影 ID），将结果用二维列表 res 返回，其中 res[j] = [shopj, moviej] 表示第 j 便宜的已借出电影是从商店 shopj 借出的电影 moviej 。res 中的电影需要按 价格 升序排序；如果价格相同，则 shopj 较小 的排在前面；如果仍然相同，则 moviej 较小 的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。<br>请你实现 MovieRentingSystem 类：</li><li><code>MovieRentingSystem(int n, int[][] entries)</code>将 MovieRentingSystem 对象用 n 个商店和 entries 表示的电影列表初始化。</li><li><code>List&lt;Integer&gt; search(int movie)</code>如上所述，返回 未借出 指定 movie 的商店列表。</li><li><code>void rent(int shop, int movie)</code> 从指定商店 shop 借出指定电影 movie 。</li><li><code>void drop(int shop, int movie)</code> 在指定商店 shop 返还之前借出的电影 movie 。</li><li><code>List&lt;List&lt;Integer&gt;&gt; report()</code> 如上所述，返回最便宜的 已借出 电影列表。</li><li>注意：测试数据保证 rent 操作中指定商店拥有 未借出 的指定电影，且 drop 操作指定的商店 之前已借出 指定电影。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MovieRentingSystem"</span>, <span class="string">"search"</span>, <span class="string">"rent"</span>, <span class="string">"rent"</span>, <span class="string">"report"</span>, <span class="string">"drop"</span>, <span class="string">"search"</span>]</span><br><span class="line">[[<span class="number">3</span>, [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>]]], [<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>], [], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>], null, null, [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]], null, [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MovieRentingSystem movieRentingSystem = new MovieRentingSystem(<span class="number">3</span>, [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>]]);</span><br><span class="line">movieRentingSystem.search(<span class="number">1</span>);  <span class="comment">// 返回 [1, 0, 2] ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。</span></span><br><span class="line">movieRentingSystem.rent(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 [2,3] 。</span></span><br><span class="line">movieRentingSystem.rent(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 [1] 。</span></span><br><span class="line">movieRentingSystem.report();   <span class="comment">// 返回 [[0, 1], [1, 2]] 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。</span></span><br><span class="line">movieRentingSystem.drop(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 [1,2] 。</span></span><br><span class="line">movieRentingSystem.search(<span class="number">2</span>);  <span class="comment">// 返回 [0, 1] 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= n &lt;= 3 * 105</li><li>1 &lt;= entries.length &lt;= 105</li><li>0 &lt;= shopi &lt; n</li><li>1 &lt;= moviei, pricei &lt;= 104</li><li>每个商店 至多 有一份电影 moviei 的拷贝。</li><li>search，rent，drop 和 report 的调用 总共 不超过 105 次。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/design-movie-rental-system" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-movie-rental-system</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> tree hash</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目确实太长了，但是实际难度很小，感觉只能算<code>5</code>分的中等难度题目，大意就是用<code>hashset</code>保存<code>[shop,movie]</code>对应的价格<code>prices</code>，同时保存每个商店中已有的电影的详细信息，且按照<code>price</code>与<code>shop</code>的顺序进行有序排序，保存每个<code>movie</code>对应的<code>[shop,price]</code>的信息，同时单独保存一张已经出租的<code>movie</code>的有序列表，以上存储都可以用<code>map</code>和<code>set</code>进行实现。</li><li>每次查询时，直接取出有序<code>set</code>中存储的前<code>5</code>个元素即可。</li><li>时间复杂度为$O(mlgn)$,空间复杂度为$O(4*n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> shop;</span><br><span class="line">    <span class="keyword">int</span> movie;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    Node(<span class="keyword">int</span> shop,<span class="keyword">int</span> movie,<span class="keyword">int</span> price)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;shop = shop;</span><br><span class="line">        <span class="keyword">this</span>-&gt;movie = movie;</span><br><span class="line">        <span class="keyword">this</span>-&gt;price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(a.price == b.price)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a.shop == b.shop) <span class="keyword">return</span> a.movie &lt; b.movie;</span><br><span class="line">           <span class="keyword">return</span> a.shop &lt; b.shop;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> a.price &lt; b.price;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieRentingSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MovieRentingSystem(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; entries) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;all = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries.size(); ++i)&#123;</span><br><span class="line">            movies[entries[i][<span class="number">1</span>]].insert(Node(entries[i][<span class="number">0</span>],entries[i][<span class="number">1</span>],entries[i][<span class="number">2</span>]));</span><br><span class="line">            shops[entries[i][<span class="number">0</span>]].insert(Node(entries[i][<span class="number">0</span>],entries[i][<span class="number">1</span>],entries[i][<span class="number">2</span>]));</span><br><span class="line">            prices[make_pair(entries[i][<span class="number">0</span>],entries[i][<span class="number">1</span>])] = entries[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; search(<span class="keyword">int</span> movie) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!movies.count(movie)) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">auto</span> it = movies[movie].begin();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> &amp;&amp; it != movies[movie].end(); ++i,it++)&#123;</span><br><span class="line">            ans.push_back(it-&gt;shop);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">(<span class="keyword">int</span> shop, <span class="keyword">int</span> movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> price = prices[make_pair(shop,movie)];</span><br><span class="line">        remove.insert(Node(shop,movie,price));</span><br><span class="line">        movies[movie].erase(Node(shop,movie,price));</span><br><span class="line">        shops[shop].erase(Node(shop,movie,price));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drop</span><span class="params">(<span class="keyword">int</span> shop, <span class="keyword">int</span> movie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> price = prices[make_pair(shop,movie)];</span><br><span class="line">        remove.erase(Node(shop,movie,price));</span><br><span class="line">        movies[movie].insert(Node(shop,movie,price));</span><br><span class="line">        shops[shop].insert(Node(shop,movie,price));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; report() &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">auto</span> it = remove.begin();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> &amp;&amp; it != remove.end(); ++i,it++)&#123;</span><br><span class="line">            ans.push_back(&#123;it-&gt;shop,it-&gt;movie&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> all;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;Node,cmp&gt;&gt; movies;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;Node,cmp&gt;&gt; shops;</span><br><span class="line">    <span class="built_in">map</span>&lt;pii,<span class="keyword">int</span>&gt; prices;</span><br><span class="line">    <span class="built_in">set</span>&lt;Node,cmp&gt; remove;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovieRentingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovieRentingSystem* obj = new MovieRentingSystem(n, entries);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;search(movie);</span></span><br><span class="line"><span class="comment"> * obj-&gt;rent(shop,movie);</span></span><br><span class="line"><span class="comment"> * obj-&gt;drop(shop,movie);</span></span><br><span class="line"><span class="comment"> * vector&lt;vector&lt;int&gt;&gt; param_4 = obj-&gt;report();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-55&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-55&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 55&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 55&lt;/h1&gt;&lt;p&gt;双周赛的题目难度一直不太稳定，要么太简单，要么太难。晚上的题目确实都很简单。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/06/27/DjQ1vFhtSUCzXge.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5780-删除一个元素使数组严格递增&quot;&gt;&lt;a href=&quot;#5780-删除一个元素使数组严格递增&quot; class=&quot;headerlink&quot; title=&quot;5780. 删除一个元素使数组严格递增&quot;&gt;&lt;/a&gt;5780. 删除一个元素使数组严格递增&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 0 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; ，如果 恰好 删除 一个 元素后，数组 严格递增 ，那么请你返回&lt;code&gt;true&lt;/code&gt; ，否则返回 false 。如果数组本身已经是严格递增的，请你也返回&lt;code&gt;true&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 246</title>
    <link href="http://yoursite.com/2021/06/20/295/"/>
    <id>http://yoursite.com/2021/06/20/295/</id>
    <published>2021-06-20T03:44:12.301Z</published>
    <updated>2021-06-20T12:16:54.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-246"><a href="#leetcode-contest-246" class="headerlink" title="leetcode  contest 246"></a>leetcode  contest 246</h1><p>本周的周赛题目竟然如此的简单，前三题感觉基本上毫无难度，题目拿到就有思路的那种，最后一题用了个比较恶心的线段树竟然超时了，后面换成暴力的前缀和，竟然过了，最后一题的分数竟然只有<code>5</code>分，可以看出最后一题是多么的简单，感觉是我把题目想复杂了。<br><img src="https://i.loli.net/2021/06/20/vjC6ErtmedKiPng.png" alt></p><h2 id="5788-字符串中的最大奇数"><a href="#5788-字符串中的最大奇数" class="headerlink" title="5788. 字符串中的最大奇数"></a>5788. 字符串中的最大奇数</h2><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>num</code>，表示一个大整数。请你在字符串 <code>num</code>的所有 非空子字符串 中找出 值最大的奇数 ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 “” 。</p><p>子字符串 是字符串中的一个连续的字符序列。</p><p>示例 1：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"52"</span></span><br><span class="line">输出：<span class="string">"5"</span></span><br><span class="line">解释：非空子字符串仅有 <span class="string">"5"</span>、<span class="string">"2"</span> 和 <span class="string">"52"</span> 。<span class="string">"5"</span> 是其中唯一的奇数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"4206"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：在 <span class="string">"4206"</span> 中不存在奇数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"35427"</span></span><br><span class="line">输出：<span class="string">"35427"</span></span><br><span class="line">解释：<span class="string">"35427"</span> 本身就是一个奇数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 105</code></li><li><code>num</code> 仅由数字组成且不含前导零</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/largest-odd-number-in-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-246/problems/largest-odd-number-in-string/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>既然需要找到表示最大的奇书，我们从又往左数，找到第一位为奇数的字符，然后前面的字符串即可，此时找到的字符串即为最大的数。</li><li>时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestOddNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = num.size()<span class="number">-1</span>;i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num[i] - <span class="string">'0'</span>)%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> num.substr(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5789-你完成的完整对局数"><a href="#5789-你完成的完整对局数" class="headerlink" title="5789. 你完成的完整对局数"></a>5789. 你完成的完整对局数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。这意味着，在 HH:00、HH:15、HH:30 和 HH:45 ，将会开始一个新的对局，其中 HH 用一个从 <code>00</code>到 23 的整数表示。游戏中使用 24 小时制的时钟 ，所以一天中最早的时间是 00:00 ，最晚的时间是 23:59 。</p><p>给你两个字符串 <code>startTime</code> 和 <code>finishTime</code>，均符合 <code>&quot;HH:MM&quot;</code> 格式，分别表示你 进入 和 退出 游戏的确切时间，请计算在整个游戏会话期间，你完成的 完整对局的对局数 。</p><p>例如，如果 <code>startTime = &quot;05:20&quot;</code>且 <code>finishTime = &quot;05:59&quot;</code> ，这意味着你仅仅完成从 05:30 到 05:45 这一个完整对局。而你没有完成从 05:15 到 05:30 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 05:45 到 06:00 的完整对局，因为你是在对局结束前退出的游戏。<br>如果 finishTime 早于 startTime ，这表示你玩了个通宵（也就是从 startTime 到午夜，再从午夜到 finishTime）。</p><p>假设你是从 startTime 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 完整对局的对局数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：startTime = <span class="string">"12:01"</span>, finishTime = <span class="string">"12:44"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你完成了从 <span class="number">12</span>:<span class="number">15</span> 到 <span class="number">12</span>:<span class="number">30</span> 的一个完整对局。</span><br><span class="line">你没有完成从 <span class="number">12</span>:<span class="number">00</span> 到 <span class="number">12</span>:<span class="number">15</span> 的完整对局，因为你是在对局开始后的 <span class="number">12</span>:<span class="number">01</span> 进入的游戏。</span><br><span class="line">你没有完成从 <span class="number">12</span>:<span class="number">30</span> 到 <span class="number">12</span>:<span class="number">45</span> 的完整对局，因为你是在对局结束前的 <span class="number">12</span>:<span class="number">44</span> 退出的游戏。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：startTime = <span class="string">"20:00"</span>, finishTime = <span class="string">"06:00"</span></span><br><span class="line">输出：<span class="number">40</span></span><br><span class="line">解释：你完成了从 <span class="number">20</span>:<span class="number">00</span> 到 <span class="number">00</span>:<span class="number">00</span> 的 <span class="number">16</span> 个完整的对局，以及从 <span class="number">00</span>:<span class="number">00</span> 到 <span class="number">06</span>:<span class="number">00</span> 的 <span class="number">24</span> 个完整的对局。</span><br><span class="line"><span class="number">16</span> + <span class="number">24</span> = <span class="number">40</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：startTime = <span class="string">"00:00"</span>, finishTime = <span class="string">"23:59"</span></span><br><span class="line">输出：<span class="number">95</span></span><br><span class="line">解释：除最后一个小时你只完成了 <span class="number">3</span> 个完整对局外，其余每个小时均完成了 <span class="number">4</span> 场完整对局。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>startTime</code> 和 <code>finishTime</code> 的格式为 <code>HH:MM</code></li><li><code>00 &lt;= HH &lt;= 23</code></li><li><code>00 &lt;= MM &lt;= 59</code></li><li><code>startTime</code> 和 <code>finishTime</code> 不相等</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/the-number-of-full-rounds-you-have-played/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-246/problems/the-number-of-full-rounds-you-have-played/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们首先将小时数转换为分钟来计算，我们可以看到观察到每次比赛必须以能被<code>15</code>整除的分钟数起点开局，此时则非常简单，我们对于开始分钟数<code>start</code>对<code>15</code>取模且向上取整，对于结束的分钟数<code>terminal</code>则对<code>15</code>向下取整，然后相减即可得到可以开局的局数。</li><li>对于开始时间大于结束时间的情况，则我们需要将结束时间加上<code>1440</code>即可。</li><li>时间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfRounds</span><span class="params">(<span class="built_in">string</span> startTime, <span class="built_in">string</span> finishTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h1 = (startTime[<span class="number">0</span>] - <span class="string">'0'</span>)*<span class="number">10</span> + startTime[<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> m1 = (startTime[<span class="number">3</span>] - <span class="string">'0'</span>)*<span class="number">10</span> + startTime[<span class="number">4</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> h2 = (finishTime[<span class="number">0</span>] - <span class="string">'0'</span>)*<span class="number">10</span> + finishTime[<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> m2 = (finishTime[<span class="number">3</span>] - <span class="string">'0'</span>)*<span class="number">10</span> + finishTime[<span class="number">4</span>] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> s = h1*<span class="number">60</span> + m1;</span><br><span class="line">        <span class="keyword">int</span> t = h2*<span class="number">60</span> + m2;</span><br><span class="line">        <span class="keyword">if</span>(t &lt; s) t = t + <span class="number">1440</span>;</span><br><span class="line">        <span class="keyword">return</span> t/<span class="number">15</span> - (s+<span class="number">14</span>)/<span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5791-统计子岛屿"><a href="#5791-统计子岛屿" class="headerlink" title="5791. 统计子岛屿"></a>5791. 统计子岛屿</h2><p>给你两个 <code>m x n</code>的二进制矩阵 <code>grid1</code> 和<code>grid2</code>，它们只包含 <code>0</code> （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。</p><p>如果 <code>grid2</code>的一个岛屿，被 <code>grid1</code>的一个岛屿 完全 包含，也就是说 <code>grid2</code>中该岛屿的每一个格子都被<code>grid1</code>中同一个岛屿完全包含，那么我们称 <code>grid2</code>中的这个岛屿为 子岛屿 。</p><p>请你返回 <code>grid2</code>中 子岛屿 的 数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid1 = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]], grid2 = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：如上图所示，左边为 grid1 ，右边为 grid2 。</span><br><span class="line">grid2 中标红的 <span class="number">1</span> 区域是子岛屿，总共有 <span class="number">3</span> 个子岛屿。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid1 = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]], grid2 = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：如上图所示，左边为 grid1 ，右边为 grid2 。</span><br><span class="line">grid2 中标红的 <span class="number">1</span> 区域是子岛屿，总共有 <span class="number">2</span> 个子岛屿。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid1.length == grid2.length</code></li><li><code>n == grid1[i].length == grid2[i].length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 0 要么是 1 。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/count-sub-islands/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-246/problems/count-sub-islands/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较简单两个<code>bfs</code>即可完成。对于第一个<code>grid</code>，此时我们通过<code>bfs</code>对每个岛屿进行标记，即标记某个陆地是属于第几个道路。</li><li>我们对第二个<code>grid</code>也进行<code>bfs</code>，通过<code>bfs</code>将<code>grid2</code>中的岛屿<code>island</code>筛选出来,则此时我们就需要判断<code>island</code>是否属于<code>grid1</code>的某个岛屿的子岛屿，我们则需要判断<code>island</code>中的每个陆地是否同属于同一个岛屿编号。这个用<code>bfs</code>即可完成时间。</li><li>时间复杂度为$O(m<em>n)$,空间复杂度为$O(3</em>m*n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid2.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid2[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit1(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit2(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; idx(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">-1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*bfs*/</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visit1[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid1[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*bfs*/</span></span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">                qu.push(i*col+j);</span><br><span class="line">                visit1[i][j] = <span class="literal">true</span>;</span><br><span class="line">                idx[i][j] = flag;</span><br><span class="line">                <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = curr/col + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = curr%col + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(grid1[x][y] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(visit1[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                        qu.push(x*col+y);</span><br><span class="line">                        visit1[x][y] = <span class="literal">true</span>;</span><br><span class="line">                        idx[x][y] = flag;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;flag&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visit2[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid2[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*bfs*/</span></span><br><span class="line">                <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">                qu.push(i*col+j);</span><br><span class="line">                visit2[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> currFlag = idx[i][j];</span><br><span class="line">                <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    <span class="keyword">if</span>(grid1[curr/col][curr%col] == <span class="number">0</span>)&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(idx[curr/col][curr%col] != currFlag)&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = curr/col + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = curr%col + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(grid2[x][y] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(visit2[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                        qu.push(x*col+y);</span><br><span class="line">                        visit2[x][y] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(valid) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5790-查询差绝对值的最小值"><a href="#5790-查询差绝对值的最小值" class="headerlink" title="5790. 查询差绝对值的最小值"></a>5790. 查询差绝对值的最小值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个数组 a 的 差绝对值的最小值 定义为：<code>0 &lt;= i &lt; j &lt; a.length</code> 且 <code>a[i] != a[j]</code> 的 <code>|a[i] - a[j]|</code>的 最小值。如果 a 中所有元素都 相同 ，那么差绝对值的最小值为 -1 。</p><p>比方说，数组 <code>[5,2,3,7,2]</code>差绝对值的最小值是<code>|2 - 3| = 1</code> 。注意答案不为 0 ，因为 a[i] 和 a[j] 必须不相等。<br>给你一个整数数组 nums 和查询数组 queries ，其中<code>queries[i] = [li, ri]</code> 。对于每个查询 i ，计算 子数组<code>nums[li...ri]</code>中 差绝对值的最小值 ，子数组 <code>nums[li...ri] 包含 nums</code> 数组（下标从 0 开始）中下标在 li 和 ri 之间的所有元素（包含 li 和 ri 在内）。</p><p>请你返回 ans 数组，其中 <code>ans[i]</code> 是第 <code>i</code>个查询的答案。</p><p>子数组 是一个数组中连续的一段元素。</p><p>|x| 的值定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-</code>x 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>], queries = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">解释：查询结果如下：</span><br><span class="line">- queries[<span class="number">0</span>] = [<span class="number">0</span>,<span class="number">1</span>]：子数组是 [<span class="number">1</span>,<span class="number">3</span>] ，差绝对值的最小值为 |<span class="number">1</span><span class="number">-3</span>| = <span class="number">2</span> 。</span><br><span class="line">- queries[<span class="number">1</span>] = [<span class="number">1</span>,<span class="number">2</span>]：子数组是 [<span class="number">3</span>,<span class="number">4</span>] ，差绝对值的最小值为 |<span class="number">3</span><span class="number">-4</span>| = <span class="number">1</span> 。</span><br><span class="line">- queries[<span class="number">2</span>] = [<span class="number">2</span>,<span class="number">3</span>]：子数组是 [<span class="number">4</span>,<span class="number">8</span>] ，差绝对值的最小值为 |<span class="number">4</span><span class="number">-8</span>| = <span class="number">4</span> 。</span><br><span class="line">- queries[<span class="number">3</span>] = [<span class="number">0</span>,<span class="number">3</span>]：子数组是 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>] ，差的绝对值的最小值为 |<span class="number">3</span><span class="number">-4</span>| = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">10</span>], queries = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：查询结果如下：</span><br><span class="line">- queries[<span class="number">0</span>] = [<span class="number">2</span>,<span class="number">3</span>]：子数组是 [<span class="number">2</span>,<span class="number">2</span>] ，差绝对值的最小值为 <span class="number">-1</span> ，因为所有元素相等。</span><br><span class="line">- queries[<span class="number">1</span>] = [<span class="number">0</span>,<span class="number">2</span>]：子数组是 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>] ，差绝对值的最小值为 |<span class="number">4</span><span class="number">-5</span>| = <span class="number">1</span> 。</span><br><span class="line">- queries[<span class="number">2</span>] = [<span class="number">0</span>,<span class="number">5</span>]：子数组是 [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">10</span>] ，差绝对值的最小值为 |<span class="number">4</span><span class="number">-5</span>| = <span class="number">1</span> 。</span><br><span class="line">- queries[<span class="number">3</span>] = [<span class="number">3</span>,<span class="number">5</span>]：子数组是 [<span class="number">2</span>,<span class="number">7</span>,<span class="number">10</span>] ，差绝对值的最小值为 |<span class="number">7</span><span class="number">-10</span>| = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= queries.length &lt;= 2 * 104</code></li><li><code>0 &lt;= li &lt; ri &lt; nums.length</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-246/problems/minimum-absolute-difference-queries/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-246/problems/minimum-absolute-difference-queries/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 前缀和</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>刚开始拿到这个题目想的太复杂了，竟然用了最复杂的暴力线段树来解题，结果竟然超时，后来发现还不如用前缀和。题目的关键点在于<code>1 &lt;= nums[i] &lt;= 100</code>，这个数量级很小，则我们利用前缀和统计每个数出现的次数即可，比如$sum[i][j]$表示前<code>i</code>个数中出现数字<code>j</code>的次数。此时我们查询时即可在$O(max(nums))$时间复杂度内找到区间中存在的元素。</li><li>我们知道绝对值最小的元素肯定为两者最近的元素的差，则很容易求出最小的绝对值之差。</li><li>时间复杂度为$O((n+m)<em>max(nums))$,空间复杂度为$O(n</em>max(nums))$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minDifference(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> maxnum = *max_element(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sum(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxnum+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i];</span><br><span class="line">            sum[i+<span class="number">1</span>][nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = sum[queries[i][<span class="number">0</span>]];</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = sum[queries[i][<span class="number">1</span>]+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxnum; ++j)&#123;</span><br><span class="line">                right[j] -= left[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxnum; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right[j] &gt; <span class="number">0</span>) arr.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.push_back(<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> diff = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size(); ++j)&#123;</span><br><span class="line">                    diff = min(diff,arr[j] - arr[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.push_back(diff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-246&quot;&gt;&lt;a href=&quot;#leetcode-contest-246&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 246&quot;&gt;&lt;/a&gt;leetcode  contest 246&lt;/h1&gt;&lt;p&gt;本周的周赛题目竟然如此的简单，前三题感觉基本上毫无难度，题目拿到就有思路的那种，最后一题用了个比较恶心的线段树竟然超时了，后面换成暴力的前缀和，竟然过了，最后一题的分数竟然只有&lt;code&gt;5&lt;/code&gt;分，可以看出最后一题是多么的简单，感觉是我把题目想复杂了。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/06/20/vjC6ErtmedKiPng.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5788-字符串中的最大奇数&quot;&gt;&lt;a href=&quot;#5788-字符串中的最大奇数&quot; class=&quot;headerlink&quot; title=&quot;5788. 字符串中的最大奇数&quot;&gt;&lt;/a&gt;5788. 字符串中的最大奇数&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 245</title>
    <link href="http://yoursite.com/2021/06/14/294/"/>
    <id>http://yoursite.com/2021/06/14/294/</id>
    <published>2021-06-14T09:27:18.244Z</published>
    <updated>2021-06-14T12:24:29.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-245"><a href="#leetcode-contest-245" class="headerlink" title="leetcode  contest 245"></a>leetcode  contest 245</h1><p>周赛的题目质量还是一如既往的高，题目质量非常不错，不过还是三道题目的节奏，感觉<code>contest</code>的技巧就是做题速度要快，手速要快，基本上要达到看到题目就有思路那种，才能给<code>hard</code>题目留足思考的时间，只有这样才能达到竞赛的技巧。许多竞赛的选手估计已经训练过非常非常多的题目，难怪最好的<code>IOI</code>选手最好是从初中或者高中就开始训练，思维和速度很重要，基本上需要尽快的训练和固话自己的思维，基本上拿到题目就像肌肉训练一样才可以。</p><a id="more"></a><h2 id="1897-重新分配字符使所有字符串都相等"><a href="#1897-重新分配字符使所有字符串都相等" class="headerlink" title="1897. 重新分配字符使所有字符串都相等"></a>1897. 重新分配字符使所有字符串都相等</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>words</code>（下标 从 0 开始 计数）。</p><p>在一步操作中，需先选出两个 不同 下标 i 和 j，其中 <code>words[i]</code> 是一个非空字符串，接着将<code>words[i]</code> 中的 任一 字符移动到 <code>words[j]</code> 中的 任一 位置上。</p><p>如果执行任意步操作可以使 <code>words</code> 中的每个字符串都相等，返回 <code>true</code>；否则，返回<code>false</code> 。</p><p>示例 1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">words</span> = [<span class="string">"abc"</span>,<span class="string">"aabc"</span>,<span class="string">"bc"</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：将 <span class="keyword">words</span>[<span class="number">1</span>] 中的第一个 <span class="string">'a'</span> 移动到 <span class="keyword">words</span>[<span class="number">2</span>] 的最前面。</span><br><span class="line">使 <span class="keyword">words</span>[<span class="number">1</span>] = <span class="string">"abc"</span> 且 <span class="keyword">words</span>[<span class="number">2</span>] = <span class="string">"abc"</span> 。</span><br><span class="line">所有字符串都等于 <span class="string">"abc"</span> ，所以返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">words</span> = [<span class="string">"ab"</span>,<span class="string">"a"</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：执行操作无法使所有字符串都相等。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 100</code></li><li><code>words[i]</code> 由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/redistribute-characters-to-make-all-strings-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redistribute-characters-to-make-all-strings-equal</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>数据量很小，我们只需要计算统计所有字符的个数，然后计算每个字符的个数是否能对字符串的长度取模为<code>0</code>.</li><li>算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">makeEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w: words)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : w)&#123;</span><br><span class="line">                cnt[c-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]%n != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1898-可移除字符的最大数目"><a href="#1898-可移除字符的最大数目" class="headerlink" title="1898. 可移除字符的最大数目"></a>1898. 可移除字符的最大数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>s</code>和 <code>p</code> ，其中 <code>p</code>是<code>s</code>的一个 子序列 。同时，给你一个元素 互不相同 且下标 从 0 开始 计数的整数数组 <code>removable</code> ，该数组是 s 中下标的一个子集（s 的下标也 从 0 开始 计数）。</p><p>请你找出一个整数 <code>k（0 &lt;= k &lt;= removable.length）</code>，选出 <code>removable</code>中的 前 <code>k</code>个下标，然后从<code>s</code>中移除这些下标对应的<code>k</code> 个字符。整数 k 需满足：在执行完上述步骤后， p 仍然是 s 的一个 子序列 。更正式的解释是，对于每个 <code>0 &lt;= i &lt; k</code>，先标记出位于 <code>s[removable[i]]</code> 的字符，接着移除所有标记过的字符，然后检查 <code>p</code>是否仍然是 <code>s</code> 的一个子序列。</p><p>返回你可以找出的 最大<code>k</code>，满足在移除字符后<code>p</code> 仍然是 <code>s</code> 的一个子序列。</p><p>字符串的一个 子序列 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcacb"</span>, p = <span class="string">"ab"</span>, removable = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：在移除下标 <span class="number">3</span> 和 <span class="number">1</span> 对应的字符后，<span class="string">"abcacb"</span> 变成 <span class="string">"accb"</span> 。</span><br><span class="line"><span class="string">"ab"</span> 是 <span class="string">"accb"</span> 的一个子序列。</span><br><span class="line">如果移除下标 <span class="number">3</span>、<span class="number">1</span> 和 <span class="number">0</span> 对应的字符后，<span class="string">"abcacb"</span> 变成 <span class="string">"ccb"</span> ，那么 <span class="string">"ab"</span> 就不再是 s 的一个子序列。</span><br><span class="line">因此，最大的 k 是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcbddddd"</span>, p = <span class="string">"abcd"</span>, removable = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：在移除下标 <span class="number">3</span> 对应的字符后，<span class="string">"abcbddddd"</span> 变成 <span class="string">"abcddddd"</span> 。</span><br><span class="line"><span class="string">"abcd"</span> 是 <span class="string">"abcddddd"</span> 的一个子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcab"</span>, p = <span class="string">"abc"</span>, removable = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：如果移除数组 removable 的第一个下标，<span class="string">"abc"</span> 就不再是 s 的一个子序列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= p.length &lt;= s.length &lt;= 105</code></li><li><code>0 &lt;= removable.length &lt; s.length</code></li><li><code>0 &lt;= removable[i] &lt; s.length</code></li><li><code>p</code> 是 <code>s</code> 的一个 子字符串</li><li><code>s</code> 和 <code>p</code> 都由小写英文字母组成</li><li><code>removable</code> 中的元素 互不相同</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-removable-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-removable-characters</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>当时这个题目竟然卡壳了很久，常规的做法即为二分查找，想了二十分钟才意识到是二分，常规的我们判断一个字符是另一个字符串的子序列非常简单。最关键的理解为：</li></ol><ul><li>如果移除$removable$ 中的前<code>k</code>个下标后，字符串<code>p</code>依旧是 s 的子序列，那么移除任意前$t$个且满足$t &lt; k$,依旧成立。<br>由此我们即可想到用二分法来测试，知道测试取得最长长度。</li></ul><ol><li>算法空间复杂度为$O(n)$,时间复杂度为$O(nlgn)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp; s,<span class="built_in">string</span> &amp; p,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; removable,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> curr = s;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) curr[removable[i]] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr[i] == p[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == p.size()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> j == p.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumRemovals</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; removable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = min(s.size()-p.size(),removable.size());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(s,p,removable,mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1899-合并若干三元组以形成目标三元组"><a href="#1899-合并若干三元组以形成目标三元组" class="headerlink" title="1899. 合并若干三元组以形成目标三元组"></a>1899. 合并若干三元组以形成目标三元组</h2><p>三元组 是一个由三个整数组成的数组。给你一个二维整数数组 <code>triplets</code> ，其中 <code>triplets[i] = [ai, bi, ci]</code> 表示第 i 个 三元组 。同时，给你一个整数数组 <code>target = [x, y, z]</code>，表示你想要得到的 三元组 。</p><p>为了得到 <code>target</code>，你需要对 <code>triplets</code>执行下面的操作 任意次（可能 零 次）：</p><p>选出两个下标（下标 从 0 开始 计数）<code>i</code> 和 <code>j（i != j）</code>，并 更新 <code>triplets[j]</code> 为 <code>[max(ai, aj), max(bi, bj), max(ci, cj)]</code>。</p><ul><li>例如，<code>triplets[i] = [2, 5, 3]</code> 且<code>triplets[j] = [1, 7, 5]，triplets[j]</code>将会更新为<code>[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]</code>。</li></ul><p>如果通过以上操作我们可以使得目标 三元组 <code>target</code> 成为 <code>triplets</code> 的一个 元素 ，则返回 true ；否则，返回 false 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>]], target = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：执行下述操作：</span><br><span class="line">- 选择第一个和最后一个三元组 [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>]] 。更新最后一个三元组为 [max(<span class="number">2</span>,<span class="number">1</span>), max(<span class="number">5</span>,<span class="number">7</span>), max(<span class="number">3</span>,<span class="number">5</span>)] = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>] 。triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>]]</span><br><span class="line">目标三元组 [<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>] 现在是 triplets 的一个元素。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：triplets = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>]], target = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：目标三元组 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>] 已经是 triplets 的一个元素。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]], target = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：执行下述操作：</span><br><span class="line">- 选择第一个和第三个三元组 [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]] 。更新第三个三元组为 [max(<span class="number">2</span>,<span class="number">1</span>), max(<span class="number">5</span>,<span class="number">2</span>), max(<span class="number">3</span>,<span class="number">5</span>)] = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>] 。triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]] 。</span><br><span class="line">- 选择第三个和第四个三元组 [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]] 。更新第四个三元组为 [max(<span class="number">2</span>,<span class="number">5</span>), max(<span class="number">5</span>,<span class="number">2</span>), max(<span class="number">5</span>,<span class="number">3</span>)] = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>] 。triplets = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]] 。</span><br><span class="line">目标三元组 [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>] 现在是 triplets 的一个元素。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：triplets = [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], target = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法得到 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>] ，因为 triplets 不含 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= triplets.length &lt;= 105</code></li><li><code>triplets[i].length == target.length == 3</code></li><li><code>1 &lt;= ai, bi, ci, x, y, z &lt;= 1000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>数学问题，还是思考的深度不够，竟然这个题目也卡壳了很久。官方题解写的非常清楚。<a href="https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet/solution/he-bing-ruo-gan-san-yuan-zu-yi-xing-chen-8ypf/" target="_blank" rel="noopener">题解</a>.</li><li>题目等价于在在数组钟选择若干个下标$x_{0},x_{1},…,x_{k}$,且$x_{0} \le x_{1} \le …\le x_{k}$,满足最终筛选的三元组$(a,b,c)$为：<script type="math/tex; mode=display">\left\{\begin{aligned}a = max(a_{x_{0}},a_{x_{1}},...,a_{x_{k}}) \\b = max(b_{x_{0}},b_{x_{1}},...,b_{x_{k}}) \\c = max(c_{x_{0}},c_{x_{1}},...,c_{x_{k}}) \\\end{aligned}\right.</script></li><li>对于任意的三元组$(x,y,z)$,如果满足$x &gt; target[0]$，$y &gt; target[1]$，$z &gt; target[2]$我们都不应选择。我们在筛选时只筛选三元组$(x,y,z)$且满足$(x \le target[0],y \le target[1] ,z \le target[2])$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mergeTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triplets, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : triplets)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] &lt;= target[<span class="number">0</span>] &amp;&amp; v[<span class="number">1</span>] &lt;= target[<span class="number">1</span>] &amp;&amp; v[<span class="number">2</span>] &lt;= target[<span class="number">2</span>])&#123;</span><br><span class="line">                a = max(a,v[<span class="number">0</span>]);</span><br><span class="line">                b = max(b,v[<span class="number">1</span>]);</span><br><span class="line">                c = max(c,v[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a == target[<span class="number">0</span>] &amp;&amp; b == target[<span class="number">1</span>] &amp;&amp; c == target[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1900-最佳运动员的比拼回合"><a href="#1900-最佳运动员的比拼回合" class="headerlink" title="1900. 最佳运动员的比拼回合"></a>1900. 最佳运动员的比拼回合</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>n 名运动员参与一场锦标赛，所有运动员站成一排，并根据 最开始的 站位从 <code>1</code>到 <code>n</code>编号（运动员 1 是这一排中的第一个运动员，运动员 2 是第二个运动员，依此类推）。</p><p>锦标赛由多个回合组成（从回合 1 开始）。每一回合中，这一排从前往后数的第 i 名运动员需要与从后往前数的第 i 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。</p><ul><li>例如，当前回合中，运动员 1, 2, 4, 6, 7 站成一排</li><li>运动员 1 需要和运动员 7 比拼</li><li>运动员 2 需要和运动员 6 比拼</li><li>运动员 4 轮空晋级下一回合<br>每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。</li></ul><p>编号为 <code>firstPlayer</code> 和 <code>secondPlayer</code> 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 裁定 谁是这一回合的获胜者。</p><p>给你三个整数 <code>n、firstPlayer</code> 和 <code>secondPlayer</code> 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 最早 回合数和 最晚 回合数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span>, firstPlayer = <span class="number">2</span>, secondPlayer = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">一种能够产生最早回合数的情景是：</span><br><span class="line">回合 <span class="number">1</span>：<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">回合 <span class="number">2</span>：<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span></span><br><span class="line">回合 <span class="number">3</span>：<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">一种能够产生最晚回合数的情景是：</span><br><span class="line">回合 <span class="number">1</span>：<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">回合 <span class="number">2</span>：<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">回合 <span class="number">3</span>：<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">回合 <span class="number">4</span>：<span class="number">2</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, firstPlayer = <span class="number">1</span>, secondPlayer = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：两名最佳运动员 <span class="number">1</span> 和 <span class="number">5</span> 将会在回合 <span class="number">1</span> 进行比拼。</span><br><span class="line">不存在使他们在其他回合进行比拼的可能。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 28</code></li><li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/the-earliest-and-latest-rounds-where-players-compete" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-earliest-and-latest-rounds-where-players-compete</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目感觉比较奇怪了一点，没有双周赛的题目好，本质是递归和穷举,感觉没有做下去的欲望。</li><li>可以参考下官方的<a href="https://leetcode-cn.com/problems/the-earliest-and-latest-rounds-where-players-compete/solution/zui-jia-yun-dong-yuan-de-bi-pin-hui-he-b-lhuo/" target="_blank" rel="noopener">题解</a>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> F[<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>], G[<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp(<span class="keyword">int</span> n, <span class="keyword">int</span> f, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (F[n][f][s]) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;F[n][f][s], G[n][f][s]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f + s == n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// F(n,f,s)=F(n,n+1-s,n+1-f)</span></span><br><span class="line">        <span class="keyword">if</span> (f + s &gt; n + <span class="number">1</span>) &#123;</span><br><span class="line">            tie(F[n][f][s], G[n][f][s]) = dp(n, n + <span class="number">1</span> - s, n + <span class="number">1</span> - f);</span><br><span class="line">            <span class="keyword">return</span> &#123;F[n][f][s], G[n][f][s]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> earlist = INT_MAX, latest = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> n_half = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= n_half) &#123;</span><br><span class="line">            <span class="comment">// 在左侧或者中间</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s - f; ++j) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> [x, y] = dp(n_half, i + <span class="number">1</span>, i + j + <span class="number">2</span>);</span><br><span class="line">                    earlist = min(earlist, x);</span><br><span class="line">                    latest = max(latest, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// s 在右侧</span></span><br><span class="line">            <span class="comment">// s'</span></span><br><span class="line">            <span class="keyword">int</span> s_prime = n + <span class="number">1</span> - s;</span><br><span class="line">            <span class="keyword">int</span> mid = (n - <span class="number">2</span> * s_prime + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s_prime - f; ++j) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> [x, y] = dp(n_half, i + <span class="number">1</span>, i + j + mid + <span class="number">2</span>);</span><br><span class="line">                    earlist = min(earlist, x);</span><br><span class="line">                    latest = max(latest, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;F[n][f][s] = earlist + <span class="number">1</span>, G[n][f][s] = latest + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; earliestAndLatest(<span class="keyword">int</span> n, <span class="keyword">int</span> firstPlayer, <span class="keyword">int</span> secondPlayer) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(F, <span class="number">0</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">        <span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// F(n,f,s) = F(n,s,f)</span></span><br><span class="line">        <span class="keyword">if</span> (firstPlayer &gt; secondPlayer) &#123;</span><br><span class="line">            swap(firstPlayer, secondPlayer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [earlist, latest] = dp(n, firstPlayer, secondPlayer);</span><br><span class="line">        <span class="keyword">return</span> &#123;earlist, latest&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-245&quot;&gt;&lt;a href=&quot;#leetcode-contest-245&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 245&quot;&gt;&lt;/a&gt;leetcode  contest 245&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是一如既往的高，题目质量非常不错，不过还是三道题目的节奏，感觉&lt;code&gt;contest&lt;/code&gt;的技巧就是做题速度要快，手速要快，基本上要达到看到题目就有思路那种，才能给&lt;code&gt;hard&lt;/code&gt;题目留足思考的时间，只有这样才能达到竞赛的技巧。许多竞赛的选手估计已经训练过非常非常多的题目，难怪最好的&lt;code&gt;IOI&lt;/code&gt;选手最好是从初中或者高中就开始训练，思维和速度很重要，基本上需要尽快的训练和固话自己的思维，基本上拿到题目就像肌肉训练一样才可以。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly Contest 54</title>
    <link href="http://yoursite.com/2021/06/08/293/"/>
    <id>http://yoursite.com/2021/06/08/293/</id>
    <published>2021-06-08T05:00:13.868Z</published>
    <updated>2021-06-14T09:28:32.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-54"><a href="#leetcode-biweekly-contest-54" class="headerlink" title="leetcode  biweekly contest 54"></a>leetcode  biweekly contest 54</h1><p>双周赛前三题还是模板题，最后一题真心不错，非常经典的表达式求解题目</p><h2 id="5767-检查是否区域内所有整数都被覆盖"><a href="#5767-检查是否区域内所有整数都被覆盖" class="headerlink" title="5767. 检查是否区域内所有整数都被覆盖"></a>5767. 检查是否区域内所有整数都被覆盖</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>ranges</code> 和两个整数<code>left</code>和 <code>right</code>。每个 <code>ranges[i] = [starti, endi]</code> 表示一个从 starti 到 endi 的 闭区间 。</p><a id="more"></a><p>如果闭区间<code>[left, right]</code>内每个整数都被<code>ranges</code> 中 至少一个 区间覆盖，那么请你返回 <code>true</code>，否则返回 <code>false</code>。</p><p>已知区间 <code>ranges[i] = [starti, endi]</code> ，如果整数 <code>x</code> 满足 <code>starti &lt;= x &lt;= endi</code>，那么我们称整数x 被覆盖了。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：ranges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]], left = <span class="number">2</span>, right = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">2</span> 到 <span class="number">5</span> 的每个整数都被覆盖了：</span><br><span class="line">- <span class="number">2</span> 被第一个区间覆盖。</span><br><span class="line">- <span class="number">3</span> 和 <span class="number">4</span> 被第二个区间覆盖。</span><br><span class="line">- <span class="number">5</span> 被第三个区间覆盖。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ranges = [[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">20</span>]], left = <span class="number">21</span>, right = <span class="number">21</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">21</span> 没有被任何一个区间覆盖。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= ranges.length &lt;= 50</code></li><li><code>1 &lt;= starti &lt;= endi &lt;= 50</code></li><li><code>1 &lt;= left &lt;= right &lt;= 50</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>因为数据量很小，所以直接暴力模拟即可。如果数据量非常大，则此时我们需要利用区间合并的技巧。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCovered</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ranges, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">51</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : ranges)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = v[<span class="number">0</span>]; i &lt;= v[<span class="number">1</span>]; ++i) cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5768-找到需要补充粉笔的学生编号"><a href="#5768-找到需要补充粉笔的学生编号" class="headerlink" title="5768. 找到需要补充粉笔的学生编号"></a>5768. 找到需要补充粉笔的学生编号</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一个班级里有 <code>n</code>个学生，编号为 0 到 <code>n - 1</code>。每个学生会依次回答问题，编号为 <code>0</code> 的学生先回答，然后是编号为<code>1</code> 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。</p><p>给你一个长度为 n 且下标从 0 开始的整数数组<code>chalk</code>和一个整数 k 。一开始粉笔盒里总共有<code>k</code>支粉笔。当编号为 <code>i</code>的学生回答问题时，他会消耗 <code>chalk[i]</code>支粉笔。如果剩余粉笔数量 严格小于 <code>chalk[i]</code> ，那么学生 i 需要 补充 粉笔。</p><p>请你返回需要 补充 粉笔的学生 编号 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：chalk = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>], k = <span class="number">22</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：学生消耗粉笔情况如下：</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">5</span> 支粉笔，然后 k = <span class="number">17</span> 。</span><br><span class="line">- 编号为 <span class="number">1</span> 的学生使用 <span class="number">1</span> 支粉笔，然后 k = <span class="number">16</span> 。</span><br><span class="line">- 编号为 <span class="number">2</span> 的学生使用 <span class="number">5</span> 支粉笔，然后 k = <span class="number">11</span> 。</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">5</span> 支粉笔，然后 k = <span class="number">6</span> 。</span><br><span class="line">- 编号为 <span class="number">1</span> 的学生使用 <span class="number">1</span> 支粉笔，然后 k = <span class="number">5</span> 。</span><br><span class="line">- 编号为 <span class="number">2</span> 的学生使用 <span class="number">5</span> 支粉笔，然后 k = <span class="number">0</span> 。</span><br><span class="line">编号为 <span class="number">0</span> 的学生没有足够的粉笔，所以他需要补充粉笔。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：chalk = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>], k = <span class="number">25</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：学生消耗粉笔情况如下：</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">3</span> 支粉笔，然后 k = <span class="number">22</span> 。</span><br><span class="line">- 编号为 <span class="number">1</span> 的学生使用 <span class="number">4</span> 支粉笔，然后 k = <span class="number">18</span> 。</span><br><span class="line">- 编号为 <span class="number">2</span> 的学生使用 <span class="number">1</span> 支粉笔，然后 k = <span class="number">17</span> 。</span><br><span class="line">- 编号为 <span class="number">3</span> 的学生使用 <span class="number">2</span> 支粉笔，然后 k = <span class="number">15</span> 。</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">3</span> 支粉笔，然后 k = <span class="number">12</span> 。</span><br><span class="line">- 编号为 <span class="number">1</span> 的学生使用 <span class="number">4</span> 支粉笔，然后 k = <span class="number">8</span> 。</span><br><span class="line">- 编号为 <span class="number">2</span> 的学生使用 <span class="number">1</span> 支粉笔，然后 k = <span class="number">7</span> 。</span><br><span class="line">- 编号为 <span class="number">3</span> 的学生使用 <span class="number">2</span> 支粉笔，然后 k = <span class="number">5</span> 。</span><br><span class="line">- 编号为 <span class="number">0</span> 的学生使用 <span class="number">3</span> 支粉笔，然后 k = <span class="number">2</span> 。</span><br><span class="line">编号为 <span class="number">1</span> 的学生没有足够的粉笔，所以他需要补充粉笔。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>chalk.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= chalk[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>非常简单的小学数学问题，我们只需找到班级学生发完一轮时所需要的总数<code>sum</code>，然后用<code>k</code>取模<code>sum</code>的余数，然后依次减直到粉笔的数目不够即可。</li><li>算法时间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">chalkReplacer</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chalk, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = accumulate(chalk.begin(),chalk.end(),<span class="number">0L</span>L);</span><br><span class="line">        k = k%sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chalk.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; chalk[i]) <span class="keyword">return</span> i;</span><br><span class="line">            k -= chalk[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5202-最大的幻方"><a href="#5202-最大的幻方" class="headerlink" title="5202. 最大的幻方"></a>5202. 最大的幻方</h2><p>一个 <code>k x k</code> 的 幻方 指的是一个 <code>k x k</code>填满整数的方格阵，且每一行、每一列以及两条对角线的和 全部相等 。幻方中的整数 不需要互不相同 。显然，每个 <code>1 x 1</code> 的方格都是一个幻方。</p><p>给你一个<code>m x n</code> 的整数矩阵 <code>grid</code> ，请你返回矩阵中 最大幻方 的 尺寸 （即边长 k）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最大幻方尺寸为 <span class="number">3</span> 。</span><br><span class="line">每一行，每一列以及两条对角线的和都等于 <span class="number">12</span> 。</span><br><span class="line">- 每一行的和：<span class="number">5</span>+<span class="number">1</span>+<span class="number">6</span> = <span class="number">5</span>+<span class="number">4</span>+<span class="number">3</span> = <span class="number">2</span>+<span class="number">7</span>+<span class="number">3</span> = <span class="number">12</span></span><br><span class="line">- 每一列的和：<span class="number">5</span>+<span class="number">5</span>+<span class="number">2</span> = <span class="number">1</span>+<span class="number">4</span>+<span class="number">7</span> = <span class="number">6</span>+<span class="number">3</span>+<span class="number">3</span> = <span class="number">12</span></span><br><span class="line">- 对角线的和：<span class="number">5</span>+<span class="number">4</span>+<span class="number">3</span> = <span class="number">6</span>+<span class="number">4</span>+<span class="number">2</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">9</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 50</code></li><li><code>1 &lt;= grid[i][j] &lt;= 106</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-magic-square" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-magic-square</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学暴力 + 前缀和</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的不好，想了一下感觉只能暴力，利用前缀和快速求出矩阵的每一行和每一列的和。我们尝试每一个可能的<code>kxk</code>的矩阵，求出每一行和每一列的值，同时求出每个对角线的值,判断是否相等即可。</li><li>我们每次枚举举证的左上顶点$(x,y)$，同时枚举矩阵的行的长度$k$，则我们可以计算依次计算所有可能的矩阵。我们利用矩阵的行的前缀和和列的前缀和即可快速求出行与列的行。</li><li>时间复杂度为$O(row<em>col</em>(2k+2)<em>k$,空间复杂度为$O(row</em>col)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestMagicSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; sum1(row+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(col+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; sum2(col+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(row+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                sum1[i][j+<span class="number">1</span>] = sum1[i][j] + grid[i][j];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                sum2[i][j+<span class="number">1</span>] = sum2[i][j] + grid[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= min(row,col) &amp;&amp; (i + k &lt;= row) &amp;&amp; (j + k &lt;= col); ++k)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> curr = sum1[i][j+k] - sum1[i][j];</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> dig1 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> dig2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; k; ++l)&#123;</span><br><span class="line">                        <span class="keyword">if</span>((sum1[i+l][j+k] - sum1[i+l][j]) != curr)&#123;</span><br><span class="line">                            valid = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>((sum2[j+l][i+k] - sum2[j+l][i]) != curr)&#123;</span><br><span class="line">                            valid = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        dig1 += grid[i+l][j+l];</span><br><span class="line">                        dig2 += grid[i+l][j+k<span class="number">-1</span>-l];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dig1 != dig2 || dig1 != curr || dig2 != curr) valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                        ans = max(ans,k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5770-反转表达式值的最少操作次数"><a href="#5770-反转表达式值的最少操作次数" class="headerlink" title="5770. 反转表达式值的最少操作次数"></a>5770. 反转表达式值的最少操作次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 有效的 布尔表达式，用字符串 expression 表示。这个字符串包含字符 <code>&#39;1&#39;，&#39;0&#39;，&#39;&amp;&#39;</code>（按位 与 运算），<code>&#39;|&#39;</code>（按位 或 运算），<code>&#39;(&#39;</code>和 ‘)’ 。</p><p>比方说，<code>&quot;()1|1&quot;</code>和 <code>&quot;(1)&amp;()&quot;</code> 不是有效 布尔表达式。而 “1”， <code>&quot;(((1))|(0))&quot;</code>和 <code>&quot;1|(0&amp;(1))&quot;</code>是 有效 布尔表达式。<br>你的目标是将布尔表达式的 值 反转 （也就是将 0 变为 1 ，或者将 1 变为 0），请你返回达成目标需要的 最少操作 次数。</p><p>比方说，如果表达式 <code>expression = &quot;1|1|(0&amp;0)&amp;1&quot;</code>，它的 值 为 <code>1|1|(0&amp;0)&amp;1 = 1|1|0&amp;1 = 1|0&amp;1 = 1&amp;1 = 1</code>。我们想要执行操作将 新的 表达式的值变成 0 。<br>可执行的 操作 如下：</p><ul><li>将一个 <code>&#39;1&#39;</code>变成一个 <code>&#39;0&#39;</code>。</li><li>将一个 <code>&#39;0&#39;</code> 变成一个 <code>&#39;1&#39;</code>。</li><li>将一个 <code>&#39;&amp;&#39;</code>变成一个 <code>&#39;|&#39;</code>。</li><li>将一个 <code>&#39;|&#39;</code>变成一个 <code>&#39;&amp;&#39;</code>。<br>注意：<code>&#39;&amp;&#39;</code> 的 运算优先级 与 ‘|’ 相同 。计算表达式时，括号优先级 最高 ，然后按照 从左到右 的顺序运算。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = <span class="string">"1&amp;(0|1)"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：我们可以将 <span class="string">"1&amp;(0|1)"</span> 变成 <span class="string">"1&amp;(0&amp;1)"</span> ，执行的操作为将一个 '|' 变成一个 '&amp;' ，执行了 <span class="number">1</span> 次操作。</span><br><span class="line">新表达式的值为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = <span class="string">"(0&amp;0)&amp;(0&amp;0&amp;0)"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们可以将 <span class="string">"(0&amp;0)&amp;(0&amp;0&amp;0)"</span> 变成 <span class="string">"(0|1)|(0&amp;0&amp;0)"</span> ，执行了 <span class="number">3</span> 次操作。</span><br><span class="line">新表达式的值为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = <span class="string">"(0|(1|0&amp;1))"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：我们可以将 <span class="string">"(0|(1|0&amp;1))"</span> 变成 <span class="string">"(0|(0|0&amp;1))"</span> ，执行了 <span class="number">1</span> 次操作。</span><br><span class="line">新表达式的值为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= expression.length &lt;= 105</code></li><li><code>expression</code> 只包含 <code>&#39;1&#39;，&#39;0&#39;，&#39;&amp;&#39;，&#39;|&#39;，&#39;(&#39;</code>和 <code>&#39;)&#39;</code></li><li>所有括号都有与之匹配的对应括号。</li><li>不会有空的括号（也就是说 “()” 不是 expression 的子字符串）。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-change-the-final-value-of-expression" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-change-the-final-value-of-expression</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 递归或者栈，动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这道题目非常不错，主要是思考的比较多，代码量实际不是特别大。非常值得思考的题目，我觉得完全可以参考<a href="https://leetcode-cn.com/problems/minimum-cost-to-change-the-final-value-of-expression/solution/zhan-dong-tai-gui-hua-by-lucifer1004-7bsn/" target="_blank" rel="noopener">lucifer1004</a>的答案。</li><li>实际计算过程中，动态规划的转移方程想到了，但是在处理表达式的时候用了个比较耗时的递归，结果超时了。这个题目出的还是相当不错的，我们首先需要处理动态规划的递推公式如下：</li></ol><ul><li>我们设$(p_{0},p_{1})$表示为将当前的操作数$num$变为$(0,1)$的最小操作数，比如：我们如果需要将$0$变为$0$,则最少需要$0$步操作即可，如果将$0$变为$1$,则此时我们需要一步操作<code>0-&gt;1</code>即可，因此此时对于操作数$0$的最小操作序列应该为$(0,1)$,同理对于操作数$1$的最小操作序列应该为$(1,0)$.</li><li>同理我们假设对于操作数$x$的最小操作序列为$(x_{0},x_{1})$,对于$y$的最小操作序列为$(y_{0},y_{1})$,则此时我们应该考虑对于表达式$x\And y$,$x|y$的递推如何处理呢?我们思考如下:</li><li>如果使得$x\And y = 0$,则我们只需要满足$x = 0$或者$y = 0$即可使得表达式$x\And y = 0$，因此使得表达式为<code>0</code>最小操作为应该$min(x_{0},y_{0})$;如果使得$x\And y$的结果为$1$,则我们只需要满足$x = 1$且$y = 1$即可使得表达式$x\And y = 1$，因此使得表达式为<code>1</code>最小操作为应该$x_{1} + y_{1}$.</li><li>如果使得$x|y = 0$,则我们只需要满足$x = 0$且$y = 0$即可使得表达式$x|y = 0$，因此使得表达式为<code>0</code>最小操作为应该$x_{0} + y_{0})$;如果使得$x|y = 1$,则我们只需要满足$x = 1$或$y = 1$即可使得表达式$x|y = 1$，因此使得表达式为<code>1</code>最小操作为应该$min(x_{1},y_{1})$.</li><li>我们同时还需要考虑到将运算符号进行变换时的最小操作，及将<code>&amp;</code>变换为<code>|</code>或者将<code>|</code>变换为<code>&amp;</code>的操作，此时符号变换还需要额外的一次操作。因此综上我们可以知道对于表达式$x\And y$的变换为<code>0</code>的最小操作数应该为：$min(x_{0},y_{0})$，变换为<code>1</code>的最小操作数应该为:$min(x_{1} + y_{1},min(x_{1},y_{1})+1)$.因此该表达式的最小变换序列应该为：<script type="math/tex; mode=display">(min(x_{0},y_{0}),min(x_{1} + y_{1},min(x_{1},y_{1})+1))</script>对于表达式$x|y$的变换为<code>0</code>的最小操作数应该为：$min(x_{0}+y_{0},min(x_{0},y_{0})+1)$，变换为<code>1</code>的最小操作数应该为:$min(x_{1},y_{1})$.因此该表达式的最小变换序列应该为：<script type="math/tex; mode=display">(min(x_{0}+y_{0},min(x_{0},y_{0})+1),min(x_{1},y_{1}))</script></li><li>以上即可动态规划的递归公式部分，对于最后的表达式的返回值我们只需要返回变为<code>0</code>或者<code>1</code>的操作数最大的那部分，应该如果操作数的值本身保持不变，则最小操作数应该为<code>0</code>，如果保持反转则操作数一定是大于<code>0</code>的。</li></ul><ol><li>题目的难点在于如何用两个栈处理符号和操作数的问题，这点确实是快忘记光了，结果导致昨天写了个非常复杂的递归程序，还超时了。还是需要再把基本计算器的题目再练习一下。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperationsToFlip</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">stack</span>&lt;pii&gt; states;</span><br><span class="line">       <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> c : expression)&#123;</span><br><span class="line">           <span class="keyword">if</span>(c == <span class="string">'0'</span> || c== <span class="string">'1'</span> || c == <span class="string">')'</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(c == <span class="string">'0'</span>)&#123;</span><br><span class="line">                   states.push(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'1'</span>)&#123;</span><br><span class="line">                   states.push(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(op.top() == <span class="string">'('</span>)&#123;</span><br><span class="line">                       op.pop();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(!op.empty() &amp;&amp; op.top() != <span class="string">'('</span>)&#123;</span><br><span class="line">                   pii va = states.top();</span><br><span class="line">                   states.pop();</span><br><span class="line">                   pii vb = states.top();</span><br><span class="line">                   states.pop();</span><br><span class="line">                   <span class="keyword">if</span>(op.top() == <span class="string">'&amp;'</span>)&#123;</span><br><span class="line">                       states.push(&#123;min(va.first,vb.first),min(va.second + vb.second,min(va.second,vb.second) + <span class="number">1</span>)&#125;);</span><br><span class="line">                   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op.top() == <span class="string">'|'</span>)&#123;</span><br><span class="line">                       states.push(&#123;min(va.first + vb.first,min(va.first,vb.first) + <span class="number">1</span>),min(va.second,vb.second)&#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">                   op.pop();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               op.push(c);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> max(states.top().first,states.top().second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-54&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-54&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 54&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 54&lt;/h1&gt;&lt;p&gt;双周赛前三题还是模板题，最后一题真心不错，非常经典的表达式求解题目&lt;/p&gt;&lt;h2 id=&quot;5767-检查是否区域内所有整数都被覆盖&quot;&gt;&lt;a href=&quot;#5767-检查是否区域内所有整数都被覆盖&quot; class=&quot;headerlink&quot; title=&quot;5767. 检查是否区域内所有整数都被覆盖&quot;&gt;&lt;/a&gt;5767. 检查是否区域内所有整数都被覆盖&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个二维整数数组 &lt;code&gt;ranges&lt;/code&gt; 和两个整数&lt;code&gt;left&lt;/code&gt;和 &lt;code&gt;right&lt;/code&gt;。每个 &lt;code&gt;ranges[i] = [starti, endi]&lt;/code&gt; 表示一个从 starti 到 endi 的 闭区间 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 MIT 6.S081 Lab1</title>
    <link href="http://yoursite.com/2021/06/07/292/"/>
    <id>http://yoursite.com/2021/06/07/292/</id>
    <published>2021-06-07T12:34:15.843Z</published>
    <updated>2021-06-20T13:17:29.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MIT6-S081"><a href="#MIT6-S081" class="headerlink" title="MIT6.S081"></a>MIT6.S081</h1><p>很早就听说MIT6.S081的课程比较经典了，所以从上周末就开始学习MIT6.S081的<code>lecture</code>,目前刚学习完<code>lecture 1</code>，并且成功完成了<code>lab1</code>，不得不说<code>lab</code>太花费时间了，<code>lab</code>设置的非常好，难度适中，有挑战性与趣味性并存，非常感谢这么好与经典的课程，不过不得不说因为确实平时没有时间，又要照顾家庭，又要上班，只能利用周末和晚上的时间抓紧来学习和完成这些<code>lab</code>的代码了，每次都需要花时间调试代码调试很长时间，目测后面的挑战题目更难。<code>MIT</code>的课程难度一向很大，难怪能够培养出很多非常优秀和出色的工程师。</p><a id="more"></a><ul><li>lab环境：<br>所有的<code>lab</code>都是基于<code>qemu</code>的模拟硬件环境的，它的所有的<code>lab</code>全部更新为基于<code>risc-v</code>的硬件环境，紧跟最新的潮流，不像国内一个<code>8086</code>都还在讲，恨不得一门组成原理用了不知道多少年，目前还在停留在单核的x86时代，目前几乎所有的通用<code>cpu</code>都是基于多核处理器，所有的体系结构都应该更新了。所有的<code>lab</code>都是基于<code>xv6</code>的操作系统，一个非常精简的微小的操作系统。按照<code>lab</code>的提示从网上下载<code>qemu</code>模拟器和<code>risc-v</code>的编译环境，国内尽量将<code>apt-get</code>的源改为阿里或者清华的，很快就能完成下载。</li><li>测试结果：<br><img src="https://i.loli.net/2021/06/07/IQJYxFsA52fdEo3.png" alt></li></ul><h2 id="1-sleep"><a href="#1-sleep" class="headerlink" title="1. sleep"></a>1. sleep</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Implement <span class="keyword">the</span> UNIX program sleep <span class="keyword">for</span> xv6; your sleep should pause <span class="keyword">for</span> <span class="keyword">a</span> user-specified <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">ticks</span>. A <span class="built_in">tick</span> is <span class="keyword">a</span> notion <span class="keyword">of</span> <span class="built_in">time</span> defined <span class="keyword">by</span> <span class="keyword">the</span> xv6 kernel, namely <span class="keyword">the</span> <span class="built_in">time</span> between <span class="literal">two</span> interrupts <span class="built_in">from</span> <span class="keyword">the</span> timer chip. Your solution should be <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">file</span> user/sleep.c.</span><br></pre></td></tr></table></figure><p>实现一个基本的<code>sleep</code>命令，这个基本上就是热身，通过最简单的题目来快速上手，实现一个最简单的程序，没有多少难度。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> wait = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sleep: need parameter error\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   wait = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">   sleep(wait);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-pingpong"><a href="#2-pingpong" class="headerlink" title="2. pingpong"></a>2. pingpong</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write <span class="keyword">a</span> program that uses UNIX <span class="keyword">system</span> calls <span class="built_in">to</span> <span class="string">''</span>ping-pong<span class="string">''</span> <span class="keyword">a</span> <span class="keyword">byte</span> between <span class="literal">two</span> processes over <span class="keyword">a</span> pair <span class="keyword">of</span> pipes, <span class="literal">one</span> <span class="keyword">for</span> <span class="keyword">each</span> direction. The parent should <span class="built_in">send</span> <span class="keyword">a</span> <span class="keyword">byte</span> <span class="built_in">to</span> <span class="keyword">the</span> child; <span class="keyword">the</span> child should print <span class="string">"&lt;pid&gt;: received ping"</span>, where &lt;pid&gt; is its <span class="built_in">process</span> ID, <span class="built_in">write</span> <span class="keyword">the</span> <span class="keyword">byte</span> <span class="keyword">on</span> <span class="title">the</span> <span class="title">pipe</span> <span class="title">to</span> <span class="title">the</span> <span class="title">parent</span>, <span class="title">and</span> <span class="title">exit</span>; <span class="title">the</span> <span class="title">parent</span> <span class="title">should</span> <span class="title">read</span> <span class="title">the</span> <span class="title">byte</span> <span class="title">from</span> <span class="title">the</span> <span class="title">child</span>, <span class="title">print</span> <span class="string">"&lt;pid&gt;: received pong"</span>, <span class="title">and</span> <span class="title">exit</span>. <span class="title">Your</span> <span class="title">solution</span> <span class="title">should</span> <span class="title">be</span> <span class="title">in</span> <span class="title">the</span> <span class="title">file</span> <span class="title">user</span>/<span class="title">pingpong</span>.<span class="title">c</span>.</span><br></pre></td></tr></table></figure><p>利用管道实现子进程与父进程的通信，通过这个简单的程序熟悉<code>pipe</code>的使用，不过很坑爹的是这个操作系统的管道不支持双端通信，只支持一端是写，一端是读，这个<code>bug</code>调试了很长时间才发现是这个问题。具体实现方法为：开两个管道，父进程往管道<code>1</code>里写数据，从管道<code>2</code>中读数据，子进程从管道<code>1</code>读数据，从管道<code>2</code>写数据。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> p2[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">"Only 1 argument is needed!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creat a pipe</span></span><br><span class="line">    pipe(p1);</span><br><span class="line">    pipe(p2);</span><br><span class="line">    <span class="comment">// child</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">//read from the parent</span></span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">        read(p1[<span class="number">0</span>],buffer,<span class="number">4</span>);</span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// write a byte to the parent</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received ping\n"</span>,getpid());</span><br><span class="line">        write(p2[<span class="number">1</span>],<span class="string">"pong"</span>, <span class="number">4</span>);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// send a byte</span></span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">        write(p1[<span class="number">1</span>],<span class="string">"ping"</span>,<span class="number">4</span>);</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// receive from child</span></span><br><span class="line">        read(p2[<span class="number">0</span>],buffer,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: received pong\n"</span>,getpid());</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-primes"><a href="#3-primes" class="headerlink" title="3. primes"></a>3. primes</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write <span class="keyword">a</span> concurrent <span class="built_in">version</span> <span class="keyword">of</span> prime sieve <span class="keyword">using</span> pipes. This idea is due <span class="built_in">to</span> Doug McIlroy, inventor <span class="keyword">of</span> Unix pipes. The picture halfway down this page <span class="keyword">and</span> <span class="keyword">the</span> surrounding <span class="keyword">text</span> explain how <span class="built_in">to</span> <span class="built_in">do</span> <span class="keyword">it</span>. Your solution should be <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">file</span> user/primes.c.</span><br></pre></td></tr></table></figure><p>利用进程实现素数筛选，不知道为什么实现的很蛋疼。估计还是<code>xv6</code>的文件描述符资源有限不能很好支持多个管道同时读写，因为开的管道过多，资源就卡住了，各种问题不知道有没有人实现快速版本，及子进程同时接受数据也同时开始计算，并同时开始写数据。目前这个的实现很糙，将当前进程筛选的不能被第一个素数整数的数据全部写入管道中，交给子进程去处理，依次这样递归下去即可。这个做法就是跟素数的快速筛查的算法是处理的一模一样的,在$O(n)$的时间复杂度内筛选出所有小于$n$的素数。</p><p><img src="https://i.loli.net/2021/06/08/dtliNxaYBsSP7Fu.gif" alt><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="builtin-name">get</span> a number <span class="keyword">from</span> left neighbor</span><br><span class="line"><span class="builtin-name">print</span> p</span><br><span class="line">loop:</span><br><span class="line">    n = <span class="builtin-name">get</span> a number <span class="keyword">from</span> left neighbor</span><br><span class="line">    <span class="keyword">if</span> (p does <span class="keyword">not</span> divide n)</span><br><span class="line">        send n <span class="keyword">to</span> right neighbor</span><br></pre></td></tr></table></figure><br>需要特殊处理的是父进程需要等待子进程完成后，才能退出。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prime = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pip[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*close p1*/</span></span><br><span class="line">    pipe(pip);</span><br><span class="line">    <span class="keyword">while</span>(read(p[<span class="number">0</span>],&amp;num,<span class="number">4</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(prime == <span class="number">1</span>)&#123;</span><br><span class="line">            prime = num;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"prime %d\n"</span>,prime);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%prime == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            write(pip[<span class="number">1</span>],&amp;num,<span class="number">4</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(pip[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(prime &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            process(pip);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    close(pip[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; ++i)&#123;</span><br><span class="line">        write(p[<span class="number">1</span>],&amp;i,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    process(p);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-find"><a href="#4-find" class="headerlink" title="4. find"></a>4. find</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write a<span class="built_in"> simple </span>version of the UNIX <span class="builtin-name">find</span> program: <span class="builtin-name">find</span> all the files <span class="keyword">in</span> a directory tree with a specific name. Your solution should be <span class="keyword">in</span> the file user/find.c.</span><br></pre></td></tr></table></figure><p>实现一个简单的查找文件名为指定关键字的程序，典型的利用递归查找到子目录下，即可完成所有子目录的查找。这个就是常规的操作。各种处理文件时需要查找相应的库函数，需要小心处理。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/fs.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getname</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">'/'</span>; p--)&#123;&#125;</span><br><span class="line">  <span class="comment">// skip '/'</span></span><br><span class="line">  p++;</span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *path,<span class="keyword">const</span> <span class="keyword">char</span> * filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="keyword">char</span> *curr;</span><br><span class="line">  <span class="keyword">char</span> *fname;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// open the dir</span></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"ls: cannot open %s\n"</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// open stat</span></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"ls: cannot stat %s\n"</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check the current the file is </span></span><br><span class="line">  <span class="keyword">if</span>(st.type != T_DIR)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"the current the file is not dictionary\n"</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//read all the files under the dir</span></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">  p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">  *p++ = <span class="string">'/'</span>;</span><br><span class="line">  <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// skip "." and ".."</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name,<span class="string">"."</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name,<span class="string">".."</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      curr = p;</span><br><span class="line">      memmove(curr, de.name, DIRSIZ);</span><br><span class="line">      curr[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"ls: cannot stat %s\n"</span>, buf);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// printf("current file name is：%s \n",buf);</span></span><br><span class="line">      <span class="comment">// record the current file</span></span><br><span class="line">      <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">        <span class="comment">// we check the current file</span></span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            fname = getname(buf);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fname,filename) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// we check the current dir</span></span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ls: path too long\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            find(buf,filename);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"we need 3 paramters!\n"</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-xargs"><a href="#5-xargs" class="headerlink" title="5. xargs"></a>5. xargs</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write a<span class="built_in"> simple </span>version of the UNIX xargs program: read lines <span class="keyword">from</span> the standard input <span class="keyword">and</span> <span class="builtin-name">run</span> a command <span class="keyword">for</span> each line, supplying the line as arguments <span class="keyword">to</span> the command. Your solution should be <span class="keyword">in</span> the file user/xargs.c.</span><br></pre></td></tr></table></figure><p>实现类似于<code>unix</code>下的<code>xargs</code>操作，这个因为要求的比较低，其实非常容易完成，我们只需要利用<code>fork</code>和<code>exec</code>函数即可完成。我们每次标准输入，在<code>xv6</code>操作系统中，标准输入及时<code>fd 0</code>读取即可，标准输出即为写入<code>fd 1</code>即可，本质来说非常简单。将参数从标准输入读入然后作为附加参数执行<code>xargs</code>后面的程序。简单就是将输入参数进行重写即可。具体可以参考代码实现。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/fs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/param.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">   <span class="keyword">char</span> *args[MAXARG];</span><br><span class="line">   <span class="keyword">char</span> c;</span><br><span class="line">   <span class="keyword">char</span> *p;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">   <span class="built_in">memset</span>(args,<span class="number">0</span>,<span class="keyword">sizeof</span>(args));</span><br><span class="line">   <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"need more parameter!\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*read from the file*/</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)&#123;</span><br><span class="line">       args[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">     p = buf;</span><br><span class="line">     <span class="comment">/*read each line from the stand input*/</span></span><br><span class="line">     <span class="keyword">while</span>((n = read(<span class="number">0</span>,&amp;c,<span class="number">1</span>)) &amp;&amp; c != <span class="string">'\n'</span>)&#123;</span><br><span class="line">        *p = c;</span><br><span class="line">        p++;</span><br><span class="line">     &#125;</span><br><span class="line">     *p = <span class="string">'\0'</span>;</span><br><span class="line">     <span class="keyword">if</span>(p != buf)&#123;</span><br><span class="line">        args[argc<span class="number">-1</span>] = buf;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            exec(argv[<span class="number">1</span>],args);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">"read error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-challenge-exercises"><a href="#Optional-challenge-exercises" class="headerlink" title="Optional challenge exercises"></a>Optional challenge exercises</h2><p>最后看了后面几个挑战题目也都是非常有意思，后面准备继续将三个挑战题目也完成，总的来说题目质量真心非常不错。</p><ul><li><code>uptime</code>:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write an uptime program that prints the uptime <span class="keyword">in</span> terms of ticks using the uptime<span class="built_in"> system </span>call. (easy)</span><br></pre></td></tr></table></figure><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/stat.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"user/user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/fs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/param.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SYS_uptime</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> now = uptime();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"the system has run %d tick.\n"</span>,now);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>regular</code><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Support regular expressions <span class="keyword">in</span> <span class="built_in">name</span> matching <span class="keyword">for</span> find. grep.c has <span class="keyword">some</span> primitive support <span class="keyword">for</span> regular expressions. (easy)</span><br></pre></td></tr></table></figure>直接抄写<code>grep</code>中的<code>reg match</code>函数即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Regexp matcher from Kernighan &amp; Pike,</span></span><br><span class="line"><span class="comment">// The Practice of Programming, Chapter 9.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matchhere</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matchstar</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>*, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">match(<span class="keyword">char</span> *re, <span class="keyword">char</span> *text)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">'^'</span>)</span><br><span class="line">    <span class="keyword">return</span> matchhere(re+<span class="number">1</span>, text);</span><br><span class="line">  <span class="keyword">do</span>&#123;  <span class="comment">// must look at empty string</span></span><br><span class="line">    <span class="keyword">if</span>(matchhere(re, text))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(*text++ != <span class="string">'\0'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchhere: search for re at beginning of text</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matchhere</span><span class="params">(<span class="keyword">char</span> *re, <span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">    <span class="keyword">return</span> matchstar(re[<span class="number">0</span>], re+<span class="number">2</span>, text);</span><br><span class="line">  <span class="keyword">if</span>(re[<span class="number">0</span>] == <span class="string">'$'</span> &amp;&amp; re[<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">    <span class="keyword">return</span> *text == <span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">if</span>(*text!=<span class="string">'\0'</span> &amp;&amp; (re[<span class="number">0</span>]==<span class="string">'.'</span> || re[<span class="number">0</span>]==*text))</span><br><span class="line">    <span class="keyword">return</span> matchhere(re+<span class="number">1</span>, text+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchstar: search for c*re at beginning of text</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matchstar</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">char</span> *re, <span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;  <span class="comment">// a * matches zero or more instances</span></span><br><span class="line">    <span class="keyword">if</span>(matchhere(re, text))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(*text!=<span class="string">'\0'</span> &amp;&amp; (*text++==c || c==<span class="string">'.'</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>sh</code>:<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The xv6 <span class="built_in">shell</span> (user/sh.c) is just another user program <span class="keyword">and</span> you can improve <span class="keyword">it</span>. It is <span class="keyword">a</span> minimal <span class="built_in">shell</span> <span class="keyword">and</span> lacks many features found <span class="keyword">in</span> real <span class="built_in">shell</span>. For example, modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> <span class="keyword">not</span> print <span class="keyword">a</span> $ when processing <span class="built_in">shell</span> commands <span class="built_in">from</span> <span class="keyword">a</span> <span class="built_in">file</span> (moderate), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> support <span class="built_in">wait</span> (easy), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> support lists <span class="keyword">of</span> commands, separated <span class="keyword">by</span> <span class="string">";"</span> (moderate), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> support sub-shells <span class="keyword">by</span> implementing <span class="string">"("</span> <span class="keyword">and</span> <span class="string">")"</span> (moderate), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> support <span class="literal">tab</span> completion (easy), modify <span class="keyword">the</span> <span class="built_in">shell</span> <span class="built_in">to</span> keep <span class="keyword">a</span> history <span class="keyword">of</span> passed <span class="built_in">shell</span> commands (moderate), <span class="keyword">or</span> anything <span class="keyword">else</span> you would like your <span class="built_in">shell</span> <span class="built_in">to</span> <span class="built_in">do</span>. (If you are very ambitious, you may have <span class="built_in">to</span> modify <span class="keyword">the</span> kernel <span class="built_in">to</span> support <span class="keyword">the</span> kernel features you need; xv6 doesn<span class="string">'t support much.)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MIT6-S081&quot;&gt;&lt;a href=&quot;#MIT6-S081&quot; class=&quot;headerlink&quot; title=&quot;MIT6.S081&quot;&gt;&lt;/a&gt;MIT6.S081&lt;/h1&gt;&lt;p&gt;很早就听说MIT6.S081的课程比较经典了，所以从上周末就开始学习MIT6.S081的&lt;code&gt;lecture&lt;/code&gt;,目前刚学习完&lt;code&gt;lecture 1&lt;/code&gt;，并且成功完成了&lt;code&gt;lab1&lt;/code&gt;，不得不说&lt;code&gt;lab&lt;/code&gt;太花费时间了，&lt;code&gt;lab&lt;/code&gt;设置的非常好，难度适中，有挑战性与趣味性并存，非常感谢这么好与经典的课程，不过不得不说因为确实平时没有时间，又要照顾家庭，又要上班，只能利用周末和晚上的时间抓紧来学习和完成这些&lt;code&gt;lab&lt;/code&gt;的代码了，每次都需要花时间调试代码调试很长时间，目测后面的挑战题目更难。&lt;code&gt;MIT&lt;/code&gt;的课程难度一向很大，难怪能够培养出很多非常优秀和出色的工程师。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 244</title>
    <link href="http://yoursite.com/2021/06/06/291/"/>
    <id>http://yoursite.com/2021/06/06/291/</id>
    <published>2021-06-06T13:36:04.088Z</published>
    <updated>2021-06-08T02:24:01.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-244"><a href="#leetcode-contest-244" class="headerlink" title="leetcode  contest 244"></a>leetcode  contest 244</h1><p>周末忙着迁移网络，真心忙的一比，没有时间刷题，特此上来总结一下，赛后还是没有看参考答案，将四道题目全部独立思考出来了。题目质量还是非常的高的，周赛还是经常参加一下，非常锻炼思考能力。</p><h2 id="5776-判断矩阵经轮转后是否一致"><a href="#5776-判断矩阵经轮转后是否一致" class="headerlink" title="5776. 判断矩阵经轮转后是否一致"></a>5776. 判断矩阵经轮转后是否一致</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个大小为 <code>n x n</code> 的二进制矩阵<code>mat</code> 和 <code>target</code> 。现 以 <code>90</code>度顺时针轮转 矩阵 <code>mat</code> 中的元素 若干次 ，如果能够使 <code>mat</code>与 <code>target</code> 一致，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[0,1],[1,0]]</span>, target = <span class="string">[[1,0],[0,1]]</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：顺时针轮转 <span class="number">90</span> 度一次可以使 mat 和 target 一致。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[0,1],[1,1]]</span>, target = <span class="string">[[1,0],[0,1]]</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法通过轮转矩阵中的元素使 equal 与 target 一致。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]], target = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：顺时针轮转 <span class="number">90</span> 度两次可以使 mat 和 target 一致。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == mat.length == target.length</code></li><li><code>n == mat[i].length == target[i].length</code></li><li><code>1 &lt;= n &lt;= 10</code></li><li><code>mat[i][j]</code> 和 <code>target[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  模拟计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们依次计算出四种可能的旋转情况即可，顺时针旋转$90^{。}$,相当于我们先交换行与列，再交换行即可达到旋转。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findRotation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; ++k)&#123;</span><br><span class="line">                    swap(mat[j][k],mat[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col/<span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; row; ++k)&#123;</span><br><span class="line">                    swap(mat[k][j],mat[k][col<span class="number">-1</span>-j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; col; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mat[j][k] != target[j][k])&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5777-使数组元素相等的减少操作次数"><a href="#5777-使数组元素相等的减少操作次数" class="headerlink" title="5777. 使数组元素相等的减少操作次数"></a>5777. 使数组元素相等的减少操作次数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，你的目标是令 <code>nums</code> 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p><p>找出 <code>nums</code> 中的 最大 值。记这个值为 <code>largest</code> 并取其下标 i （下标从 0 开始计数）。如果有多个元素都是最大值，则取最小的 i 。<br>找出 <code>nums</code>中的 下一个最大 值，这个值 严格小于 <code>largest</code> ，记为 <code>nextLargest</code>。<br>将 <code>nums[i]</code> 减少到 <code>nextLargest</code> 。<br>返回使 <code>nums</code>中的所有元素相等的操作次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：需要 <span class="number">3</span> 次操作使 nums 中的所有元素相等：</span><br><span class="line"><span class="number">1.</span> largest = <span class="number">5</span> 下标为 <span class="number">0</span> 。nextLargest = <span class="number">3</span> 。将 nums[<span class="number">0</span>] 减少到 <span class="number">3</span> 。nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>] 。</span><br><span class="line"><span class="number">2.</span> largest = <span class="number">3</span> 下标为 <span class="number">0</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">0</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>] 。</span><br><span class="line"><span class="number">3.</span> largest = <span class="number">3</span> 下标为 <span class="number">2</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">2</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums 中的所有元素已经是相等的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：需要 <span class="number">4</span> 次操作使 nums 中的所有元素相等：</span><br><span class="line"><span class="number">1.</span> largest = <span class="number">3</span> 下标为 <span class="number">4</span> 。nextLargest = <span class="number">2</span> 。将 nums[<span class="number">4</span>] 减少到 <span class="number">2</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br><span class="line"><span class="number">2.</span> largest = <span class="number">2</span> 下标为 <span class="number">2</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">2</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 。 </span><br><span class="line"><span class="number">3.</span> largest = <span class="number">2</span> 下标为 <span class="number">3</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">3</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] 。 </span><br><span class="line"><span class="number">4.</span> largest = <span class="number">2</span> 下标为 <span class="number">4</span> 。nextLargest = <span class="number">1</span> 。将 nums[<span class="number">4</span>] 减少到 <span class="number">1</span> 。nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li><li><code>1 &lt;= nums[i] &lt;= 5 * 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的数学问题，我们知道假设数列排序后，按照无重复按照从小达到排列后的序列为$x_{1},x_{2},x_{3},…,x_{n}$,则我们可以知道最终的序列肯定都会变成$x_{1},x_{1},x_{1},…,x_{1}$,对于任意的$x_{i}$,则我们知道它需要依次变换为$x_{i-1},x_{i-2},…,x_{2},x_{1}$，则需要变换次数总计为$i-1$次，则我们知道需要对于数组中的任意元素，它都需要变换的次数为该元素在数组中的排序的位置。这样就非常简单了，我们依次获取每个元素的排名次数即可，然后即可求出所有的元素的变换次数。</li><li>时间复杂度为$O(n)$,空间复杂度$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reductionOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) cnt[v]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            ans += curr*v.second;</span><br><span class="line">            curr++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5778-使二进制字符串字符交替的最少反转次数"><a href="#5778-使二进制字符串字符交替的最少反转次数" class="headerlink" title="5778. 使二进制字符串字符交替的最少反转次数"></a>5778. 使二进制字符串字符交替的最少反转次数</h2><p>给你一个二进制字符串 s 。你可以按任意顺序执行以下两种操作任意次：</p><ul><li>类型 <code>1</code>：删除 字符串 s 的第一个字符并将它 添加 到字符串结尾。</li><li>类型 <code>2</code> ：选择 字符串 s 中任意一个字符并将该字符 反转 ，也就是如果值为 ‘0’ ，则反转得到 ‘1’ ，反之亦然。<br>请你返回使 s 变成 交替 字符串的前提下， 类型 2 的 最少 操作次数 。</li></ul><p>我们称一个字符串是 交替 的，需要满足任意相邻字符都不同。</p><p>比方说，字符串 <code>&quot;010&quot;</code> 和 <code>&quot;1010&quot;</code>都是交替的，但是字符串 <code>&quot;0100&quot;</code> 不是。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"111000"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：执行第一种操作两次，得到 <span class="attr">s</span> = <span class="string">"100011"</span> 。</span><br><span class="line">然后对第三个和第六个字符执行第二种操作，得到 <span class="attr">s</span> = <span class="string">"101010"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"010"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串已经是交替的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1110"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：对第二个字符执行第二种操作，得到 <span class="attr">s</span> = <span class="string">"1010"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code>要么是 <code>&#39;0&#39;</code> ，要么是 <code>&#39;1&#39;</code> 。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目看上去很复杂，但是我们实际上可以利用前缀和，我们设四个等式如下：</li></ol><ul><li><code>left[0][i]</code>表示将前<code>i</code>位变为首位以<code>0</code>起始，且满足<code>0</code>,<code>1</code>交替时，所需要替换的最小替换次数;</li><li><code>left[1][i]</code>表示将前<code>i</code>位变为首位以<code>1</code>起始，且满足<code>0</code>,<code>1</code>交替时，所需要替换的最小替换次数;</li><li><code>right[0][i]</code>表示从<code>i</code>位至最后一位变为首位以<code>0</code>起始，且满足<code>0</code>,<code>1</code>交替时，所需要替换的最小替换次数;</li><li><code>right[1][i]</code>表示从<code>i</code>位至最后一位变为首位以<code>1</code>起始，且满足<code>0</code>,<code>1</code>交替时，所需要替换的最小替换次数;<br>我们很容易利用前缀和，计算出上述的四个等式的值。</li></ul><ol><li>我们依次计算需要向队尾移动<code>1,2,3,4...n</code>个元素时的最小变换次数，我们知道可以有以下几种情况：</li></ol><ul><li>如果数组的长度$n$为偶数，则我们知道假如我们向队尾移动<code>x</code>个元素，则还剩余<code>n-x</code>个元素，因为$x,n-x$的奇偶性一样，此时则需要满足：如果数组的前<code>n-x</code>个元素以<code>0</code>开头且交替，则末尾的<code>x</code>个元素也必须以<code>0</code>开头且交替;如果数组的前<code>n-x</code>个元素以<code>1</code>开头且交替，则末尾的<code>x</code>个元素也必须以<code>1</code>开头且交替。此时我们可以得到如下等式：<script type="math/tex; mode=display">ans = min(left[1][x] + right[1][x+1],left[0][x] + right[0][x+1]) \\</script></li><li>如果数组的长度$n$为奇数，则我们知道假如我们向队尾移动<code>x</code>个元素，则还剩余<code>n-x</code>个元素，因为$x,n-x$的奇偶性不一样，此时则需要满足：如果数组的前<code>n-x</code>个元素以<code>0</code>开头且交替，则末尾的<code>x</code>个元素也必须以<code>1</code>开头且交替;如果数组的前<code>n-x</code>个元素以<code>1</code>开头且交替，则末尾的<code>x</code>个元素也必须以<code>0</code>开头且交替。此时我们可以得到如下等式：<script type="math/tex; mode=display">ans = min(left[1][x] + right[0][x+1],left[1][x] + right[0][x+1]) \\</script></li></ul><ol><li>我们遍历所有可能的情况，即可得出最小的变换次数。时间复杂度为$O(n)$,空间复杂度$O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> invalid0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> invalid1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start0(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start1(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c0 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) invalid1++;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) invalid0++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) invalid0++;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) invalid1++;</span><br><span class="line">            &#125;</span><br><span class="line">            start0[i+<span class="number">1</span>] = invalid0;</span><br><span class="line">            start1[i+<span class="number">1</span>] = invalid1;</span><br><span class="line">        &#125;      </span><br><span class="line">        ans = min(start0[n],start1[n]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ans = min(ans,start0[i] + start1[n] - start1[i]);</span><br><span class="line">                ans = min(ans,start1[i] + start0[n] - start0[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5779-装包裹的最小浪费空间"><a href="#5779-装包裹的最小浪费空间" class="headerlink" title="5779. 装包裹的最小浪费空间"></a>5779. 装包裹的最小浪费空间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 n 个包裹，你需要把它们装在箱子里，每个箱子装一个包裹。总共有<code>m</code> 个供应商提供 不同尺寸 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 小于等于 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p><p>包裹的尺寸用一个整数数组 <code>packages</code> 表示，其中 <code>packages[i]</code>是第 i 个包裹的尺寸。供应商用二维数组 <code>boxes</code> 表示，其中 <code>boxes[j]</code> 是第 j 个供应商提供的所有箱子尺寸的数组。</p><p>你想要选择 一个供应商 并只使用该供应商提供的箱子，使得 总浪费空间最小 。对于每个装了包裹的箱子，我们定义 浪费的 空间等于 箱子的尺寸 - 包裹的尺寸 。总浪费空间 为 所有 箱子中浪费空间的总和。</p><ul><li>比方说，如果你想要用尺寸数组为 <code>[4,8]</code>的箱子装下尺寸为 <code>[2,3,5]</code>的包裹，你可以将尺寸为 2 和 3 的两个包裹装入两个尺寸为 4 的箱子中，同时把尺寸为 5 的包裹装入尺寸为 8 的箱子中。总浪费空间为 <code>(4-2) + (4-3) + (8-5) = 6</code> 。<br>请你选择 最优 箱子供应商，使得 总浪费空间最小 。如果 无法 将所有包裹放入箱子中，请你返回 -1 。由于答案可能会 很大 ，请返回它对 <code>109 + 7</code> 取余 的结果。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：packages = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], boxes = [[<span class="number">4</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：选择第一个供应商最优，用两个尺寸为 <span class="number">4</span> 的箱子和一个尺寸为 <span class="number">8</span> 的箱子。</span><br><span class="line">总浪费空间为 (<span class="number">4</span><span class="number">-2</span>) + (<span class="number">4</span><span class="number">-3</span>) + (<span class="number">8</span><span class="number">-5</span>) = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：packages = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], boxes = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：没有箱子能装下尺寸为 <span class="number">5</span> 的包裹。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：packages = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>], boxes = [[<span class="number">12</span>],[<span class="number">11</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">5</span>,<span class="number">14</span>]]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：选择第三个供应商最优，用两个尺寸为 <span class="number">5</span> 的箱子，两个尺寸为 <span class="number">10</span> 的箱子和两个尺寸为 <span class="number">14</span> 的箱子。</span><br><span class="line">总浪费空间为 (<span class="number">5</span><span class="number">-3</span>) + (<span class="number">5</span><span class="number">-5</span>) + (<span class="number">10</span><span class="number">-8</span>) + (<span class="number">10</span><span class="number">-10</span>) + (<span class="number">14</span><span class="number">-11</span>) + (<span class="number">14</span><span class="number">-12</span>) = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == packages.length</code></li><li><code>m == boxes.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= m &lt;= 105</code></li><li><code>1 &lt;= packages[i] &lt;= 105</code></li><li><code>1 &lt;= boxes[j].length &lt;= 105</code></li><li><code>1 &lt;= boxes[j][k] &lt;= 105</code></li><li><code>sum(boxes[j].length) &lt;= 105</code></li><li><code>boxes[j]</code> 中的元素 互不相同 。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-space-wasted-from-packaging" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-space-wasted-from-packaging</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找贪心或者双指针</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目本质就是贪心算法，对于每个供应商来说，对于每个<code>package</code>则需要找到刚好最小能够大于等于该元素的箱子。我们首先需要将所有的<code>package</code>进行排序。关键点在于如下：</li></ol><ul><li>我们<code>cost[i]</code>表示第<code>i</code>个供应商刚好能够满足包装前<code>dp[i]</code>个箱子时最小的浪费空间.</li><li>对于第<code>i</code>个包裹，我们肯定优先选择处在以下范围内的箱子是最优解，及越接近$package[i]$的箱子。<script type="math/tex; mode=display">package_{i} \le b_{j} \le b_{j+1} \le ... \le b_{j+k} < package_{i+1}</script></li><li>我们对于所有的供应商的箱子都进行排序，同时标记该箱子属于哪一个供应商，我们每次遍历所有满足大于等于第<code>i</code>个包裹且小于第<code>i+1</code>个包裹的箱子，及满足如下：<script type="math/tex; mode=display">package_{i} \le b_{j} \le b_{j+1} \le ... \le b_{j+k} < package_{i+1}</script>我们可以知道此时的待选的匹配序列为:$(b_{j} \le b_{j+1} \le … \le b_{j+k})$<br>则此时我们依次检查这<code>k</code>个箱子，如果$b_{j+m}$属于第<code>x</code>个供应商,且第<code>x</code>个供应商的箱子此时已经匹配了<code>dp[x]</code>个包裹，且最小浪费为<code>cost[x]</code>;如果<code>dp[x] == i</code>则表示此时已经有更小的箱子匹配了第<code>i</code>个包裹，则我们直接忽略；如果<code>dp[x] &lt; i</code>,则意味着此时$b_{j+m}$应该最佳匹配第$(dp[x]+1,dp[x]+2,…,i)$个箱子,此时我们求出用$b_{j+m}$匹配排序为$(dp[x]+1,dp[x]+2,…,i)$这些箱子的最小浪费，我们可以很容易计算出需要浪费的空间为:<script type="math/tex; mode=display">waste = b_{j+m}*(i-dp[x]) - \sum_{k=dp[x]+1}^{i}package[k] \\</script>此时表示第<code>x</code>个供应商已经最佳匹配了前<code>i</code>个箱子，我们需要更新<code>cost[x]</code>为：<script type="math/tex; mode=display">cost[x] = cost[x] + b_{j+m}*(i-dp[x]) - \sum_{k=dp[x]+1}^{i}package[k]</script></li><li>我们此时刚好可以利用前缀和快速的求出区间和，所有上述表达式还可以继续变换为：<script type="math/tex; mode=display">cost[x] = cost[x] + b_{j+m}*(i-dp[x]) - (sum[i] - sum[dp[x]])</script></li></ul><ol><li>最终所有的计算完成后，我们则需要判断哪些供应商完美匹配了前<code>n</code>个<code>package</code>，同时比较最小的<code>cost</code>.总的时间复杂度为$O(nlgn + mlgm + m + n)$.空间复杂度为$O(m)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minWastedSpace</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; packages, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; boxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = packages.size();</span><br><span class="line">        <span class="keyword">int</span> m = boxes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; cost(m,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = LLONG_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*intial*/</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        packages.push_back(INT_MAX);</span><br><span class="line">        sort(packages.begin(),packages.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + packages[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : boxes[i])&#123;</span><br><span class="line">                arr.push_back(make_pair(v,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr &lt; arr.size() &amp;&amp; arr[curr].first &lt; packages[i]) curr++;</span><br><span class="line">            <span class="keyword">while</span>(curr &lt; arr.size() &amp;&amp; arr[curr].first &gt;= packages[i] &amp;&amp; arr[curr].first &lt; packages[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> val = arr[curr].first;</span><br><span class="line">                <span class="keyword">int</span> idx = arr[curr].second;</span><br><span class="line">                <span class="keyword">if</span>(dp[idx] &lt; i)&#123;</span><br><span class="line">                    cost[idx] += (<span class="keyword">long</span> <span class="keyword">long</span>)(i - dp[idx])*val - (sum[i+<span class="number">1</span>] - sum[dp[idx]+<span class="number">1</span>]);</span><br><span class="line">                    dp[idx] = i;</span><br><span class="line">                    <span class="keyword">if</span>(i == n<span class="number">-1</span>) ans = min(ans,cost[idx]);                    </span><br><span class="line">                &#125;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ans == LLONG_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-244&quot;&gt;&lt;a href=&quot;#leetcode-contest-244&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 244&quot;&gt;&lt;/a&gt;leetcode  contest 244&lt;/h1&gt;&lt;p&gt;周末忙着迁移网络，真心忙的一比，没有时间刷题，特此上来总结一下，赛后还是没有看参考答案，将四道题目全部独立思考出来了。题目质量还是非常的高的，周赛还是经常参加一下，非常锻炼思考能力。&lt;/p&gt;&lt;h2 id=&quot;5776-判断矩阵经轮转后是否一致&quot;&gt;&lt;a href=&quot;#5776-判断矩阵经轮转后是否一致&quot; class=&quot;headerlink&quot; title=&quot;5776. 判断矩阵经轮转后是否一致&quot;&gt;&lt;/a&gt;5776. 判断矩阵经轮转后是否一致&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个大小为 &lt;code&gt;n x n&lt;/code&gt; 的二进制矩阵&lt;code&gt;mat&lt;/code&gt; 和 &lt;code&gt;target&lt;/code&gt; 。现 以 &lt;code&gt;90&lt;/code&gt;度顺时针轮转 矩阵 &lt;code&gt;mat&lt;/code&gt; 中的元素 若干次 ，如果能够使 &lt;code&gt;mat&lt;/code&gt;与 &lt;code&gt;target&lt;/code&gt; 一致，返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++智能指针学习</title>
    <link href="http://yoursite.com/2021/06/01/290/"/>
    <id>http://yoursite.com/2021/06/01/290/</id>
    <published>2021-06-01T04:40:00.614Z</published>
    <updated>2021-06-07T06:08:21.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><p>因为前段时间需要进行面试时，顺便对C++的部分语言特性学习了一下，虽然感觉C++语言非常强大，但是感觉这种面向对象的语言非常不友好，不够自然理解，总体来说感觉比<code>java</code>要难的多，<code>java</code>中一切皆对象的概念非常深入人心，彻底的<code>object-oriented</code>,<code>C++</code>这种既有面向对象的东西，又要兼容<code>C</code>的特性，对我这种从<code>C</code>转过来的程序猿感觉非常不友好，最大的问题是由于面向对象的封装，语言内部的机制和逻辑对我来说就像一个黑匣子，我完全不太了解函数内部到底实现了什么，所以对<code>C++</code>这种类似于黑匣子的语言有些畏惧，而对于常用的<code>C</code>语言来说，由于是面向过程的，所以写的每一行代码基本上都能猜测出来<code>CPU</code>执行了哪些指令，对于实际的内存到底做了哪些变动，非常的简洁。看到各种模板和各种奇怪的变量命名就感觉头大。<br><code>C++</code>的智能指针主要是解决指针管理的问题，我们知道在<code>C</code>语言中对于一般的动态内存申请，在内存使用完毕时都需要由程序猿主动去<code>free</code>,但是常常在使用过程中许多程序员会忘记主动去释放内存，从而产生各种各样的内存泄露问题，有没有一种简单的办法来管理指针，使得动态内存使用时，当它的生命周期完成时，能不能向对象一样主动去执行析构函数，从而释放内存，从而产生了<code>c++</code>的智能指针的使用。</p><a id="more"></a><h2 id="1-unique-ptr"><a href="#1-unique-ptr" class="headerlink" title="1. unique_ptr"></a>1. unique_ptr</h2><p><code>unique_ptr</code>表示当前的指针只能有一个所有权，既然unique_ptr是独享对象，那么任何可能被共享的操作都是不允许的，但是可以通过移动来转移所有权。以下通过直接赋值，编译器则会提示不支持该操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up0;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1111</span>));</span><br><span class="line">up0 = up1 <span class="comment">//错误，不可赋值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up2(up1);<span class="comment">//错误，不支持拷贝</span></span><br></pre></td></tr></table></figure></p><p>也即假设智能指针<code>a</code>有了指针<code>p</code>的所有权，则假设我们此时将<code>a</code>的所有权赋给<code>b</code>之后，则<code>a</code>将不再拥有指针<code>p</code>的所有权，即我们通过<code>a</code>就不能访问<code>p</code>所指向的内存，此时即强调所有权的唯一性。<br>对于<code>unique_ptr</code>指针需要注意的几点：</p><ul><li><code>release()</code>:</li><li><code>reset()</code>:</li><li><code>move</code>:<h2 id="2-shared-ptr"><a href="#2-shared-ptr" class="headerlink" title="2. shared_ptr"></a>2. shared_ptr</h2><h2 id="3-weak-ptr"><a href="#3-weak-ptr" class="headerlink" title="3. weak_ptr"></a>3. weak_ptr</h2><h2 id="4-make-shared"><a href="#4-make-shared" class="headerlink" title="4. make_shared"></a>4. make_shared</h2></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-智能指针&quot;&gt;&lt;a href=&quot;#C-智能指针&quot; class=&quot;headerlink&quot; title=&quot;C++智能指针&quot;&gt;&lt;/a&gt;C++智能指针&lt;/h1&gt;&lt;p&gt;因为前段时间需要进行面试时，顺便对C++的部分语言特性学习了一下，虽然感觉C++语言非常强大，但是感觉这种面向对象的语言非常不友好，不够自然理解，总体来说感觉比&lt;code&gt;java&lt;/code&gt;要难的多，&lt;code&gt;java&lt;/code&gt;中一切皆对象的概念非常深入人心，彻底的&lt;code&gt;object-oriented&lt;/code&gt;,&lt;code&gt;C++&lt;/code&gt;这种既有面向对象的东西，又要兼容&lt;code&gt;C&lt;/code&gt;的特性，对我这种从&lt;code&gt;C&lt;/code&gt;转过来的程序猿感觉非常不友好，最大的问题是由于面向对象的封装，语言内部的机制和逻辑对我来说就像一个黑匣子，我完全不太了解函数内部到底实现了什么，所以对&lt;code&gt;C++&lt;/code&gt;这种类似于黑匣子的语言有些畏惧，而对于常用的&lt;code&gt;C&lt;/code&gt;语言来说，由于是面向过程的，所以写的每一行代码基本上都能猜测出来&lt;code&gt;CPU&lt;/code&gt;执行了哪些指令，对于实际的内存到底做了哪些变动，非常的简洁。看到各种模板和各种奇怪的变量命名就感觉头大。&lt;br&gt;&lt;code&gt;C++&lt;/code&gt;的智能指针主要是解决指针管理的问题，我们知道在&lt;code&gt;C&lt;/code&gt;语言中对于一般的动态内存申请，在内存使用完毕时都需要由程序猿主动去&lt;code&gt;free&lt;/code&gt;,但是常常在使用过程中许多程序员会忘记主动去释放内存，从而产生各种各样的内存泄露问题，有没有一种简单的办法来管理指针，使得动态内存使用时，当它的生命周期完成时，能不能向对象一样主动去执行析构函数，从而释放内存，从而产生了&lt;code&gt;c++&lt;/code&gt;的智能指针的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="技术知识" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 243</title>
    <link href="http://yoursite.com/2021/05/30/289/"/>
    <id>http://yoursite.com/2021/05/30/289/</id>
    <published>2021-05-30T08:37:27.995Z</published>
    <updated>2021-06-01T01:32:06.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-243"><a href="#leetcode-contest-243" class="headerlink" title="leetcode  contest 243"></a>leetcode  contest 243</h1><p>周赛的题目质量一向非常稳定，还是质量非常高的四道题目，不过还是依旧三道题目的节奏，感觉还是智商不够。</p><h2 id="5772-检查某单词是否等于两单词之和"><a href="#5772-检查某单词是否等于两单词之和" class="headerlink" title="5772. 检查某单词是否等于两单词之和"></a>5772. 检查某单词是否等于两单词之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>字母的 字母值 取决于字母在字母表中的位置，从 0 开始 计数。即，<code>&#39;a&#39; -&gt; 0、&#39;b&#39; -&gt; 1、&#39;c&#39; -&gt; 2</code>，以此类推。</p><a id="more"></a><p>对某个由小写字母组成的字符串 s 而言，其 数值 就等于将 s 中每个字母的 字母值 按顺序 连接 并 转换 成对应整数。</p><p>例如，<code>s = &quot;acb&quot;</code> ，依次连接每个字母的字母值可以得到 <code>&quot;021&quot;</code>，转换为整数得到 <code>21</code> 。<br>给你三个字符串 <code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> ，每个字符串都由从 ‘<code>a&#39;</code> 到 <code>&#39;j&#39;</code> （含 ‘a’ 和 ‘j’ ）的小写英文字母组成。</p><p>如果 <code>firstWord</code> 和 <code>secondWord</code>的 数值之和 等于 <code>targetWord</code>的数值，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：firstWord = <span class="string">"acb"</span>, secondWord = <span class="string">"cba"</span>, targetWord = <span class="string">"cdb"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">firstWord 的数值为 <span class="string">"acb"</span> -&gt; <span class="string">"021"</span> -&gt; <span class="number">21</span></span><br><span class="line">secondWord 的数值为 <span class="string">"cba"</span> -&gt; <span class="string">"210"</span> -&gt; <span class="number">210</span></span><br><span class="line">targetWord 的数值为 <span class="string">"cdb"</span> -&gt; <span class="string">"231"</span> -&gt; <span class="number">231</span></span><br><span class="line">由于 <span class="number">21</span> + <span class="number">210</span> == <span class="number">231</span> ，返回 <span class="keyword">true</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：firstWord = <span class="string">"aaa"</span>, secondWord = <span class="string">"a"</span>, targetWord = <span class="string">"aab"</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">firstWord 的数值为 <span class="string">"aaa"</span> -&gt; <span class="string">"000"</span> -&gt; <span class="number">0</span></span><br><span class="line">secondWord 的数值为 <span class="string">"a"</span> -&gt; <span class="string">"0"</span> -&gt; <span class="number">0</span></span><br><span class="line">targetWord 的数值为 <span class="string">"aab"</span> -&gt; <span class="string">"001"</span> -&gt; <span class="number">1</span></span><br><span class="line">由于 <span class="number">0</span> + <span class="number">0</span> != <span class="number">1</span> ，返回 <span class="keyword">false</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：firstWord = <span class="string">"aaa"</span>, secondWord = <span class="string">"a"</span>, targetWord = <span class="string">"aaaa"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">firstWord 的数值为 <span class="string">"aaa"</span> -&gt; <span class="string">"000"</span> -&gt; <span class="number">0</span></span><br><span class="line">secondWord 的数值为 <span class="string">"a"</span> -&gt; <span class="string">"0"</span> -&gt; <span class="number">0</span></span><br><span class="line">targetWord 的数值为 <span class="string">"aaaa"</span> -&gt; <span class="string">"0000"</span> -&gt; <span class="number">0</span></span><br><span class="line">由于 <span class="number">0</span> + <span class="number">0</span> == <span class="number">0</span> ，返回 <span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= firstWord.length, secondWord.length, targetWord.length &lt;= 8</code></li><li><code>firstWord、secondWord</code> 和 <code>targetWord</code> 仅由从 ‘a’ 到 ‘j’ （含 ‘a’ 和 ‘j’ ）的小写英文字母组成。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-word-equals-summation-of-two-words" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-word-equals-summation-of-two-words</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力计算出<code>nums1</code>和<code>nums2</code>的值，然后相加看二者之和是否跟<code>num3</code>相等。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            ans = ans*<span class="number">10</span> + c - <span class="string">'a'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSumEqual</span><span class="params">(<span class="built_in">string</span> firstWord, <span class="built_in">string</span> secondWord, <span class="built_in">string</span> targetWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = calc(firstWord);</span><br><span class="line">        <span class="keyword">int</span> b = calc(secondWord);</span><br><span class="line">        <span class="keyword">int</span> c = calc(targetWord);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a + b == c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5773-插入后的最大值"><a href="#5773-插入后的最大值" class="headerlink" title="5773. 插入后的最大值"></a>5773. 插入后的最大值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个非常大的整数 n 和一个整数数字 x ，大整数 n 用一个字符串表示。n 中每一位数字和数字 x 都处于闭区间 [1, 9] 中，且 n 可能表示一个 负数 。</p><p>你打算通过在 n 的十进制表示的任意位置插入 x 来 最大化 n 的 数值 ​​​​​​。但 不能 在负号的左边插入 x 。</p><p>例如，如果 n = 73 且 x = 6 ，那么最佳方案是将 6 插入 7 和 3 之间，使 n = 763 。<br>如果 n = -55 且 x = 2 ，那么最佳方案是将 2 插在第一个 5 之前，使 n = -255 。<br>返回插入操作后，用字符串表示的 n 的最大值。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="string">"99"</span>, x = <span class="number">9</span></span><br><span class="line">输出：<span class="string">"999"</span></span><br><span class="line">解释：不管在哪里插入 <span class="number">9</span> ，结果都是相同的。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="string">"-13"</span>, x = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"-123"</span></span><br><span class="line">解释：向 n 中插入 x 可以得到 <span class="number">-213</span>、<span class="number">-123</span> 或者 <span class="number">-132</span> ，三者中最大的是 <span class="number">-123</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n.length &lt;= 105</code></li><li><code>1 &lt;= x &lt;= 9</code></li><li>n​​​ 中每一位的数字都在闭区间 <code>[1, 9]</code> 中。</li><li>n 代表一个有效的整数。</li><li>当 n 表示负数时，将会以字符 ‘-‘ 开始。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-value-after-insertion" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-value-after-insertion</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们每次进行贪心算法即可，我们知道假如整数<code>n</code>为正数，则我们希望它数字部分的数字越大越好，则我们知道可以用<code>x</code>替换从左往右第一个比<code>x</code>小的数即可，使得得到数最大；如果<code>x</code>为负数，则我们希望它数字部分的数越小越好，则我们知道肯定应该用<code>x</code>替换从左往右替第一个比<code>x</code>大的数即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">string</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> sig = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        curr.push_back(x+<span class="string">'0'</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n[<span class="number">0</span>] == <span class="string">'-'</span>) sig = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sig)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n[i]-<span class="string">'0'</span> &lt; x)&#123;</span><br><span class="line">                    <span class="keyword">return</span> n.substr(<span class="number">0</span>,i) + curr + n.substr(i,n.size()-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n + curr;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n[i]-<span class="string">'0'</span> &gt; x)&#123;</span><br><span class="line">                    <span class="keyword">return</span> n.substr(<span class="number">0</span>,i) + curr + n.substr(i,n.size()-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n + curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5774-使用服务器处理任务"><a href="#5774-使用服务器处理任务" class="headerlink" title="5774. 使用服务器处理任务"></a>5774. 使用服务器处理任务</h2><p>给你两个 下标从 0 开始 的整数数组 <code>servers</code> 和 <code>tasks</code>，长度分别为<code>n​​​​​​</code>和 <code>m​​​​​​</code> 。<code>servers[i]</code> 是第 <code>i​​​​​​​​​​</code> 台服务器的 权重 ，而<code>tasks[j]</code>是处理第 <code>j​​​​​​</code> 项任务 所需要的时间（单位：秒）。</p><p>你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第 0 项任务在第 0 秒可以开始处理，相应地，第 j 项任务在第 j 秒可以开始处理。处理第 j 项任务时，你需要为它分配一台 权重最小 的空闲服务器。如果存在多台相同权重的空闲服务器，请选择 下标最小 的服务器。如果一台空闲服务器在第 t 秒分配到第 j 项任务，那么在<code>t + tasks[j]</code> 时它将恢复空闲状态。</p><p>如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并 尽可能早 地处理剩余任务。 如果有多项任务等待分配，则按照 下标递增 的顺序完成分配。</p><p>如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。</p><p>构建长度为 m 的答案数组 <code>ans</code> ，其中 <code>ans[j]</code> 是第 <code>j</code>项任务分配的服务器的下标。</p><p>返回答案数组 <code>ans​​​​</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：servers = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>], tasks = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：事件按时间顺序如下：</span><br><span class="line">- <span class="number">0</span> 秒时，第 <span class="number">0</span> 项任务加入到任务队列，使用第 <span class="number">2</span> 台服务器处理到 <span class="number">1</span> 秒。</span><br><span class="line">- <span class="number">1</span> 秒时，第 <span class="number">2</span> 台服务器空闲，第 <span class="number">1</span> 项任务加入到任务队列，使用第 <span class="number">2</span> 台服务器处理到 <span class="number">3</span> 秒。</span><br><span class="line">- <span class="number">2</span> 秒时，第 <span class="number">2</span> 项任务加入到任务队列，使用第 <span class="number">0</span> 台服务器处理到 <span class="number">5</span> 秒。</span><br><span class="line">- <span class="number">3</span> 秒时，第 <span class="number">2</span> 台服务器空闲，第 <span class="number">3</span> 项任务加入到任务队列，使用第 <span class="number">2</span> 台服务器处理到 <span class="number">5</span> 秒。</span><br><span class="line">- <span class="number">4</span> 秒时，第 <span class="number">4</span> 项任务加入到任务队列，使用第 <span class="number">1</span> 台服务器处理到 <span class="number">5</span> 秒。</span><br><span class="line">- <span class="number">5</span> 秒时，所有服务器都空闲，第 <span class="number">5</span> 项任务加入到任务队列，使用第 <span class="number">2</span> 台服务器处理到 <span class="number">7</span> 秒。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：servers = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>], tasks = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释：事件按时间顺序如下：</span><br><span class="line">- <span class="number">0</span> 秒时，第 <span class="number">0</span> 项任务加入到任务队列，使用第 <span class="number">1</span> 台服务器处理到 <span class="number">2</span> 秒。</span><br><span class="line">- <span class="number">1</span> 秒时，第 <span class="number">1</span> 项任务加入到任务队列，使用第 <span class="number">4</span> 台服务器处理到 <span class="number">2</span> 秒。</span><br><span class="line">- <span class="number">2</span> 秒时，第 <span class="number">1</span> 台和第 <span class="number">4</span> 台服务器空闲，第 <span class="number">2</span> 项任务加入到任务队列，使用第 <span class="number">1</span> 台服务器处理到 <span class="number">4</span> 秒。</span><br><span class="line">- <span class="number">3</span> 秒时，第 <span class="number">3</span> 项任务加入到任务队列，使用第 <span class="number">4</span> 台服务器处理到 <span class="number">7</span> 秒。</span><br><span class="line">- <span class="number">4</span> 秒时，第 <span class="number">1</span> 台服务器空闲，第 <span class="number">4</span> 项任务加入到任务队列，使用第 <span class="number">1</span> 台服务器处理到 <span class="number">9</span> 秒。</span><br><span class="line">- <span class="number">5</span> 秒时，第 <span class="number">5</span> 项任务加入到任务队列，使用第 <span class="number">3</span> 台服务器处理到 <span class="number">7</span> 秒。</span><br><span class="line">- <span class="number">6</span> 秒时，第 <span class="number">6</span> 项任务加入到任务队列，使用第 <span class="number">2</span> 台服务器处理到 <span class="number">7</span> 秒。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>servers.length == n</code></li><li><code>tasks.length == m</code></li><li><code>1 &lt;= n, m &lt;= 2 * 105</code></li><li><code>1 &lt;= servers[i], tasks[j] &lt;= 2 * 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/process-tasks-using-servers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/process-tasks-using-servers</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目看上去好复杂，实际就是优先级队列。关键是题目太长了，好多细节需要仔细考虑，题目本身来说不是特别难的题目。</li><li>题目中要求每次从空闲的服务器列表中选择一个来进行处理任务，并且优先选择权重最小且编号最小的服务器，我们每次从待选序列中选择一个即可。</li><li>我们设计两个优先级队列，<code>runQue</code>准要存储已经分配任务的<code>server</code>的结束时间，<code>waitQue</code>存储空闲的服务器列表，每次遇到第<code>i</code>个任务时处理如下:</li></ol><ul><li>首先将<code>runQue</code>中的<code>server</code>的结束时间小于等于<code>i</code>的机器列表全部放入<code>waitQue</code>中。</li><li>如果<code>waitQue</code>不为空，则表示当前有空闲的服务器可用，我们直接从队列中取出权重最小且编号最小的服务器<code>t[i]</code>，并将<code>t[i]</code>分配给第<code>i</code>个服务器，同时将<code>t[i]</code>服务器的任务结束时间$i + tasks[i]$放入到<code>runQue</code>中；</li><li>如果<code>waitQue</code>为空，则表示当前没有空闲的服务器可用，则此时我们需要将<code>runQue</code>中结束时间最小的服务器全部放入到<code>waitQue</code>中，此时我们直接从队列中取出权重最小且编号最小的服务器<code>t[i]</code>，并将<code>t[i]</code>分配给第<code>i</code>个服务器，同时将<code>t[i]</code>服务器的任务结束时间$start[i] + tasks[i]$放入到<code>runQue</code>中，$start[i]$表示$t[i]$服务器任务的结束时间；<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    Node(<span class="keyword">int</span> idx,<span class="keyword">int</span> weight,<span class="keyword">int</span> start)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;idx = idx;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.start &gt; b.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp2</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.weight == b.weight)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.idx &gt; b.idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; assignTasks(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; servers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tasks) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = servers.size();</span><br><span class="line">        <span class="keyword">int</span> m = tasks.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp1&gt; runQ;</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp2&gt; waitQ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            waitQ.push(Node(i,servers[i],<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!runQ.empty() &amp;&amp; runQ.top().start &lt;= i)&#123;</span><br><span class="line">                waitQ.push(runQ.top());</span><br><span class="line">                runQ.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(waitQ.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> time  = runQ.top().start;</span><br><span class="line">                <span class="keyword">while</span>(!runQ.empty() &amp;&amp; runQ.top().start &lt;= time)&#123;</span><br><span class="line">                    waitQ.push(runQ.top());</span><br><span class="line">                    runQ.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            Node t = waitQ.top();</span><br><span class="line">            waitQ.pop();</span><br><span class="line">            ans.push_back(t.idx);</span><br><span class="line">            runQ.push(Node(t.idx,t.weight,max(i,t.start) + tasks[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5775-准时抵达会议现场的最小跳过休息次数"><a href="#5775-准时抵达会议现场的最小跳过休息次数" class="headerlink" title="5775. 准时抵达会议现场的最小跳过休息次数"></a>5775. 准时抵达会议现场的最小跳过休息次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>hoursBefore</code> ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 n 条道路。道路的长度用一个长度为 n 的整数数组<code>dist</code>表示，其中 <code>dist[i]</code> 表示第 i 条道路的长度（单位：千米）。另给你一个整数 <code>speed</code> ，表示你在道路上前进的速度（单位：千米每小时）。</p><p>当你通过第 i 条路之后，就必须休息并等待，直到 下一个整数小时 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。</p><p>例如，如果你通过一条道路用去 1.4 小时，那你必须停下来等待，到 2 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 2 小时，就无需等待，可以直接继续。<br>然而，为了能准时到达，你可以选择 跳过 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。</p><p>例如，假设通过第 1 条道路用去 1.4 小时，且通过第 2 条道路用去 0.6 小时。跳过第 1 条道路的休息时间意味着你将会在恰好 2 小时完成通过第 2 条道路，且你能够立即开始通过第 3 条道路。<br>返回准时抵达会议现场所需要的 最小跳过次数 ，如果 无法准时参会 ，返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], speed = <span class="number">4</span>, hoursBefore = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">不跳过任何休息时间，你将用 (<span class="number">1</span>/<span class="number">4</span> + <span class="number">3</span>/<span class="number">4</span>) + (<span class="number">3</span>/<span class="number">4</span> + <span class="number">1</span>/<span class="number">4</span>) + (<span class="number">2</span>/<span class="number">4</span>) = <span class="number">2.5</span> 小时才能抵达会议现场。</span><br><span class="line">可以跳过第 <span class="number">1</span> 次休息时间，共用 ((<span class="number">1</span>/<span class="number">4</span> + <span class="number">0</span>) + (<span class="number">3</span>/<span class="number">4</span> + <span class="number">0</span>)) + (<span class="number">2</span>/<span class="number">4</span>) = <span class="number">1.5</span> 小时抵达会议现场。</span><br><span class="line">注意，第 <span class="number">2</span> 次休息时间缩短为 <span class="number">0</span> ，由于跳过第 <span class="number">1</span> 次休息时间，你是在整数小时处完成通过第 <span class="number">2</span> 条道路。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>], speed = <span class="number">2</span>, hoursBefore = <span class="number">10</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">不跳过任何休息时间，你将用 (<span class="number">7</span>/<span class="number">2</span> + <span class="number">1</span>/<span class="number">2</span>) + (<span class="number">3</span>/<span class="number">2</span> + <span class="number">1</span>/<span class="number">2</span>) + (<span class="number">5</span>/<span class="number">2</span> + <span class="number">1</span>/<span class="number">2</span>) + (<span class="number">5</span>/<span class="number">2</span>) = <span class="number">11.5</span> 小时才能抵达会议现场。</span><br><span class="line">可以跳过第 <span class="number">1</span> 次和第 <span class="number">3</span> 次休息时间，共用 ((<span class="number">7</span>/<span class="number">2</span> + <span class="number">0</span>) + (<span class="number">3</span>/<span class="number">2</span> + <span class="number">0</span>)) + ((<span class="number">5</span>/<span class="number">2</span> + <span class="number">0</span>) + (<span class="number">5</span>/<span class="number">2</span>)) = <span class="number">10</span> 小时抵达会议现场。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>], speed = <span class="number">1</span>, hoursBefore = <span class="number">10</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：即使跳过所有的休息时间，也无法准时参加会议。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == dist.length</code></li><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= dist[i] &lt;= 105</code></li><li><code>1 &lt;= speed &lt;= 106</code></li><li><code>1 &lt;= hoursBefore &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-skips-to-arrive-at-meeting-on-time" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-skips-to-arrive-at-meeting-on-time</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个动态规划题目感觉出的比较奇怪，不过当时也确实没有时间来弄这个题目，涉及到精度的问题。我们<code>dp[i][j]</code>表示经过前<code>i</code>条路共休息<code>j</code>次的所花费的最小时间。则我们可以知道当第<code>i+1</code>段距离时，选择如下：</li></ol><ul><li>如果选择跳过第<code>i+1</code>段路程，则此时我们可以知道前<code>i</code>段路程则最多只能跳过<code>j-1</code>次，而此时我们跳过第<code>i+1</code>段路程时，走完第<code>j+1</code>段路程时所需要花费的时间为$\frac{dist[i+1]}{speed}$,因此总的花费的时间增加即为$\frac{dist[i+1]}{speed}$.<script type="math/tex; mode=display">dp[i+1][j] = min(dp[i+1][j],dp[i+1][j-1] + \frac{dist[i+1]}{speed})</script></li><li>如果不选则跳过第<code>i+1</code>段路程，则此时我们根据题意可以知道,则我们需要在第<code>i+1</code>段路程进行停留，等待为整数时间后再出发。则此时我们知道所花费的时间为:<script type="math/tex; mode=display">dp[i+1][j] = min(dp[i+1][j],ceil(dp[i][j] + \frac{dist[i+1]}{speed}))</script></li></ul><ol><li>题目最麻烦的还是在于精度问题不太好处理，这个题目感觉比较怪异，可能也是第一次遇到这样需要进行精度处理的问题，确实不太熟悉，还是需要仔细研究一下此类问题。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSkips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dist, <span class="keyword">int</span> speed, <span class="keyword">int</span> hoursBefore)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> n = dist.size();</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n+<span class="number">1</span>,INT_MAX));</span><br><span class="line"></span><br><span class="line">         dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(j != i)  dp[i][j] = min(dp[i][j],((dp[i<span class="number">-1</span>][j] + dist[i<span class="number">-1</span>]<span class="number">-1</span>)/speed + <span class="number">1</span>)*speed);</span><br><span class="line">                 <span class="keyword">if</span>(j != <span class="number">0</span>)  dp[i][j] = min(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dist[i<span class="number">-1</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">             <span class="keyword">if</span>(dp[n][i] &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>)speed*hoursBefore)&#123;</span><br><span class="line">                 <span class="keyword">return</span> i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-243&quot;&gt;&lt;a href=&quot;#leetcode-contest-243&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 243&quot;&gt;&lt;/a&gt;leetcode  contest 243&lt;/h1&gt;&lt;p&gt;周赛的题目质量一向非常稳定，还是质量非常高的四道题目，不过还是依旧三道题目的节奏，感觉还是智商不够。&lt;/p&gt;&lt;h2 id=&quot;5772-检查某单词是否等于两单词之和&quot;&gt;&lt;a href=&quot;#5772-检查某单词是否等于两单词之和&quot; class=&quot;headerlink&quot; title=&quot;5772. 检查某单词是否等于两单词之和&quot;&gt;&lt;/a&gt;5772. 检查某单词是否等于两单词之和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;字母的 字母值 取决于字母在字母表中的位置，从 0 开始 计数。即，&lt;code&gt;&amp;#39;a&amp;#39; -&amp;gt; 0、&amp;#39;b&amp;#39; -&amp;gt; 1、&amp;#39;c&amp;#39; -&amp;gt; 2&lt;/code&gt;，以此类推。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 53</title>
    <link href="http://yoursite.com/2021/05/30/288/"/>
    <id>http://yoursite.com/2021/05/30/288/</id>
    <published>2021-05-30T08:37:27.993Z</published>
    <updated>2021-05-30T11:49:00.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-53"><a href="#leetcode-biweekly-contest-53" class="headerlink" title="leetcode  biweekly contest 53"></a>leetcode  biweekly contest 53</h1><p>双周赛的题目质量确实忽高忽低，有时题目非常难，有时又特别简单。本周的双周赛题目真心非常简单，特别是第四题，典型的状态压缩<code>dp</code>，感觉也就10分钟的节奏就能写出来，反倒是第三题还算稍微有点难度，不过还是手速不够快，思路也确实不够快。反正现在周赛基本上能够百分之百稳定的做出三道题目来。<br><img src="https://i.loli.net/2021/05/30/cCKWgdRMpOLZI45.png" alt></p><a id="more"></a><h2 id="5754-长度为三且各字符不同的子字符串"><a href="#5754-长度为三且各字符不同的子字符串" class="headerlink" title="5754. 长度为三且各字符不同的子字符串"></a>5754. 长度为三且各字符不同的子字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果一个字符串不含有任何重复字符，我们称这个字符串为 好 字符串。<br>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 中长度为<code>3</code>的 好子字符串 的数量。<br>注意，如果相同的好子字符串出现多次，每一次都应该被记入答案之中。<br>子字符串 是一个字符串中连续的字符序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"xyzzaz"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：总共有 <span class="number">4</span> 个长度为 <span class="number">3</span> 的子字符串：<span class="string">"xyz"</span>，<span class="string">"yzz"</span>，<span class="string">"zza"</span> 和 <span class="string">"zaz"</span> 。</span><br><span class="line">唯一的长度为 <span class="number">3</span> 的好子字符串是 <span class="string">"xyz"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aababcabc"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：总共有 <span class="number">7</span> 个长度为 <span class="number">3</span> 的子字符串：<span class="string">"aab"</span>，<span class="string">"aba"</span>，<span class="string">"bab"</span>，<span class="string">"abc"</span>，<span class="string">"bca"</span>，<span class="string">"cab"</span> 和 <span class="string">"abc"</span> 。</span><br><span class="line">好子字符串包括 <span class="string">"abc"</span>，<span class="string">"bca"</span>，<span class="string">"cab"</span> 和 <span class="string">"abc"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code>​​​​​​ 只包含小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-53/problems/substrings-of-size-three-with-distinct-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-53/problems/substrings-of-size-three-with-distinct-characters/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力遍历连续的三个字符即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力连续的检测连续的三个字符是否互不相等。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[i<span class="number">-1</span>] &amp;&amp; s[i] != s[i<span class="number">-2</span>] &amp;&amp; s[i<span class="number">-1</span>] != s[i<span class="number">-2</span>])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5755-数组中最大数对和的最小值"><a href="#5755-数组中最大数对和的最小值" class="headerlink" title="5755. 数组中最大数对和的最小值"></a>5755. 数组中最大数对和的最小值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一个数对 <code>(a,b)</code>的 数对和 等于 <code>a + b</code>。最大数对和 是一个数对数组中最大的 数对和 。</p><p>比方说，如果我们有数对<code>(1,5)</code>，<code>(2,3)</code> 和 <code>(4,4)</code>，最大数对和 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。<br>给你一个长度为 偶数 <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code>个数对，使得：</p><p>nums 中每个元素 恰好 在 一个 数对中，且<br>最大数对和 的值 最小 。<br>请你在最优数对划分的方案下，返回最小的 最大数对和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：数组中的元素可以分为数对 (<span class="number">3</span>,<span class="number">3</span>) 和 (<span class="number">5</span>,<span class="number">2</span>) 。</span><br><span class="line">最大数对和为 max(<span class="number">3</span>+<span class="number">3</span>, <span class="number">5</span>+<span class="number">2</span>) = max(<span class="number">6</span>, <span class="number">7</span>) = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：数组中的元素可以分为数对 (<span class="number">3</span>,<span class="number">5</span>)，(<span class="number">4</span>,<span class="number">4</span>) 和 (<span class="number">6</span>,<span class="number">2</span>) 。</span><br><span class="line">最大数对和为 max(<span class="number">3</span>+<span class="number">5</span>, <span class="number">4</span>+<span class="number">4</span>, <span class="number">6</span>+<span class="number">2</span>) = max(<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>) = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>n</code> 是 偶数 。</li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常简单，我们使用贪心策略如下，假设数组中最大的元素需要配对，则必须要求最大的数与另一个数的配对最小，则我们此时优选选择应该为最大的数与最小的数进行配对。按照此贪心策略算法，则我们可以知道$nums[i]$应该与$nums[n-1-i]$进行配对，我们求出最大的数对即可。当然上述的思路不够严谨，严格的数学证明还是参考官方题解:<br><a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/solution/shu-zu-zhong-zui-da-shu-dui-he-de-zui-xi-cvll/" target="_blank" rel="noopener">题解</a></li><li>严格的数学证明:<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">            ans = max(ans,nums[i] + nums[n<span class="number">-1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1878-矩阵中最大的三个菱形和"><a href="#1878-矩阵中最大的三个菱形和" class="headerlink" title="1878. 矩阵中最大的三个菱形和"></a>1878. 矩阵中最大的三个菱形和</h2><p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p><p>菱形和 指的是 <code>grid</code> 中一个正菱形 边界 上的元素之和。本题中的菱形必须为正方形旋转45度，且四个角都在一个格子当中。下图是四个可行的菱形，每个菱形和应该包含的格子都用了相应颜色标注在图中。<br>注意，菱形可以是一个面积为 <code>0</code> 的区域，如上图中右下角的紫色菱形所示。<br>请你按照 降序 返回 <code>grid</code> 中三个最大的 互不相同的菱形和 。如果不同的和少于三个，则将它们全部返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">20</span>,<span class="number">30</span>,<span class="number">200</span>,<span class="number">40</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">228</span>,<span class="number">216</span>,<span class="number">211</span>]</span><br><span class="line">解释：最大的三个菱形和如上图所示。</span><br><span class="line">- 蓝色：<span class="number">20</span> + <span class="number">3</span> + <span class="number">200</span> + <span class="number">5</span> = <span class="number">228</span></span><br><span class="line">- 红色：<span class="number">200</span> + <span class="number">2</span> + <span class="number">10</span> + <span class="number">4</span> = <span class="number">216</span></span><br><span class="line">- 绿色：<span class="number">5</span> + <span class="number">200</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">211</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">20</span>,<span class="number">9</span>,<span class="number">8</span>]</span><br><span class="line">解释：最大的三个菱形和如上图所示。</span><br><span class="line">- 蓝色：<span class="number">4</span> + <span class="number">2</span> + <span class="number">6</span> + <span class="number">8</span> = <span class="number">20</span></span><br><span class="line">- 红色：<span class="number">9</span> （右下角红色的面积为 <span class="number">0</span> 的菱形）</span><br><span class="line">- 绿色：<span class="number">8</span> （下方中央面积为 <span class="number">0</span> 的菱形）</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]]</span><br><span class="line">输出：[<span class="number">7</span>]</span><br><span class="line">解释：所有三个可能的菱形和都相同，所以返回 [<span class="number">7</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>1 &lt;= grid[i][j] &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/get-biggest-three-rhombus-sums-in-a-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/get-biggest-three-rhombus-sums-in-a-grid</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力枚举，对角线前缀和</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目实际也确实没有想到太多的好的解法，感觉就是类似于小学奥数题目。暴力枚举所有的可能即可。</li><li>我们可以枚举菱形的边长，我们可以看到菱形的边长为$i$,则菱形的对角线的长度为$2*i-1$,我们同时枚举所有同边长的菱形的左顶点$(x,y)$，我们可以知道假设菱形的左顶点为$(x,y)$,边长为$i$,则菱形的四个顶点分别为:<script type="math/tex; mode=display">(x,y),(x,y+2*i-2),(x+i-1,y+i-1),(x-i+1,y+i-1)</script>观测上以上规律以后，我们即可枚举所有菱形的可能的左顶点即可，然后依次计算菱形边上所有点的和即可。</li><li>最后为常见的<code>topk</code>问题，排序或者优先级队列均可，时间复杂度约为$O(n^{3})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getBiggestThree(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                curr.insert(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(m,n); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j + i &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k + <span class="number">2</span>*i &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">/*top*/</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; i; ++a)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line">                            sum += grid[j][k];</span><br><span class="line">                            sum += grid[j][k+<span class="number">2</span>*i];</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            sum += grid[j+a][k+a] + grid[j-a][k+a];</span><br><span class="line">                            sum += grid[j+a][k+<span class="number">2</span>*i-a] + grid[j-a][k+<span class="number">2</span>*i-a];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*middle*/</span></span><br><span class="line">                    sum += grid[j-i][k+i] + grid[j+i][k+i];</span><br><span class="line">                    curr.insert(sum);                  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : curr)&#123;</span><br><span class="line">            arr.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            ans.push_back(arr[arr.size()<span class="number">-1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5756-两个数组最小的异或值之和"><a href="#5756-两个数组最小的异或值之和" class="headerlink" title="5756. 两个数组最小的异或值之和"></a>5756. 两个数组最小的异或值之和</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们长度都为 <code>n</code> 。</p><p>两个数组的 异或值之和 为 <code>(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])</code>（下标从 0 开始）。</p><p>比方说，<code>[1,2,3]</code>和 <code>[3,2,1]</code> 的 异或值之和 等于<code>(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4</code>。<br>请你将 <code>nums2</code>中的元素重新排列，使得 异或值之和 最小 。</p><p>请你返回重新排列之后的 异或值之和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：将 nums2 重新排列得到 [<span class="number">3</span>,<span class="number">2</span>] 。</span><br><span class="line">异或值之和为 (<span class="number">1</span> XOR <span class="number">3</span>) + (<span class="number">2</span> XOR <span class="number">2</span>) = <span class="number">2</span> + <span class="number">0</span> = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>], nums2 = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：将 nums2 重新排列得到 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>] 。</span><br><span class="line">异或值之和为 (<span class="number">1</span> XOR <span class="number">5</span>) + (<span class="number">0</span> XOR <span class="number">4</span>) + (<span class="number">3</span> XOR <span class="number">3</span>) = <span class="number">4</span> + <span class="number">4</span> + <span class="number">0</span> = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>1 &lt;= n &lt;= 14</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-xor-sum-of-two-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-xor-sum-of-two-arrays</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本题看到数据量提示<code>1 &lt;= n &lt;= 14</code>肯定知道需要用状态压缩<code>dp</code>，关键是在于如何确定递推公式，这个题目算是比较简单的状态压缩<code>dp</code>.</li><li>设<code>dp[i][state]</code>表示<code>nums1</code>的前<code>i</code>个元素与<code>state</code>表示的<code>nums2</code>中总共<code>i</code>个元素两两异或后的和最小值。则我们可以知道递推公式如下：<script type="math/tex; mode=display">dp[i][state] = min(dp[i][state],dp[i-1][state\oplus k]) \qquad k\in state</script>这个是最直接的解法，算法时间复杂度为$O(n^2<em>2^{n})$.实际还可以进行优化，时间复杂度可以继续优化为$O(n</em>2^{2})$.</li><li>我们设$dp[state]$表示由$state$所表示的$nums2$中的<code>i</code>个元素与$nums1$中前<code>i</code>个元素进行两两异或后的和的最小值。首先我们可以用函数计算出$state$中含有多少个二进制位$1$，即表示$state$所表示的位图中表示由多少个元素。递推公式如下:<script type="math/tex; mode=display">dp[state] = min(dp[state],dp[state\oplus k] + nums1[count(state)]\oplus nums2[k])</script>这样实际上对状态进行了优化。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            x = x&amp;(x<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>&lt;&lt;n,INT_MAX));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;n); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count(j) != i) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;k))&#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j],dp[i<span class="number">-1</span>][j^(<span class="number">1</span>&lt;&lt;k)] + (nums1[i<span class="number">-1</span>]^nums2[k]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __builtin_popcount(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,INT_MAX);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> mask = <span class="number">1</span>; mask &lt; (<span class="number">1</span>&lt;&lt;n); ++mask)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mask&amp;(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">                    dp[mask] = min(dp[mask],dp[mask^(<span class="number">1</span>&lt;&lt;i)] + (nums1[count(mask)<span class="number">-1</span>]^nums2[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-53&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-53&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 53&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 53&lt;/h1&gt;&lt;p&gt;双周赛的题目质量确实忽高忽低，有时题目非常难，有时又特别简单。本周的双周赛题目真心非常简单，特别是第四题，典型的状态压缩&lt;code&gt;dp&lt;/code&gt;，感觉也就10分钟的节奏就能写出来，反倒是第三题还算稍微有点难度，不过还是手速不够快，思路也确实不够快。反正现在周赛基本上能够百分之百稳定的做出三道题目来。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/05/30/cCKWgdRMpOLZI45.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Kickstart】 Kickstart 2021 roundC</title>
    <link href="http://yoursite.com/2021/05/24/287/"/>
    <id>http://yoursite.com/2021/05/24/287/</id>
    <published>2021-05-24T02:55:24.627Z</published>
    <updated>2021-05-25T03:48:40.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kickstart-2021-roundC"><a href="#kickstart-2021-roundC" class="headerlink" title="kickstart 2021 roundC"></a>kickstart 2021 roundC</h1><p>最喜欢的<code>kcick start</code>来了，但是由于本次<code>round</code>的时候家里有事，正在陪小孩一直也没有时间来参加，所以只能等到比赛结束后来补上了，非常喜欢<code>google kickstart</code>的题目，质量很高又非常有趣。</p><h2 id="a-Smaller-Strings-6pts-9pts"><a href="#a-Smaller-Strings-6pts-9pts" class="headerlink" title="a.Smaller Strings (6pts, 9pts)"></a>a.Smaller Strings (6pts, 9pts)</h2><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/05/24/sOrgvzPI2GpiQMl.png" alt="1"></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ebe5e" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ebe5e</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数位<code>dp</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中要求给定的字符串<code>s</code>，长度为<code>n</code>，给定最大字符k,求所出长度为<code>n</code>的且字典序严格小于<code>s</code>的回文字符串的个数，且构成的回文子符串中所有的字符均小于等于<code>k</code>。</li><li>典型的数位<code>dp</code>.由于是回文字符串，因此我们只需要找到字符串的前半部分即可，因为后半部分与前半部分相同，我们设<code>dp[i]</code>表示字符串长度为<code>i</code>且符合最大字符小于等于<code>k</code>，且字典序严格小于字符串<code>s</code>的前<code>i</code>个字符构成的字符串的个数。<code>limit</code>表示当前字符串<code>s</code>中的前<code>i</code>个字符是否存在字符大于等于<code>k</code>，<code>limit = 1</code>表示不存在不符合要求的字符，<code>limit = 0</code>表示存在大于<code>k</code>的字符。</li><li>我们可以知道递推公式：<br>当我们选择第<code>i</code>个字符时：</li></ol><ul><li>如果当前字符串的前<code>i-1</code>个字符构成的字符串的字典序严格小于<code>s</code>的前<code>i-1</code>个字符构成的字典序，则在第<code>i</code>个字符我们可以在<code>[a,a+k]</code>中我们可以任意取值;</li><li>如果当前字符串的前<code>i-1</code>个字符构成的字符串刚好等于<code>s</code>的前<code>i-1</code>个字符构成的字符串，则第<code>i</code>位我们就只能取严格小于<code>s[i]</code>且小于等于<code>“a&quot;+k</code>的字符;</li></ul><ol><li>最后需要检测一下，如果把整个数组的前半部分全部转换为回文字符串，则此时需要去检查是否字典序严格小于字符串$s$,算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*dp*/</span></span><br><span class="line">    <span class="keyword">int</span> m = (n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> limit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(m);</span><br><span class="line">    dp[<span class="number">0</span>] = min(s[<span class="number">0</span>]-<span class="string">'a'</span>,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] -<span class="string">'a'</span> + <span class="number">1</span> &gt; k)&#123;</span><br><span class="line">            dp[i] = (dp[i<span class="number">-1</span>]*k + k)%mod;</span><br><span class="line">            limit = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = (dp[i<span class="number">-1</span>]*k + limit*(s[i]-<span class="string">'a'</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = dp[m<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(limit)&#123;</span><br><span class="line">        <span class="built_in">string</span> p = s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            p[n<span class="number">-1</span>-i] = p[i] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; s) ans = (ans + <span class="number">1</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans%mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="b-Alien-Generato"><a href="#b-Alien-Generato" class="headerlink" title="b. Alien Generato"></a>b. Alien Generato</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/05/24/XPFzfylCS1mekWO.png" alt="1"></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec1cb" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec1cb</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学计算</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常简单，感觉就是送分题，也就<code>leetcode</code>中等难度的题目。</li><li>我们得出计算公式为:<script type="math/tex; mode=display">g = n*k + \frac{(n-1)*n}{2} \\k = \frac{g-\frac{(n-1)*n}{2}}{n}</script>此时我们只需要判断$g-\frac{(n-1)*n}{2}$是否能够整除$n$即可，且商大于等于<code>1</code>.</li><li>我们很轻易的可以判断$n \le \sqrt{g}$,我们只需要暴力测试所有可能的<code>n</code>即可。算法时间复杂度为$O(lgn)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> g;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;g;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="built_in">sqrt</span>(g)*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= curr; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = i*(i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= g) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>((g-x)%i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="c-Rock-Paper-Scissors"><a href="#c-Rock-Paper-Scissors" class="headerlink" title="c.Rock Paper Scissors"></a>c.Rock Paper Scissors</h2><p><img src="https://i.loli.net/2021/05/24/EBjb4TSs5GKWtun.png" alt></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec28e" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec28e</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常有意思的<code>dp</code>,题目很长，大意就是说两个人玩石头剪刀布的游戏，每个人每轮可以在<code>(r,p,s)</code>分别代表石头、剪刀、布中任意选择一个，石头可以赢剪刀，剪刀可以赢布，布可以赢石头。对方在第<code>i</code>轮出手时，会根据当前已方已经出手的统计次数，来计算出自己选择的概率。假设第<code>i</code>轮时，已方已经出示过的石头、布、剪刀的统计次数分别为$(r_{i},p_{i},s_{i})$,且已知$r_{i} + p_{i} + s_{i} = i$,则在第<code>i+1</code>轮时，对方选择出示石头的概率为$\frac{s_{i}}{i}$，选择布的概率为$\frac{r_{i}}{i}$,选择剪刀的概率为$\frac{p_{i}}{i}$.需要注意的是，在第<code>1</code>轮时，因为没有前面轮次的统计数据，则对方选择出示石头剪刀布的概率均为$\frac{1}{3}$,每天一共需要进行游戏<code>60</code>轮，每天给定每一局赢时获得的分数<code>W</code>，以及平局是获得的分数<code>E</code>，给定一个特定的分数<code>X</code>，求出游戏进行<code>T</code>天后，每天的期望的平均值大于等于<code>X</code>的每天的游戏的出牌方案。</li><li>这个题目很长，初看起来还是非常的复杂，不过仔细思考一下，其实也不算是特别难的。首先需要思考的几点:</li></ol><ul><li>题目要求给定满足期望平均值大于等于<code>X</code>的方案，那么假设我们每天都以期望最大值即最优的方案来出牌，肯定可以满足题意。所以我们就不用再去讨论其他的可能的方案，按照这个思路转化，本题即转换为求出每天期望值最大的出牌方案。</li><li>如果求出期望最大值的方案？实际上应该有多少种组合，我们如果每一轮都按照该轮期望最大值的方案进行出牌是不是一定能够得到最终的期望的最大值？这几个问题是值得深入思考的。</li><li>试想如果我们把所有的出牌的顺序的期望值都求一遍，肯定可以求得期望最大值的方案，则此时的算法时间复杂度为$3^{60}$,肯定会超时，有没有可能更简单的枚举方法可以来求？则此时我们应该想到用动态规划的子状态，我们设<code>dp[r][p][s]</code>表示当前已方已经出示了$r$次石头，$p$次布，$s$次剪刀时的最大期望值，则我们可以发现此时游戏一共进行了$ t = r + p + s$轮，则我们发现最优状态与第<code>t</code>轮的选择有直接关系。</li><li>我们发现最优状态之间存在关系如下：</li><li><ul><li>假设第<code>t</code>轮己方选择的是石头，则第<code>t</code>轮对方选择为剪刀时己方会赢,而此时对方选择为剪刀的概率为$\frac{p}{r+p+s-1}$;对方选择的是石头时，己方会平局，则此时对方选择为石头的概率为$\frac{s}{r+p+s-1}$.因此我们可以推导如下：<script type="math/tex; mode=display">dp[r][p][s] = max(dp[r][p][s],dp[r-1][p][s] + W*\frac{p}{r+p+s-1} + E*\frac{s}{r+p+s-1})</script></li></ul></li><li><ul><li>假设第<code>t</code>轮己方选择的是布，则第<code>t</code>轮对方选择为石头时己方会赢,而此时对方选择为石头的概率为$\frac{s}{r+p+s-1}$;对方选择的是布时，己方会平局，则此时对方选择为布的概率为$\frac{r}{r+p+s-1}$.因此我们可以推导如下：<script type="math/tex; mode=display">dp[r][p][s] = max(dp[r][p][s],dp[r][p-1][s] + W*\frac{s}{r+p+s-1} + E*\frac{r}{r+p+s-1})</script></li></ul></li><li><ul><li>假设第<code>t</code>轮己方选择的是剪刀，则第<code>t</code>轮对方选择为布时己方会赢,而此时对方选择为布的概率为$\frac{r}{r+p+s-1}$;对方选择的是剪刀时，己方会平局，则此时对方选择为剪刀的概率为$\frac{p}{r+p+s-1}$.因此我们可以推导如下：<script type="math/tex; mode=display">dp[r][p][s] = max(dp[r][p][s],dp[r][p][s-1] + W*\frac{r}{r+p+s-1} + E*\frac{p}{r+p+s-1})</script></li></ul></li><li>我们依次遍历所有的可能即可得到在满足$r + p + s = 60$时的最大期望值，并记录下最大期望值时，$(r,p,s)$分别是多少。</li></ul><ol><li>最后还有关键的一步，我们如何找到最优的步骤，此时我们可以设定一个数字$choose[r][p][s]$表示当前选择为$(r,p,s)$时，则此时的最后一轮出示的到底是石头、剪刀还是布。我们分别对相应的计数进行减<code>1</code>，寻找前一个最优解的最后一轮出示的内容，则依次我们即可找到最优解，最后进行倒序即可。感觉<code>google</code>给的分析解答貌似表达式有问题，还是自己琢磨最靠谱。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days,exp_value;</span><br><span class="line">    <span class="keyword">int</span> win,equal;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;days&gt;&gt;exp_value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= days; ++j)&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;win&gt;&gt;equal;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//r &lt; p &lt; s &lt; r</span></span><br><span class="line">        <span class="keyword">double</span> dp[<span class="number">61</span>][<span class="number">61</span>][<span class="number">61</span>]; </span><br><span class="line">        <span class="keyword">char</span> choose[<span class="number">61</span>][<span class="number">61</span>][<span class="number">61</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(choose,<span class="number">0</span>,<span class="keyword">sizeof</span>(choose));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*intial*/</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">double</span>(win + equal)/<span class="number">3</span>;</span><br><span class="line">        choose[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="string">'R'</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">double</span>(win + equal)/<span class="number">3</span>;</span><br><span class="line">        choose[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="string">'P'</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">double</span>(win + equal)/<span class="number">3</span>;</span><br><span class="line">        choose[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="string">'S'</span>;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="keyword">double</span> maxexpr = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*get maxmium expect value of each day*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">60</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= i; ++r)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; r + p &lt;= i; ++p)&#123;</span><br><span class="line">                    <span class="comment">/*all the possible*/</span></span><br><span class="line">                    <span class="keyword">int</span> s = i - r - p;</span><br><span class="line">                    <span class="keyword">double</span> curr = <span class="number">0.0</span>;</span><br><span class="line">                    <span class="comment">// win : (r,s) , euqal (r,r)</span></span><br><span class="line">                    <span class="comment">// we choose "R", friend choose "S" OR "R"</span></span><br><span class="line">                    <span class="keyword">if</span>(r &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        curr = dp[r<span class="number">-1</span>][p][s] + (<span class="keyword">double</span>)win*(p)/(i<span class="number">-1</span>) + (<span class="keyword">double</span>)equal*(s)/(i<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(curr &gt; dp[r][p][s])&#123;</span><br><span class="line">                            dp[r][p][s] = curr;</span><br><span class="line">                            choose[r][p][s] = <span class="string">'R'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// win : (p,r) , euqal (p,p)</span></span><br><span class="line">                    <span class="comment">// we choose "P", friend choose "R" OR "P"</span></span><br><span class="line">                    <span class="keyword">if</span>(p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        curr = dp[r][p<span class="number">-1</span>][s] + (<span class="keyword">double</span>)win*(s)/(i<span class="number">-1</span>) + (<span class="keyword">double</span>)(equal)*(r)/(i<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(curr &gt; dp[r][p][s])&#123;</span><br><span class="line">                            dp[r][p][s] = curr;</span><br><span class="line">                            choose[r][p][s] = <span class="string">'P'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;     </span><br><span class="line">                    <span class="comment">// win : (s,p) , euqal (s,s)</span></span><br><span class="line">                    <span class="comment">// we choose "S", friend choose "P" OR "S"</span></span><br><span class="line">                    <span class="keyword">if</span>(s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        curr = dp[r][p][s<span class="number">-1</span>] + (<span class="keyword">double</span>)win*(r)/(i<span class="number">-1</span>) + (<span class="keyword">double</span>)(equal)*(p)/(i<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(curr &gt; dp[r][p][s])&#123;</span><br><span class="line">                            dp[r][p][s] = curr;</span><br><span class="line">                            choose[r][p][s] = <span class="string">'S'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">60</span> &amp;&amp; dp[r][p][s] &gt; maxexpr)&#123;</span><br><span class="line">                        maxexpr = dp[r][p][s];</span><br><span class="line">                        x = r;</span><br><span class="line">                        y = p;</span><br><span class="line">                        z = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = choose[x][y][z];</span><br><span class="line">            ans.push_back(c);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'R'</span>) x--;;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'P'</span>) y--;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'S'</span>) z--;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(),ans.end());</span><br><span class="line">        <span class="comment">// we just maxium the expect value of dp[60];</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;j&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="d-Binary-Operator"><a href="#d-Binary-Operator" class="headerlink" title="d.Binary Operator"></a>d.Binary Operator</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/05/25/qMp3RSFwnGICbB5.png" alt></p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec290" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec290</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> <code>hash</code></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>最后一题真心挺难，看了很长时间没有看懂题意,Q4全部做出来且测试用例全部通过的全球不到<code>100</code>人。题目大概的意思是可以对题目中给定的表达式进行化简，然后将化简得表达式进行分类，将表达式相同的进行划分为同一类，最终输出每个表达式的分类。</li><li>仔细看一下感觉题目还是非常的复杂，但是最终涉及到需要对表达式进行化简处理，还需要对表达式进行移位和合并计算，刚开始意味非常的麻烦，最后看了大家的解法，各种神奇的解法。</li></ol><ul><li><code>Errichto</code>的解法是用一个非常特殊的<code>hash</code>运算来替代<code>#</code>运算，<code>lucifer1004</code>的解法是把所有可能的运算都计算一遍，如果发现所有可能运算结果都相等，则认为两个表达式相等，否则则认为不相等。确实是暴力出奇迹的解法,如果按照这两种思路来求解表达式的值的话，这题反而没有那么难了，仔细检查了一下答案发现好多人都用这种解法来完成，当然这种解法存在一定的概率导致出现冲突而计算错误，但是实际商概率非常小。</li></ul><ol><li>主要是题目中涉及到这个<code>#</code>的处理，如果完全用表达式的话，则确实不太好处理，反而我们换种思路去测试它的计算结果是否一致来检测两个表达式是否相等。求该表达式求值本身比较简单，利用后缀式即可，利用栈来处理，这个是常规做法。</li><li>官方给的解答是将所有的表达式转化为逆波兰式，然后再通过某种调整的方法对二叉树进行调整，最终判定逆波兰式的二叉树是否相等，不过确实好复杂。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>暴力测试所有可能的运算<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">randoms = [randint(<span class="number">-1000</span>, <span class="number">1000</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_int</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(stdin.readline())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_ints</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> map(int, stdin.readline().split(<span class="string">' '</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y + randoms[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y + randoms[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y + randoms[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_div</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x // (abs(y) + <span class="number">1</span>) + randoms[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_inv_div</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> y // (abs(x) + <span class="number">1</span>) + randoms[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_mod</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x % (abs(y) + <span class="number">1</span>) + randoms[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_inv_mod</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> y % (abs(x) + <span class="number">1</span>) + randoms[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bit_and</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; y + randoms[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bit_or</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x | y + randoms[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bit_xor</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ^ y + randoms[<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">const</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> randoms[<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">only_x</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + randoms[<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">only_y</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> y + randoms[<span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quad_x</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x + y + randoms[<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quad_y</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y * y + randoms[<span class="number">14</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">funcs = [plus, sub, mul, my_div, my_mod, my_inv_div, my_inv_mod,</span><br><span class="line">         bit_and, bit_or, bit_xor, const, only_x, only_y, quad_x, quad_y]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expression</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        self.s = <span class="string">'('</span> + s + <span class="string">')'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        nums = []</span><br><span class="line">        ops = []</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        is_num = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">if</span> is_num:</span><br><span class="line">                    nums.append(curr)</span><br><span class="line">                    is_num = <span class="literal">False</span></span><br><span class="line">                ops.append(<span class="string">'('</span>)</span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">'+*#'</span>:</span><br><span class="line">                <span class="keyword">if</span> is_num:</span><br><span class="line">                    nums.append(curr)</span><br><span class="line">                    is_num = <span class="literal">False</span></span><br><span class="line">                ops.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> is_num:</span><br><span class="line">                    nums.append(curr)</span><br><span class="line">                    is_num = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">while</span> ops[<span class="number">-1</span>] != <span class="string">'('</span>:</span><br><span class="line">                    op = ops.pop()</span><br><span class="line">                    b = nums.pop()</span><br><span class="line">                    a = nums.pop()</span><br><span class="line">                    <span class="keyword">if</span> op == <span class="string">'+'</span>:</span><br><span class="line">                        nums.append(a + b)</span><br><span class="line">                    <span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">                        nums.append(a * b)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        nums.append(func(a, b))</span><br><span class="line">                ops.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_num:</span><br><span class="line">                    curr = <span class="number">0</span></span><br><span class="line">                    is_num = <span class="literal">True</span></span><br><span class="line">                curr = curr * <span class="number">10</span> + int(c)</span><br><span class="line">        <span class="keyword">assert</span>(len(nums) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> funcs:</span><br><span class="line">            a = self.evaluate(func)</span><br><span class="line">            b = other.evaluate(func)</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = read_int()</span><br><span class="line"><span class="keyword">for</span> case_num <span class="keyword">in</span> range(<span class="number">1</span>, t + <span class="number">1</span>):</span><br><span class="line">    n = read_int()</span><br><span class="line">    expressions = [Expression(input()) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    color = [<span class="number">0</span>] * n</span><br><span class="line">    color[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    new_color = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> expressions[i] == expressions[j]:</span><br><span class="line">                color[i] = color[j]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> color[i] == <span class="number">0</span>:</span><br><span class="line">            color[i] = new_color</span><br><span class="line">            new_color += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"Case #<span class="subst">&#123;case_num&#125;</span>: <span class="subst">&#123;<span class="string">' '</span>.join(map(str, color))&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></li><li>利用特殊的<code>hash</code>替代<code>#</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sim template &lt; class c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ris return * this</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dor &gt; debug &amp; operator &lt;&lt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eni(x) sim &gt; typename \</span></span><br><span class="line">  enable_if&lt;<span class="keyword">sizeof</span> dud&lt;c&gt;(<span class="number">0</span>) x <span class="number">1</span>, debug&amp;&gt;::type <span class="keyword">operator</span>&lt;&lt;(c i) &#123;</span><br><span class="line">sim &gt; <span class="class"><span class="keyword">struct</span> <span class="title">rge</span> &#123;</span> c b, e; &#125;;</span><br><span class="line">sim &gt; rge&lt;c&gt; range(c i, c j) &#123; <span class="keyword">return</span> rge&lt;c&gt;&#123;i, j&#125;; &#125;</span><br><span class="line">sim &gt; auto dud(c* x) -&gt; decltype(cerr &lt;&lt; *x, 0);</span><br><span class="line">sim &gt; <span class="function"><span class="keyword">char</span> <span class="title">dud</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">debug</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">~debug() &#123; <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">eni(!=) <span class="built_in">cerr</span> &lt;&lt; boolalpha &lt;&lt; i; ris; &#125;</span><br><span class="line">eni(==) ris &lt;&lt; range(begin(i), end(i)); &#125;</span><br><span class="line">sim, <span class="function">class b <span class="title">dor</span><span class="params">(pair &lt; b, c &gt; d)</span> </span>&#123;</span><br><span class="line">  ris &lt;&lt; <span class="string">"("</span> &lt;&lt; d.first &lt;&lt; <span class="string">", "</span> &lt;&lt; d.second &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sim <span class="title">dor</span><span class="params">(rge&lt;c&gt; d)</span> </span>&#123;</span><br><span class="line">  *<span class="keyword">this</span> &lt;&lt; <span class="string">"["</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = d.b; it != d.e; ++it)</span><br><span class="line">*<span class="keyword">this</span> &lt;&lt; <span class="string">", "</span> + <span class="number">2</span> * (it == d.b) &lt;&lt; *it;</span><br><span class="line">  ris &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">sim <span class="title">dor</span><span class="params">(<span class="keyword">const</span> c&amp;)</span> </span>&#123; ris; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> imie(...) <span class="meta-string">" ["</span> &lt;&lt; #__VA_ARGS__ <span class="meta-string">": "</span> &lt;&lt; (__VA_ARGS__) &lt;&lt; <span class="meta-string">"] "</span></span></span><br><span class="line"><span class="comment">// debug &amp; operator &lt;&lt; (debug &amp; dd, P p) &#123; dd &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")"; return dd; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000050131</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasz</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="number">100594677L</span>L * (a + <span class="number">450617412</span>)) ^ <span class="number">208774486</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">char</span> ope)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ope == <span class="string">'+'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ope == <span class="string">'*'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>) a * b % mod;</span><br><span class="line">&#125;</span><br><span class="line">assert(ope == <span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">return</span> (((<span class="number">337807718L</span>L * hasz(a)) + <span class="number">254452523</span>) ^ ((<span class="number">842188890L</span>L * hasz(b)) + <span class="number">900099649</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_balance</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'('</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">')'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="comment">// debug() &lt;&lt; imie(L) imie(R);</span></span><br><span class="line"><span class="keyword">int</span> bal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">bal += get_balance(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">assert(bal == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(s[L] == <span class="string">'('</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> balance = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = L + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(balance &gt; <span class="number">0</span>) &#123;</span><br><span class="line">balance += get_balance(s[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// past closing bracket</span></span><br><span class="line"><span class="keyword">int</span> a = rec(L + <span class="number">1</span>, i - <span class="number">2</span>); <span class="comment">// this was inside the brackets</span></span><br><span class="line"><span class="keyword">if</span>(i &gt;= R) &#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">assert(s[i] == <span class="string">'#'</span> || s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'*'</span>);</span><br><span class="line"><span class="comment">// debug() &lt;&lt; imie(i+1) imie(R);</span></span><br><span class="line"><span class="keyword">int</span> b = rec(i + <span class="number">1</span>, R);</span><br><span class="line"><span class="keyword">return</span> merge(a, b, s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(L &lt;= R &amp;&amp; <span class="built_in">isdigit</span>(s[L])) &#123;</span><br><span class="line">a = (<span class="number">10L</span>L * a + (s[L] - <span class="string">'0'</span>)) % mod;</span><br><span class="line">L++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(L &gt; R) &#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// debug() &lt;&lt; imie(L);</span></span><br><span class="line">assert(s[L] == <span class="string">'+'</span> || s[L] == <span class="string">'*'</span> || s[L] == <span class="string">'#'</span>);</span><br><span class="line"><span class="keyword">int</span> b = rec(L + <span class="number">1</span>, R);</span><br><span class="line"><span class="keyword">return</span> merge(a, b, s[L]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_case</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">int</span> value = rec(<span class="number">0</span>, (<span class="keyword">int</span>) <span class="built_in">strlen</span>(s) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mapping.find(value) == mapping.end()) &#123;</span><br><span class="line"><span class="keyword">int</span> nxt = mapping.size();</span><br><span class="line">nxt++;</span><br><span class="line">mapping[value] = nxt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d"</span>, mapping[value]);</span><br><span class="line"><span class="comment">// debug() &lt;&lt; imie(value);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= T; z++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d:"</span>, z);</span><br><span class="line">test_case();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kickstart-2021-roundC&quot;&gt;&lt;a href=&quot;#kickstart-2021-roundC&quot; class=&quot;headerlink&quot; title=&quot;kickstart 2021 roundC&quot;&gt;&lt;/a&gt;kickstart 2021 roundC&lt;/h1&gt;&lt;p&gt;最喜欢的&lt;code&gt;kcick start&lt;/code&gt;来了，但是由于本次&lt;code&gt;round&lt;/code&gt;的时候家里有事，正在陪小孩一直也没有时间来参加，所以只能等到比赛结束后来补上了，非常喜欢&lt;code&gt;google kickstart&lt;/code&gt;的题目，质量很高又非常有趣。&lt;/p&gt;&lt;h2 id=&quot;a-Smaller-Strings-6pts-9pts&quot;&gt;&lt;a href=&quot;#a-Smaller-Strings-6pts-9pts&quot; class=&quot;headerlink&quot; title=&quot;a.Smaller Strings (6pts, 9pts)&quot;&gt;&lt;/a&gt;a.Smaller Strings (6pts, 9pts)&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly Contest 242</title>
    <link href="http://yoursite.com/2021/05/23/286/"/>
    <id>http://yoursite.com/2021/05/23/286/</id>
    <published>2021-05-23T08:03:09.306Z</published>
    <updated>2021-05-23T14:59:39.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-weekly-contest-242"><a href="#leetcode-weekly-contest-242" class="headerlink" title="leetcode  weekly contest 242"></a>leetcode  weekly contest 242</h1><p>感觉还是三道题的节奏，无法突破全部<code>ak</code>的怪圈，不到30分钟搞定前三题，前三题感觉基本上就是手速题，谁的手快即可拿到前200名。前三题感觉已经基本上全是套路了，没有任何新意，目前只有第四题还能有一些乐趣。<br><img src="https://i.loli.net/2021/05/23/9DAoZz5HbiQKwmy.png" alt></p><h2 id="5763-哪种连续子字符串更长"><a href="#5763-哪种连续子字符串更长" class="headerlink" title="5763. 哪种连续子字符串更长"></a>5763. 哪种连续子字符串更长</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 <code>s</code>。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 <code>true</code>；否则，返回 <code>false</code>。</p><a id="more"></a><p>例如，<code>s = &quot;110100010&quot;</code> 中，由 1 组成的最长连续子字符串的长度是 2 ，由 0 组成的最长连续子字符串的长度是 3 。<br>注意，如果字符串中不存在 0 ，此时认为由 0 组成的最长连续子字符串的长度是 0 。字符串中不存在 1 的情况也适用此规则。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1101"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">由 <span class="number">1</span> 组成的最长连续子字符串的长度是 <span class="number">2</span>：<span class="string">"1101"</span></span><br><span class="line">由 <span class="number">0</span> 组成的最长连续子字符串的长度是 <span class="number">1</span>：<span class="string">"1101"</span></span><br><span class="line">由 <span class="number">1</span> 组成的子字符串更长，故返回 true 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"111000"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">由 <span class="number">1</span> 组成的最长连续子字符串的长度是 <span class="number">3</span>：<span class="string">"111000"</span></span><br><span class="line">由 <span class="number">0</span> 组成的最长连续子字符串的长度是 <span class="number">3</span>：<span class="string">"111000"</span></span><br><span class="line">由 <span class="number">1</span> 组成的子字符串不比由 <span class="number">0</span> 组成的子字符串长，故返回 false 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"110100010"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">由 <span class="number">1</span> 组成的最长连续子字符串的长度是 <span class="number">2</span>：<span class="string">"110100010"</span></span><br><span class="line">由 <span class="number">0</span> 组成的最长连续子字符串的长度是 <span class="number">3</span>：<span class="string">"110100010"</span></span><br><span class="line">由 <span class="number">1</span> 组成的子字符串不比由 <span class="number">0</span> 组成的子字符串长，故返回 false 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code>不是 ‘0’ 就是 ‘1’</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longer-contiguous-segments-of-ones-than-zeros" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longer-contiguous-segments-of-ones-than-zeros</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力遍历连续的<code>0</code>或者<code>1</code>即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>用二进制编码，遍历所有可能的子集即可。时间复杂度为$O(n)$,空间复杂度为$O(1)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkZeroOnes</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr0 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> curr1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                curr0++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                curr1++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            max0 = max(max0,curr0);</span><br><span class="line">            max1 = max(max1,curr1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max1 &gt; max0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5764-准时到达的列车最小时速"><a href="#5764-准时到达的列车最小时速" class="headerlink" title="5764. 准时到达的列车最小时速"></a>5764. 准时到达的列车最小时速</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个浮点数 <code>hour</code>，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 <code>n</code>趟列车。另给你一个长度为 n 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code>表示第 i 趟列车的行驶距离（单位是千米）。</p><p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p><ul><li>例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。<br>返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。<br>生成的测试用例保证答案不超过 <code>107</code> ，且 <code>hour</code>的 小数点后最多存在两位数字 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], hour = <span class="number">6</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：速度为 <span class="number">1</span> 时：</span><br><span class="line">- 第 <span class="number">1</span> 趟列车运行需要 <span class="number">1</span>/<span class="number">1</span> = <span class="number">1</span> 小时。</span><br><span class="line">- 由于是在整数时间到达，可以立即换乘在第 <span class="number">1</span> 小时发车的列车。第 <span class="number">2</span> 趟列车运行需要 <span class="number">3</span>/<span class="number">1</span> = <span class="number">3</span> 小时。</span><br><span class="line">- 由于是在整数时间到达，可以立即换乘在第 <span class="number">4</span> 小时发车的列车。第 <span class="number">3</span> 趟列车运行需要 <span class="number">2</span>/<span class="number">1</span> = <span class="number">2</span> 小时。</span><br><span class="line">- 你将会恰好在第 <span class="number">6</span> 小时到达。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], hour = <span class="number">2.7</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：速度为 <span class="number">3</span> 时：</span><br><span class="line">- 第 <span class="number">1</span> 趟列车运行需要 <span class="number">1</span>/<span class="number">3</span> = <span class="number">0.33333</span> 小时。</span><br><span class="line">- 由于不是在整数时间到达，故需要等待至第 <span class="number">1</span> 小时才能搭乘列车。第 <span class="number">2</span> 趟列车运行需要 <span class="number">3</span>/<span class="number">3</span> = <span class="number">1</span> 小时。</span><br><span class="line">- 由于是在整数时间到达，可以立即换乘在第 <span class="number">2</span> 小时发车的列车。第 <span class="number">3</span> 趟列车运行需要 <span class="number">2</span>/<span class="number">3</span> = <span class="number">0.66667</span> 小时。</span><br><span class="line">- 你将会在第 <span class="number">2.66667</span> 小时到达。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], hour = <span class="number">1.9</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：不可能准时到达，因为第 <span class="number">3</span> 趟列车最早是在第 <span class="number">2</span> 小时发车。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == dist.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= dist[i] &lt;= 105</code></li><li><code>1 &lt;= hour &lt;= 109</code></li><li><code>hours</code> 中，小数点后最多存在两位数字</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-speed-to-arrive-on-time" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-speed-to-arrive-on-time</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的二分查找套路题目，不需要过多思考，每次给定<code>speed</code>尝试计算所花费的时间，如果所花费的时间能够满足要求，则我们缩小<code>speed</code>再次进行尝试，否则我们则增大<code>speed</code>再次进行尝试。</li><li>本题稍微复杂一点在于需要向上进行取整，我们知道通常的向上或者向下取整的常见办法,<code>x</code>除以<code>y</code>取整:<script type="math/tex; mode=display">floor(\frac{x}{y}) = \frac{x}{y}\\ceil(\frac{x}{y}) = \frac{x+y-1}{y}</script>对于最后一趟列车我们计算花费时间时，则不需要进行取整，直接取浮点数的除法结果即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; dist,<span class="keyword">int</span> speed,<span class="keyword">double</span> hour)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dist.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            tot += (dist[i] + speed<span class="number">-1</span>)/speed;</span><br><span class="line">        &#125;</span><br><span class="line">        tot += (<span class="keyword">double</span>)dist.back()/speed;</span><br><span class="line">        <span class="keyword">if</span>(tot &lt;= hour) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSpeedOnTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dist, <span class="keyword">double</span> hour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(dist,mid,hour))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5765-跳跃游戏-VII"><a href="#5765-跳跃游戏-VII" class="headerlink" title="5765. 跳跃游戏 VII"></a>5765. 跳跃游戏 VII</h2><p>给你一个下标从 0 开始的二进制字符串 s 和两个整数<code>minJump</code> 和 <code>maxJump</code> 。一开始，你在下标 0 处，且该位置的值一定为 ‘0’ 。当同时满足如下条件时，你可以从下标 <code>i</code>移动到下标 <code>j</code>处：</p><ul><li><code>i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1)</code> 且</li><li><code>s[j] == &#39;0&#39;</code>.<br>如果你可以到达 s 的下标<code>s.length - 1</code> 处，请你返回<code>true</code>，否则返回 <code>false</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"011010"</span>, minJump = <span class="number">2</span>, maxJump = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">第一步，从下标 <span class="number">0</span> 移动到下标 <span class="number">3</span> 。</span><br><span class="line">第二步，从下标 <span class="number">3</span> 移动到下标 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"01101110"</span>, <span class="attr">minJump</span> = <span class="number">2</span>, <span class="attr">maxJump</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= s.length &lt;= 105</code></li><li><code>s[i] 要么是 &#39;0&#39; ，要么是 &#39;1&#39;</code></li><li><code>s[0] == &#39;0&#39;</code></li><li><code>1 &lt;= minJump &lt;= maxJump &lt; s.length</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/jump-game-vii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game-vii</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划或者<code>BFS</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>BFS</code>:常规做法，我们可以利用<code>BFS</code>,我们将所有值为<code>0</code>的点全部进入到集合中，每次从队列中取出一个点<code>i</code>时，则我们利用<code>set</code>的二分查找，将所有符合<code>i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1)</code><br>的<code>j</code>从集合中取出，再次进行迭代入队列，这样我们即可遍历所有的可能，时间复杂度为$nlg(n)$,空间复杂度为$O(n)$.</li><li>动态规划:利用前缀和，我们设<code>dp[i]</code>表示<code>i</code>节点是否可以被访问，<code>dp[i] = 0</code>则表示节点<code>i</code>可以被访问，<code>dp[i] = 0</code>表示节点不能被访问，则我们可以利用前缀和，<code>pre[i]</code>表示从<code>[0,i]</code>之间<code>dp[i]</code>的和，则我们可以很快利用前缀和可以查找到区间<code>[i,j]</code>之间是否存在可以被访问的节点。即是否满足:<script type="math/tex; mode=display">pre[j]-pre[i-1] > 0</script>我们知道节点<code>i</code>，可以被前置节点跳到范围为$[max(0,i-maxJump),min(0,i-minJump)]$,则此时我们利用动态规划很快就能完成。时间复杂度为$O(n)$,空间复杂度为$O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li><code>BFS</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> minJump, <span class="keyword">int</span> maxJump)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) cnt.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        qu.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curr == s.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">auto</span> it1 = cnt.lower_bound(curr+minJump);</span><br><span class="line">            <span class="keyword">auto</span> it2 = cnt.upper_bound(curr+maxJump);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = it1; it != it2;)&#123;</span><br><span class="line">                <span class="keyword">int</span> v = *it++;</span><br><span class="line">                qu.push(v);</span><br><span class="line">                cnt.erase(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>DP<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> minJump, <span class="keyword">int</span> maxJump)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        pre[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = max(<span class="number">0</span>,i-maxJump);</span><br><span class="line">            <span class="keyword">int</span> r = i-minJump;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span> &amp;&amp; l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[r+<span class="number">1</span>]-pre[l] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre[i+<span class="number">1</span>] = pre[i] + dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5766-石子游戏-VIII"><a href="#5766-石子游戏-VIII" class="headerlink" title="5766. 石子游戏 VIII"></a>5766. 石子游戏 VIII</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><code>Alice</code> 和 <code>Bob</code> 玩一个游戏，两人轮流操作， <code>Alice</code> 先手 。</p><p>总共有 n 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 大于 1 ，他将执行以下操作：</p><ul><li>选择一个整数 x &gt; 1 ，并且 移除 最左边的 x 个石子。</li><li>将 移除 的石子价值之 和 累加到该玩家的分数中。</li><li>将一个 新的石子 放在最左边，且新石子的值为被移除石子值之和。</li><li>当只剩下 一个 石子时，游戏结束。</li></ul><p><code>Alice</code> 和<code>Bob</code>的 分数之差 为 (<code>Alice</code> 的分数 - <code>Bob</code> 的分数) 。 <code>Alice</code> 的目标是 最大化 分数差，<code>Bob</code>的目标是 最小化 分数差。</p><p>给你一个长度为 n 的整数数组 <code>stones</code>，其中 <code>stones[i]</code> 是 从左边起 第 i 个石子的价值。请你返回在双方都采用 最优 策略的情况下，<code>Alice</code> 和 <code>Bob</code> 的 分数之差 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-5</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：</span><br><span class="line">- Alice 移除最左边的 <span class="number">4</span> 个石子，得分增加 (<span class="number">-1</span>) + <span class="number">2</span> + (<span class="number">-3</span>) + <span class="number">4</span> = <span class="number">2</span> ，并且将一个价值为 <span class="number">2</span> 的石子放在最左边。stones = [<span class="number">2</span>,<span class="number">-5</span>] 。</span><br><span class="line">- Bob 移除最左边的 <span class="number">2</span> 个石子，得分增加 <span class="number">2</span> + (<span class="number">-5</span>) = <span class="number">-3</span> ，并且将一个价值为 <span class="number">-3</span> 的石子放在最左边。stones = [<span class="number">-3</span>] 。</span><br><span class="line">两者分数之差为 <span class="number">2</span> - (<span class="number">-3</span>) = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">7</span>,<span class="number">-6</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">-2</span>,<span class="number">-6</span>]</span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：</span><br><span class="line">- Alice 移除所有石子，得分增加 <span class="number">7</span> + (<span class="number">-6</span>) + <span class="number">5</span> + <span class="number">10</span> + <span class="number">5</span> + (<span class="number">-2</span>) + (<span class="number">-6</span>) = <span class="number">13</span> ，并且将一个价值为 <span class="number">13</span> 的石子放在最左边。stones = [<span class="number">13</span>] 。</span><br><span class="line">两者分数之差为 <span class="number">13</span> - <span class="number">0</span> = <span class="number">13</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">-10</span>,<span class="number">-12</span>]</span><br><span class="line">输出：<span class="number">-22</span></span><br><span class="line">解释：</span><br><span class="line">- Alice 只有一种操作，就是移除所有石子。得分增加 (<span class="number">-10</span>) + (<span class="number">-12</span>) = <span class="number">-22</span> ，并且将一个价值为 <span class="number">-22</span> 的石子放在最左边。stones = [<span class="number">-22</span>] 。</span><br><span class="line">两者分数之差为 (<span class="number">-22</span>) - <span class="number">0</span> = <span class="number">-22</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == stones.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>-104 &lt;= stones[i] &lt;= 104</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stone-game-viii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-viii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目当时确实卡了很长时间，虽然最后的解法非常简单，但是非常喜欢这种带有思考性质的题目，非常不错的题目。</li><li>实际上在做题目时，也观察到了这点，即任意一名玩家操作后，剩余的所有的石子的总价值不变，则我们可以利用前缀和。假设某位选手选择了将<code>i</code>以前的石子进行合并成为了一个石子，则我们不管前<code>i</code>个石子是如何合并的，那么剩余的石子的进行合并后的最优值也是保持不变的，从这点上观察出，我们就应该利用倒序的<code>dp</code>，从<code>n-1</code>往前遍历，关键在于如何定义最优的状态。</li><li>我们定义动态规划的递推公式为<code>dp[i]</code>表示，前<code>i-1</code>个石子已经合并为<code>1</code>个石子，此时<code>alice</code>必须选择从<code>[i,n-1]</code>中选一个索引，然后对石子进行合并，然后交替选择时，<code>Alice</code>此时与<code>bob</code>能获得的最大分数的差值。则此时我们可以知道最优选择:</li></ol><ul><li>要么<code>Alice</code>选择对<code>[i-1,i]</code>进行合并，则此时<code>Bob</code>会在剩余的<code>[i+1,n-1]</code>中进行最优选择，即最大化二者之间的得分的差值，此时<code>dp[i+1]</code>则表示<code>Bob</code>与<code>Alice</code>的得分的最大差值,则此时<code>Alice</code>的得分与<code>bob</code>得分的最大差值应该为:$sum[i] - dp[i+1]$;</li><li>要么<code>Alice</code>在<code>[i+1,n-1]</code>中进行最优选择，则此时它的得分最大差值应该为$dp[i+1]$;</li></ul><ol><li>这一题最疑惑的一点就是<code>Alice</code> 的目标是 最大化 分数差，<code>Bob</code>的目标是 最小化分数差。初始看起来很容易让人觉得就是<code>bob</code>的目标时最小化两者分数的绝对值之差，如果按照这个思路去想就很容易出问题。实际上当<code>Bob</code>进行选择时，他的最优选择也是尽可能的最大化二者之间的得分的差值，这样去理解这个问题的话就会简单很多。</li><li>这个解析可能更容易理解一点<a href="https://leetcode-cn.com/problems/stone-game-viii/solution/zai-qian-zhui-he-shang-dao-xu-dp-by-endl-jxqs/" target="_blank" rel="noopener">dp</a><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameVIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sum[i+<span class="number">1</span>] = sum[i] + stones[i];</span><br><span class="line">        dp[n<span class="number">-1</span>] = sum[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            dp[i] = max(dp[i+<span class="number">1</span>],sum[i+<span class="number">1</span>]-dp[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-weekly-contest-242&quot;&gt;&lt;a href=&quot;#leetcode-weekly-contest-242&quot; class=&quot;headerlink&quot; title=&quot;leetcode  weekly contest 242&quot;&gt;&lt;/a&gt;leetcode  weekly contest 242&lt;/h1&gt;&lt;p&gt;感觉还是三道题的节奏，无法突破全部&lt;code&gt;ak&lt;/code&gt;的怪圈，不到30分钟搞定前三题，前三题感觉基本上就是手速题，谁的手快即可拿到前200名。前三题感觉已经基本上全是套路了，没有任何新意，目前只有第四题还能有一些乐趣。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/05/23/9DAoZz5HbiQKwmy.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5763-哪种连续子字符串更长&quot;&gt;&lt;a href=&quot;#5763-哪种连续子字符串更长&quot; class=&quot;headerlink&quot; title=&quot;5763. 哪种连续子字符串更长&quot;&gt;&lt;/a&gt;5763. 哪种连续子字符串更长&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个二进制字符串 &lt;code&gt;s&lt;/code&gt;。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【生活】记一次失败的面试总结</title>
    <link href="http://yoursite.com/2021/05/19/285/"/>
    <id>http://yoursite.com/2021/05/19/285/</id>
    <published>2021-05-19T02:54:51.735Z</published>
    <updated>2021-05-23T08:02:59.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次失败的面试经历"><a href="#记一次失败的面试经历" class="headerlink" title="记一次失败的面试经历"></a>记一次失败的面试经历</h1><p>最近一直比较忙，每天忙于家里和工作，好久都没有时间来更新日志了，今天刚趁着有时间来好好更新一篇日志，主要想谈谈最近一直影响比较深刻的某外企的面试经历，虽然没有通过，但是我觉得把这段经历去复盘一下，总结其中的不足之处，也是对自己的一种成长，提醒自己在哪方面准备的还不足。</p><h2 id="1-接到通知"><a href="#1-接到通知" class="headerlink" title="1. 接到通知"></a>1. 接到通知</h2><a id="more"></a><p>某日正在上班期间，突然接到一个陌生的上海的电话，告知我因为在某次力扣双周赛排名比较靠前，问我有没有兴趣参加他们公司的面试。当时接到电话的那一刻确实比较诧异，因为很多公司都会介意我目前是在职公务员的经历，然后我跟她反复确认了一下，是否介意我目前是在职公务员的身份，被告知不是很介意，然后就发了面试确认。<br>实话实说我目前是在职公务员，并且已经从工程师的职业生涯已经<code>GAP</code>了好几年了，很多公司基本上看到简历都会直接丢弃的那种状态。不过只是业余爱好，平时工作之余时间也非常多，非常喜欢刷力扣算法题和计算机的四大的公开课。平时工作之余因为时间确实较多，心想反正闲着也是闲着，不能把这些时间浪费掉，纯粹是出于兴趣的目的来刷算法题目和学习这些专业课程的，一方面是把这些时间花在学习上总比浪费在抖音和游戏上强的多；另一方面，说句实话这些课程真的是非常非常有意思，纯粹是激起了我这种有两娃的中年男人的学习兴趣。</p><h2 id="2-笔试过程"><a href="#2-笔试过程" class="headerlink" title="2. 笔试过程"></a>2. 笔试过程</h2><p>跟<code>HR</code>确认邮件后，很快就收到了<code>first step</code>的<code>online assignment</code>.查看了一下，题目是在<code>hackrank</code>上，用<code>c++</code>设计一道系统设计题目，需要通过所有的测试用例。平时周一到周五确实没有时间，只能乘着周末来完成这个题目。大概在周日的时候，到旁边大学的自习室，打开了题目，从开始构思系统设计，到通过全部测试用例差不多花费了2个多小时，虽然最终的代码量再精简一下，估计也就不到<code>200</code>行就能完成。虽然花费了精力，但是完成提交<code>online assignment</code>，我觉得题目本身来说非常有意思，这个系统设计题目出的还是相当有水平的。题目大意如下：</p><blockquote><p>要求设计一个由多个<code>unit</code>连接组成的系统，该系统有多个输入，只有一个输出，通过每次输入不同的<code>input</code>来给出系统的最终输出。每个<code>unit</code>也可能有多个输入<code>input</code>，但是只有一个输出<code>output</code>，每个<code>unit</code>会执行某种运算，运算操作可能是<code>+，-，/，*，异或，与，或，非</code>等等,运算操作的数即为该<code>unit</code>的输入<code>input</code>，最终运算的结果即通过输出<code>output</code>获取。关键的一点在于，必须所有的<code>unit</code>的输入上<code>input</code>上都有合法的输入参数时，<code>unit</code>的<code>output</code>才会有输出。需要提示的是系统的<code>input</code>可能会连接多个<code>unit</code>的输入，一个<code>unit</code>的<code>output</code>可能会连接多个<code>unit</code>的<code>input</code>。题目给出了给出了所有解析输入的函数，要求利用这些函数来解析输入的参数。</p></blockquote><p>解题思路如下：</p><ul><li>本题实际就是一个有向图的遍历的问题，我们将每个的<code>unit</code>都看作为图中一个特殊的节点。图中的不同的<code>unit</code>的输出与<code>unit</code>的输入的连接即可看作为两个节点之间的边。我们每次遇到系统不同的<code>input</code>输入时，则我们会对相连接的<code>unit</code>的进行运算，并将运算的结果向后传递给下一个<code>unit</code>，如果我们检查传递后的<code>unit</code>的所有的<code>input</code>的输入状态是否都是合法，如果合法，则我们进行该<code>unit</code>的运算，并将输出结果再继续向下一个节点进行传递，直到最终由系统的<code>output</code>有输出，此时我们打印出系统的输出即可。</li><li><p>系统中特别需要注意的一点是一个<code>unit</code>的某个<code>input</code>只能连接一个<code>unit</code>的输出,但是一个<code>unit</code>的输出<code>output</code>,可以连接到多个<code>unit</code>的输入端口<code>input</code>。此时我们就需要记载每个<code>unit</code>的输出<code>output</code>连接了哪些<code>unit</code>的<code>input</code>;但是我们不需要记载每个<code>unit</code>的输入连接了哪个<code>unit</code>的输出。每个<code>unit</code>定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*unit define*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unit</span>&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// unit name</span></span><br><span class="line">  UNIT_TYPE type;   <span class="comment">// unit type</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; valid; <span class="comment">// every input port state</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input;  <span class="comment">// every input value</span></span><br><span class="line">  <span class="keyword">int</span> output;         <span class="comment">// output</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;Edge&gt; out;   <span class="comment">// output link to the input of the next unit</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*edge link*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> us; <span class="comment">// the next unit name</span></span><br><span class="line">    <span class="keyword">int</span> in;         <span class="comment">// input port of the unit   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>同时我们需要对整个系统的<code>input</code>和<code>output</code>也做抽象成为特殊的<code>unit</code>，每个<code>input</code>端口表示为只有一个输入和输出的<code>unit</code>，它的运算即为输出等于输入，系统的<code>output</code>端口表示为只有一个输入和输出的<code>unit</code>，它的运算也为输出等于输入，这样我们即可把整个系统全部抽象为<code>unit</code>，不同的<code>input</code>进入时，相当于有向图中的部分节点的值向它的相邻节点进行值传递，我们依次即可计算出图中中所有的<code>unit</code>的输出，最终能够计算出系统的<code>output</code>.实际即是一个非常简单的<code>bfs</code>即可完成，时间复杂度也即为<code>O(n)</code>即可。按照这个思路很快就完成了代码的编写，不过期间<code>debug</code>花了不少时间才完成。</p><h2 id="2-准备电话面试"><a href="#2-准备电话面试" class="headerlink" title="2. 准备电话面试"></a>2. 准备电话面试</h2><p>笔试很快就完成了，然后就给<code>HR</code>发了<code>email</code>确认了笔试已经完成，后面<code>HR</code>告知<code>online assignment</code>已经通过了，就需要进入<code>second step</code>的<code>phone interview</code>了，并且明确告知需要用英文进行，想想自己刚刚过六级的水平，口语搓的一比，并且在体制内也不会有用口语的地方，那也只能硬着头皮硬上了。办法总比困难多，那就开始练习口语了，不过确实不太好练习，因为周围也没有几个口语特别好的；另一方面即使口语非常好的，但是也没有时间来陪我模拟面试，大家基本上都有家庭了。<br>我想办法总比困难多，这就需要发挥自己的主观能动性了，分别从四个方面着手来准备面试：</p></li><li>从该公司的官方网站上查找一下相关公司的信息，大概需要了解一下公司的<code>backgroud</code>和<code>interview detail</code>，<code>job description</code>,大概对公司的基本信息和招聘职位的信息做一下基本的了解，同时也在<code>linked in</code>上找了该公司的员工的部分个人背景简介和工作内容的详细介绍，以上这些都是对基本信息的搜集，能够快速的对公司的基本信息和职位信息做一个基本的了解。</li><li>从<code>youtube</code>上快速的找一些<code>software engineer interview tips</code>诸如此类的视频，以及一些部分<code>up</code>主的<code>online mock coding interview</code>的面试视频来学习观看，一方面通过这些视频的学习了解<code>phone technical interview</code>的基本流程，另一方面能够顺便对部分专有的专业英语术语能够熟悉下，毕竟<code>CS</code>专业的英语专业术语非常多，同时自己也在默默的模仿一下。</li><li>在网上找了一个口语较好的<code>师弟</code>来进行练习，大概练习了有两三次，可惜期间<code>师弟parterner</code>有事中途退场了，我只能自己找了，在网上搜了几个还不错的<code>APP</code>，都能够付费进行口语练习。第一次拨通跟老外进行口语练习，还是蛮紧张的，不过想想就是要脸皮厚点，不过大部分国外人还是非常热心的，反正大部分口语说错了，他们大概也能懂，并且跟其中一个叫<code>ALEX</code>的老外还混熟了，基本上都找他瞎聊，感觉蛮开心的。不过其中<code>HR</code>问我要了一份英文简历，我也只能硬着头皮把我那个本身就写的非常烂的简历又用<code>tex</code>重新弄了一份英文版本的，不过写作英语时，发现国外的<code>Grammarly</code>的软件真心好用，如果需要写书面英语的话强烈推荐。</li><li>其余就是针对<code>whitepaper coding</code>和<code>C++ concept detail</code>的学习了，这个是本次面试中最大的失误，太注重在线<code>coding</code>能力了，反而忽视了对<code>c++ basic concept</code>的学习了，在<code>binary search</code>平台上练习了大量的算法题，感觉如果是靠算法题的话，我基本上可以百分之九十的题目都能秒杀。不过也是因为干公务员太长时间了，没有过多去关注实际工程中需要应用的技术细节和语言的语法细节方面了，另一方面也确实没有多少可以实践的地方。虽然自己尝试在<code>hackrank</code>上面去练习<code>c++</code>的专题训练，同时通过网上的部分面经来学习一些常见的<code>C++</code>的问题了，这方面是此次面试的最大失误，毕竟实际工程中算法其实并没有那么重要，实际工程中可能更加关注技术细节和代码落地，比如最基本的现程同步之类的，结果就是在这些细节的<code>concept</code>上失败了。<h2 id="3-电话面试过程"><a href="#3-电话面试过程" class="headerlink" title="3. 电话面试过程"></a>3. 电话面试过程</h2>电话面试邮件通知的时间大概是在周五的下午四点钟，于是早早的提前周五下午请好假，回家打开电脑，打开<code>hackerRank</code>,因为之前<code>HR</code>通知是在<code>hackerRank</code>上面进行白板面试，所有的题目都会在<code>hackerRank codepair</code>上出现，早早打开<code>hr</code>通知的链接，然后等在电脑前，四点到了，发现怎么还没有电话进来，后来又等了<code>10</code>分钟，还米有电话进来，以为面试取消了，都准备去洗洗睡了。结果差不多到了<code>4</code>点<code>15</code>了，手机显示上海的陌生号码打过来了，接听后，一位很轻的小哥告诉我是本次的面试官，说抱歉刚才因为有会议所以才迟到了，耳测小哥年龄应该在25~30岁之间。<br>我以为会有简单的自我介绍或者基本的关于过往的项目经历的简介之类的，没想到面试官上来就说开始吧，然后就开始了一堆关于<code>C++</code>的基础知识的细节和系统基础知识的考问，感觉之前准备的部分<code>behavior problem</code>都白准备了。下面是对部分详细问题的描述<h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">what<span class="symbol">'s</span>  the difference <span class="keyword">of</span> stack memory <span class="keyword">and</span> heap memory ?</span><br></pre></td></tr></table></figure></li><li>这个问题用中文还是蛮简单，用英文确实有点麻烦了，就用用举例的方法简单说了一下。定义静态数组的空间都是使用栈内存的，每次进行函数调用的时候，也是需要将参数压入栈，利用<code>stackmachine</code>,实际上如果要利用栈空间，大都是由在编译阶段编译器会直接定义好栈空间的分配；定义动态数组时则使用的是<code>heap memory</code>,比如我们常见的<code>malloc</code>,<code>new</code>的操作，则是在<code>heap</code>中进行申请。目前的操作系统中，每一个线程都会分配一个独立的<code>stack</code>,<code>stack</code>的大小则可以由现程初始化时进行指定，而<code>heap</code>则是由操作系统统一进行管理，每次申请动态内存时，操作系统则会在空余的<code>heap</code>中分配一块，常见的<code>heap</code>分配的算法有<code>first fit</code>,<code>best fit</code>等常见的分配算法。<h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">what<span class="symbol">'s</span> the usage <span class="keyword">of</span> memory pool?</span><br></pre></td></tr></table></figure></li><li><code>memory pool</code>常用内作为缓存，由于我们需要一些缓存来存储一些关键信息，如果我们每次需要使用内存时，都直接用<code>malloc,new</code>之类得动态内存申请，必然会造成很大一部分时间得开销，因为在实际得操作系统中<code>malloc</code>之类得开销非常耗费时间得，因为我们可以在系统初始化化即申请一大块动态内存，然后后面如果需要用到存储时，则从这一大块<code>memory pool</code>中取出一小块即可，避免了系统过多次得<code>malloc</code>操作，从而造成系统不必要得开销。<h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C++ smart pointer:</span><br><span class="line">what<span class="symbol">'s</span> the difference <span class="keyword">of</span> unique_ptr <span class="keyword">and</span> shared_ptr?</span><br><span class="line">why we <span class="keyword">use</span> make_shared ?</span><br></pre></td></tr></table></figure></li><li>常见的C++智能指针得问题。<code>unique_ptr</code>和<code>shared_ptr</code>主要关注内部实现即可知道他们的内部的原理和不同，这个基本上可以通过阅读智能指针的源代码即可了解其中的不同。<h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c++ <span class="keyword">template</span>:</span><br></pre></td></tr></table></figure></li><li>这个问题直接卒掉，C++的模板编程非常方便，这个也是C++的高级特性的一个核心，说实话已经很长时间没有用模板编程了，还是好好的去学习学习<code>haskell</code>之类的语言，好好的学习一下<code>lisp</code>之类的高级语言，或者学习学习<code>SCIP</code>从而对这些语言的高级特性能够一劳永逸的去解决。<h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">what<span class="symbol">'s</span> the useage <span class="keyword">of</span> conditional variables ?</span><br></pre></td></tr></table></figure></li><li>C++的<code>conditional variables</code>主要用来作为线程同步和并发。<h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> oriented question:</span><br><span class="line">c++ <span class="function"><span class="keyword">constructor</span> &amp; <span class="title">destructor</span>?</span></span><br><span class="line"><span class="function"><span class="title">c</span>++ <span class="title">Base</span> <span class="title">Object</span>?</span></span><br></pre></td></tr></table></figure></li><li>题目中定义了函数的构造函数和析构函数，但是并没有对函数进行构造函数和虚构函数进行实例化，最终会导致我们在进行初始化一个类的变量时，就会报错<code>undefined reference</code>。问了一个关于C++基类的问题，这个问题确实已经很长时间没有关注过C++基类的用法。<h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coding:</span><br><span class="line"><span class="built_in">write</span> <span class="keyword">a</span> <span class="keyword">string</span> <span class="built_in">split</span> <span class="function"><span class="keyword">function</span> <span class="title">using</span> <span class="title">c</span>++.</span></span><br></pre></td></tr></table></figure></li><li>给了一个超级简单的<code>coding</code>题目，就是用<code>c++</code>写出<code>split</code>函数，感觉可能面试官不想再继续面了，可能就随便给了一个题目打发人的意思。刚开始明显看他还准备问我<code>dynamic programming</code>的题目，后面可能发现对我不敢兴趣了，就想快点结束面试的意思。差不多不到2分钟就写出了一个无<code>bug</code>的代码，反正是非常的简单。<h2 id="4-面试总结"><a href="#4-面试总结" class="headerlink" title="4. 面试总结"></a>4. 面试总结</h2>总得来说面试得不是非常好，许多基础知识都忘记得差不多了，但是我觉得通过自己练习算法题，还是得到了不少的面试机会，至少这样能感受到自己的努力有一些回报。还是需要多加努力学习，因为我知道像我这种没有背景没有关系得人什么都需要靠自己，在这个社会上立足，只有越努力才能越自由。<br>努力挣扎，虽然中年人生活不易，但是一定不要放弃自己得努力，依次诫勉，来告诫一个不敢轻易松懈得中年人。俗话说，“君子不立于危墙之下”，如果自己对周围的环境不爽，那么要么尝试着去改变这个环境，要么就努力脱离这个让你变得糟糕得环境，不要一味的抱怨环境和抱怨人生，尽快让自己进入一个上升的正循环的通道。</li><li>下一步的计划，是需要对基础知识进行恶补，虽然<code>C++</code>的不是一门特别容易上手的语言，但是里面非常多的语言特性是非常值得学习的，还是自己的基础不够扎实。学习的书单目前基本如下：</li><li>《the little scheme》</li><li>《MIT SCIP》</li><li>《C++ 深度探索内存模型》</li><li>《C++ 模板元编程》</li><li>《C++ 多线程编程》</li><li>《C++ 智能指针的实现》</li><li>《C++ 对象池的实现》<h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;记一次失败的面试经历&quot;&gt;&lt;a href=&quot;#记一次失败的面试经历&quot; class=&quot;headerlink&quot; title=&quot;记一次失败的面试经历&quot;&gt;&lt;/a&gt;记一次失败的面试经历&lt;/h1&gt;&lt;p&gt;最近一直比较忙，每天忙于家里和工作，好久都没有时间来更新日志了，今天刚趁着有时间来好好更新一篇日志，主要想谈谈最近一直影响比较深刻的某外企的面试经历，虽然没有通过，但是我觉得把这段经历去复盘一下，总结其中的不足之处，也是对自己的一种成长，提醒自己在哪方面准备的还不足。&lt;/p&gt;&lt;h2 id=&quot;1-接到通知&quot;&gt;&lt;a href=&quot;#1-接到通知&quot; class=&quot;headerlink&quot; title=&quot;1. 接到通知&quot;&gt;&lt;/a&gt;1. 接到通知&lt;/h2&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="职场" scheme="http://yoursite.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Weekly Contest 241</title>
    <link href="http://yoursite.com/2021/05/16/284/"/>
    <id>http://yoursite.com/2021/05/16/284/</id>
    <published>2021-05-16T05:18:56.989Z</published>
    <updated>2021-05-20T12:18:41.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-weekly-contest-241"><a href="#leetcode-weekly-contest-241" class="headerlink" title="leetcode  weekly contest 241"></a>leetcode  weekly contest 241</h1><p>最后一题也没有时间想了，还是三道题的节奏，前三题确实没啥难度的题目。<br><img src="https://i.loli.net/2021/05/16/f51inxEeqLoQ7TN.png" alt></p><h2 id="5759-找出所有子集的异或总和再求和"><a href="#5759-找出所有子集的异或总和再求和" class="headerlink" title="5759. 找出所有子集的异或总和再求和"></a>5759. 找出所有子集的异或总和再求和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个数组的 异或总和 定义为数组中所有元素按位 <code>XOR</code>的结果；如果数组为 空 ，则异或总和为 0 。</p><p>例如，数组 <code>[2,5,6]</code> 的 异或总和 为 <code>2 XOR 5 XOR 6 = 1</code> 。<br>给你一个数组 nums ，请你求出 <code>nums</code>中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p><a id="more"></a><p>注意：在本题中，元素 相同 的不同子集应 多次 计数。</p><p>数组 <code>a</code> 是数组 <code>b</code> 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">3</span>] 共有 <span class="number">4</span> 个子集：</span><br><span class="line">- 空子集的异或总和是 <span class="number">0</span> 。</span><br><span class="line">- [<span class="number">1</span>] 的异或总和为 <span class="number">1</span> 。</span><br><span class="line">- [<span class="number">3</span>] 的异或总和为 <span class="number">3</span> 。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">3</span>] 的异或总和为 <span class="number">1</span> XOR <span class="number">3</span> = <span class="number">2</span> 。</span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">2</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">解释：[<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>] 共有 <span class="number">8</span> 个子集：</span><br><span class="line">- 空子集的异或总和是 <span class="number">0</span> 。</span><br><span class="line">- [<span class="number">5</span>] 的异或总和为 <span class="number">5</span> 。</span><br><span class="line">- [<span class="number">1</span>] 的异或总和为 <span class="number">1</span> 。</span><br><span class="line">- [<span class="number">6</span>] 的异或总和为 <span class="number">6</span> 。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">1</span>] 的异或总和为 <span class="number">5</span> XOR <span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">6</span>] 的异或总和为 <span class="number">5</span> XOR <span class="number">6</span> = <span class="number">3</span> 。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">6</span>] 的异或总和为 <span class="number">1</span> XOR <span class="number">6</span> = <span class="number">7</span> 。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>] 的异或总和为 <span class="number">5</span> XOR <span class="number">1</span> XOR <span class="number">6</span> = <span class="number">2</span> 。</span><br><span class="line"><span class="number">0</span> + <span class="number">5</span> + <span class="number">1</span> + <span class="number">6</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">7</span> + <span class="number">2</span> = <span class="number">28</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">480</span></span><br><span class="line">解释：每个子集的全部异或总和值之和为 <span class="number">480</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 12</code></li><li><code>1 &lt;= nums[i] &lt;= 20</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力遍历所有子集即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>用二进制编码，遍历所有可能的子集即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i)&#123;</span><br><span class="line">                    curr = curr^nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5760-构成交替字符串需要的最小交换次数"><a href="#5760-构成交替字符串需要的最小交换次数" class="headerlink" title="5760. 构成交替字符串需要的最小交换次数"></a>5760. 构成交替字符串需要的最小交换次数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 <code>s</code>，现需要将其转化为一个 交替字符串 。请你计算并返回转化所需的 最小 字符交换次数，如果无法完成转化，返回 -1 。</p><p>交替字符串 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 <code>&quot;010&quot;</code> 和 <code>&quot;1010&quot;</code>属于交替字符串，但 <code>&quot;0100&quot;</code>不是。</p><p>任意两个字符都可以进行交换，不必相邻 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"111000"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：交换位置 <span class="number">1</span> 和 <span class="number">4</span>：<span class="string">"111000"</span> -&gt; <span class="string">"101010"</span> ，字符串变为交替字符串。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"010"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串已经是交替字符串了，不需要交换。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1110"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i] 的值为 &#39;0&#39; 或 &#39;1&#39;</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力统计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们判断是否可以交换构成交替，如果字符串的长度为偶数，则我们判断字符中<code>1</code>的个数和<code>0</code>的个数是否相等，如果不相等则不可能构成交替，直接返回<code>-1</code>;如果字符串的长度为奇数，则我们判断字符串中<code>1</code>的个数和<code>0</code>的个数的差的绝对值是否为<code>1</code>，如果不为<code>1</code>，则直接返回<code>-1</code>。</li><li>我们在可以满足交换的条件下，则去求最小的交换次数，如果为字符串的长度为偶数，则我们考虑是将奇数位全部置为<code>1</code>的代价最小还是将奇数位全部置为<code>0</code>的代价最小，此时我们可以求出奇数位中<code>0</code>的个数为$cnt0$，则此时最小的交换值应该为$min(cnt0,n/2-cnt0)$;如果字符串中<code>1</code>的个数大于<code>0</code>的个数，则此时我们考虑的是将奇数位中的<code>0</code>全部替换为<code>1</code>，此时应该返回$cnt0$；如果字符串中<code>0</code>的个数大于<code>1</code>的个数，则此时我们考虑的是将奇数位中的<code>1</code>全部替换为<code>0</code>，此时我们应该返回$(n+1)/2 - cnt0$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) zero++;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) one++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="built_in">abs</span>(one-zero)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) cnt0++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zero == one)&#123;</span><br><span class="line">            ans = min(cnt0,n/<span class="number">2</span>-cnt0);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(one &gt; zero)&#123;</span><br><span class="line">                ans = cnt0;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = (n+<span class="number">1</span>)/<span class="number">2</span> - cnt0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5761-找出和为指定值的下标对"><a href="#5761-找出和为指定值的下标对" class="headerlink" title="5761. 找出和为指定值的下标对"></a>5761. 找出和为指定值的下标对</h2><p>给你两个整数数组 nums1 和 nums2 ，请你实现一个支持下述两类查询的数据结构：</p><p>累加 ，将一个正整数加到 nums2 中指定下标对应元素上。<br>计数 ，统计满足 <code>nums1[i] + nums2[j]</code>等于指定值的下标对 <code>(i, j)</code>数目<code>（0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length）</code>。<br>实现 FindSumPairs 类：<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FindSumPairs(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) 使用整数数组 nums1 和 nums2 初始化 FindSumPairs 对象。</span><br><span class="line"><span class="type">void</span> <span class="keyword">add</span>(<span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> val) 将 val 加到 nums2[<span class="keyword">index</span>] 上，即，执行 nums2[<span class="keyword">index</span>] += val 。</span><br><span class="line"><span class="type">int</span> count(<span class="type">int</span> tot) 返回满足 nums1[i] + nums2[j] == tot 的下标对 (i, j) 数目。</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"FindSumPairs"</span>, <span class="string">"count"</span>, <span class="string">"add"</span>, <span class="string">"count"</span>, <span class="string">"count"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"count"</span>]</span><br><span class="line">[[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]], [<span class="number">7</span>], [<span class="number">3</span>, <span class="number">2</span>], [<span class="number">8</span>], [<span class="number">4</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">7</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">8</span>, null, <span class="number">2</span>, <span class="number">1</span>, null, null, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">FindSumPairs findSumPairs = new FindSumPairs([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]);</span><br><span class="line">findSumPairs.count(<span class="number">7</span>);  <span class="comment">// 返回 8 ; 下标对 (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) 满足 2 + 5 = 7 ，下标对 (5,1), (5,5) 满足 3 + 4 = 7</span></span><br><span class="line">findSumPairs.add(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 此时 nums2 = [1,4,5,4,5,4]</span></span><br><span class="line">findSumPairs.count(<span class="number">8</span>);  <span class="comment">// 返回 2 ；下标对 (5,2), (5,4) 满足 3 + 5 = 8</span></span><br><span class="line">findSumPairs.count(<span class="number">4</span>);  <span class="comment">// 返回 1 ；下标对 (5,0) 满足 3 + 1 = 4</span></span><br><span class="line">findSumPairs.add(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 此时 nums2 = [2,4,5,4,5,4]</span></span><br><span class="line">findSumPairs.add(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 此时 nums2 = [2,5,5,4,5,4]</span></span><br><span class="line">findSumPairs.count(<span class="number">7</span>);  <span class="comment">// 返回 11 ；下标对 (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) 满足 2 + 5 = 7 ，下标对 (5,3), (5,5) 满足 3 + 4 = 7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length &lt;= 1000</code></li><li><code>1 &lt;= nums2.length &lt;= 105</code></li><li><code>1 &lt;= nums1[i] &lt;= 109</code></li><li><code>1 &lt;= nums2[i] &lt;= 105</code></li><li><code>0 &lt;= index &lt; nums2.length</code></li><li><code>1 &lt;= val &lt;= 105</code></li><li><code>1 &lt;= tot &lt;= 109</code></li><li>最多调用 <code>add</code>和 <code>count</code> 函数各 <code>1000</code>次</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/finding-pairs-with-a-certain-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/finding-pairs-with-a-certain-sum</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接模拟 + hash</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目的关键在于看到一个点，<code>nums1</code>的长度为<code>1000</code>以下，此时我们即可使用暴力<code>hash</code>.每次用<code>hash table</code>统计<code>nums2</code>数组中每个元素的个数，每次进行查询下，我们遍历<code>nums1</code>中的所有元素，然后在<code>hashtable</code>中查询$tot-nums1[i]$的个数，就是暴力<code>hash</code>即可，不需要用任何技巧。</li><li>每次对<code>nums2</code>中的元素进行更新时，我们直接更新<code>hash table</code>即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindSumPairs</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FindSumPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        arr1 = nums1;</span><br><span class="line">        arr2 = nums2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.size(); ++i) cnt[nums2[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        cnt[arr2[index]]--;</span><br><span class="line">        arr2[index] += val;</span><br><span class="line">        cnt[arr2[index]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(tot-arr1[i]))&#123;</span><br><span class="line">                ans += cnt[tot-arr1[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindSumPairs object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindSumPairs* obj = new FindSumPairs(nums1, nums2);</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;count(tot);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5762-恰有-K-根木棍可以看到的排列数目"><a href="#5762-恰有-K-根木棍可以看到的排列数目" class="headerlink" title="5762. 恰有 K 根木棍可以看到的排列数目"></a>5762. 恰有 K 根木棍可以看到的排列数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有 n 根长度互不相同的木棍，长度为从 <code>1</code> 到 <code>n</code>的整数。请你将这些木棍排成一排，并满足从左侧 可以看到 恰好<code>k</code> 根木棍。从左侧 可以看到 木棍的前提是这个木棍的 左侧 不存在比它 更长的 木棍。</p><ul><li>例如，如果木棍排列为 <code>[1,3,2,5,4]</code>，那么从左侧可以看到的就是长度分别为 <code>1、3 、5</code>的木棍。<br>给你 <code>n</code> 和 <code>k</code> ，返回符合题目要求的排列 数目 。由于答案可能很大，请返回对 <code>109 + 7</code> 取余 的结果。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 和 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 是仅有的能满足恰好 <span class="number">2</span> 根木棍可以看到的排列。</span><br><span class="line">可以看到的木棍已经用粗体+斜体标识。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 是唯一一种能满足全部 <span class="number">5</span> 根木棍可以看到的排列。</span><br><span class="line">可以看到的木棍已经用粗体+斜体标识。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">20</span>, k = <span class="number">11</span></span><br><span class="line">输出：<span class="number">647427950</span></span><br><span class="line">解释：总共有 <span class="number">647427950</span> (mod <span class="number">109</span> + <span class="number">7</span>) 种能满足恰好有 <span class="number">11</span> 根木棍可以看到的排列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目的动态规划有点意思，因为一直想着从小往大进行增长元素，却发现很难推出递推公式。我们设<code>dp[i][j]</code>表示从后<code>i</code>个元素$[n-i+1,n-i+2,n-i+3,…,n]$中选出组成能够看到<code>j</code>个棍子的方案数目。此时我们如果假如一个更小的元素$n-i$，如果我们将$[n-i]$放在序列中的第一个元素，则此时我们再从$[n-i+1,n-i+2,n-i+3,…,n]$选出<code>j-1</code>个元素，满足能够看到<code>j-1</code>个棍子即可，因为此时$n-i$为序列中的最小元素，$n-i$一定会被看到，则此时:<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1]</script>如果我们第一个元素不为$n-i$,则我们可以将$n-i$放到后面的<code>i-1</code>个元素中的任意一个元素后面，它都不可见，则此时的方案数应该为:<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j]*(i-1)</script>综上我们可以得到如下推论:<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1] + dp[i-1][j]*(i-1)</script></li><li>仔细查了以下考斯林数的定义，基本上就是等于第一类斯特林数的推论应用，可以直接看到该公式是利用数学归纳法来证明出来的。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rearrangeSticks</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]*(i<span class="number">-1</span>))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-weekly-contest-241&quot;&gt;&lt;a href=&quot;#leetcode-weekly-contest-241&quot; class=&quot;headerlink&quot; title=&quot;leetcode  weekly contest 241&quot;&gt;&lt;/a&gt;leetcode  weekly contest 241&lt;/h1&gt;&lt;p&gt;最后一题也没有时间想了，还是三道题的节奏，前三题确实没啥难度的题目。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/05/16/f51inxEeqLoQ7TN.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5759-找出所有子集的异或总和再求和&quot;&gt;&lt;a href=&quot;#5759-找出所有子集的异或总和再求和&quot; class=&quot;headerlink&quot; title=&quot;5759. 找出所有子集的异或总和再求和&quot;&gt;&lt;/a&gt;5759. 找出所有子集的异或总和再求和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个数组的 异或总和 定义为数组中所有元素按位 &lt;code&gt;XOR&lt;/code&gt;的结果；如果数组为 空 ，则异或总和为 0 。&lt;/p&gt;&lt;p&gt;例如，数组 &lt;code&gt;[2,5,6]&lt;/code&gt; 的 异或总和 为 &lt;code&gt;2 XOR 5 XOR 6 = 1&lt;/code&gt; 。&lt;br&gt;给你一个数组 nums ，请你求出 &lt;code&gt;nums&lt;/code&gt;中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 52</title>
    <link href="http://yoursite.com/2021/05/15/283/"/>
    <id>http://yoursite.com/2021/05/15/283/</id>
    <published>2021-05-15T15:47:09.226Z</published>
    <updated>2021-05-22T12:58:15.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-52"><a href="#leetcode-biweekly-contest-52" class="headerlink" title="leetcode  biweekly contest 52"></a>leetcode  biweekly contest 52</h1><p>最近周赛题目质量越来越不稳定了，最后一题就是稍微麻烦一点的数学题目。<br><img src="https://i.loli.net/2021/05/16/TQS2JViKeLsdtoI.png" alt></p><h2 id="5742-将句子排序"><a href="#5742-将句子排序" class="headerlink" title="5742. 将句子排序"></a>5742. 将句子排序</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个 句子 指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。<br>我们可以给一个句子添加 从 1 开始的单词位置索引 ，并且将句子中所有单词 打乱顺序 。<br>比方说，句子 <code>&quot;This is a sentence&quot;</code> 可以被打乱顺序得到<code>&quot;sentence4 a3 is2 This1&quot; 或者 &quot;is2 sentence4 This1 a3&quot;</code> 。<br>给你一个 打乱顺序 的句子 s ，它包含的单词不超过 9 个，请你重新构造并得到原本顺序的句子。</p><a id="more"></a><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"is2 sentence4 This1 a3"</span></span><br><span class="line">输出：<span class="string">"This is a sentence"</span></span><br><span class="line">解释：将 s 中的单词按照初始位置排序，得到 <span class="string">"This1 is2 a3 sentence4"</span> ，然后删除数字。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"Myself2 Me1 I4 and3"</span></span><br><span class="line">输出：<span class="string">"Me Myself and I"</span></span><br><span class="line">解释：将 s 中的单词按照初始位置排序，得到 <span class="string">"Me1 Myself2 and3 I4"</span> ，然后删除数字。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= s.length &lt;= <span class="number">200</span>`</span><br><span class="line">+ s 只包含小写和大写英文字母、空格以及从 <span class="number">1</span> 到 <span class="number">9</span> 的数字。</span><br><span class="line">+ s 中单词数目为 <span class="number">1</span> 到 <span class="number">9</span> 个。</span><br><span class="line">+ s 中的单词由单个空格分隔。</span><br><span class="line">+ s 不包含任何前导或者后缀空格。</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/sorting-the-sentence</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力拆分排序</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 先将每个单词拆分出来，然后按照序号进行排序即可。排序完成后，再进行恢复即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s,char c)&#123;</span><br><span class="line">        <span class="built_in">int</span> len = s.size();</span><br><span class="line">        <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len;)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len &amp;&amp; s[i] == c) i++;</span><br><span class="line">            <span class="built_in">int</span> curr = i;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len &amp;&amp; s[i] != c) i++;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; len) ans.push_back(s.substr(curr,i-curr));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> sortSentence(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        vector&lt;<span class="built_in">string</span>&gt; words = split(s,<span class="string">' '</span>);</span><br><span class="line">        sort(words.begin(),words.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">string</span> &amp; a, <span class="keyword">const</span> <span class="built_in">string</span> &amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.back() &lt; b.back();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; words.size() - <span class="number">1</span>)&#123;</span><br><span class="line">                ans += words[i].substr(<span class="number">0</span>,words[i].size()<span class="number">-1</span>) + <span class="string">" "</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += words[i].substr(<span class="number">0</span>,words[i].size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5743-增长的内存泄露"><a href="#5743-增长的内存泄露" class="headerlink" title="5743. 增长的内存泄露"></a>5743. 增长的内存泄露</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数 <code>memory1</code> 和 <code>memory2</code>分别表示两个内存条剩余可用内存的位数。现在有一个程序每秒递增的速度消耗着内存。</p><p>在第 <code>i</code> 秒（秒数从 1 开始），有 <code>i</code> 位内存被分配到 剩余内存较多 的内存条（如果两者一样多，则分配到第一个内存条）。如果两者剩余内存都不足 <code>i</code>位，那么程序将 意外退出 。</p><p>请你返回一个数组，包含 <code>[crashTime, memory1crash, memory2crash]</code> ，其中 crashTime是程序意外退出的时间（单位为秒）， <code>memory1crash</code> 和 <code>memory2crash</code>分别是两个内存条最后剩余内存的位数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：memory1 = <span class="number">2</span>, memory2 = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">解释：内存分配如下：</span><br><span class="line">- 第 <span class="number">1</span> 秒，内存条 <span class="number">1</span> 被占用 <span class="number">1</span> 位内存。内存条 <span class="number">1</span> 现在有 <span class="number">1</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">2</span> 秒，内存条 <span class="number">2</span> 被占用 <span class="number">2</span> 位内存。内存条 <span class="number">2</span> 现在有 <span class="number">0</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">3</span> 秒，程序意外退出，两个内存条分别有 <span class="number">1</span> 位和 <span class="number">0</span> 位剩余可用内存。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：memory1 = <span class="number">8</span>, memory2 = <span class="number">11</span></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">解释：内存分配如下：</span><br><span class="line">- 第 <span class="number">1</span> 秒，内存条 <span class="number">2</span> 被占用 <span class="number">1</span> 位内存，内存条 <span class="number">2</span> 现在有 <span class="number">10</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">2</span> 秒，内存条 <span class="number">2</span> 被占用 <span class="number">2</span> 位内存，内存条 <span class="number">2</span> 现在有 <span class="number">8</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">3</span> 秒，内存条 <span class="number">1</span> 被占用 <span class="number">3</span> 位内存，内存条 <span class="number">1</span> 现在有 <span class="number">5</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">4</span> 秒，内存条 <span class="number">2</span> 被占用 <span class="number">4</span> 位内存，内存条 <span class="number">2</span> 现在有 <span class="number">4</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">5</span> 秒，内存条 <span class="number">1</span> 被占用 <span class="number">5</span> 位内存，内存条 <span class="number">1</span> 现在有 <span class="number">0</span> 位剩余可用内存。</span><br><span class="line">- 第 <span class="number">6</span> 秒，程序意外退出，两个内存条分别有 <span class="number">0</span> 位和 <span class="number">4</span> 位剩余可用内存。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>0 &lt;= memory1, memory2 &lt;= 231 - 1</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/incremental-memory-leak" target="_blank" rel="noopener">https://leetcode-cn.com/problems/incremental-memory-leak</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接模拟即可满足题目要求，因为时间复杂度约为$O(lg(m+n))$,所有的都在时间的允许范围内。</li><li>我们直到最大的可能开销约为$\frac{k*(k+1)}{2} \le (m+n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memLeak(<span class="keyword">int</span> memory1, <span class="keyword">int</span> memory2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr &lt;= memory1 || curr &lt;= memory2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(memory1 &gt;= memory2)&#123;</span><br><span class="line">                memory1 -= curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                memory2 -= curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;curr,memory1,memory2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5744-旋转盒子"><a href="#5744-旋转盒子" class="headerlink" title="5744. 旋转盒子"></a>5744. 旋转盒子</h2><p>给你一个 <code>m x n</code> 的字符矩阵 <code>box</code>，它表示一个箱子的侧视图。箱子的每一个格子可能为：</p><ul><li><code>&#39;#&#39;</code> 表示石头</li><li><code>&#39;*&#39;</code> 表示固定的障碍物</li><li><code>&#39;.&#39;</code> 表示空位置<br>这个箱子被 顺时针旋转 90 度 ，由于重力原因，部分石头的位置会发生改变。每个石头会垂直掉落，直到它遇到障碍物，另一个石头或者箱子的底部。重力 不会 影响障碍物的位置，同时箱子旋转不会产生惯性 ，也就是说石头的水平位置不会发生改变。</li></ul><p>题目保证初始时 <code>box</code> 中的石头要么在一个障碍物上，要么在另一个石头上，要么在箱子的底部。</p><p>请你返回一个 <code>n x m</code>的矩阵，表示按照上述旋转后，箱子内的结果。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：box = [[<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"#"</span>]]</span><br><span class="line">输出：[[<span class="string">"."</span>],</span><br><span class="line">      [<span class="string">"#"</span>],</span><br><span class="line">      [<span class="string">"#"</span>]]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：box = [[<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"*"</span>,<span class="string">"."</span>],</span><br><span class="line">            [<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"*"</span>,<span class="string">"."</span>]]</span><br><span class="line">输出：[[<span class="string">"#"</span>,<span class="string">"."</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"#"</span>],</span><br><span class="line">      [<span class="string">"*"</span>,<span class="string">"*"</span>],</span><br><span class="line">      [<span class="string">"."</span>,<span class="string">"."</span>]]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：box = [[<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"*"</span>,<span class="string">"."</span>,<span class="string">"*"</span>,<span class="string">"."</span>],</span><br><span class="line">            [<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"*"</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">            [<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"#"</span>,<span class="string">"."</span>]]</span><br><span class="line">输出：[[<span class="string">"."</span>,<span class="string">"#"</span>,<span class="string">"#"</span>],</span><br><span class="line">      [<span class="string">"."</span>,<span class="string">"#"</span>,<span class="string">"#"</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"*"</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"*"</span>,<span class="string">"."</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"*"</span>],</span><br><span class="line">      [<span class="string">"#"</span>,<span class="string">"."</span>,<span class="string">"."</span>]]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == box.length</code></li><li><code>n == box[i].length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>box[i][j]</code>只可能是 ‘#’ ，’*’ 或者 ‘.’ 。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/rotating-the-box" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotating-the-box</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接模拟</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接找到下一个可能的存放的单元格，然后将石头放入到此单元格，直接模拟即可，利用双指针，一个指针指向当前的单元格，另一个指针指向可以存放的单元格，每次进行尝试即可，感觉算是一个简单的题目。时间复杂度为$O(m*n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; rotateTheBox(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; box) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = box.size();</span><br><span class="line">        <span class="keyword">int</span> col = box[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; ans(col,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(row));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = col<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(box[i][j] == <span class="string">'#'</span>)&#123;</span><br><span class="line">                    box[i][curr] = <span class="string">'#'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(curr != j) box[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                    curr--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(box[i][j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    curr = j - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                ans[i][j] = box[row<span class="number">-1</span>-j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5212-向下取整数对和"><a href="#5212-向下取整数对和" class="headerlink" title="5212. 向下取整数对和"></a>5212. 向下取整数对和</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，请你返回所有下标对 <code>0 &lt;= i, j &lt; nums.length</code> 的 <code>floor(nums[i] / nums[j])</code> 结果之和。由于答案可能会很大，请你返回答案对<code>109 + 7</code>取余 的结果。<br>函数 <code>floor()</code>返回输入数字的整数部分。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：</span><br><span class="line">floor(<span class="number">2</span> / <span class="number">5</span>) = floor(<span class="number">2</span> / <span class="number">9</span>) = floor(<span class="number">5</span> / <span class="number">9</span>) = <span class="number">0</span></span><br><span class="line">floor(<span class="number">2</span> / <span class="number">2</span>) = floor(<span class="number">5</span> / <span class="number">5</span>) = floor(<span class="number">9</span> / <span class="number">9</span>) = <span class="number">1</span></span><br><span class="line">floor(<span class="number">5</span> / <span class="number">2</span>) = <span class="number">2</span></span><br><span class="line">floor(<span class="number">9</span> / <span class="number">2</span>) = <span class="number">4</span></span><br><span class="line">floor(<span class="number">9</span> / <span class="number">5</span>) = <span class="number">1</span></span><br><span class="line">我们计算每一个数对商向下取整的结果并求和得到 <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/sum-of-floored-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-floored-pairs</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 素数筛查法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote></li></ul><ol><li>我们首先利用前缀和统计元素个数，比如$sum(n)$则表示当前小于等于<code>n</code>的元素的个数，然后我们就可以很快的利用前缀和求出区间$[i,j]$之间的元素的个数,$cnt(i,j) = sum[j] - sum[i-1]$.</li><li>我们依次枚举每个元素<code>x</code>的倍数，比如枚举如下:<script type="math/tex; mode=display">[x,2x,3x,4x,....,nx]</script>则我们很容易的知道处在区间$[ax,(a+1)x-1]$的数对于<code>x</code>取<code>floor</code>的结果为$a$,则我们依次枚举所有可能的区间即可。在处在区间$[ax,(a+1)x-1]$的数对<code>a</code>求<code>floor</code>的值为$a$.</li><li>感觉这个题目就是类似于素数筛查的方法，时间复杂度接近于<code>n</code>倍的调和级数，已经知道结论如下：<script type="math/tex; mode=display">1+1/2+1/3+1/4+...1/n = ln(n+1) + r</script>则本题的算法复杂度约为$n\sum_{i=1}^n\frac{1}{i}$,时间复杂度近似于$nlgn$.</li><li>比较坑爹得是，平台中的测试用例变换了，所以之前的代码可能有问题，特别是对于数组中所有元素都为<code>1</code>的情况下，此时则代码就会出现超时的问题，所以还是将代码进行了更新，本质的方法是一样的，不过是不是枚举数组中的元素，而是枚举数组中所有元素的最大值。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfFlooredPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxNum = *max_element(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; freq(maxNum+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(maxNum+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) freq[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; freq.size(); ++i) sum[i] = sum[i<span class="number">-1</span>] + freq[i]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxNum; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(freq[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j*i &lt;= maxNum; ++j)&#123;</span><br><span class="line">                ans = (ans + (<span class="keyword">long</span> <span class="keyword">long</span>)freq[i]*j*(sum[min(maxNum,(j+<span class="number">1</span>)*i<span class="number">-1</span>)] - sum[j*i<span class="number">-1</span>]))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-52&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-52&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 52&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 52&lt;/h1&gt;&lt;p&gt;最近周赛题目质量越来越不稳定了，最后一题就是稍微麻烦一点的数学题目。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/05/16/TQS2JViKeLsdtoI.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5742-将句子排序&quot;&gt;&lt;a href=&quot;#5742-将句子排序&quot; class=&quot;headerlink&quot; title=&quot;5742. 将句子排序&quot;&gt;&lt;/a&gt;5742. 将句子排序&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个 句子 指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。&lt;br&gt;我们可以给一个句子添加 从 1 开始的单词位置索引 ，并且将句子中所有单词 打乱顺序 。&lt;br&gt;比方说，句子 &lt;code&gt;&amp;quot;This is a sentence&amp;quot;&lt;/code&gt; 可以被打乱顺序得到&lt;code&gt;&amp;quot;sentence4 a3 is2 This1&amp;quot; 或者 &amp;quot;is2 sentence4 This1 a3&amp;quot;&lt;/code&gt; 。&lt;br&gt;给你一个 打乱顺序 的句子 s ，它包含的单词不超过 9 个，请你重新构造并得到原本顺序的句子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 二叉树的非递归遍历</title>
    <link href="http://yoursite.com/2021/05/11/282/"/>
    <id>http://yoursite.com/2021/05/11/282/</id>
    <published>2021-05-11T13:13:00.092Z</published>
    <updated>2021-05-15T15:01:20.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binary-tree-非递归遍历"><a href="#binary-tree-非递归遍历" class="headerlink" title="binary tree 非递归遍历"></a>binary tree 非递归遍历</h1><p>最近在练习题目的时候经常遇到二叉树的非递归遍历，感觉有许多非常有意思和思考的题目，其中二叉树的几个非递归遍历的几个小的观点。</p><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><ol><li><code>preorder traverse</code>：对于递归来说非常容易处理，我们先访问根节点，然后访问左子树，再次访问右子树，所以如果利用栈的话，则我们先将右子树入栈，然后再将左子树入栈，然后访问根节点。对于递归来说访问的核心代码为:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visit(root);</span><br><span class="line">dfs(root-&gt;left);</span><br><span class="line">dfs(root-&gt;right);</span><br></pre></td></tr></table></figure>源代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode * &gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            TreeNode * node = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            ans.emplace_back(node-&gt;val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)  st.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>inorder traverse</code>: 对于中序遍历则麻烦许多，首先我们会访问根节点的左子树，直到没有左子数节点时，则从栈中弹出一个数据，并进行访问，然后将其右子树节点压入到栈中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</span><br><span class="line">        TreeNode * node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node||!st.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(node)&#123;</span><br><span class="line">                    st.push(node);</span><br><span class="line">                    node = node-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    ans.emplace_back(node-&gt;val);</span><br><span class="line">                    node = node-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>postorder traverse</code>: 后续遍历感觉最难搞了，需要两个栈来配合才能完成，感觉还是偏难的题目。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; st1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; st2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        TreeNode * node = root;</span><br><span class="line"></span><br><span class="line">        st1.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st1.empty())&#123;</span><br><span class="line">            TreeNode * node = st1.top();</span><br><span class="line">            st1.pop();</span><br><span class="line">            st2.push(node);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                st1.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                st1.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st2.empty())&#123;</span><br><span class="line">            ans.push_back(st2.top()-&gt;val);</span><br><span class="line">            st2.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;binary-tree-非递归遍历&quot;&gt;&lt;a href=&quot;#binary-tree-非递归遍历&quot; class=&quot;headerlink&quot; title=&quot;binary tree 非递归遍历&quot;&gt;&lt;/a&gt;binary tree 非递归遍历&lt;/h1&gt;&lt;p&gt;最近在练习题目的时候经常遇到二叉树的非递归遍历，感觉有许多非常有意思和思考的题目，其中二叉树的几个非递归遍历的几个小的观点。&lt;/p&gt;&lt;h2 id=&quot;非递归遍历&quot;&gt;&lt;a href=&quot;#非递归遍历&quot; class=&quot;headerlink&quot; title=&quot;非递归遍历&quot;&gt;&lt;/a&gt;非递归遍历&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;preorder traverse&lt;/code&gt;：对于递归来说非常容易处理，我们先访问根节点，然后访问左子树，再次访问右子树，所以如果利用栈的话，则我们先将右子树入栈，然后再将左子树入栈，然后访问根节点。对于递归来说访问的核心代码为:&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;visit(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dfs(root-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dfs(root-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
源代码：&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct TreeNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *left;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *right;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode() : val(0), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; preorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;TreeNode * &amp;gt; st;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!root) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        st.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!st.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            TreeNode * node = st.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            st.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans.emplace_back(node-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node-&amp;gt;right) st.push(node-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node-&amp;gt;left)  st.push(node-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inorder traverse&lt;/code&gt;: 对于中序遍历则麻烦许多，首先我们会访问根节点的左子树，直到没有左子数节点时，则从栈中弹出一个数据，并进行访问，然后将其右子树节点压入到栈中。&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct TreeNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *left;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *right;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode() : val(0), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; inorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;TreeNode *&amp;gt; st;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TreeNode * node = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(node||!st.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    st.push(node);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    node = node-&amp;gt;left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    node = st.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    st.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    ans.emplace_back(node-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    node = node-&amp;gt;right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postorder traverse&lt;/code&gt;: 后续遍历感觉最难搞了，需要两个栈来配合才能完成，感觉还是偏难的题目。&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct TreeNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *left;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode *right;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode() : val(0), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; postorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;TreeNode *&amp;gt; st1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;TreeNode *&amp;gt; st2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!root) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TreeNode * node = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        st1.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!st1.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            TreeNode * node = st1.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            st1.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            st2.push(node);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node-&amp;gt;left)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                st1.push(node-&amp;gt;left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(node-&amp;gt;right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                st1.push(node-&amp;gt;right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!st2.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans.push_back(st2.top()-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            st2.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 Mono Stack</title>
    <link href="http://yoursite.com/2021/05/11/281/"/>
    <id>http://yoursite.com/2021/05/11/281/</id>
    <published>2021-05-11T12:49:12.496Z</published>
    <updated>2021-05-11T13:56:36.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mono-stack"><a href="#mono-stack" class="headerlink" title="mono stack"></a>mono stack</h1><p>最近在练习题目的时候经常遇到<code>mono stack</code>的题目，总的来说题目还是非常非常的有意思，单调栈真心是个利器。可以解决非常多的复杂的问题。可以利用单调栈求出以当前值为最大值或者最小值的连续子数组的最大长度。</p><h2 id="单调栈的原理"><a href="#单调栈的原理" class="headerlink" title="单调栈的原理"></a>单调栈的原理</h2><p>单调栈中的数据需要遵循两个原则：</p><ul><li>栈中的数据会是严格递增或者递减，则我们可以知道，假如单调栈中的数据为递减，则可以知道栈顶的数据一定为当前序列中最大的数据;假如单调栈中的数据为递增，则可以知道栈顶的数据一定为当前序列中最小的数据。一般情况下我们都会用<code>dequeue</code>来处理单调栈的数据，则可以知道队列的头部一定为当前序列中所求的最大值或者最小值。</li><li>为了保持单调性，则每当加入一个新的元素时，则会将栈中所有比当前元素小或者大的数据全部进行出栈，则由此我们可以判断如下，假设当前的栈为递减：<br><img src="https://i.loli.net/2021/05/11/xJKB3lbXmrjCZ6q.png" alt="1"><br>从图中可以看出我们可以在$O(1)$的时间复杂度内求出当前序列的极值。栈中任意相邻的两个元素比如$(arr[i],arr[j])$,则表示所有处于$(i,j)$之间的元素均小于$arr[j]$,有了这个重要的推论，则许多问题都可以利用这个特性来求解，比如我们知道假设某个元素<code>x</code>大于$arr[j]$,则表示<code>x</code>一定大于所有位于$[i+1,j]$之间的元素。下面有几个非常有代表性的题目需要讨论下：</li></ul><a id="more"></a><ol><li><a href="https://www.hackerrank.com/challenges/deque-stl/problem" target="_blank" rel="noopener">找到子数组长度为k的最大值</a></li><li><a href="https://binarysearch.com/problems/Longest-Sublist-with-Value-Range-Condition" target="_blank" rel="noopener">Longest Sublist with Value Range Condition</a></li><li><a href="https://leetcode-cn.com/problems/maximum-subarray-min-product/" target="_blank" rel="noopener">子数组最小乘积的最大值</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">下一个更大元素 I</a></li><li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">下一个更大元素 II</a></li></ol><h2 id="下一个更大元素-II"><a href="#下一个更大元素-II" class="headerlink" title="下一个更大元素 II"></a>下一个更大元素 II</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-ii</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  classical problem</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>首先题目中要求循环处理，这个很简单我们只需要在数组后面对数组本身再进行重复复制一遍即可，这样我们即可完成循环处理。</li><li>最经典的处理莫过于如何求第一个比其小或者大的数的处理，我们利用单调栈，所有小于当前的数全部从栈中弹出，因为我们知道一个推论为，栈中任意相邻的两个元素比如$(arr[i],arr[j])$,则表示所有处于$(i,j)$之间的元素均小于$arr[j]$,此时我们即可利用单调性很快求出所有的值。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            nums.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dq.back() &lt; n)&#123;</span><br><span class="line">                    ans[dq.back()] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Longest-Sublist-with-Value-Range-Condition"><a href="#Longest-Sublist-with-Value-Range-Condition" class="headerlink" title="Longest Sublist with Value Range Condition"></a>Longest Sublist with Value Range Condition</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a list of integers nums, return the length of the longest sublist where 2 * min(sublist) &gt; max(sublist).</p><p>Constraints</p><p>n ≤ 100,000 where n is the length of nums<br>Example 1<br>Input<br>nums = [9, 1, 5, 5, 3, 3]<br>Output<br>4<br>Explanation<br>The sublist [5, 5, 3, 3] is the longest sublist that meet the criteria since 2 * 3 &gt; 5.</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://binarysearch.com/problems/Longest-Sublist-with-Value-Range-Condition" target="_blank" rel="noopener">https://binarysearch.com/problems/Longest-Sublist-with-Value-Range-Condition</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  双指针加单调栈</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目更加经典，需要同时利用单调栈和双指针。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; minq;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxq;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">// we remove all the element is more than nums[i]</span></span><br><span class="line">        <span class="keyword">while</span>(!minq.empty() &amp;&amp; nums[minq.back()] &gt; nums[i]) minq.pop_back();</span><br><span class="line">        minq.push_back(i);</span><br><span class="line">        <span class="comment">// we remove all the element is less than nums[i]</span></span><br><span class="line">        <span class="keyword">while</span>(!maxq.empty() &amp;&amp; nums[maxq.back()] &lt; nums[i]) maxq.pop_back();</span><br><span class="line">        maxq.push_back(i);</span><br><span class="line">        <span class="keyword">while</span>(!minq.empty() &amp;&amp; !maxq.empty() &amp;&amp; nums[maxq.front()] &gt;= <span class="number">2</span>*nums[minq.front()])&#123;</span><br><span class="line">            <span class="keyword">while</span>(!minq.empty() &amp;&amp; minq.front() &lt;= j) minq.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!maxq.empty() &amp;&amp; maxq.front() &lt;= j) maxq.pop_front();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="qiu"><a href="#qiu" class="headerlink" title="qiu"></a>qiu</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given a set of arrays of size  and an integer , you have to find the maximum integer for each and every contiguous subarray of size  for each of the given arrays.<br>nput Format</p><p>First line of input will contain the number of test cases T. For each test case, you will be given the size of array N and the size of subarray to be used K. This will be followed by the elements of the array Ai.</p><p>Constraints, where  is the  element in the array .</p><p>Output Format</p><p>For each of the contiguous subarrays of size  of each array, you have to print the maximum integer.</p><p>Sample Input<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">6</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">1</span> <span class="number">4</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><br>Sample Output<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">6</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">8</span> <span class="number">8</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.hackerrank.com/challenges/deque-stl/problem" target="_blank" rel="noopener">https://www.hackerrank.com/challenges/deque-stl/problem</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  单调栈 + 滑动窗口</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目更加经典，需要同时利用单调栈和双指针。利用单调性，单调栈中的栈头一定保存的是当前序列的最大值。同时利用滑动窗口，一旦窗口超过队头的元素，则将队头的元素进行删除即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printKMax</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.empty() &amp;&amp; arr[i] &gt; arr[dq.back()])&#123;</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.push_back(i);</span><br><span class="line">        <span class="keyword">while</span>((i-j+<span class="number">1</span>) &gt; k)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; dq.front() &lt;= j) dq.pop_front();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[dq.front()]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    printKMax(arr, n, k);</span><br><span class="line">    t--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mono-stack&quot;&gt;&lt;a href=&quot;#mono-stack&quot; class=&quot;headerlink&quot; title=&quot;mono stack&quot;&gt;&lt;/a&gt;mono stack&lt;/h1&gt;&lt;p&gt;最近在练习题目的时候经常遇到&lt;code&gt;mono stack&lt;/code&gt;的题目，总的来说题目还是非常非常的有意思，单调栈真心是个利器。可以解决非常多的复杂的问题。可以利用单调栈求出以当前值为最大值或者最小值的连续子数组的最大长度。&lt;/p&gt;&lt;h2 id=&quot;单调栈的原理&quot;&gt;&lt;a href=&quot;#单调栈的原理&quot; class=&quot;headerlink&quot; title=&quot;单调栈的原理&quot;&gt;&lt;/a&gt;单调栈的原理&lt;/h2&gt;&lt;p&gt;单调栈中的数据需要遵循两个原则：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;栈中的数据会是严格递增或者递减，则我们可以知道，假如单调栈中的数据为递减，则可以知道栈顶的数据一定为当前序列中最大的数据;假如单调栈中的数据为递增，则可以知道栈顶的数据一定为当前序列中最小的数据。一般情况下我们都会用&lt;code&gt;dequeue&lt;/code&gt;来处理单调栈的数据，则可以知道队列的头部一定为当前序列中所求的最大值或者最小值。&lt;/li&gt;
&lt;li&gt;为了保持单调性，则每当加入一个新的元素时，则会将栈中所有比当前元素小或者大的数据全部进行出栈，则由此我们可以判断如下，假设当前的栈为递减：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/05/11/xJKB3lbXmrjCZ6q.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;从图中可以看出我们可以在$O(1)$的时间复杂度内求出当前序列的极值。栈中任意相邻的两个元素比如$(arr[i],arr[j])$,则表示所有处于$(i,j)$之间的元素均小于$arr[j]$,有了这个重要的推论，则许多问题都可以利用这个特性来求解，比如我们知道假设某个元素&lt;code&gt;x&lt;/code&gt;大于$arr[j]$,则表示&lt;code&gt;x&lt;/code&gt;一定大于所有位于$[i+1,j]$之间的元素。下面有几个非常有代表性的题目需要讨论下：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 240</title>
    <link href="http://yoursite.com/2021/05/09/280/"/>
    <id>http://yoursite.com/2021/05/09/280/</id>
    <published>2021-05-09T09:05:42.330Z</published>
    <updated>2021-05-11T12:50:00.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-240"><a href="#leetcode-contest-240" class="headerlink" title="leetcode  contest 240"></a>leetcode  contest 240</h1><p>本周的题目质量还算真心不错，印象最深的应该是第三题，单调栈的应用，最后一题反而感觉不是太难。已经经历过许多次单调栈了，还是对单调栈的理解不够透彻，刚刚复习了<code>tarjan</code>和<code>heap</code>的应用，印象非常深刻。</p><h2 id="5750-人口最多的年份"><a href="#5750-人口最多的年份" class="headerlink" title="5750. 人口最多的年份"></a>5750. 人口最多的年份</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>logs</code> ，其中每个 <code>logs[i] = [birthi, deathi]</code> 表示第 <code>i</code> 个人的出生和死亡年份。</p><a id="more"></a><p>年份 x 的 人口 定义为这一年期间活着的人的数目。第 <code>i</code> 个人被计入年份 x 的人口需要满足：x 在闭区间<code>[birthi, deathi - 1]</code> 内。注意，人不应当计入他们死亡当年的人口中。</p><p>返回 人口最多 且 最早 的年份。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">1993</span>,<span class="number">1999</span>],[<span class="number">2000</span>,<span class="number">2010</span>]]</span><br><span class="line">输出：<span class="number">1993</span></span><br><span class="line">解释：人口最多为 <span class="number">1</span> ，而 <span class="number">1993</span> 是人口为 <span class="number">1</span> 的最早年份。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：logs = [[<span class="number">1950</span>,<span class="number">1961</span>],[<span class="number">1960</span>,<span class="number">1971</span>],[<span class="number">1970</span>,<span class="number">1981</span>]]</span><br><span class="line">输出：<span class="number">1960</span></span><br><span class="line">解释： </span><br><span class="line">人口最多为 <span class="number">2</span> ，分别出现在 <span class="number">1960</span> 和 <span class="number">1970</span> 。</span><br><span class="line">其中最早年份是 <span class="number">1960</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= logs.length &lt;= 100</code></li><li><code>1950 &lt;= birthi &lt; deathi &lt;= 2050</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-population-year" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-population-year</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  差分数组暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的直接暴力排序统计即可，时间复杂度为$O(n)$,稍微高级点的我们可以用点技巧的我们可以用查分数组。</li><li>我们每次在出身的年份将人数进行加<code>1</code>，在死亡的年份将人数减<code>1</code>，统计当年年份中人数最多的一年即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumPopulation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(<span class="number">2051</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; logs.size(); ++i)&#123;</span><br><span class="line">            arr[logs[i][<span class="number">0</span>]]++;</span><br><span class="line">            arr[logs[i][<span class="number">1</span>]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxP = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> year = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1950</span>; i &lt;= <span class="number">2050</span>; ++i)&#123;</span><br><span class="line">            curr += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; maxP)&#123;</span><br><span class="line">                maxP = curr;</span><br><span class="line">                year = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> year;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5751-下标对中的最大距离"><a href="#5751-下标对中的最大距离" class="headerlink" title="5751. 下标对中的最大距离"></a>5751. 下标对中的最大距离</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个 非递增 的整数数组 <code>nums1</code>​​​​​​ 和 <code>nums2</code>​​​​​​ ，数组下标均 从 0 开始 计数。<br>下标对 <code>(i, j)</code> 中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code> 。如果该下标对同时满足 <code>i &lt;= j</code> 且 <code>nums1[i] &lt;= nums2[j]</code> ，则称之为 有效 下标对，该下标对的 距离 为 <code>j - i</code>​​ 。​​</p><p>返回所有 有效 下标对 <code>(i, j)</code> 中的 最大距离 。如果不存在有效下标对，返回 0 。</p><p>一个数组 <code>arr</code> ，如果每个 <code>1 &lt;= i &lt; arr.length</code> 均有 <code>arr[i-1] &gt;= arr[i]</code> 成立，那么该数组是一个 非递增 数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">55</span>,<span class="number">30</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>], nums2 = [<span class="number">100</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有效下标对是 (<span class="number">0</span>,<span class="number">0</span>), (<span class="number">2</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">3</span>), (<span class="number">3</span>,<span class="number">4</span>) 和 (<span class="number">4</span>,<span class="number">4</span>) 。</span><br><span class="line">最大距离是 <span class="number">2</span> ，对应下标对 (<span class="number">2</span>,<span class="number">4</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">10</span>,<span class="number">10</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：有效下标对是 (<span class="number">0</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">1</span>) 和 (<span class="number">1</span>,<span class="number">1</span>) 。</span><br><span class="line">最大距离是 <span class="number">1</span> ，对应下标对 (<span class="number">0</span>,<span class="number">1</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">30</span>,<span class="number">29</span>,<span class="number">19</span>,<span class="number">5</span>], nums2 = [<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有效下标对是 (<span class="number">2</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">3</span>) 和 (<span class="number">3</span>,<span class="number">4</span>) 。</span><br><span class="line">最大距离是 <span class="number">2</span> ，对应下标对 (<span class="number">2</span>,<span class="number">4</span>) 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">5</span>,<span class="number">4</span>], nums2 = [<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在有效下标对，所以返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length &lt;= 105</code></li><li><code>1 &lt;= nums2.length &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[j] &lt;= 105</code></li><li><code>nums1</code> 和 <code>nums2</code> 都是 非递增 数组</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 双指针或者二分查找</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的二分查找或者双指针问题，对于二分查找就比较简单，我们每次固定<code>nums1[i]</code>,然后利用二分查找法，在<code>nums2</code>中找到最小且比<code>nums1[i]</code>的大的数的索引，即可很快得到结论，算法时间复杂度为$O(nlg(n))$.</li><li>双指针法，由于两个数组都是已经排好序了，我们遍历一个元素时<code>nums1[i]</code>时，用一个指针指向当且大于等于且最小的数的索引，此时如果我们将<code>nums1[i]</code>移动到<code>nums1[i+1]</code>时，则我们将<code>nums2[j]</code>往后移动直到满足题目要求。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &lt;= nums2[mid])&#123;</span><br><span class="line">                    curr = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,curr-i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>双指针<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; nums2[j] &gt;= nums1[i]) j++;</span><br><span class="line">            ans = max(ans,j-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5752-子数组最小乘积的最大值"><a href="#5752-子数组最小乘积的最大值" class="headerlink" title="5752. 子数组最小乘积的最大值"></a>5752. 子数组最小乘积的最大值</h2><p>一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。</p><p>比方说，数组<code>[3,2,5]</code>（最小值是 2）的最小乘积为<code>2 * (3+2+5) = 2 * 10 = 20</code>。<br>给你一个正整数数组 <code>nums</code> ，请你返回 <code>nums</code>任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对  <code>109 + 7</code>取余 的结果。</p><p>请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 <code>64</code> 位有符号整数 保存。</p><p>子数组 定义为一个数组的 连续 部分。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">解释：最小乘积的最大值由子数组 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>] （最小值是 <span class="number">2</span>）得到。</span><br><span class="line"><span class="number">2</span> * (<span class="number">2</span>+<span class="number">3</span>+<span class="number">2</span>) = <span class="number">2</span> * <span class="number">7</span> = <span class="number">14</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：最小乘积的最大值由子数组 [<span class="number">3</span>,<span class="number">3</span>] （最小值是 <span class="number">3</span>）得到。</span><br><span class="line"><span class="number">3</span> * (<span class="number">3</span>+<span class="number">3</span>) = <span class="number">3</span> * <span class="number">6</span> = <span class="number">18</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">60</span></span><br><span class="line">解释：最小乘积的最大值由子数组 [<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] （最小值是 <span class="number">4</span>）得到。</span><br><span class="line"><span class="number">4</span> * (<span class="number">5</span>+<span class="number">6</span>+<span class="number">4</span>) = <span class="number">4</span> * <span class="number">15</span> = <span class="number">60</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 107</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 单调栈</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们直接暴力的话，双层循环，时间复杂度为$O(n^{2}$.</li><li>我们可以利用单调栈，对每一个元素求出以作为最小元素最长连续子数组，我们即可求该元素的两边距离该元素最近且比该元素小的数组的索引，我们可以利用单调栈；</li></ol><ul><li>左边严格小于<code>nums[i]</code>的元素，且距离<code>nums[i]</code>最近，我们记该元素的索引为<code>left[i]</code>；</li><li>右边严格小于<code>nums[i]</code>的元素，且距离<code>nums[i]</code>最近，我们记该元素的索引为<code>right[i]</code>；<br>则我们可以直到以<code>nums[i]</code>为最小元素的最长连续子数组的索引为$[left[i]+1,right[i]-1]$，此时我们即可利用前缀和很快即可求出数组的最小乘积，我们枚举所有可能的最小乘积即可求出所有可能的元素；</li></ul><ol><li>我们每次将比当前元素大的元素从栈内弹出，并将弹出元素的最近小于等于的元素即等于当前的元素。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumMinProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n,n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sum[i+<span class="number">1</span>] = nums[i] + sum[i];</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; curr1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!curr1.empty() &amp;&amp; nums[i] &lt; nums[curr1.top()])&#123;</span><br><span class="line">                right[curr1.top()] = i;</span><br><span class="line">                curr1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            curr1.push(i);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; curr2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!curr2.empty() &amp;&amp; nums[i] &lt; nums[curr2.top()])&#123;</span><br><span class="line">                left[curr2.top()] = i;</span><br><span class="line">                curr2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            curr2.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> prod = nums[i] *(sum[right[i]]-sum[left[i]+<span class="number">1</span>]);</span><br><span class="line">            ans = max(ans,prod);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5753-有向图中最大颜色值"><a href="#5753-有向图中最大颜色值" class="headerlink" title="5753. 有向图中最大颜色值"></a>5753. 有向图中最大颜色值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 有向图 ，它含有 <code>n</code> 个节点和 <code>m</code>条边。节点编号从 0 到 <code>n - 1</code>。</p><p>给你一个字符串 <code>colors</code> ，其中 <code>colors[i]</code> 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 <code>edges</code> ，其中 <code>edges[j] = [aj, bj]</code>表示从节点 <code>aj</code>到节点<code>bj</code> 有一条 有向边 。</p><p>图中一条有效 路径 是一个点序列 <code>x1 -&gt; x2 -&gt; x3 -&gt; ... -&gt; xk</code>，对于所有 <code>1 &lt;= i &lt; k</code>，从 <code>xi</code>到 <code>xi+1</code> 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。</p><p>请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = <span class="string">"abaca"</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：路径 <span class="number">0</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> 含有 <span class="number">3</span> 个颜色为 <span class="string">"a"</span> 的节点（上图中的红色节点）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = <span class="string">"a"</span>, edges = [[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：从 <span class="number">0</span> 到 <span class="number">0</span> 有一个环。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == colors.length</code></li><li><code>m == edges.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= m &lt;= 105</code></li><li><code>colors</code> 只含有小写英文字母。</li><li><code>0 &lt;= aj, bj &lt; n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>拓扑排序</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>感觉这个题目反而没有太多亮点，常规的题目，因为题目中不需要处理环的特殊情况，所以就非常简单，我们首先判断图中是否有环，如果有环我们直接返回<code>-1</code>即可。</li><li>我们设<code>dp[i][c]</code>表示经过节点的<code>i</code>且颜色为<code>c</code>的节点最多的个数，则我们利用拓扑排序，每一条新的路径达到某个顶点，则我们对该顶点的每种颜色的最大个数都进行跟新比较即可，感觉中规中距的题目。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestPathValue</span><span class="params">(<span class="built_in">string</span> colors, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = colors.size();</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                qu.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            dp[curr][colors[curr]-<span class="string">'a'</span>]++;</span><br><span class="line">            ans = max(ans,dp[curr][colors[curr]-<span class="string">'a'</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">                indegree[v]--;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">                    dp[v][i] = max(dp[v][i],dp[curr][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(indegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-240&quot;&gt;&lt;a href=&quot;#leetcode-contest-240&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 240&quot;&gt;&lt;/a&gt;leetcode  contest 240&lt;/h1&gt;&lt;p&gt;本周的题目质量还算真心不错，印象最深的应该是第三题，单调栈的应用，最后一题反而感觉不是太难。已经经历过许多次单调栈了，还是对单调栈的理解不够透彻，刚刚复习了&lt;code&gt;tarjan&lt;/code&gt;和&lt;code&gt;heap&lt;/code&gt;的应用，印象非常深刻。&lt;/p&gt;&lt;h2 id=&quot;5750-人口最多的年份&quot;&gt;&lt;a href=&quot;#5750-人口最多的年份&quot; class=&quot;headerlink&quot; title=&quot;5750. 人口最多的年份&quot;&gt;&lt;/a&gt;5750. 人口最多的年份&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个二维整数数组 &lt;code&gt;logs&lt;/code&gt; ，其中每个 &lt;code&gt;logs[i] = [birthi, deathi]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个人的出生和死亡年份。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 239</title>
    <link href="http://yoursite.com/2021/05/03/279/"/>
    <id>http://yoursite.com/2021/05/03/279/</id>
    <published>2021-05-03T08:33:32.332Z</published>
    <updated>2021-05-09T09:06:20.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-239"><a href="#leetcode-contest-239" class="headerlink" title="leetcode  contest 239"></a>leetcode  contest 239</h1><p>感觉周赛的题目还算是稍微好看点，不过最后一题确实不太难，基本上都是暴力加一定的技巧就能做出来。题目比双周赛要难一点，但是不是特别难，感觉至少三题的节奏。</p><h2 id="1848-到目标元素的最小距离"><a href="#1848-到目标元素的最小距离" class="headerlink" title="1848. 到目标元素的最小距离"></a>1848. 到目标元素的最小距离</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> （下标 从 0 开始 计数）以及两个整数 <code>target</code> 和 <code>start</code> ，请你找出一个下标 i ，满足 <code>nums[i] == target</code> 且 <code>abs(i - start)</code>最小化 。注意：<code>abs(x)</code>表示 x 的绝对值。</p><a id="more"></a><p>返回 <code>abs(i - start)</code> 。</p><p>题目数据保证 <code>target</code> 存在于 <code>nums</code> 中。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], target = <span class="number">5</span>, start = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：nums[<span class="number">4</span>] = <span class="number">5</span> 是唯一一个等于 target 的值，所以答案是 abs(<span class="number">4</span> - <span class="number">3</span>) = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], target = <span class="number">1</span>, start = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums[<span class="number">0</span>] = <span class="number">1</span> 是唯一一个等于 target 的值，所以答案是 abs(<span class="number">0</span> - <span class="number">0</span>) = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">1</span>, start = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums 中的每个值都是 <span class="number">1</span> ，但 nums[<span class="number">0</span>] 使 abs(i - start) 的结果得以最小化，所以答案是 abs(<span class="number">0</span> - <span class="number">0</span>) = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li><li><code>0 &lt;= start &lt; nums.length</code></li><li><code>target 存在于 nums 中</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-distance-to-the-target-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-to-the-target-element</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力统计就可，题目有点奇怪，不是中规中矩的题目<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(ans-start) &gt; <span class="built_in">abs</span>(i-start))&#123;</span><br><span class="line">                        ans = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(ans-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1849-将字符串拆分为递减的连续值"><a href="#1849-将字符串拆分为递减的连续值" class="headerlink" title="1849. 将字符串拆分为递减的连续值"></a>1849. 将字符串拆分为递减的连续值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个仅由数字组成的字符串 <code>s</code>。</p><p>请你判断能否将 <code>s</code>拆分成两个或者多个 非空子字符串 ，使子字符串的 数值 按 降序 排列，且每两个 相邻子字符串 的数值之 差 等于 1 。</p><p>例如，字符串 <code>s = &quot;0090089&quot;</code>可以拆分成 [“0090”, “089”] ，数值为 [90,89] 。这些数值满足按降序排列，且相邻值相差 1 ，这种拆分方法可行。<br>另一个例子中，字符串 s = “001” 可以拆分成 [“0”, “01”]、[“00”, “1”] 或 [“0”, “0”, “1”] 。然而，所有这些拆分方法都不可行，因为对应数值分别是 [0,1]、[0,1] 和 [0,0,1] ，都不满足按降序排列的要求。<br>如果可以按要求拆分 <code>s</code>，返回<code>true</code>；否则，返回 <code>false</code> 。</p><p>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1234"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：不存在拆分 s 的可行方法。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"050043"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：s 可以拆分为 [<span class="string">"05"</span>, <span class="string">"004"</span>, <span class="string">"3"</span>] ，对应数值为 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>] 。</span><br><span class="line">满足按降序排列，且相邻值相差 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"9080701"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：不存在拆分 s 的可行方法。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"10009998"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：s 可以拆分为 [<span class="string">"100"</span>, <span class="string">"099"</span>, <span class="string">"98"</span>] ，对应数值为 [<span class="number">100</span>,<span class="number">99</span>,<span class="number">98</span>] 。</span><br><span class="line">满足按降序排列，且相邻值相差 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values" target="_blank" rel="noopener">https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力<code>dfs</code></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>上来就知道这个题目可以暴力<code>dfs</code>加剪枝就可以搞定。但是一般不喜欢用<code>dfs</code>，想来想去没有想到好的解法，最后还算老老实实的用<code>dfs</code>。</li><li>每次进行<code>dfs</code>递归时，需要记录前一个已经分割后的值以及当前已经进行分割的次数。关键一点需要提示，当前值如果大于$10^{10}$,则我们可以直接进行中止，因为后面的字符无论如何都不可能构成比当前数小<code>1</code>的值，这样即可放置<code>long long</code>溢出的问题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> prev,<span class="keyword">int</span> curr,<span class="keyword">int</span> cnt,<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> max = <span class="number">1e10</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span> &amp;&amp; curr == s.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = curr; i &lt; s.size(); ++i)&#123;</span><br><span class="line">                x = x*<span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(dfs(x,i+<span class="number">1</span>,cnt+<span class="number">1</span>,s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = curr; i &lt; s.size(); ++i)&#123;</span><br><span class="line">                x = x*<span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(x == prev<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(x,i+<span class="number">1</span>,cnt+<span class="number">1</span>,s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; prev<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="1850-邻位交换的最小次数"><a href="#1850-邻位交换的最小次数" class="headerlink" title="1850. 邻位交换的最小次数"></a>1850. 邻位交换的最小次数</h2><p>给你一个表示大整数的字符串 <code>num</code> ，和一个整数 <code>k</code> 。</p><p>如果某个整数是 <code>num</code> 中各位数字的一个 排列 且它的 值大于 <code>num</code>，则称这个整数为 妙数 。可能存在很多妙数，但是只需要关注 值最小 的那些。</p><ul><li>例如，num = “5489355142” ：<ul><li>第 1 个最小妙数是 “5489355214”</li><li>第 2 个最小妙数是 “5489355241”</li><li>第 3 个最小妙数是 “5489355412”</li><li>第 4 个最小妙数是 “5489355421”<br>返回要得到第 k 个 最小妙数 需要对 num 执行的 相邻位数字交换的最小次数 。</li></ul></li></ul><p>测试用例是按存在第 k 个最小妙数而生成的。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"5489355142"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：第 <span class="number">4</span> 个最小妙数是 <span class="string">"5489355421"</span> ，要想得到这个数字：</span><br><span class="line">- 交换下标 <span class="number">7</span> 和下标 <span class="number">8</span> 对应的位：<span class="string">"5489355142"</span> -&gt; <span class="string">"5489355412"</span></span><br><span class="line">- 交换下标 <span class="number">8</span> 和下标 <span class="number">9</span> 对应的位：<span class="string">"5489355412"</span> -&gt; <span class="string">"5489355421"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"11112"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：第 <span class="number">4</span> 个最小妙数是 <span class="string">"21111"</span> ，要想得到这个数字：</span><br><span class="line">- 交换下标 <span class="number">3</span> 和下标 <span class="number">4</span> 对应的位：<span class="string">"11112"</span> -&gt; <span class="string">"11121"</span></span><br><span class="line">- 交换下标 <span class="number">2</span> 和下标 <span class="number">3</span> 对应的位：<span class="string">"11121"</span> -&gt; <span class="string">"11211"</span></span><br><span class="line">- 交换下标 <span class="number">1</span> 和下标 <span class="number">2</span> 对应的位：<span class="string">"11211"</span> -&gt; <span class="string">"12111"</span></span><br><span class="line">- 交换下标 <span class="number">0</span> 和下标 <span class="number">1</span> 对应的位：<span class="string">"12111"</span> -&gt; <span class="string">"21111"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"00123"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第 <span class="number">1</span> 个最小妙数是 <span class="string">"00132"</span> ，要想得到这个数字：</span><br><span class="line">- 交换下标 <span class="number">3</span> 和下标 <span class="number">4</span> 对应的位：<span class="string">"00123"</span> -&gt; <span class="string">"00132"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= num.length &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 1000</code></li><li><code>num</code> 仅由数字组成</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>第一步我们需要求出第<code>k</code>个<code>next_permutation</code>，即下一个的有序序列和，当然我们可以很快的利用<code>c++</code>的库函数$next_permutation$,如果不知道库如何解决，我们从<code>n-1</code>个字符开始倒序遍历，并记录已经访问过的字符，如果发现已经访问过的字符列表中存在比当前字符$s[i]$大的字符时，此时我们则从已经访问过的字符列表中找到第最小且严格大于$s[i]$的字符，并且进行交换，然后对字符串$s[i+1…n-1]$按照从小到大的顺序进行排列即可，这个就是严格的规律。</li><li>第二部我们需要找到最小的相邻字符的交换次数，此时我们仔细观察，队员元素字符串$src$和原始字符串$dst$我们则进行逐个比较，如果当前字符相等则我们跳过，如果$src[i] != dst[i]$时，则我们从$src[i+1…n-1]$中找到第一个跟$dst[i]$相等的字符$src[j]$，然后我们进行相邻的字符交换，此时我们需要交换的次数为$j-i$。</li><li>继续下一个字符比较，重复<code>2</code>的步骤，知道两个字符串相等，则此时我们得到交换次数即为最小的交换次数。本质题目不是特别难，但是还算需要一点严格的数学证明过程。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinSwaps</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> s = num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr.empty())&#123;</span><br><span class="line">                    curr[s[j]] = j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[j] &lt; curr.rbegin()-&gt;first)&#123;</span><br><span class="line">                        <span class="keyword">auto</span> it = curr.upper_bound(s[j]);</span><br><span class="line">                        <span class="keyword">int</span> x = it-&gt;second;</span><br><span class="line">                        swap(s[j],s[x]);</span><br><span class="line">                        sort(s.begin()+j+<span class="number">1</span>,s.end());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        curr[s[j]] = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == num[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n ; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] == s[i])&#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt; i; --j)&#123;</span><br><span class="line">                num[j] = num[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans += k - i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1851-包含每个查询的最小区间"><a href="#1851-包含每个查询的最小区间" class="headerlink" title="1851. 包含每个查询的最小区间"></a>1851. 包含每个查询的最小区间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [lefti, righti]</code>表示第<code>i</code>个区间开始于 <code>lefti</code> 、结束于 <code>righti</code>（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 <code>righti - lefti + 1</code>。</p><p>再给你一个整数数组 <code>queries</code>。第 j 个查询的答案是满足 <code>lefti &lt;= queries[j] &lt;= righti</code>的 长度最小区间 <code>i</code> 的长度 。如果不存在这样的区间，那么答案是 -1 。</p><p>以数组形式返回对应查询的所有答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">4</span>]], queries = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">解释：查询处理如下：</span><br><span class="line">- Query = <span class="number">2</span> ：区间 [<span class="number">2</span>,<span class="number">4</span>] 是包含 <span class="number">2</span> 的最小区间，答案为 <span class="number">4</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> 。</span><br><span class="line">- Query = <span class="number">3</span> ：区间 [<span class="number">2</span>,<span class="number">4</span>] 是包含 <span class="number">3</span> 的最小区间，答案为 <span class="number">4</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> 。</span><br><span class="line">- Query = <span class="number">4</span> ：区间 [<span class="number">4</span>,<span class="number">4</span>] 是包含 <span class="number">4</span> 的最小区间，答案为 <span class="number">4</span> - <span class="number">4</span> + <span class="number">1</span> = <span class="number">1</span> 。</span><br><span class="line">- Query = <span class="number">5</span> ：区间 [<span class="number">3</span>,<span class="number">6</span>] 是包含 <span class="number">5</span> 的最小区间，答案为 <span class="number">6</span> - <span class="number">3</span> + <span class="number">1</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">int</span>ervals = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">8</span>],[<span class="number">20</span>,<span class="number">25</span>]], queries = [<span class="number">2</span>,<span class="number">19</span>,<span class="number">5</span>,<span class="number">22</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">解释：查询处理如下：</span><br><span class="line">- Query = <span class="number">2</span> ：区间 [<span class="number">2</span>,<span class="number">3</span>] 是包含 <span class="number">2</span> 的最小区间，答案为 <span class="number">3</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span> 。</span><br><span class="line">- Query = <span class="number">19</span>：不存在包含 <span class="number">19</span> 的区间，答案为 <span class="number">-1</span> 。</span><br><span class="line">- Query = <span class="number">5</span> ：区间 [<span class="number">2</span>,<span class="number">5</span>] 是包含 <span class="number">5</span> 的最小区间，答案为 <span class="number">5</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">- Query = <span class="number">22</span>：区间 [<span class="number">20</span>,<span class="number">25</span>] 是包含 <span class="number">22</span> 的最小区间，答案为 <span class="number">25</span> - <span class="number">20</span> + <span class="number">1</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= intervals.length &lt;= 105</code></li><li><code>1 &lt;= queries.length &lt;= 105</code></li><li><code>queries[i].length == 2</code></li><li><code>1 &lt;= lefti &lt;= righti &lt;= 107</code></li><li><code>1 &lt;= queries[j] &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-interval-to-include-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-interval-to-include-each-query</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>优先级队列或者离线二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目跟<code>1847</code>很像，都是利用类似的离线查询加贪心的算法，我们首先按照区间的大小进行排序，然后我们对按照区间的长短从小到大遍历每个区间，每次去查询区间中包含有多少个查询的点，然后将查询的点进行赋值，然后将已经查询到的点进行移除，每次只需依次遍历一遍即可完成该操作。时间复杂度为$O(n<em>lg(n) + m</em>lg(m) + 2n*lg(m))$</li><li>利用优先级队列，我们首先还算将区间按照区间的左端点进行排序，将所有的查询点也按照从小到大进行排序，然后我们依次遍历每一个查询点，我们每次进行遍历时，将所有左起点小于等于$query_{i}$的端点进行入优先级队列。优先级队列中按照区间的长度进行排序，每次我们将所有右端点小于$query_{i}$的区间从队列中去掉，剩余的队列中的第一个元素即为最小的满足的区间。依次遍历即可完成所有的查询。时间复杂度为$O(nlg + mlgm + mlgn)$,其中<code>n</code>为区间的长度，<code>m</code>为查询数组的长度。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li></ol><ul><li>解法1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minInterval(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; itv, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) st.emplace(q[i], i);</span><br><span class="line">        sort(itv.begin(), itv.end(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] - a[<span class="number">0</span>] &lt; b[<span class="number">1</span>] - b[<span class="number">0</span>];&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v : itv)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = st.lower_bound(&#123;v[<span class="number">0</span>], <span class="number">-1</span>&#125;);</span><br><span class="line">            <span class="keyword">while</span>(it != st.end() &amp;&amp; it-&gt;first &lt;= v[<span class="number">1</span>])&#123;</span><br><span class="line">                ans[it-&gt;second] = v[<span class="number">1</span>] - v[<span class="number">0</span>] + <span class="number">1</span>, st.erase(it++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>解法2<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    Node(<span class="keyword">int</span> len,<span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len = len;</span><br><span class="line">        <span class="keyword">this</span>-&gt;end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a, <span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.len &gt; b.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minInterval(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">        sort(intervals.begin(),intervals.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) arr.push_back(&#123;queries[i],i&#125;);</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: arr)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= v[<span class="number">0</span>])&#123;</span><br><span class="line">                pq.push(Node(intervals[i][<span class="number">1</span>]-intervals[i][<span class="number">0</span>]+<span class="number">1</span>,intervals[i][<span class="number">1</span>]));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!pq.empty() &amp;&amp; pq.top().end &lt; v[<span class="number">0</span>])&#123;</span><br><span class="line">                pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!pq.empty())&#123;</span><br><span class="line">                ans[v[<span class="number">1</span>]] = pq.top().len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-239&quot;&gt;&lt;a href=&quot;#leetcode-contest-239&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 239&quot;&gt;&lt;/a&gt;leetcode  contest 239&lt;/h1&gt;&lt;p&gt;感觉周赛的题目还算是稍微好看点，不过最后一题确实不太难，基本上都是暴力加一定的技巧就能做出来。题目比双周赛要难一点，但是不是特别难，感觉至少三题的节奏。&lt;/p&gt;&lt;h2 id=&quot;1848-到目标元素的最小距离&quot;&gt;&lt;a href=&quot;#1848-到目标元素的最小距离&quot; class=&quot;headerlink&quot; title=&quot;1848. 到目标元素的最小距离&quot;&gt;&lt;/a&gt;1848. 到目标元素的最小距离&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; （下标 从 0 开始 计数）以及两个整数 &lt;code&gt;target&lt;/code&gt; 和 &lt;code&gt;start&lt;/code&gt; ，请你找出一个下标 i ，满足 &lt;code&gt;nums[i] == target&lt;/code&gt; 且 &lt;code&gt;abs(i - start)&lt;/code&gt;最小化 。注意：&lt;code&gt;abs(x)&lt;/code&gt;表示 x 的绝对值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
