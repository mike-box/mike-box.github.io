<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-10-10T10:58:52.351Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 262</title>
    <link href="http://yoursite.com/2021/10/09/333/"/>
    <id>http://yoursite.com/2021/10/09/333/</id>
    <published>2021-10-09T08:29:33.238Z</published>
    <updated>2021-10-10T10:58:52.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-262"><a href="#leetcode-contest-262" class="headerlink" title="leetcode contest 262"></a>leetcode contest 262</h1><p>周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.</p><h2 id="5894-至少在两个数组中出现的值"><a href="#5894-至少在两个数组中出现的值" class="headerlink" title="5894. 至少在两个数组中出现的值"></a>5894. 至少在两个数组中出现的值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">3</span> ，在全部三个数组中都出现过。</span><br><span class="line">- <span class="number">2</span> ，在数组 nums1 和 nums2 中出现过。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">3</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">2</span> ，在数组 nums2 和 nums3 中出现过。</span><br><span class="line">- <span class="number">3</span> ，在数组 nums1 和 nums2 中出现过。</span><br><span class="line">- <span class="number">1</span> ，在数组 nums1 和 nums3 中出现过。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>], nums3 = [<span class="number">5</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：不存在至少在两个数组中出现的值。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100</code></li><li><code>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/two-out-of-three" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-out-of-three</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接对每个元素统计它所在的数组的标记，如果标记大于等等于$2$,则我们认为该元素满足题目要求。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为数组的长度,我们此时需要遍历两边即可。</li><li>空间复杂度: $O(N*M)$,其中 $N$ 为每个数组的最长长度, $M$ 为数组的个数.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoOutOfThree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums3) &#123;</span><br><span class="line">            cnt[v].insert(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans.push_back(v.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5895-获取单值网格的最小操作数"><a href="#5895-获取单值网格的最小操作数" class="headerlink" title="5895. 获取单值网格的最小操作数"></a>5895. 获取单值网格的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>m x n</code>的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 加 <code>x</code> 或 减 <code>x</code>。<br>单值网格 是全部元素都相等的网格。<br>返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">8</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：可以执行下述操作使所有元素都等于 <span class="number">4</span> ： </span><br><span class="line">- <span class="number">2</span> 加 x 一次。</span><br><span class="line">- <span class="number">6</span> 减 x 一次。</span><br><span class="line">- <span class="number">8</span> 减 x 两次。</span><br><span class="line">共计 <span class="number">4</span> 次操作。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>]], x = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：可以使所有元素都等于 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：无法使所有元素相等。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>1 &lt;= x, grid[i][j] &lt;= 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简答,典型的数学问题，首先我们需要检测该数组是否能够变成同一个元素：</li></ol><ul><li>需要满足单元格中的任意两个元素的差的绝对值可以被 $v$ 整除.</li><li>我们只需要依次检测相邻的元素的差可以被 $v$ 整除即可.</li><li>我们可以证明,最终的变换元素一定为单元格中的某个元素.</li></ul><ol><li>我们依次尝试每一个元素 $v$,尝试将网格中所有的元素都变为 $v$, 则我们需要所有小于 $v$ 的元素都加上 $x$,所有大于 $v$ 的元素都减去 $x$,$prefix[i]$ 表示前$i$个元素的前缀和,$suffix[i]$ 表示从$i$开始以后的元素的后缀和,我们依次计算得到最小的 $cost[i]$ 即可．计算$cost[i]$的公式为:<script type="math/tex; mode=display">cost[i] = \frac{(i-1)*nums[i] - prefix[i-1]}{x} + \frac{suffix[i+1]-(n-i)*nums[i]}{x}</script></li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n<em>m</em>\lg(m<em>n))$，由于需要一次排序,因此时间复杂度为 $O(n</em>m<em>\lg(m</em>n))$.</li><li>空间复杂度分析: 空间复杂度为$O(m*n)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> k = m*n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[i] - arr[i<span class="number">-1</span>])%x != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; left(k+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; right(k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            left[i+<span class="number">1</span>] = left[i] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">            l = (arr[i]*i - left[i])/x;</span><br><span class="line">            r = (right[i+<span class="number">1</span>] - arr[i]*(k<span class="number">-1</span>-i))/x;</span><br><span class="line">            ans = min(ans,l + r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5896-股票价格波动"><a href="#5896-股票价格波动" class="headerlink" title="5896. 股票价格波动"></a>5896. 股票价格波动</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一支股票价格的数据流。数据流中每一条记录包含一个 时间戳 和该时间点股票对应的 价格 。</p><p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 更正 前一条错误的记录。</p><p>请你设计一个算法，实现：</p><ul><li>更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 更正 之前的错误价格。</li><li>找到当前记录里 最新股票价格 。最新股票价格 定义为时间戳最晚的股票价格。</li><li>找到当前记录里股票的 最高价格 。</li><li>找到当前记录里股票的 最低价格 。<br>请你实现 <code>StockPrice</code> 类：</li><li><code>StockPrice()</code> 初始化对象，当前无股票价格记录。</li><li><code>void update(int timestamp, int price)</code> 在时间点 timestamp 更新股票价格为 <code>price</code> 。</li><li><code>int current()</code> 返回股票 最新价格 。</li><li><code>int maximum()</code> 返回股票 最高价格 。</li><li><code>int minimum()</code> 返回股票 最低价格 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"StockPrice"</span>, <span class="string">"update"</span>, <span class="string">"update"</span>, <span class="string">"current"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"minimum"</span>]</span><br><span class="line">[[], [<span class="number">1</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">5</span>], [], [], [<span class="number">1</span>, <span class="number">3</span>], [], [<span class="number">4</span>, <span class="number">2</span>], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">5</span>, <span class="number">10</span>, null, <span class="number">5</span>, null, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">StockPrice stockPrice = new StockPrice();</span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 时间戳为 [1] ，对应的股票价格为 [10] 。</span></span><br><span class="line">stockPrice.update(<span class="number">2</span>, <span class="number">5</span>);  <span class="comment">// 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。</span></span><br><span class="line">stockPrice.current();     <span class="comment">// 返回 5 ，最新时间戳为 2 ，对应价格为 5 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。</span></span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 之前时间戳为 1 的价格错误，价格更新为 3 。</span></span><br><span class="line">                          <span class="comment">// 时间戳为 [1,2] ，对应股票价格为 [3,5] 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 5 ，更正后最高价格为 5 。</span></span><br><span class="line">stockPrice.update(<span class="number">4</span>, <span class="number">2</span>);  <span class="comment">// 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。</span></span><br><span class="line">stockPrice.minimum();     <span class="comment">// 返回 2 ，最低价格时间戳为 4 ，价格为 2 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= timestamp, price &lt;= 109</code></li><li><code>update</code>，<code>current</code>，<code>maximum</code> 和 <code>minimum</code> 总 调用次数不超过 105 。</li><li><code>current</code>，<code>maximum</code> 和 <code>minimum</code> 被调用时，<code>update</code> 操作 至少 已经被调用过一次. </li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stock-price-fluctuation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stock-price-fluctuation</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> <code>Treemap</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目感觉比第二题要简单一些,我们用<code>TreeMap</code>存储股票的时间戳对应的股票价格即可,会自动按照时间早晚进行存储和更新.</li><li>我们用<code>multiset</code>存储存储股票的所有价格,当出现股票更新操作时,需要将将股票的价格从 $x$ 更新到 $y$ 时,则我们从<code>multiset</code>中删除$x$,并同时插入$y$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(\lg n)$, $\texttt{update}$的时间复杂度为$O(\lg n)$,其余的操作时间复杂度为 $O(1)$.</li><li>空间复杂度为 $O(N)$,我们需要存储所有的股票的价格.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockPrice() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> timestamp, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(timestamp))&#123;</span><br><span class="line">            <span class="built_in">log</span>.erase(<span class="built_in">log</span>.find(cnt[timestamp]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>.insert(price);</span><br><span class="line">        cnt[timestamp] = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.rbegin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.rbegin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.begin();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5897-将数组分成两个数组并最小化数组和的差"><a href="#5897-将数组分成两个数组并最小化数组和的差" class="headerlink" title="5897. 将数组分成两个数组并最小化数组和的差"></a>5897. 将数组分成两个数组并最小化数组和的差</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 两个 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。<code>nums</code> 中每个元素都需要放入两个数组之一。<br>请你返回 最小 的数组和之差。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">3</span>,<span class="number">9</span>] 和 [<span class="number">7</span>,<span class="number">3</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">3</span> + <span class="number">9</span>) - (<span class="number">7</span> + <span class="number">3</span>)) = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-36</span>,<span class="number">36</span>]</span><br><span class="line">输出：<span class="number">72</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">-36</span>] 和 [<span class="number">36</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">-36</span>) - (<span class="number">36</span>)) = <span class="number">72</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">-2</span>,<span class="number">-9</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">-9</span>] 和 [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">2</span> + <span class="number">4</span> + <span class="number">-9</span>) - (<span class="number">-1</span> + <span class="number">0</span> + <span class="number">-2</span>)) = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 15</code></li><li><code>nums.length == 2 * n</code></li><li><code>-107 &lt;= nums[i] &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩 + 二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的很好,还是非常有深度的思考题目,既考虑了状态压缩,也考虑了二分查找.</li><li>如果我们直接枚举所有的含有$n$个元素的子数组的话,时间复杂度为$C_{m}^{n}$,d当$m = 30$时,则总的耗费的时间约为$C_{30}^{15}$，这时肯定会超时.</li><li>此时我们想到用折半的办法,假设数组的长度为$2n$,我们在前$n$个元素中选择$x$个元素,设这$x$个元素的和为$left[x]$;我们在后$n$个元素中选择$n-x$个元素,设这$n-x$个元素的和为$right[n-x]$,则此时我们共选出$n$个元素,这$n$个元素的和为<script type="math/tex">left[x] + right[n-x]</script>,我们设$sum$表示整个数组的元素的和,则我们此时知道两个子数组的差为<script type="math/tex">sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])|</script>,因此我们选取子数组使的上述等式的结果最小即可.</li><li>我们对上式进行变形可以得到:<script type="math/tex; mode=display">\begin{aligned}sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])| \\= |2*left[x]+2*right[n-x] - sum| \\= |(sum - 2*left[x]) - 2*right[n-x]| \\\end{aligned}</script>因此我们只需要找到满足 $(sum - 2<em>left[x])$ 与 $2</em>right[n-x]$ 尽可能的接近即可.因此我们可以对每一个$left[x]$进行枚举,然后我们可以利用二分查找找到最接近的值$2<em>right[n-x]$即可,我们利用状态压缩枚举所有的$(sum - 2</em>left[x])$的值即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(n*2^{n})$，其中$2n$表示数组的长度.</li><li>空间复杂度分析: $O(2^{n})$，其中$2n$表示数组的长度.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = m/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    left += nums[j];</span><br><span class="line">                    right += nums[n+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[__builtin_popcount(i)].push_back(<span class="number">2</span>*right);</span><br><span class="line">            dp[i] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            sort(arr[i].begin(),arr[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = n - __builtin_popcount(i);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = sum - <span class="number">2</span>*dp[i];</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr[x].begin(),arr[x].end(),curr);</span><br><span class="line">            <span class="keyword">if</span>(it == arr[x].begin())&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == arr[x].end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-262&quot;&gt;&lt;a href=&quot;#leetcode-contest-262&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 262&quot;&gt;&lt;/a&gt;leetcode contest 262&lt;/h1&gt;&lt;p&gt;周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.&lt;/p&gt;&lt;h2 id=&quot;5894-至少在两个数组中出现的值&quot;&gt;&lt;a href=&quot;#5894-至少在两个数组中出现的值&quot; class=&quot;headerlink&quot; title=&quot;5894. 至少在两个数组中出现的值&quot;&gt;&lt;/a&gt;5894. 至少在两个数组中出现的值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你三个整数数组 &lt;code&gt;nums1&lt;/code&gt;、&lt;code&gt;nums2&lt;/code&gt; 和 &lt;code&gt;nums3&lt;/code&gt; ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab7 Thread</title>
    <link href="http://yoursite.com/2021/10/08/332/"/>
    <id>http://yoursite.com/2021/10/08/332/</id>
    <published>2021-10-08T15:30:08.810Z</published>
    <updated>2021-10-09T05:25:32.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><p>感觉<code>thread lab</code>是我做的基本上最简单的<code>lab</code>了，但是感觉这个章节是干货最多的章节，很多操作系统的原理和技术实现细节就一下子全部很清晰．再配合<code>lab</code>完成现程的实现,感觉对操作系统的进程调度有了一个非常清晰的认识,是非常值得仔细学习和思考的章节.</p><ul><li><p>时间片调度的本质: CPU内部有定时器,定时器会定期的发起中断.操作系统内核接收到了定时器中断后，通过<code>context</code>切换,从当前进程的内核线程切换内核的进程调度程序，而在调度程序内部会实现对进程的调度．我们仔细分析一下源代码可以知道,进程调度工作的流程．</p></li><li><p>在所有的进程中顺序查找到下一个处在就绪态的进程,然后通过切换上下文将该进程的内核线程切换到<code>CPU</code>中,而该内核线程又通过<code>trapret</code>，<code>cpu</code>恢复到该进程的用户线程.如果当前进程接受到中断时,就会进入<code>usertrap</code>中,在<code>usertrap</code>中检测如果当前为定时器中断,则进行上下文切换切换到内核中的线程调度程序．实际的进程调度分为两种方式，一种方式是时间片到了，当前的进程被动放弃<code>CPU</code>,另一种方式是当前的进程可能需要等待挂起,主动的放弃<code>CPU</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"wfi"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>进程调度的实现原理: 在<code>xv6</code>系统中,进程调度直接顺序查找即可,当然找到下一个线程需要$O(n)$的时间复杂度,在实际的<code>Linux</code>系统中,线程都带有优先级,在做线程切换时,可以利用堆的特性,在 $O(\lg n)$ 的时间复杂度内即可将优先级最高的线程且处于就绪态的线程找出来.</li><li>上下文切换的本质: 本质即为切换寄存器的值.将程序运行过程中的<code>ra</code>以及<code>sp</code>以及几个常用的由<code>callee</code>保存的寄存器进行保存相关的值即可.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, <span class="number">0</span>(a0)</span><br><span class="line">        sd sp, <span class="number">8</span>(a0)</span><br><span class="line">        sd s0, <span class="number">16</span>(a0)</span><br><span class="line">        sd s1, <span class="number">24</span>(a0)</span><br><span class="line">        sd s2, <span class="number">32</span>(a0)</span><br><span class="line">        sd s3, <span class="number">40</span>(a0)</span><br><span class="line">        sd s4, <span class="number">48</span>(a0)</span><br><span class="line">        sd s5, <span class="number">56</span>(a0)</span><br><span class="line">        sd s6, <span class="number">64</span>(a0)</span><br><span class="line">        sd s7, <span class="number">72</span>(a0)</span><br><span class="line">        sd s8, <span class="number">80</span>(a0)</span><br><span class="line">        sd s9, <span class="number">88</span>(a0)</span><br><span class="line">        sd s10, <span class="number">96</span>(a0)</span><br><span class="line">        sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, <span class="number">0</span>(a1)</span><br><span class="line">        ld sp, <span class="number">8</span>(a1)</span><br><span class="line">        ld s0, <span class="number">16</span>(a1)</span><br><span class="line">        ld s1, <span class="number">24</span>(a1)</span><br><span class="line">        ld s2, <span class="number">32</span>(a1)</span><br><span class="line">        ld s3, <span class="number">40</span>(a1)</span><br><span class="line">        ld s4, <span class="number">48</span>(a1)</span><br><span class="line">        ld s5, <span class="number">56</span>(a1)</span><br><span class="line">        ld s6, <span class="number">64</span>(a1)</span><br><span class="line">        ld s7, <span class="number">72</span>(a1)</span><br><span class="line">        ld s8, <span class="number">80</span>(a1)</span><br><span class="line">        ld s9, <span class="number">88</span>(a1)</span><br><span class="line">        ld s10, <span class="number">96</span>(a1)</span><br><span class="line">        ld s11, <span class="number">104</span>(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></li><li>本章还讲述了<code>spin lock</code>的实现原理,感觉非常清晰明了.首先我们需要知道<code>CPU</code>支持的原子操作,一般使用编译器自带的几个通用的原子操作如下，具体可以参考<code>gcc</code>的文档:<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">Gcc手册中《Using the GNU Compiler Collection (GCC)》</a>.</li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value加到*ptr上，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 从*ptr减去value，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相或，结果更新到*ptr， 并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相与，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value异或，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_add_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value加到*ptr上，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_sub_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 从*ptr减去value，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_or_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相或， 结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_and_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_xor_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value异或，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_nand_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line"><span class="keyword">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"><span class="comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true</span></span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"><span class="comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回操作之前*ptr的值</span></span><br><span class="line">__sync_synchronize (...)</span><br><span class="line"><span class="comment">// 发出完整内存栅栏</span></span><br><span class="line">type __sync_lock_test_and_set (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value写入*ptr，对*ptr加锁，并返回操作之前*ptr的值。即，try spinlock语义</span></span><br><span class="line"><span class="keyword">void</span> __sync_lock_release (type *ptr, ...)</span><br><span class="line"><span class="comment">// 将0写入到*ptr，并对*ptr解锁。即，unlock spinlock语义</span></span><br></pre></td></tr></table></figure><ul><li>典型的<code>spin lock</code>的实现，仔细分析一下源代码：</li><li><ul><li><code>acquire</code>期间会关闭中断,这是为了防止死锁.并同时将计数加<code>1</code>.<code>release</code>时,将计数减<code>1</code>,同时会恢复中断.</li></ul></li><li><ul><li>我们会一直等待<code>lk-&gt;locked</code>变为<code>0</code>,如果<code>lk-&gt;locked</code>为<code>1</code>则会一直等待,<code>lk-&gt;locked</code>为<code>0</code>,则我们会继续进程到下一步.</li></ul></li><li><ul><li>从自旋锁的实现方式上来看,我们可以看到自旋锁的资源的消耗还是非常大的,这就需要我们谨慎的使用锁.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">"acquire"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section's memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">release(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">"release"</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn't use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether this cpu is holding the lock.</span></span><br><span class="line"><span class="comment">// Interrupts must be off.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">holding(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">push_off(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">pop_off(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> = <span class="title">mycpu</span>();</span></span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">"pop_off - interruptible"</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"pop_off"</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>线程的切换：在XV6中，任何时候都需要经历：</p></li></ul><ol><li>从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存<br>用户进程的状态并运行第一个用户进程的内核线程。</li><li>再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。</li><li>之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。</li><li>最后返回到第二个用户进程继续执行。<br><img src="https://i.loli.net/2021/10/09/OuJrW8gPRQfx9nU.png" alt></li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>本次<code>lab</code>的几个程序倒是非常简单.<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-cow-handin" target="_blank" rel="noopener">git repo</a></p><h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your job <span class="keyword">is</span> <span class="keyword">to</span> come up <span class="keyword">with</span> a plan <span class="keyword">to</span> create threads <span class="keyword">and</span> save/restore registers <span class="keyword">to</span> switch between threads, <span class="keyword">and</span> implement that plan. <span class="keyword">When</span> you<span class="comment">'re done, make grade should say that your solution passes the uthread test.</span></span><br></pre></td></tr></table></figure><p>实现几个基本线程的切换：上下文切换这部分最难，但是我们可以直接可以参考<code>switch.S</code>的实现，直接<code>copy</code>过来即可.关于线程切换时．每个线程都有独立的栈，我们在初始化线程时，会将线程的上下文中<code>sp</code>和<code>ra</code>进行初始化,分别指向当前线程的栈的高位地址,返回地址则指向线程的起始函数地址.</p><ul><li>最坑的一个<code>bug</code>是: 线程的栈的地址是从高地址向低地址增长,刚开始没有发现这个问题,直接将低地址赋给$sp$,然后总是出错.莫名奇妙的会改写线程的状态,总是找不到原因,最终查看,由于栈的地址是从高往低增长,我们在对栈进行操作时会覆盖掉$thread$结构体中的其他信息和内容.</li><li>关于线程的定义:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread's stack */</span></span><br><span class="line">  <span class="keyword">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>       <span class="comment">/* thread context */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>thread_switch</strong>定义：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">sd ra, <span class="number">0</span>(a0)</span><br><span class="line">    sd sp, <span class="number">8</span>(a0)</span><br><span class="line">    sd s0, <span class="number">16</span>(a0)</span><br><span class="line">    sd s1, <span class="number">24</span>(a0)</span><br><span class="line">    sd s2, <span class="number">32</span>(a0)</span><br><span class="line">    sd s3, <span class="number">40</span>(a0)</span><br><span class="line">    sd s4, <span class="number">48</span>(a0)</span><br><span class="line">    sd s5, <span class="number">56</span>(a0)</span><br><span class="line">    sd s6, <span class="number">64</span>(a0)</span><br><span class="line">    sd s7, <span class="number">72</span>(a0)</span><br><span class="line">    sd s8, <span class="number">80</span>(a0)</span><br><span class="line">    sd s9, <span class="number">88</span>(a0)</span><br><span class="line">    sd s10, <span class="number">96</span>(a0)</span><br><span class="line">    sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, <span class="number">0</span>(a1)</span><br><span class="line">    ld sp, <span class="number">8</span>(a1)</span><br><span class="line">    ld s0, <span class="number">16</span>(a1)</span><br><span class="line">    ld s1, <span class="number">24</span>(a1)</span><br><span class="line">    ld s2, <span class="number">32</span>(a1)</span><br><span class="line">    ld s3, <span class="number">40</span>(a1)</span><br><span class="line">    ld s4, <span class="number">48</span>(a1)</span><br><span class="line">    ld s5, <span class="number">56</span>(a1)</span><br><span class="line">    ld s6, <span class="number">64</span>(a1)</span><br><span class="line">    ld s7, <span class="number">72</span>(a1)</span><br><span class="line">    ld s8, <span class="number">80</span>(a1)</span><br><span class="line">    ld s9, <span class="number">88</span>(a1)</span><br><span class="line">    ld s10, <span class="number">96</span>(a1)</span><br><span class="line">    ld s11, <span class="number">104</span>(a1)</span><br><span class="line">    </span><br><span class="line">ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure></li><li>线程初始化：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">thread_create(<span class="keyword">void</span> (*func)())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;t-&gt;context,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct context));</span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>线程调度与切换:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">thread_schedule(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>, *<span class="title">next_thread</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find another runnable thread. */</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br><span class="line">  t = current_thread + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">      t = all_thread;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">      next_thread = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next_thread == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread_schedule: no runnable threads\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;context,(uint64)&amp;next_thread-&gt;context);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">     next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you will explore <span class="keyword">parallel</span> programming <span class="keyword">with</span> threads <span class="keyword">and</span> locks <span class="keyword">using</span> a hash table. You should <span class="keyword">do</span> this assignment <span class="keyword">on</span> a real Linux <span class="keyword">or</span> MacOS computer (<span class="keyword">not</span> xv6, <span class="keyword">not</span> qemu) that <span class="keyword">has</span> multiple cores. Most recent laptops have multicore processors.</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>在多线程下,多个线程同时更新和查找<code>hash table</code>,会出现数据竞争的问题,如何去解决该问题?很明显就是加锁，在更新<code>hash table</code>时加锁,防止两个线程同时更新<code>hash tbale</code>即可.</p></li><li><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> = 0;</span></span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;lock);</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you<span class="symbol">'ll</span> implement a barrier: a point <span class="keyword">in</span> an application at which <span class="keyword">all</span> participating threads must <span class="keyword">wait</span> <span class="keyword">until</span> <span class="keyword">all</span> other participating threads reach that point too. You<span class="symbol">'ll</span> <span class="keyword">use</span> pthread condition variables, which are a <span class="keyword">sequence</span> coordination technique similar <span class="keyword">to</span> xv6<span class="symbol">'s</span> sleep <span class="keyword">and</span> wakeup.</span><br></pre></td></tr></table></figure><ul><li>题目中用了多个线程的同步,实际上利用了条件变量<code>cond</code>,这个与<code>C++</code>中的条件变量实现原理类似<code>condition_variable</code>, 可以参考<code>pthread_cond_wait</code>与<code>pthread_cond_timedwait</code>的用法.<a href="https://baike.baidu.com/item/pthread_cond_wait/3011997?fr=aladdin" target="_blank" rel="noopener">cond</a></li><li><ul><li>阻塞功能: 必须和一个互斥锁配合，以防止多个线程同时请求<code>pthread_cond_wait()</code>（或<code>pthread_cond_timedwait()</code>，下同）的竞争条件（<code>Race Condition</code>）。<code>mutex</code>互斥锁必须是普通锁（<code>PTHREAD_MUTEX_TIMED_NP</code>）或者适应锁（<code>PTHREAD_MUTEX_ADAPTIVE_NP</code>），且在调用pthread_cond_wait()前必须由本线程加锁（<code>pthread_mutex_lock()</code>），而在更新条件等待队列以前，<code>mutex</code>保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开<code>pthread_cond_wait()</code>之前，<code>mutex</code>将被重新加锁，以与进入<code>pthread_cond_wait()</code>前的加锁动作对应。阻塞时处于解锁状态。</li></ul></li><li><ul><li>pthread_cond_wait进入阻塞时,则会释放锁,从而别的线程可以获取到该锁;当<code>pthread_cond_wait</code>被唤醒时,则又会加锁,因此当它唤醒后,还需要释放锁的操作.</li></ul></li><li><ul><li>在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应</li></ul></li><li><ul><li>激活功能: 激发条件有两种形式，<code>pthread_cond_signal()</code>激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而<code>pthread_cond_broadcast()</code>则激活所有等待线程。</li></ul></li><li><p>重要函数的使用说明:　使用<code>pthread_mutex_lock(&amp;mutex1)</code>;加互斥所，然后在<code>pthread_cond_wait(&amp;cond, &amp;mutex1)</code>;这样可以保证这期间没有<code>pthread_cond_broadcast</code>或者<code>pthread_cond_signal</code>操作，从而保证条件不会丢失，当<code>pthread_cond_wait(&amp;cond, &amp;mutex1)</code>;</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">barrier()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">　<span class="comment">// acquire mutex</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread == nthread)&#123;</span><br><span class="line">  bstate.round += <span class="number">1</span>;</span><br><span class="line">  bstate.nthread = <span class="number">0</span>;</span><br><span class="line">  pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  pthread_cond_wait(&amp;bstate.barrier_cond,&amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul><li>通过这一章几个重要的原理讲解,非常清晰的了解操作系统进程调度的第层实现原理与锁的实现原理.</li><li>通过学习<code>pthread_cond_wait</code>的原理从而能够学习<code>c++</code>中<code>conditional_variable</code>的原理.</li><li>下一步计划:</li><li><ul><li>完成<code>option chanllenge</code>的<code>project</code>;</li></ul></li><li><ul><li>学习<code>conditional_variable</code>的实现原理;</li></ul></li><li><ul><li>阅读<code>pthread_cond_wait</code>的源代码.<h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ul></li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;thread&quot;&gt;&lt;a href=&quot;#thread&quot; class=&quot;headerlink&quot; title=&quot;thread&quot;&gt;&lt;/a&gt;thread&lt;/h1&gt;&lt;p&gt;感觉&lt;code&gt;thread lab&lt;/code&gt;是我做的基本上最简单的&lt;code&gt;lab&lt;/code&gt;了，但是感觉这个章节是干货最多的章节，很多操作系统的原理和技术实现细节就一下子全部很清晰．再配合&lt;code&gt;lab&lt;/code&gt;完成现程的实现,感觉对操作系统的进程调度有了一个非常清晰的认识,是非常值得仔细学习和思考的章节.&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;时间片调度的本质: CPU内部有定时器,定时器会定期的发起中断.操作系统内核接收到了定时器中断后，通过&lt;code&gt;context&lt;/code&gt;切换,从当前进程的内核线程切换内核的进程调度程序，而在调度程序内部会实现对进程的调度．我们仔细分析一下源代码可以知道,进程调度工作的流程．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在所有的进程中顺序查找到下一个处在就绪态的进程,然后通过切换上下文将该进程的内核线程切换到&lt;code&gt;CPU&lt;/code&gt;中,而该内核线程又通过&lt;code&gt;trapret&lt;/code&gt;，&lt;code&gt;cpu&lt;/code&gt;恢复到该进程的用户线程.如果当前进程接受到中断时,就会进入&lt;code&gt;usertrap&lt;/code&gt;中,在&lt;code&gt;usertrap&lt;/code&gt;中检测如果当前为定时器中断,则进行上下文切换切换到内核中的线程调度程序．实际的进程调度分为两种方式，一种方式是时间片到了，当前的进程被动放弃&lt;code&gt;CPU&lt;/code&gt;,另一种方式是当前的进程可能需要等待挂起,主动的放弃&lt;code&gt;CPU&lt;/code&gt;.&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;usertrap(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; which_dev = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((r_sstatus() &amp;amp; SSTATUS_SPP) != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    panic(&lt;span class=&quot;string&quot;&gt;&quot;usertrap: not from user mode&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// send interrupts and exceptions to kerneltrap(),&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// since we&#39;re now in the kernel.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  w_stvec((uint64)kernelvec);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;proc&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;myproc&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// save user program counter.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  p-&amp;gt;trapframe-&amp;gt;epc = r_sepc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r_scause() == &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// system call&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;killed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// sepc points to the ecall instruction,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// but we want to return to the next instruction.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;trapframe-&amp;gt;epc += &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// an interrupt will change sstatus &amp;amp;c registers,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// so don&#39;t enable until done with those registers.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    intr_on();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    syscall();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((which_dev = devintr()) != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ok&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;usertrap(): unexpected scause %p pid=%d\n&quot;&lt;/span&gt;, r_scause(), p-&amp;gt;pid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;            sepc=%p stval=%p\n&quot;&lt;/span&gt;, r_sepc(), r_stval());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;killed = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;killed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// give up the CPU if this is a timer interrupt.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(which_dev == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yield();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  usertrapret();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Avoid deadlock by ensuring that devices can interrupt.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    intr_on();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nproc = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(p = proc; p &amp;lt; &amp;amp;proc[NPROC]; p++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      acquire(&amp;amp;p-&amp;gt;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;state != UNUSED) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nproc++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;state == RUNNABLE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Switch to chosen process.  It is the process&#39;s job&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// to release its lock and then reacquire it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// before jumping back to us.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p-&amp;gt;state = RUNNING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c-&amp;gt;proc = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        swtch(&amp;amp;c-&amp;gt;context, &amp;amp;p-&amp;gt;context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Process is done running for now.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// It should have changed its p-&amp;gt;state before coming back.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c-&amp;gt;proc = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      release(&amp;amp;p-&amp;gt;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nproc &amp;lt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// only init and sh exist&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      intr_on();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volatile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;wfi&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;进程调度的实现原理: 在&lt;code&gt;xv6&lt;/code&gt;系统中,进程调度直接顺序查找即可,当然找到下一个线程需要$O(n)$的时间复杂度,在实际的&lt;code&gt;Linux&lt;/code&gt;系统中,线程都带有优先级,在做线程切换时,可以利用堆的特性,在 $O(\lg n)$ 的时间复杂度内即可将优先级最高的线程且处于就绪态的线程找出来.&lt;/li&gt;
&lt;li&gt;上下文切换的本质: 本质即为切换寄存器的值.将程序运行过程中的&lt;code&gt;ra&lt;/code&gt;以及&lt;code&gt;sp&lt;/code&gt;以及几个常用的由&lt;code&gt;callee&lt;/code&gt;保存的寄存器进行保存相关的值即可.&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.globl swtch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swtch:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd ra, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd sp, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s0, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s1, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s2, &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s3, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s4, &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s5, &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s6, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s7, &lt;span class=&quot;number&quot;&gt;72&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s8, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s9, &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s10, &lt;span class=&quot;number&quot;&gt;96&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s11, &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld ra, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld sp, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s0, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s1, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s2, &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s3, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s4, &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s5, &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s6, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s7, &lt;span class=&quot;number&quot;&gt;72&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s8, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s9, &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s10, &lt;span class=&quot;number&quot;&gt;96&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s11, &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;本章还讲述了&lt;code&gt;spin lock&lt;/code&gt;的实现原理,感觉非常清晰明了.首先我们需要知道&lt;code&gt;CPU&lt;/code&gt;支持的原子操作,一般使用编译器自带的几个通用的原子操作如下，具体可以参考&lt;code&gt;gcc&lt;/code&gt;的文档:&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gcc手册中《Using the GNU Compiler Collection (GCC)》&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 261</title>
    <link href="http://yoursite.com/2021/10/05/331/"/>
    <id>http://yoursite.com/2021/10/05/331/</id>
    <published>2021-10-05T03:14:03.459Z</published>
    <updated>2021-10-05T08:09:41.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-261"><a href="#leetcode-contest-261" class="headerlink" title="leetcode contest 261"></a>leetcode contest 261</h1><p>周赛题目质量非常不错，还是继续三道题的节奏。</p><h2 id="2027-转换字符串的最少操作次数"><a href="#2027-转换字符串的最少操作次数" class="headerlink" title="2027. 转换字符串的最少操作次数"></a>2027. 转换字符串的最少操作次数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，由 <code>n</code> 个字符组成，每个字符不是 <code>&#39;X&#39;</code> 就是 <code>&#39;O&#39;</code> 。</p><p>一次 操作 定义为从<code>s</code>中选出 三个连续字符 并将选中的每个字符都转换为 <code>&#39;O&#39;</code>。注意，如果字符已经是 <code>&#39;O&#39;</code>，只需要保持 不变 。</p><a id="more"></a><p>返回将 <code>s</code>中所有字符均转换为 <code>&#39;O</code>‘ 需要执行的 最少 操作次数。</p><p>示例 1：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"XXX"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：XXX -&gt; OOO</span><br><span class="line">一次操作，选中全部 <span class="number">3</span> 个字符，并将它们转换为 <span class="string">'O'</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"XXOX"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：XXOX -&gt; OOOX -&gt; OOOO</span><br><span class="line">第一次操作，选择前 <span class="number">3</span> 个字符，并将这些字符转换为 <span class="string">'O'</span> 。</span><br><span class="line">然后，选中后 <span class="number">3</span> 个字符，并执行转换。最终得到的字符串全由字符 <span class="string">'O'</span> 组成。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"OOOO"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：s 中不存在需要转换的 'X' 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 1000</code></li><li><code>s[i]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-convert-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-moves-to-convert-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接转化即可，每次尝试改变三个字符即可。</li><li>尝试所有可能性即可，时间复杂度为 $O(N)$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; s[pos] == <span class="string">'O'</span>) pos++;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; s[pos] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ans += (curr + <span class="number">2</span>)/<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr%<span class="number">3</span>)&#123;</span><br><span class="line">                pos += <span class="number">3</span>-(curr%<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="2028-找出缺失的观测数据"><a href="#2028-找出缺失的观测数据" class="headerlink" title="2028. 找出缺失的观测数据"></a>2028. 找出缺失的观测数据</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>现有一份 <code>n + m</code> 次投掷单个 六面 骰子的观测数据，骰子的每个面从 <code>1</code>到 <code>6</code>编号。观测数据中缺失了 <code>n</code>份，你手上只拿到剩余 <code>m</code> 次投掷的数据。幸好你有之前计算过的这 <code>n + m</code> 次投掷数据的 平均值 。</p><p>给你一个长度为<code>m</code>的整数数组 <code>rolls</code> ，其中 <code>rolls[i]</code> 是第 <code>i</code> 次观测的值。同时给你两个整数 <code>mean</code> 和 <code>n</code>。</p><p>返回一个长度为 <code>n</code> 的数组，包含所有缺失的观测数据，且满足这 <code>n + m</code> 次投掷的 平均值 是 <code>mean</code> 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p><p><code>k</code>个数字的 平均值 为这些数字求和后再除以 <code>k</code>。</p><p>注意 <code>mean</code> 是一个整数，所以 <code>n + m</code> 次投掷的总和需要被 <code>n + m</code>整除。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], mean = <span class="number">4</span>, n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (<span class="number">3</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">6</span> + <span class="number">6</span>) / <span class="number">6</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>], mean = <span class="number">3</span>, n = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (<span class="number">1</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">2</span>) / <span class="number">7</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], mean = <span class="number">6</span>, n = <span class="number">4</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：无论丢失的 <span class="number">4</span> 次数据是什么，平均值都不可能是 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>], mean = <span class="number">3</span>, n = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">5</span>]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (<span class="number">1</span> + <span class="number">5</span>) / <span class="number">2</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示:</p><ul><li><code>m == rolls.length</code></li><li><code>1 &lt;= n, m &lt;= 105</code></li><li><code>1 &lt;= rolls[i], mean &lt;= 6</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-missing-observations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-missing-observations</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目其实非常简答，首先我们需要求出缺失的 $n$ 份数据的总和 $sum$，$sum$ 满足合法的条件为 $6 \le sum \le 6*n$.</li><li>我们可以选择任意一种方法分配即可,一种比较直接的简单方法为 $n$ 份数据中的每个元素 $nums[i] = \frac{sum}{n} + sum \mod n$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N + M)$，所有数据的总量．</li><li>空间复杂度分析: 空间复杂度为$O(N)$,其中$N$为缺失数据的长度．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; missingRolls(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rolls, <span class="keyword">int</span> mean, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = rolls.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : rolls) sum += v;</span><br><span class="line">        <span class="keyword">int</span> tot = mean*(n+m) - sum;</span><br><span class="line">        <span class="keyword">if</span>(tot &gt; <span class="number">6</span>*n || tot &lt; n) <span class="keyword">return</span> ans;</span><br><span class="line">        ans = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans[i] = tot/n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (tot%n); ++i)&#123;</span><br><span class="line">            ans[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2029-石子游戏-IX"><a href="#2029-石子游戏-IX" class="headerlink" title="2029. 石子游戏 IX"></a>2029. 石子游戏 IX</h2><p><code>Alice</code> 和 <code>Bob</code> 再次设计了一款新的石子游戏。现有一行 <code>n</code> 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code>是第 <code>i</code>个石子的价值。</p><p><code>Alice</code> 和 <code>Bob</code> 轮流进行自己的回合，<code>Alice</code> 先手。每一回合，玩家需要从 <code>stones</code> 中移除任一石子。</p><ul><li>如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 <code>3</code> 整除，那么该玩家就 输掉游戏 。</li><li>如果不满足上一条，且移除后没有任何剩余的石子，那么 <code>Bob</code>将会直接获胜（即便是在<code>Alice</code> 的回合）。<br>假设两位玩家均采用 最佳 决策。如果<code>Alice</code> 获胜，返回 <code>true</code> ；如果 <code>Bob</code> 获胜，返回 <code>false</code>。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：游戏进行如下：</span><br><span class="line">- 回合 <span class="number">1</span>：Alice 可以移除任意一个石子。</span><br><span class="line">- 回合 <span class="number">2</span>：Bob 移除剩下的石子。 </span><br><span class="line">已移除的石子的值总和为 <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> 且可以被 <span class="number">3</span> 整除。因此，Bob 输，Alice 获胜。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：Alice 会移除唯一一个石子，已移除石子的值总和为 <span class="number">2</span> 。 </span><br><span class="line">由于所有石子都已移除，且值总和无法被 <span class="number">3</span> 整除，Bob 获胜。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：</span><br><span class="line">- 回合 <span class="number">1</span>：Alice 可以移除值为 <span class="number">1</span> 的第 <span class="number">2</span> 个石子。已移除石子值总和为 <span class="number">1</span> 。</span><br><span class="line">- 回合 <span class="number">2</span>：Bob 可以移除值为 <span class="number">3</span> 的第 <span class="number">5</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br><span class="line">- 回合 <span class="number">3</span>：Alices 可以移除值为 <span class="number">4</span> 的第 <span class="number">4</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">8</span> 。</span><br><span class="line">- 回合 <span class="number">4</span>：Bob 可以移除值为 <span class="number">2</span> 的第 <span class="number">3</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">10.</span></span><br><span class="line">- 回合 <span class="number">5</span>：Alice 可以移除值为 <span class="number">5</span> 的第 <span class="number">1</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">2</span> + <span class="number">5</span> = <span class="number">15.</span></span><br><span class="line">Alice 输掉游戏，因为已移除石子值总和（<span class="number">15</span>）可以被 <span class="number">3</span> 整除，Bob 获胜。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= stones.length &lt;= 105</code></li><li><code>1 &lt;= stones[i] &lt;= 104</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stone-game-ix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-ix</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>贪心算法，每个人都会防止当前已经取得的石子总和能够被 $3$ 整除，则 $\textit{Bob}$ 和 $\textit{Alice}$ 的最优选择一定如下:</li></ol><ul><li>如果 $\textit{Alice}$ 第一次选择的是 $1$，我们暂时不考虑能被 $3$ 整除的数，则 $Bob$ 的选择一定为 $1$,紧接着 $\textit{Alice}$ 选择 $2$,$Bob$会选择 $1$,二者的选择序列一定为:$1,1,2,1,2,1,2,…$.直达无法按照上述规律继续取石头为止,而能被 $3$ 整除的数则可以在上述序列中的任意为止插入即可,因此我们只需要找到按照上述规律组成的序列的最长长度即可.如果组成的最长长度能够被 $2$ 整除,则表示 $Bob$为最后一个取,下一次轮到 $ALICE$ 取时一定会打破上述规律,导致已经取的数据的和被 $3$ 整除.</li><li>如果 $\textit{Alice}$ 第一次选择的是 $2$，我们暂时不考虑能被 $3$ 整除的数，则 $Bob$ 的选择一定为 $2$,紧接着 $\textit{Alice}$ 选择 $1$,$Bob$会选择 $2$,二者的选择序列一定为:$2,2,1,2,1,2,1,…$.直达无法按照上述规律继续取石头为止,而能被 $3$ 整除的数则可以在上述序列中的任意为止插入即可,因此我们只需要找到按照上述规律组成的序列的最长长度即可.如果组成的最长长度能够被 $2$ 整除,则表示 $Bob$为最后一个取,下一次轮到 $ALICE$ 取时一定会打破上述规律,导致已经取的数据的和被 $3$ 整除.</li><li>特殊情况需要考虑的是,假如$ALICE$ 取最后一个剩余得数,则此时$ALICE$会失败.</li><li>我们只需要按照贪心算法,如果 $\textit{Alice}$ 尝试先手取 $1$ 能够保证 $ALICE$ 一定赢,则我们直接先手取 $1$;如果 $\textit{Alice}$ 尝试先手取 $2$ 能够保证 $ALICE$ 一定赢,则我们直接先手取 $2$,</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$, 其中 $N$ 表示数组的长度.</li><li>空间复杂度为 $O(1)$, 我们只需要三个变量分别存储当前数组中.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGameIX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : stones) &#123;</span><br><span class="line">            cnt[v%<span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*first one:1121212....*/</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = min(cnt[<span class="number">1</span>]<span class="number">-1</span>,cnt[<span class="number">2</span>]);</span><br><span class="line">            maxlen = <span class="number">1</span> + a*<span class="number">2</span> + cnt[<span class="number">0</span>] + ((cnt[<span class="number">1</span>] - <span class="number">1</span>) &gt; a ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>((maxlen%<span class="number">2</span>) &amp;&amp; maxlen != n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*first two:2212121....*/</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = min(cnt[<span class="number">1</span>],cnt[<span class="number">2</span>]<span class="number">-1</span>);</span><br><span class="line">            maxlen = <span class="number">1</span> + a*<span class="number">2</span> + cnt[<span class="number">0</span>] + ((cnt[<span class="number">2</span>] - <span class="number">1</span>) &gt; a ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>((maxlen%<span class="number">2</span>) &amp;&amp; maxlen != n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2030-含特定字母的最小子序列"><a href="#2030-含特定字母的最小子序列" class="headerlink" title="2030. 含特定字母的最小子序列"></a>2030. 含特定字母的最小子序列</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，一个整数 <code>k</code> ，一个字母 <code>letter</code> 以及另一个整数 <code>repetition</code>。</p><p>返回 <code>s</code>中长度为 <code>k</code>且 字典序最小 的子序列，该子序列同时应满足字母 <code>letter</code>出现 至少 <code>repetition</code> 次。生成的测试用例满足 <code>letter</code>在 <code>s</code> 中出现 至少 <code>repetition</code> 次。</p><p>子序列 是由原字符串删除一些（或不删除）字符且不改变剩余字符顺序得到的剩余字符串。</p><p>字符串 <code>a</code> 字典序比字符串 <code>b</code> 小的定义为：在 <code>a</code> 和<code>b</code>出现不同字符的第一个位置上，字符串<code>a</code>的字符在字母表中的顺序早于字符串 b 的字符。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leet"</span>, k = <span class="number">3</span>, letter = <span class="string">"e"</span>, repetition = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"eet"</span></span><br><span class="line">解释：存在 <span class="number">4</span> 个长度为 <span class="number">3</span> ，且满足字母 'e' 出现至少 <span class="number">1</span> 次的子序列：</span><br><span class="line">- <span class="string">"lee"</span>（<span class="string">"leet"</span>）</span><br><span class="line">- <span class="string">"let"</span>（<span class="string">"leet"</span>）</span><br><span class="line">- <span class="string">"let"</span>（<span class="string">"leet"</span>）</span><br><span class="line">- <span class="string">"eet"</span>（<span class="string">"leet"</span>）</span><br><span class="line">其中字典序最小的子序列是 <span class="string">"eet"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">4</span>, letter = <span class="string">"e"</span>, repetition = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"ecde"</span></span><br><span class="line">解释：<span class="string">"ecde"</span> 是长度为 <span class="number">4</span> 且满足字母 <span class="string">"e"</span> 出现至少 <span class="number">2</span> 次的字典序最小的子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"bb"</span>, k = <span class="number">2</span>, letter = <span class="string">"b"</span>, repetition = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"bb"</span></span><br><span class="line">解释：<span class="string">"bb"</span> 是唯一一个长度为 <span class="number">2</span> 且满足字母 <span class="string">"b"</span> 出现至少 <span class="number">2</span> 次的子序列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= repetition &lt;= k &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>letter</code> 是一个小写英文字母，在 <code>s</code> 中至少出现 <code>repetition</code> 次</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们贪心算法，依次尝试 $k$个位置处所有可能的字符组合,找到索引最小且满足题目要求的组合即可.我们记录当前目标字符中已经压入到栈中的最后一个字符的索引为 $last$,我们记录当前已经压入到栈中的字符 $\textit{letter}$ 的个数,我们记录当前栈中的长度为$len$.假设我们已经找到的目标字符串的长度为 $i$, 最后一个字符的索引为 $last$,当前的目标字符串中已经包含 $\textit{letter}$ 的个数为 $repetition$,则我们在寻找第$i+1$ 个字符时,应当按照如下规则进行尝试:</li></ol><ul><li>我们从原始字符串的索引 $0$ 开始依次尝试.</li><li>我们按照字符的从小到大的顺序开始尝试,即我们从 $\texttt{‘a’}$ 到 $\texttt{‘z’}$ 开始尝试,这样才能保证字符串的字典序最小;</li><li>索引小于当前字符串的最后的索引 $last$ 的字符全部需要跳过, 这样才能保证子序列的正确顺序；</li><li>假设我们可以将当前的索引 $k$ 的字符加入到字符串中的第 $i+1$ 个字符,则必须满足以下几个条件:<ul><li>索引 $k+1$ 以后的字符串中至少还需要包含 $n - k - 1$ 个字符;</li><li>索引 $k$ 以后的字符串中至少还需要包含 $repetition$ 个$\textit{letter}$;</li><li>如果索引 $k$ 的对应的字符为 $letter$,则索引 $k+1$ 以后的字符串中至少还需要包含 $repetition-1$ 个$\textit{letter}$,且目标字符串中剩余的位置还能够满足可以放置$repetition-1$ 个字符;如果索引 $k$ 的对应的字符不为 $letter$,则索引 $k+1$ 以后的字符串中至少还需要包含 $repetition$ 个$\textit{letter}$,且目标字符串中剩余的位置还能够满足可以放置$repetition$ 个字符;</li></ul></li></ul><ol><li>非常典型的贪心算法,感觉还算非常不错的题目,值得好好思考的题目,扩展提示如何找到满足要求且字典序最大的字符串？</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(26*K + |S|)$，其中 |S| 表示字符串的长度，$K$ 表示目标字符串的长度.</li><li>空间复杂度分析: $O(K + |S|)$，其中 |S| 表示字符串的长度，$K$ 表示目标字符串的长度.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k, <span class="keyword">char</span> letter, <span class="keyword">int</span> repetition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rem(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            rem[i] = rem[i+<span class="number">1</span>] + (s[i] == letter ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; pos(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pos[s[i] - <span class="string">'a'</span>].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!pos[j].empty() &amp;&amp; pos[j].front() &lt; last) pos[j].pop();</span><br><span class="line">                <span class="comment">// 下一个索引处最少需要 need 个 letter</span></span><br><span class="line">                <span class="keyword">int</span> need = (j == letter - <span class="string">'a'</span>) ? repetition - <span class="number">1</span> : repetition;</span><br><span class="line">                <span class="keyword">if</span>(pos[j].empty() || rem[pos[j].front() + <span class="number">1</span>] &lt; need) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 剩余的字符中至少需要预留 need 个位置, 且剩余的索引中至少应该包含k - i个元素</span></span><br><span class="line">                <span class="keyword">if</span>(k - i - <span class="number">1</span> &gt;= need &amp;&amp; n - pos[j].front() &gt;= k - i) &#123;</span><br><span class="line">                    ans.push_back(<span class="string">'a'</span> + j);</span><br><span class="line">                    <span class="keyword">if</span>(j == letter - <span class="string">'a'</span>) &#123;</span><br><span class="line">                        repetition--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    last = pos[j].front();</span><br><span class="line">                    pos[j].pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-261&quot;&gt;&lt;a href=&quot;#leetcode-contest-261&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 261&quot;&gt;&lt;/a&gt;leetcode contest 261&lt;/h1&gt;&lt;p&gt;周赛题目质量非常不错，还是继续三道题的节奏。&lt;/p&gt;&lt;h2 id=&quot;2027-转换字符串的最少操作次数&quot;&gt;&lt;a href=&quot;#2027-转换字符串的最少操作次数&quot; class=&quot;headerlink&quot; title=&quot;2027. 转换字符串的最少操作次数&quot;&gt;&lt;/a&gt;2027. 转换字符串的最少操作次数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，由 &lt;code&gt;n&lt;/code&gt; 个字符组成，每个字符不是 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 就是 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;一次 操作 定义为从&lt;code&gt;s&lt;/code&gt;中选出 三个连续字符 并将选中的每个字符都转换为 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt;。注意，如果字符已经是 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt;，只需要保持 不变 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 62</title>
    <link href="http://yoursite.com/2021/10/03/330/"/>
    <id>http://yoursite.com/2021/10/03/330/</id>
    <published>2021-10-02T23:49:21.792Z</published>
    <updated>2021-10-03T06:32:30.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-62"><a href="#leetcode-biweekly-contest-62" class="headerlink" title="leetcode  biweekly contest 62"></a>leetcode  biweekly contest 62</h1><p>双周赛的题目质量还算不错，第三题竟然卡壳了好久，第四题感觉应该只能算一个中等难度题目．模拟比赛做了一下，大概排名<code>200</code>多名.</p><h2 id="5871-将一维数组转变成二维数组"><a href="#5871-将一维数组转变成二维数组" class="headerlink" title="5871. 将一维数组转变成二维数组"></a>5871. 将一维数组转变成二维数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的一维整数数组 <code>original</code> 和两个整数 <code>m</code> 和  <code>n</code>。你需要使用 <code>original</code> 中 所有 元素创建一个 <code>m</code> 行 <code>n</code> 列的二维数组。</p><a id="more"></a><p><code>original</code> 中下标从 <code>0</code> 到 <code>n - 1</code> （都 包含 ）的元素构成二维数组的第一行，下标从 <code>n</code> 到 <code>2 * n - 1</code> （都 包含 ）的元素构成二维数组的第二行，依此类推。</p><p>请你根据上述过程返回一个<code>m x n</code>的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：original = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], m = <span class="number">2</span>, n = <span class="number">2</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释：</span><br><span class="line">构造出的二维数组应该包含 <span class="number">2</span> 行 <span class="number">2</span> 列。</span><br><span class="line">original 中第一个 n=<span class="number">2</span> 的部分为 [<span class="number">1</span>,<span class="number">2</span>] ，构成二维数组的第一行。</span><br><span class="line">original 中第二个 n=<span class="number">2</span> 的部分为 [<span class="number">3</span>,<span class="number">4</span>] ，构成二维数组的第二行。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], m = <span class="number">1</span>, n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">构造出的二维数组应该包含 <span class="number">1</span> 行 <span class="number">3</span> 列。</span><br><span class="line">将 original 中所有三个元素放入第一行中，构成要求的二维数组。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original = [<span class="number">1</span>,<span class="number">2</span>], m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">original 中有 <span class="number">2</span> 个元素。</span><br><span class="line">无法将 <span class="number">2</span> 个元素放入到一个 <span class="number">1</span>x1 的二维数组中，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">输入：original = [<span class="number">3</span>], m = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">original 中只有 <span class="number">1</span> 个元素。</span><br><span class="line">无法将 <span class="number">1</span> 个元素放满一个 <span class="number">1</span>x2 的二维数组，所以返回一个空的二维数组。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= original.length &lt;= <span class="number">5</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= original[i] &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= m, n &lt;= <span class="number">4</span> * <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力检测</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接转化即可.</span><br><span class="line"><span class="number">2.</span> 算法时间复杂度为$O(N)$,空间复杂度$O(N)$，其中 $N$ 表示数组的长度.</span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; construct2DArray(vector&lt;<span class="built_in">int</span>&gt;&amp; original, <span class="built_in">int</span> m, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">int</span> tot = original.size();</span><br><span class="line">        <span class="keyword">if</span>(m*n != tot) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        ans = vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;(m,vector&lt;<span class="built_in">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                ans[i][j] = original[i*n + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5872-连接后等于目标字符串的字符串对"><a href="#5872-连接后等于目标字符串的字符串对" class="headerlink" title="5872. 连接后等于目标字符串的字符串对"></a>5872. 连接后等于目标字符串的字符串对</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 数字 字符串数组 <code>nums</code> 和一个 数字 字符串 <code>target</code>，请你返回 <code>nums[i] + nums[j]</code> （两个字符串连接）结果等于 <code>target</code> 的下标 <code>(i, j)</code>（需满足 <code>i != j</code>）的数目。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"777"</span>,<span class="string">"7"</span>,<span class="string">"77"</span>,<span class="string">"77"</span>], target = <span class="string">"7777"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：符合要求的下标对包括：</span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>)：<span class="string">"777"</span> + <span class="string">"7"</span></span><br><span class="line">- (<span class="number">1</span>, <span class="number">0</span>)：<span class="string">"7"</span> + <span class="string">"777"</span></span><br><span class="line">- (<span class="number">2</span>, <span class="number">3</span>)：<span class="string">"77"</span> + <span class="string">"77"</span></span><br><span class="line">- (<span class="number">3</span>, <span class="number">2</span>)：<span class="string">"77"</span> + <span class="string">"77"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"123"</span>,<span class="string">"4"</span>,<span class="string">"12"</span>,<span class="string">"34"</span>], target = <span class="string">"1234"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：符合要求的下标对包括</span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>)：<span class="string">"123"</span> + <span class="string">"4"</span></span><br><span class="line">- (<span class="number">2</span>, <span class="number">3</span>)：<span class="string">"12"</span> + <span class="string">"34"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>], target = <span class="string">"11"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：符合要求的下标对包括</span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">1</span>, <span class="number">0</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">0</span>, <span class="number">2</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">2</span>, <span class="number">0</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">1</span>, <span class="number">2</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">2</span>, <span class="number">1</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= nums.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i].length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">2</span> &lt;= target.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `nums[i]` 和 `target` 只包含数字。</span><br><span class="line">+ `nums[i]` 和 `target` 不含有任何前导 <span class="number">0</span> 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的滑动滑动窗口实现．我们保存所有的字符串，用`hashmap`存储，我们试着尝试`target`的每一种可能的分解，将其分解的前缀和后缀在`hashmap`中查找对应的统计数量即可.</span><br><span class="line">+ 需要注意的是当前字符串的前缀与后缀相同时,此时需要特殊处理一下,假设符合前缀的字符串数量为$n$,则此时符合的组合数量应该为$A_&#123;n&#125;^&#123;<span class="number">2</span>&#125;$.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度分析: 时间复杂度为$O(N*M)$，其中$N$为字符串数组的长度，$M$表示为字符串$\textit&#123;target&#125;$的长度．</span><br><span class="line">+ 空间复杂度分析:　空间复杂度为$O(N*C)$,其中$N$为字符串数组的长度, 其中$C$为字符串数组中每个元素的平均长度.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> numOfPairs(vector&lt;<span class="built_in">string</span>&gt;&amp; nums, <span class="built_in">string</span> target) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = target.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : nums) &#123;</span><br><span class="line">            cnt[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> a = target.substr(<span class="number">0</span>,i);</span><br><span class="line">            <span class="built_in">string</span> b = target.substr(i);</span><br><span class="line">            <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">                <span class="built_in">int</span> x = cnt[a];</span><br><span class="line">                ans += x*(x<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += cnt[a]*cnt[b];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5873-考试的最大困扰度"><a href="#5873-考试的最大困扰度" class="headerlink" title="5873. 考试的最大困扰度"></a>5873. 考试的最大困扰度</h2><p>一位老师正在出一场由<code>n</code>道判断题构成的考试，每道题的答案为 <code>true</code>（用 <code>&#39;T&#39;</code> 表示）或者 <code>false</code> （用 <code>&#39;F&#39;</code> 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 <code>true</code> 或者连续出现 <code>false</code>）。</p><p>给你一个字符串 <code>answerKey</code>，其中 <code>answerKey[i]</code>是第 <code>i</code> 个问题的正确结果。除此以外，还给你一个整数 <code>k</code> ，表示你能进行以下操作的最多次数：</p><ul><li>每次操作中，将问题的正确答案改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> （也就是将 <code>answerKey[i]</code> 改为 <code>&#39;T&#39;</code>或者 <code>&#39;F&#39;</code> ）。<br>请你返回在不超过 <code>k</code> 次操作的情况下，最大 连续 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> 的数目。</li></ul><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：answerKey = <span class="string">"TTFF"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = <span class="string">"TTTT"</span> 。</span><br><span class="line">总共有四个连续的 'T' 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：answerKey = <span class="string">"TFFT"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = <span class="string">"FFFT"</span> 。</span><br><span class="line">或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = <span class="string">"TFFF"</span> 。</span><br><span class="line">两种情况下，都有三个连续的 'F' 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：answerKey = <span class="string">"TTFTTFTT"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：我们可以将第一个 'F' 换成 'T' ，得到 answerKey = <span class="string">"TTTTTFTT"</span> 。</span><br><span class="line">或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = <span class="string">"TTFTTTTT"</span> 。</span><br><span class="line">两种情况下，都有五个连续的 'T' 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == answerKey.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>answerKey[i]</code> 要么是 <code>&#39;T&#39;</code> ，要么是 <code>&#39;F&#39;</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找或者滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>二分查找的思路比较直接和简单,思路如下:</li></ol><ul><li>每次尝试当前可能的最大窗口长度 $\textit{m}$,在当前窗口中检测统计是否满足<code>F</code>或者<code>T</code>的统计数目小于等于<code>k</code>；</li><li>如果满足符合要求的窗口,则我们直接返回即可；</li></ul><ol><li>滑动窗口思路如下:</li></ol><ul><li>我们尝试扩展当前的窗口，如果发现当前的窗口无法满足题目中的要求时，则此时我们尝试收缩窗口．</li><li>我们用 $r$ 指向当前窗口的最右端, $l$ 指向当前窗口的最左段，每次我们扩展最右端;</li><li>当发现当前窗口无法变为连续相同的字符时,则此时我们收获最左端直达当前窗口满足要求即可.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$, 其中 $N$ 表示字符串的长度.</li><li>空间复杂度为 $O(1)$, 我们只需要保存当前字符中<code>T</code>或者<code>F</code>的统计数目即可.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s,<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'T'</span>)&#123;</span><br><span class="line">                curr[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= len) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i-len] == <span class="string">'T'</span>)&#123;</span><br><span class="line">                    pre[<span class="number">0</span>]++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre[<span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= len - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr[<span class="number">0</span>] - pre[<span class="number">0</span>] &lt;= k || curr[<span class="number">1</span>] - pre[<span class="number">1</span>] &lt;= k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(<span class="built_in">string</span> answerKey, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = answerKey.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(answerKey,k,mid)) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>滑动窗口<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(<span class="built_in">string</span> answerKey, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = answerKey.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(answerKey[pos] == <span class="string">'T'</span>) &#123;</span><br><span class="line">                cnt[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(cnt[<span class="number">0</span>] &gt; k &amp;&amp; cnt[<span class="number">1</span>] &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(answerKey[curr] == <span class="string">'T'</span>)&#123;</span><br><span class="line">                    cnt[<span class="number">0</span>]--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt[<span class="number">1</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,pos-curr+<span class="number">1</span>);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5874-分割数组的最多方案数"><a href="#5874-分割数组的最多方案数" class="headerlink" title="5874. 分割数组的最多方案数"></a>5874. 分割数组的最多方案数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始且长度为 <code>n</code> 的整数数组 <code>nums</code> 。分割 数组 nums 的方案数定义为符合以下两个条件的 <code>pivot</code> 数目：</p><ul><li><code>1 &lt;= pivot &lt; n</code></li><li><code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code><br>同时给你一个整数 <code>k</code> 。你可以将 <code>nums</code> 中 一个 元素变为 k 或 不改变 数组。</li></ul><p>请你返回在 至多 改变一个元素的前提下，最多 有多少种方法 分割 <code>nums</code> 使得上述两个条件都满足。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">2</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：一个最优的方案是将 nums[<span class="number">0</span>] 改为 k 。数组变为 [<span class="number">3</span>,<span class="number">-1</span>,<span class="number">2</span>] 。</span><br><span class="line">有一种方法分割数组：</span><br><span class="line">- pivot = <span class="number">2</span> ，我们有分割 [<span class="number">3</span>,<span class="number">-1</span> | <span class="number">2</span>]：<span class="number">3</span> + <span class="number">-1</span> == <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：一个最优的方案是不改动数组。</span><br><span class="line">有两种方法分割数组：</span><br><span class="line">- pivot = <span class="number">1</span> ，我们有分割 [<span class="number">0</span> | <span class="number">0</span>,<span class="number">0</span>]：<span class="number">0</span> == <span class="number">0</span> + <span class="number">0</span> 。</span><br><span class="line">- pivot = <span class="number">2</span> ，我们有分割 [<span class="number">0</span>,<span class="number">0</span> | <span class="number">0</span>]: <span class="number">0</span> + <span class="number">0</span> == <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">22</span>,<span class="number">4</span>,<span class="number">-25</span>,<span class="number">-20</span>,<span class="number">-15</span>,<span class="number">15</span>,<span class="number">-16</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">-10</span>,<span class="number">0</span>,<span class="number">-13</span>,<span class="number">-14</span>], k = <span class="number">-33</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一个最优的方案是将 nums[<span class="number">2</span>] 改为 k 。数组变为 [<span class="number">22</span>,<span class="number">4</span>,<span class="number">-33</span>,<span class="number">-20</span>,<span class="number">-15</span>,<span class="number">15</span>,<span class="number">-16</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">-10</span>,<span class="number">0</span>,<span class="number">-13</span>,<span class="number">-14</span>] 。</span><br><span class="line">有四种方法分割数组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>-105 &lt;= k, nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口 + 前缀和</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们统计所有的索引 $i$ 的前缀和 $prefix[i]$ 和后缀和 $suffix[i]$，我们用 $prefix[i]$ 表示索引从 $0$ 到 $i$ 的元素之和, $suffix[i]$ 表示索引从 $i$ 到 $n-1$ 的元素之和.</li><li>题目中要求替换其中一个元素为 $k$，假设我们将 $nums[j]$ 替换为 $k$, 则二者替换后元素的变化为 $k-nums[j]$,我们只需要找到所有前缀和和后缀和的差值刚好等于元素替换之和的值即可．</li></ol><ul><li>此时我们只需要找到所有满足如下等式的索引 $i$:<script type="math/tex; mode=display">prefix[i] - suffix[i+1] = k - nums[j] \quad ( if  \quad i\ge j) \\suffix[i] - prefix[i-1] = k - nums[j] \quad ( if  \quad i\le j) \\</script></li><li>我们用<code>map</code>存储所有的 $prefix[i] - suffix[i+1]$和$suffix[i] - prefix[i-1]$的值，每次进行查询,并同时更新更新．</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(N)$，其中 $N$ 表示数组的长度.</li><li>空间复杂度分析: $O(N)$，其中 $N$ 表示数组的长度.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; prefix(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; suffix(n);</span><br><span class="line"></span><br><span class="line">        prefix[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        suffix[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            prefix[i] = prefix[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">            suffix[n-i<span class="number">-1</span>] = suffix[n-i] + nums[n-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; right;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prefix[i] == suffix[i+<span class="number">1</span>]) ans++;</span><br><span class="line">            right[suffix[i+<span class="number">1</span>] - prefix[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = k - nums[i];</span><br><span class="line">            ans = max(ans,right[x] + left[x]);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                left[prefix[i] - suffix[i+<span class="number">1</span>]]++;</span><br><span class="line">                right[suffix[i+<span class="number">1</span>] - prefix[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-62&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-62&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 62&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 62&lt;/h1&gt;&lt;p&gt;双周赛的题目质量还算不错，第三题竟然卡壳了好久，第四题感觉应该只能算一个中等难度题目．模拟比赛做了一下，大概排名&lt;code&gt;200&lt;/code&gt;多名.&lt;/p&gt;&lt;h2 id=&quot;5871-将一维数组转变成二维数组&quot;&gt;&lt;a href=&quot;#5871-将一维数组转变成二维数组&quot; class=&quot;headerlink&quot; title=&quot;5871. 将一维数组转变成二维数组&quot;&gt;&lt;/a&gt;5871. 将一维数组转变成二维数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的一维整数数组 &lt;code&gt;original&lt;/code&gt; 和两个整数 &lt;code&gt;m&lt;/code&gt; 和  &lt;code&gt;n&lt;/code&gt;。你需要使用 &lt;code&gt;original&lt;/code&gt; 中 所有 元素创建一个 &lt;code&gt;m&lt;/code&gt; 行 &lt;code&gt;n&lt;/code&gt; 列的二维数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 260</title>
    <link href="http://yoursite.com/2021/09/26/329/"/>
    <id>http://yoursite.com/2021/09/26/329/</id>
    <published>2021-09-26T14:36:48.576Z</published>
    <updated>2021-09-26T15:22:17.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-260"><a href="#leetcode-contest-260" class="headerlink" title="leetcode  contest 260"></a>leetcode  contest 260</h1><p>还是三道题目的节奏,无奈太菜了. 感觉中间两道题目出的很水,第四题其实出的还算比较有水平的题目,不过感觉不算太难.</p><h2 id="5881-增量元素之间的最大差值"><a href="#5881-增量元素之间的最大差值" class="headerlink" title="5881. 增量元素之间的最大差值"></a>5881. 增量元素之间的最大差值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，该数组的大小为 <code>n</code> ，请你计算 <code>nums[j] - nums[i]</code> 能求得的 最大差值 ，其中 <code>0 &lt;= i &lt; j &lt; n</code>且 <code>nums[i] &lt; nums[j]</code> 。</p><a id="more"></a><p>返回 最大差值 。如果不存在满足要求的 <code>i</code> 和 <code>j</code> ，返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">最大差值出现在 i = <span class="number">1</span> 且 j = <span class="number">2</span> 时，nums[j] - nums[i] = <span class="number">5</span> - <span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">注意，尽管 i = <span class="number">1</span> 且 j = <span class="number">0</span> 时 ，nums[j] - nums[i] = <span class="number">7</span> - <span class="number">1</span> = <span class="number">6</span> &gt; <span class="number">4</span> ，但 i &gt; j 不满足题面要求，所以 <span class="number">6</span> 不是有效的答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">不存在同时满足 <span class="built_in">i</span> &lt; <span class="built_in">j</span> 和 nums[<span class="built_in">i</span>] &lt; nums[<span class="built_in">j</span>] 这两个条件的 <span class="built_in">i</span>, <span class="built_in">j</span> 组合。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：</span><br><span class="line">最大差值出现在 i = <span class="number">0</span> 且 j = <span class="number">3</span> 时，nums[j] - nums[i] = <span class="number">10</span> - <span class="number">1</span> = <span class="number">9</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == nums.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">109</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-260/problems/maximum-difference-between-increasing-elements/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力检测</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接暴力检测即可,数据量较小.</span><br><span class="line"><span class="number">2.</span> 算法时间复杂度为$O(N^&#123;<span class="number">2</span>&#125;)$,空间复杂度$O(<span class="number">1</span>)$.当然另一种可以采用排序的方法,时间复杂度可以优化到 $O(n\lg(n))$.</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maximumDifference(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                    ans = max(ans,nums[j]-nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5882-网格游戏"><a href="#5882-网格游戏" class="headerlink" title="5882. 网格游戏"></a>5882. 网格游戏</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的二维数组 <code>grid</code> ，数组大小为 <code>2 x n</code> ，其中 <code>grid[r][c]</code> 表示矩阵中 <code>(r, c)</code> 位置上的点数。现在有两个机器人正在矩阵上参与一场游戏。</p><p>两个机器人初始位置都是 <code>(0, 0)</code> ，目标位置是 <code>(1, n-1)</code> 。每个机器人只会 向右 <code>((r, c)</code> 到 <code>(r, c + 1))</code> 或 向下 <code>((r, c)</code> 到 <code>(r + 1, c))</code> 。</p><p>游戏开始，第一个 机器人从 <code>(0, 0)</code> 移动到 <code>(1, n-1)</code>，并收集路径上单元格的全部点数。对于路径上所有单元格 <code>(r, c)</code> ，途经后 <code>grid[r][c]</code> 会重置为 <code>0</code>。然后，第二个 机器人从 <code>(0, 0)</code> 移动到 <code>(1, n-1)</code> ，同样收集路径上单元的全部点数。注意，它们的路径可能会存在相交的部分。</p><p>第一个 机器人想要打击竞争对手，使 第二个 机器人收集到的点数 最小化 。与此相对，第二个 机器人想要 最大化 自己收集到的点数。两个机器人都发挥出自己的 最佳水平 的前提下，返回 第二个 机器人收集到的 点数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。</span><br><span class="line">第一个机器人访问过的单元格将会重置为 <span class="number">0</span> 。</span><br><span class="line">第二个机器人将会收集到 <span class="number">0</span> + <span class="number">0</span> + <span class="number">4</span> + <span class="number">0</span> = <span class="number">4</span> 个点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。 </span><br><span class="line">第一个机器人访问过的单元格将会重置为 <span class="number">0</span> 。</span><br><span class="line">第二个机器人将会收集到 <span class="number">0</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">0</span> = <span class="number">4</span> 个点。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">15</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。</span><br><span class="line">第一个机器人访问过的单元格将会重置为 <span class="number">0</span> 。</span><br><span class="line">第二个机器人将会收集到 <span class="number">0</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">3</span> + <span class="number">0</span> = <span class="number">7</span> 个点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>grid.length == 2</code></li><li><code>n == grid[r].length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>1 &lt;= grid[r][c] &lt;= 105</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-260/problems/grid-game/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-260/problems/grid-game/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的滑动窗口，设二位数组的长度为 $n$,题目中的关键在于数组只有两行，则我们可以知道第一个机器人最多只有 $n$ 种走法,因此我们可以遍历第一个机器人所有的走法．</li><li>题目中要求,第一个机器人的走法使得第二个机器人收集到的点数最小化 。与此相对，第二个机器人想要最大化自己收集到的点数.因此我们遍历第一个机器人在不同得走法下,使得第二个机器所能收集的最大点数尽可能的小即可. 我们利用前缀和即可,我们假设第一个机器人在第 $i$ 处从第一行走到了第二行,则此时第一个机器人的所收集的点数我们利用前缀和即可得到 $prefix[i+1][0] + prefix[n][1] - prefix[i][1]$，即第一行的前 $i$ 个元素的点数加上第二行的后 $n-i$ 个元素; 此时第二个机器人只有两种可能的走法,要么一直沿着第一行走，要么一直严着第二行走，则其要么获取第一行的后 $n-i$个元素的点数,要么获取第二行的前 $i$ 个元素.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(N)$, 其中$N$为数组的长度.</li><li>空间复杂度为$O(N)$,其中$N$为数组的长度.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gridGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">1e10</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; prefix(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                prefix[i+<span class="number">1</span>][j] = prefix[i][j] + grid[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p1 = prefix[i+<span class="number">1</span>][<span class="number">0</span>] + prefix[n][<span class="number">1</span>] - prefix[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p2 = max(prefix[n][<span class="number">0</span>]-prefix[i+<span class="number">1</span>][<span class="number">0</span>],prefix[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(p2 &lt; curr) &#123;</span><br><span class="line">                curr = p2;</span><br><span class="line">                ans = p2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5883-判断单词是否能放入填字游戏内"><a href="#5883-判断单词是否能放入填字游戏内" class="headerlink" title="5883. 判断单词是否能放入填字游戏内"></a>5883. 判断单词是否能放入填字游戏内</h2><p>给你一个 <code>m x n</code>的矩阵 <code>board</code> ，它代表一个填字游戏 当前 的状态。填字游戏格子中包含小写英文字母（已填入的单词），表示 空 格的 ‘ ‘ 和表示 障碍 格子的 ‘#’ 。</p><p>如果满足以下条件，那么我们可以 水平 （从左到右 或者 从右到左）或 竖直 （从上到下 或者 从下到上）填入一个单词：</p><p>该单词不占据任何 <code>&#39;#&#39;</code> 对应的格子。<br>每个字母对应的格子要么是 ‘ ‘ （空格）要么与 board 中已有字母 匹配 。<br>如果单词是 水平 放置的，那么该单词左边和右边 相邻 格子不能为 ‘ ‘ 或小写英文字母。<br>如果单词是 竖直 放置的，那么该单词上边和下边 相邻 格子不能为 ‘ ‘ 或小写英文字母。<br>给你一个字符串 <code>word</code>，如果 <code>word</code> 可以被放入 <code>board</code> 中，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"#"</span>, <span class="string">" "</span>, <span class="string">"#"</span>], [<span class="string">" "</span>, <span class="string">" "</span>, <span class="string">"#"</span>], [<span class="string">"#"</span>, <span class="string">"c"</span>, <span class="string">" "</span>]], word = <span class="string">"abc"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：单词 <span class="string">"abc"</span> 可以如上图放置（从上往下）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">" "</span>, <span class="string">"#"</span>, <span class="string">"a"</span>], [<span class="string">" "</span>, <span class="string">"#"</span>, <span class="string">"c"</span>], [<span class="string">" "</span>, <span class="string">"#"</span>, <span class="string">"a"</span>]], word = <span class="string">"ac"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：无法放置单词，因为放置该单词后上方或者下方相邻格会有空格。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"#"</span>, <span class="string">" "</span>, <span class="string">"#"</span>], [<span class="string">" "</span>, <span class="string">" "</span>, <span class="string">"#"</span>], [<span class="string">"#"</span>, <span class="string">" "</span>, <span class="string">"c"</span>]], word = <span class="string">"ca"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：单词 <span class="string">"ca"</span> 可以如上图放置（从右到左）。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `m == board.length`</span><br><span class="line">+ `n == board[i].length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= m * n &lt;= <span class="number">2</span> * <span class="number">105</span>`</span><br><span class="line">+ `board[i][j]` 可能为 <span class="string">' '</span> ，<span class="string">'#'</span> 或者一个小写英文字母。</span><br><span class="line">+ `<span class="number">1</span> &lt;= word.length &lt;= max(m, n)`</span><br><span class="line">+ `word` 只包含小写英文字母。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址</span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-260/problems/check-if-word-can-be-placed-in-crossword/</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;  遍历</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 这个题目感觉好无聊，感觉只能算是非常简单的难度，我们遍历所有符合单词的长度的连续格子，然后判断该连续的格子是否满足题目中单词的要求：</span><br><span class="line">+ 设字符串的长度为 $n$ ,该水平或者垂直连续的格子的长度为 $n$, 且满足连续的格子两端只能为障碍物.</span><br><span class="line">+ 判断连续的格子中要么为空格,要么为字符.</span><br><span class="line">+ 我们判断字符的位置是否符合字符串中字符位置的要求</span><br><span class="line"><span class="number">2.</span> 时间复杂度为 $O(N)$, 其中 $N$ 表示矩阵中元素的个数.空间复杂度为 $O(<span class="number">1</span>)$.</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> placeWordInCrossword(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">string</span> word) &#123;</span><br><span class="line">        <span class="keyword">int</span>　n = word.size();</span><br><span class="line">        <span class="keyword">int</span> row = board.size();</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*check row*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; col)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pos &lt; col &amp;&amp; board[i][pos] == <span class="string">'#'</span>) pos++;</span><br><span class="line">                <span class="keyword">int</span> l = pos;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*check space*/</span></span><br><span class="line">                <span class="keyword">while</span>(pos &lt; col &amp;&amp; board[i][pos]!= <span class="string">'#'</span>) pos++;</span><br><span class="line">                <span class="keyword">if</span>(pos - l == n)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> valid1 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">bool</span> valid2 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt; pos; ++j)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][j] != <span class="string">' '</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(board[i][j] != word[j-l])&#123;</span><br><span class="line">                                valid1 = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(board[i][j] != word[n<span class="number">-1</span>-(j-l)])&#123;</span><br><span class="line">                                valid2 = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(valid1||valid2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*check col*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; row)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pos &lt; row &amp;&amp; board[pos][j] == <span class="string">'#'</span>) pos++;</span><br><span class="line">                <span class="keyword">int</span> l = pos;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(pos &lt; row &amp;&amp; board[pos][j] != <span class="string">'#'</span>) pos++;</span><br><span class="line">                <span class="keyword">if</span>(pos - l == n)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> valid1 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">bool</span> valid2 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt; pos; ++i)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][j] != <span class="string">' '</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(board[i][j] != word[i-l])&#123;</span><br><span class="line">                                valid1 = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(board[i][j] != word[n<span class="number">-1</span>-(i-l)])&#123;</span><br><span class="line">                                valid2 = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(valid1||valid2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5884-解出数学表达式的学生分数"><a href="#5884-解出数学表达式的学生分数" class="headerlink" title="5884. 解出数学表达式的学生分数"></a>5884. 解出数学表达式的学生分数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，它 只 包含数字<code>0-9</code>，加法运算符 <code>&#39;+&#39;</code>和乘法运算符 ‘<em>‘ ，这个字符串表示一个 合法 的只含有 个位数数字 的数学表达式（比方说 3+5</em>2）。有 n 位小学生将计算这个数学表达式，并遵循如下 运算顺序 ：</p><ul><li>按照 从左到右 的顺序计算 乘法 ，然后</li><li>按照 从左到右 的顺序计算 加法 。</li><li><p>给你一个长度为 <code>n</code> 的整数数组 <code>answers</code> ，表示每位学生提交的答案。你的任务是给 <code>answer</code> 数组按照如下 规则 打分：</p></li><li><p>如果一位学生的答案 等于 表达式的正确结果，这位学生将得到 5 分。</p></li><li>否则，如果答案由 一处或多处错误的运算顺序 计算得到，那么这位学生能得到 2 分。</li><li>否则，这位学生将得到 0 分。<br>请你返回所有学生的分数和。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"7+3*1*2"</span>, answers = [<span class="number">20</span>,<span class="number">13</span>,<span class="number">42</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：如上图所示，正确答案为 <span class="number">13</span> ，因此有一位学生得分为 <span class="number">5</span> 分：[<span class="number">20</span>,<span class="number">13</span>,<span class="number">42</span>] 。</span><br><span class="line">一位学生可能通过错误的运算顺序得到结果 <span class="number">20</span> ：<span class="number">7</span>+<span class="number">3</span>=<span class="number">10</span>，<span class="number">10</span>*<span class="number">1</span>=<span class="number">10</span>，<span class="number">10</span>*<span class="number">2</span>=<span class="number">20</span> 。所以这位学生得分为 <span class="number">2</span> 分：[<span class="number">20</span>,<span class="number">13</span>,<span class="number">42</span>] 。</span><br><span class="line">所有学生得分分别为：[<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>] 。所有得分之和为 <span class="number">2</span>+<span class="number">5</span>+<span class="number">0</span>=<span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"3+5*2"</span>, answers = [<span class="number">13</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">16</span>]</span><br><span class="line">输出：<span class="number">19</span></span><br><span class="line">解释：表达式的正确结果为 <span class="number">13</span> ，所以有 <span class="number">3</span> 位学生得到 <span class="number">5</span> 分：[<span class="number">13</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">16</span>] 。</span><br><span class="line">学生可能通过错误的运算顺序得到结果 <span class="number">16</span> ：<span class="number">3</span>+<span class="number">5</span>=<span class="number">8</span>，<span class="number">8</span>*<span class="number">2</span>=<span class="number">16</span> 。所以两位学生得到 <span class="number">2</span> 分：[<span class="number">13</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">16</span>] 。</span><br><span class="line">所有学生得分分别为：[<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>] 。所有得分之和为 <span class="number">5</span>+<span class="number">0</span>+<span class="number">0</span>+<span class="number">5</span>+<span class="number">5</span>+<span class="number">2</span>+<span class="number">2</span>=<span class="number">19</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"6+0*1"</span>, answers = [<span class="number">12</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：表达式的正确结果为 <span class="number">6</span> 。</span><br><span class="line">如果一位学生通过错误的运算顺序计算该表达式，结果仍为 <span class="number">6</span> 。</span><br><span class="line">根据打分规则，运算顺序错误的学生也将得到 <span class="number">5</span> 分（因为他们仍然得到了正确的结果），而不是 <span class="number">2</span> 分。</span><br><span class="line">所有学生得分分别为：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>] 。所有得分之和为 <span class="number">10</span> 分。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">3</span> &lt;= s.length &lt;= <span class="number">31</span>`</span><br><span class="line">+ `s` 表示一个只包含 `<span class="number">0</span><span class="number">-9</span>` ，`<span class="string">'+'</span>` 和 `<span class="string">'*'</span>` 的合法表达式。</span><br><span class="line">+ 表达式中所有整数运算数字都在闭区间 `[<span class="number">0</span>, <span class="number">9</span>]` 以内。</span><br><span class="line">+ <span class="number">1</span> &lt;= 数学表达式中所有运算符数目`（<span class="string">'+'</span>` 和 `<span class="string">'*'</span>） &lt;= <span class="number">15</span>`</span><br><span class="line">+ 测试数据保证正确表达式结果在范围` [<span class="number">0</span>, <span class="number">1000</span>] `以内。</span><br><span class="line">+ `n == answers.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= answers[i] &lt;= <span class="number">1000</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-260/problems/the-score-of-students-solving-math-expression/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   dp</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 其实题目本身的解法就是比较暴力,计算出所有可能的得分,然后将 $answer$ 中的每个元素在所有可能的得分里面进行查找, 如果不能找到则得分为  $<span class="number">0</span>$,如果可以找到则得分为 $<span class="number">2</span>$,如果得分刚好等于正确的结果,则得分为 $<span class="number">5</span>$,题目的难点在于如果得到所有的得分,题目另外一个关键的提示为$<span class="number">0</span> \le answers[i] \le <span class="number">1000</span>$, 则我们知道可以尽可能的缩小范围.</span><br><span class="line"><span class="number">2.</span> 我们设 $dp[i][j]$ 表示为表达式从$i$ 到 $j$ 范围内的所有可能的计算组合的得分,则我们在计算 $dp[i][j+k]$ 时,我们会枚举所的可能，即从表达式的 $i$ 到 $j+k$ 枚举每一个计算符为最后的计算组合. 题目本身还算非常不错的题目, 非常适合面试.但是说到底本身还算暴力求解的过程. 还是喜欢那种带有计算性质且有技巧的题目.</span><br><span class="line"><span class="number">3.</span> 时间复杂度为$O(N^&#123;<span class="number">3</span>&#125;*MAX(answer))$,空间复杂度为 $O(N^&#123;<span class="number">2</span>&#125;*MAX(answer))$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> calc(<span class="keyword">const</span> vector&lt;<span class="built_in">int</span>&gt; &amp; nums,<span class="keyword">const</span> vector&lt;char&gt; &amp; ops) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        arr.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">/*calc mult*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ops.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ops[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">                arr.push_back(nums[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ops[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                arr[arr.size()<span class="number">-1</span>] = arr.back()*nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*calc add*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            ans += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> scoreOfStudents(<span class="built_in">string</span> s, vector&lt;<span class="built_in">int</span>&gt;&amp; answers) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">int</span> m = n/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> correct = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; nums;</span><br><span class="line">        vector&lt;char&gt; ops;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="built_in">int</span>&gt;&gt; dp(<span class="number">1</span>&lt;&lt;m);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*parse expression*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'+'</span>||c == <span class="string">'*'</span>)&#123;</span><br><span class="line">                ops.push_back(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums.push_back(c-<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        correct = calc(nums,ops);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ops[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">                dp[<span class="number">1</span>&lt;&lt;i].insert(nums[i] + nums[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[<span class="number">1</span>&lt;&lt;i].insert(nums[i] * nums[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j+i &lt;= m; ++j)&#123;</span><br><span class="line">                <span class="built_in">int</span> mask = ((<span class="number">1</span>&lt;&lt;(j+i))<span class="number">-1</span>)^((<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">auto</span> v : dp[mask^(<span class="number">1</span>&lt;&lt;j)])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ops[j] == <span class="string">'+'</span> &amp;&amp; nums[j] + v &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                        dp[mask].insert(nums[j] + v);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">if</span>(ops[j] == <span class="string">'*'</span> &amp;&amp; nums[j] * v &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                        dp[mask].insert(nums[j] * v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">auto</span> v : dp[mask^(<span class="number">1</span>&lt;&lt;(j+i<span class="number">-1</span>))])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ops[j+i<span class="number">-1</span>] == <span class="string">'+'</span> &amp;&amp; nums[j+i] + v &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                        dp[mask].insert(nums[j+i] + v);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ops[j+i<span class="number">-1</span>] == <span class="string">'*'</span> &amp;&amp; nums[j+i] * v &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                        dp[mask].insert(nums[j+i] * v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> k = j+<span class="number">1</span>; k &lt; j+i<span class="number">-1</span>; ++k)&#123;</span><br><span class="line">                    <span class="built_in">int</span> left = ((<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>)^((<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">int</span> right = ((<span class="number">1</span>&lt;&lt;(j+i))<span class="number">-1</span>)^((<span class="number">1</span>&lt;&lt;k+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">auto</span> v1 : dp[left])&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="built_in">auto</span> v2 : dp[right])&#123;</span><br><span class="line">                            <span class="keyword">if</span>(ops[k] == <span class="string">'+'</span> &amp;&amp; v1 + v2 &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                                dp[mask].insert(v1 + v2);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(ops[k] == <span class="string">'*'</span> &amp;&amp; v1 * v2 &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                                dp[mask].insert(v1 * v2);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>].erase(correct);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : answers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == correct)&#123;</span><br><span class="line">                ans += <span class="number">5</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>].count(v))&#123;</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-260&quot;&gt;&lt;a href=&quot;#leetcode-contest-260&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 260&quot;&gt;&lt;/a&gt;leetcode  contest 260&lt;/h1&gt;&lt;p&gt;还是三道题目的节奏,无奈太菜了. 感觉中间两道题目出的很水,第四题其实出的还算比较有水平的题目,不过感觉不算太难.&lt;/p&gt;&lt;h2 id=&quot;5881-增量元素之间的最大差值&quot;&gt;&lt;a href=&quot;#5881-增量元素之间的最大差值&quot; class=&quot;headerlink&quot; title=&quot;5881. 增量元素之间的最大差值&quot;&gt;&lt;/a&gt;5881. 增量元素之间的最大差值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; ，该数组的大小为 &lt;code&gt;n&lt;/code&gt; ，请你计算 &lt;code&gt;nums[j] - nums[i]&lt;/code&gt; 能求得的 最大差值 ，其中 &lt;code&gt;0 &amp;lt;= i &amp;lt; j &amp;lt; n&lt;/code&gt;且 &lt;code&gt;nums[i] &amp;lt; nums[j]&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 259</title>
    <link href="http://yoursite.com/2021/09/19/328/"/>
    <id>http://yoursite.com/2021/09/19/328/</id>
    <published>2021-09-19T05:28:32.938Z</published>
    <updated>2021-09-20T08:14:08.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-259"><a href="#leetcode-contest-259" class="headerlink" title="leetcode  contest 259"></a>leetcode  contest 259</h1><p>还是三道题目的节奏,无奈太菜了.</p><h2 id="5875-执行操作后的变量值"><a href="#5875-执行操作后的变量值" class="headerlink" title="5875. 执行操作后的变量值"></a>5875. 执行操作后的变量值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>存在一种仅支持 4 种操作和 1 个变量 X 的编程语言：</p><ul><li><code>++X</code> 和 <code>X++</code> 使变量 <code>X</code> 的值 加 1</li><li><code>--X</code> 和 <code>X--</code> 使变量 <code>X</code> 的值 减 1<br>最初，X 的值是 0</li></ul><p>给你一个字符串数组 <code>operations</code> ，这是由操作组成的一个列表，返回执行所有操作后， X 的 最终值 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：operations = [<span class="string">"--X"</span>,<span class="string">"X++"</span>,<span class="string">"X++"</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：操作按下述步骤执行：</span><br><span class="line">最初，X = <span class="number">0</span></span><br><span class="line">--X：X 减 <span class="number">1</span> ，X =  <span class="number">0</span> - <span class="number">1</span> = <span class="number">-1</span></span><br><span class="line">X++：X 加 <span class="number">1</span> ，X = <span class="number">-1</span> + <span class="number">1</span> =  <span class="number">0</span></span><br><span class="line">X++：X 加 <span class="number">1</span> ，X =  <span class="number">0</span> + <span class="number">1</span> =  <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：operations = [<span class="string">"++X"</span>,<span class="string">"++X"</span>,<span class="string">"X++"</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：操作按下述步骤执行： </span><br><span class="line">最初，X = <span class="number">0</span></span><br><span class="line">++X：X 加 <span class="number">1</span> ，X = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">++X：X 加 <span class="number">1</span> ，X = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">X++：X 加 <span class="number">1</span> ，X = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：operations = [<span class="string">"X++"</span>,<span class="string">"++X"</span>,<span class="string">"--X"</span>,<span class="string">"X--"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：操作按下述步骤执行：</span><br><span class="line">最初，X = <span class="number">0</span></span><br><span class="line">X++：X 加 <span class="number">1</span> ，X = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">++X：X 加 <span class="number">1</span> ，X = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">--X：X 减 <span class="number">1</span> ，X = <span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">X--：X 减 <span class="number">1</span> ，X = <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= operations.length &lt;= 100</code></li><li><code>operations[i] 将会是 &quot;++X&quot;、&quot;X++&quot;、&quot;--X&quot; 或 &quot;X--&quot;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/final-value-of-variable-after-performing-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/final-value-of-variable-after-performing-operations</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力检测当前字符串是加还是减即可.</li><li>算法时间复杂度为$O(N)$,空间复杂度$O(1)$.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">finalValueAfterOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; operations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w : operations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w == <span class="string">"++X"</span> || w == <span class="string">"X++"</span>) ans++;</span><br><span class="line">            <span class="keyword">else</span> ans--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5876-数组美丽值求和"><a href="#5876-数组美丽值求和" class="headerlink" title="5876. 数组美丽值求和"></a>5876. 数组美丽值求和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 nums 。对于每个下标 <code>i（1 &lt;= i &lt;= nums.length - 2）</code>，<code>nums[i]</code>的 美丽值 等于：</p><ul><li><code>2</code>，对于所有 <code>0 &lt;= j &lt; i</code> 且 <code>i &lt; k &lt;= nums.length - 1</code>，满足 <code>nums[j] &lt; nums[i] &lt; nums[k]</code></li><li><code>1</code>，如果满足 <code>nums[i - 1] &lt; nums[i] &lt; nums[i + 1]</code>，且不满足前面的条件</li><li><code>0</code>，如果上述条件全部不满足<br>返回符合 <code>1 &lt;= i &lt;= nums.length - 2</code> 的所有 <code>nums[i]</code> 的 美丽值的总和 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：对于每个符合范围 <span class="number">1</span> &lt;= i &lt;= <span class="number">1</span> 的下标 i :</span><br><span class="line">- nums[<span class="number">1</span>] 的美丽值等于 <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：对于每个符合范围 <span class="number">1</span> &lt;= i &lt;= <span class="number">2</span> 的下标 i :</span><br><span class="line">- nums[<span class="number">1</span>] 的美丽值等于 <span class="number">1</span></span><br><span class="line">- nums[<span class="number">2</span>] 的美丽值等于 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：对于每个符合范围 <span class="number">1</span> &lt;= i &lt;= <span class="number">1</span> 的下标 i :</span><br><span class="line">- nums[<span class="number">1</span>] 的美丽值等于 <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-beauty-in-the-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-beauty-in-the-array</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目其实非常简单，我们利用滑动窗口即可，我们设$left[i]$表示当前索引小于等于$i$的元素的最大值,$right[i]$表示当前索引大于等于$i$的元素的最小值,我们每次检测当前的$i$是否满足:<script type="math/tex; mode=display">left[i-1] < nums[i] < right[i]</script>如果满足则美丽值为$2$,否则则检测是否满足$nums[i - 1] &lt; nums[i] &lt; nums[i + 1]$,如果满足则美丽值为$1$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(N)$, 其中$N$为数组的长度.</li><li>空间复杂度为$O(N)$,其中$N$为数组的长度.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfBeauties</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n);</span><br><span class="line">        </span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[i] = max(nums[i],left[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        right[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = min(right[i+<span class="number">1</span>],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; left[i<span class="number">-1</span>] &amp;&amp; nums[i] &lt; right[i+<span class="number">1</span>])&#123;</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; nums[i] &lt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5877-检测正方形"><a href="#5877-检测正方形" class="headerlink" title="5877. 检测正方形"></a>5877. 检测正方形</h2><p>给你一个在 <code>X-Y</code> 平面上的点构成的数据流。设计一个满足下述要求的算法：</p><ul><li><strong>添加</strong> 一个在数据流中的新点到某个数据结构中。可以添加 重复 的点，并会视作不同的点进行处理。</li><li>给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 面积为正 的 轴对齐正方形 ，统计 满足该要求的方案数目。<br>轴对齐正方形 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。</li></ul><p>实现 <code>DetectSquares</code> 类：</p><ul><li><code>DetectSquares()</code> 使用空数据结构初始化对象</li><li><code>void add(int[] point)</code> 向数据结构添加一个新的点 <code>point = [x, y]int count(int[] point)</code> 统计按上述方式与点 <code>point = [x, y]</code> 共同构造 轴对齐正方形 的方案数。</li></ul><p>示例：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"DetectSquares"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"count"</span>, <span class="string">"count"</span>, <span class="string">"add"</span>, <span class="string">"count"</span>]</span><br><span class="line">[[], [[<span class="number">3</span>, <span class="number">10</span>]], [[<span class="number">11</span>, <span class="number">2</span>]], [[<span class="number">3</span>, <span class="number">2</span>]], [[<span class="number">11</span>, <span class="number">10</span>]], [[<span class="number">14</span>, <span class="number">8</span>]], [[<span class="number">11</span>, <span class="number">2</span>]], [[<span class="number">11</span>, <span class="number">10</span>]]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, null, <span class="number">1</span>, <span class="number">0</span>, null, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">DetectSquares detectSquares = new DetectSquares();</span><br><span class="line">detectSquares.add([<span class="number">3</span>, <span class="number">10</span>]);</span><br><span class="line">detectSquares.add([<span class="number">11</span>, <span class="number">2</span>]);</span><br><span class="line">detectSquares.add([<span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line">detectSquares.count([<span class="number">11</span>, <span class="number">10</span>]); <span class="comment">// 返回 1 。你可以选择：</span></span><br><span class="line">                               <span class="comment">//   - 第一个，第二个，和第三个点</span></span><br><span class="line">detectSquares.count([<span class="number">14</span>, <span class="number">8</span>]);  <span class="comment">// 返回 0 。查询点无法与数据结构中的这些点构成正方形。</span></span><br><span class="line">detectSquares.add([<span class="number">11</span>, <span class="number">2</span>]);    <span class="comment">// 允许添加重复的点。</span></span><br><span class="line">detectSquares.count([<span class="number">11</span>, <span class="number">10</span>]); <span class="comment">// 返回 2 。你可以选择：</span></span><br><span class="line">                               <span class="comment">//   - 第一个，第二个，和第三个点</span></span><br><span class="line">                               <span class="comment">//   - 第一个，第三个，和第四个点</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>point.length == 2</code></li><li><code>0 &lt;= x, y &lt;= 1000</code></li><li>调用 add 和 count 的 总次数 最多为 <code>5000</code><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/detect-squares" target="_blank" rel="noopener">https://leetcode-cn.com/problems/detect-squares</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash统计</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>感觉这个题目出的非常不好,也不清楚想考什么,反正很怪异的题目.</li><li>首先我们将所有的坐标进行统计,然后统计每个坐标$x$上都包含哪些总坐标$y$．</li></ol><ul><li>当执行$add$时,我们直接添加即可;</li><li>当执行查询$(x,y)$时,我们遍历所有横坐标同样也为$x$的点的统计.枚举每一个点$(x,z)$,此时我们即可知道需要查询的正方形的边长以及其余两个可能的点,直接查询点的统计数目,然后利用组合公式计算返回即可.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为$O(N)$,其中 $N$ 表示点的个数.</li><li>空间复杂度分析:　时间复杂度为$O(N*MAXP)$,其中 $N$ 表示点的个数. $MAXP$ 表示当前点的横坐标或者纵坐标的最大值．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectSquares</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DetectSquares() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        cnt[make_pair(point[<span class="number">0</span>],point[<span class="number">1</span>])]++;</span><br><span class="line">        cntx[point[<span class="number">0</span>]].insert(point[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = point[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = point[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cntx.count(x))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : cntx[x])&#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="built_in">abs</span>(v-y);</span><br><span class="line">                <span class="keyword">if</span>(l == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> a = cnt[make_pair(x,v)];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//up</span></span><br><span class="line">                <span class="keyword">if</span>(cntx.count(x-l))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt.count(make_pair(x-l,y)) &amp;&amp; cnt.count(make_pair(x-l,v)))&#123;</span><br><span class="line">                        <span class="keyword">int</span> b = cnt[make_pair((x-l),y)];</span><br><span class="line">                        <span class="keyword">int</span> c = cnt[make_pair((x-l),v)];</span><br><span class="line">                        ans += a*b*c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//down</span></span><br><span class="line">                <span class="keyword">if</span>(cntx.count(x+l))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt.count(make_pair(x+l,y)) &amp;&amp; cnt.count(make_pair(x+l,v)))&#123;</span><br><span class="line">                        <span class="keyword">int</span> b = cnt[make_pair((x+l),y)];</span><br><span class="line">                        <span class="keyword">int</span> c = cnt[make_pair((x+l),v)];</span><br><span class="line">                        ans += a*b*c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; cntx;</span><br><span class="line">    <span class="built_in">map</span>&lt;pii,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your DetectSquares object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * DetectSquares* obj = new DetectSquares();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(point);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;count(point);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5878-重复-K-次的最长子序列"><a href="#5878-重复-K-次的最长子序列" class="headerlink" title="5878. 重复 K 次的最长子序列"></a>5878. 重复 K 次的最长子序列</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 n 的字符串 s ，和一个整数 k 。请你找出字符串 s 中 重复 k 次的 最长子序列 。</p><p>子序列 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。</p><p>如果 seq <em> k 是 s 的一个子序列，其中 seq </em> k 表示一个由 seq 串联 k 次构造的字符串，那么就称 seq 是字符串 s 中一个 重复 k 次 的子序列。</p><p>举个例子，”bba” 是字符串 “bababcba” 中的一个重复 2 次的子序列，因为字符串 “bbabba” 是由 “bba” 串联 2 次构造的，而 “bbabba” 是字符串 “bababcba” 的一个子序列。<br>返回字符串 s 中 重复 k 次的最长子序列  。如果存在多个满足的子序列，则返回 字典序最大 的那个。如果不存在这样的子序列，返回一个 空 字符串。</p><p>示例 1：</p><p>输入：s = “letsleetcode”, k = 2<br>输出：”let”<br>解释：存在两个最长子序列重复 2 次：let” 和 “ete” 。<br>“let” 是其中字典序最大的一个。<br>示例 2：</p><p>输入：s = “bb”, k = 2<br>输出：”b”<br>解释：重复 2 次的最长子序列是 “b” 。<br>示例 3：</p><p>输入：s = “ab”, k = 2<br>输出：””<br>解释：不存在重复 2 次的最长子序列。返回空字符串。<br>示例 4：</p><p>输入：s = “bbabbabbbbabaababab”, k = 3<br>输出：”bbbb”<br>解释：在 “bbabbabbbbabaababab” 中重复 3 次的最长子序列是 “bbbb” 。</p><p>提示：</p><ul><li><code>n == s.length</code></li><li><code>2 &lt;= k &lt;= 2000</code></li><li><code>2 &lt;= n &lt; k * 8</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>比赛时看了5分钟就退出了,后来下来之后仔细看了下解答,感觉比想象中神奇的题目,竟然不需要用到太复杂的理论,就是暴力枚举加减枝即可,真心是比较奇怪的题目,感觉按照这种解题思路不需要太多特殊的技巧.</li><li>题目的关键提示在于$2 &lt;= n &lt; k * 8$,根据这个提示我们可以知道,目标结果的字符串最长长度只能为$7$,所以目标字符串最多可能只含有$7$个字符,我们统计出字符中所有出现次数大于$k$的字符数目最多也只有$7$个,我们试想一下排列组合,$7$种字符的排列组合最多只有 $7! = 5000$种组合,我们可以把所有可能的组合计算出来，然后再进行在原字符串种检测是否重复出现$k$次,当然中间还可以通过各种减枝的手段进行优化和提升效率.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为$O(N*(\frac{N}{K})!)$,其中 $N$ 表示字符串的长度.</li><li>空间复杂度分析:　时间复杂度为$O(N)$,其中 $N$ 表示字符串的长度.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; cnt,<span class="built_in">string</span> &amp; curr,<span class="built_in">string</span> &amp; res,<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [c,freq] : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[c] &lt; k) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            curr.push_back(c + <span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt; res.size() || (curr.size() == res.size() &amp;&amp; curr &gt; res))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(c == curr[pos])&#123;</span><br><span class="line">                        pos++;</span><br><span class="line">                        <span class="keyword">if</span>(pos == curr.size())&#123;</span><br><span class="line">                            pos = <span class="number">0</span>;</span><br><span class="line">                            times++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(times &gt;= k)&#123;</span><br><span class="line">                    res = curr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[c] -= k;</span><br><span class="line">            dfs(cnt,curr,res,s);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">            cnt[c] = freq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestSubsequenceRepeatedK</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; k) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(<span class="number">26</span>);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        <span class="built_in">string</span> t;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) arr[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt;= k)&#123;</span><br><span class="line">                cnt[i] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(c-<span class="string">'a'</span>))&#123;</span><br><span class="line">                t.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(cnt,curr,ans,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-259&quot;&gt;&lt;a href=&quot;#leetcode-contest-259&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 259&quot;&gt;&lt;/a&gt;leetcode  contest 259&lt;/h1&gt;&lt;p&gt;还是三道题目的节奏,无奈太菜了.&lt;/p&gt;&lt;h2 id=&quot;5875-执行操作后的变量值&quot;&gt;&lt;a href=&quot;#5875-执行操作后的变量值&quot; class=&quot;headerlink&quot; title=&quot;5875. 执行操作后的变量值&quot;&gt;&lt;/a&gt;5875. 执行操作后的变量值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;存在一种仅支持 4 种操作和 1 个变量 X 的编程语言：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;++X&lt;/code&gt; 和 &lt;code&gt;X++&lt;/code&gt; 使变量 &lt;code&gt;X&lt;/code&gt; 的值 加 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--X&lt;/code&gt; 和 &lt;code&gt;X--&lt;/code&gt; 使变量 &lt;code&gt;X&lt;/code&gt; 的值 减 1&lt;br&gt;最初，X 的值是 0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;operations&lt;/code&gt; ，这是由操作组成的一个列表，返回执行所有操作后， X 的 最终值 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 61</title>
    <link href="http://yoursite.com/2021/09/19/327/"/>
    <id>http://yoursite.com/2021/09/19/327/</id>
    <published>2021-09-19T01:11:28.094Z</published>
    <updated>2021-09-19T05:23:12.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-61"><a href="#leetcode-biweekly-contest-61" class="headerlink" title="leetcode  biweekly contest 61"></a>leetcode  biweekly contest 61</h1><p>今天的题目都非常简单，基本上看一眼都有思路,感觉最后一题就是送分题，晚上坐火车没时间打卡，今天早上补上。<br><img src="https://i.loli.net/2021/09/19/wL2Zatf4UQB1TE3.png" alt></p><h2 id="5859-差的绝对值为-K-的数对数目"><a href="#5859-差的绝对值为-K-的数对数目" class="headerlink" title="5859. 差的绝对值为 K 的数对数目"></a>5859. 差的绝对值为 K 的数对数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回数对<code>(i, j)</code> 的数目，满足 <code>i &lt; j</code>且 <code>|nums[i] - nums[j]| == k</code>。</p><a id="more"></a><p><code>|x|</code> 的值定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code>。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：差的绝对值为 <span class="number">1</span> 的数对为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有任何数对差的绝对值为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：差的绝对值为 <span class="number">2</span> 的数对为：</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 99</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力双层循环,找到所有$|nums[i] - nums[j]| == k$ 的数对即可,时间复杂度为$O(N^{2})$.</li><li>采用<code>hash</code>查找,时间复杂度为$O(N)$,空间复杂度为$O(N)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countKDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[i]-nums[j]) == k) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countKDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) cnt[v]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(v + k))&#123;</span><br><span class="line">                ans += cnt[v+k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5860-从双倍数组中还原原数组"><a href="#5860-从双倍数组中还原原数组" class="headerlink" title="5860. 从双倍数组中还原原数组"></a>5860. 从双倍数组中还原原数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一个整数数组 <code>original</code> 可以转变成一个 双倍 数组 <code>changed</code>，转变方式为将 <code>original</code> 中每个元素 值乘以 2 加入数组中，然后将所有元素 随机打乱 。</p><p>给你一个数组 <code>changed</code>，如果 <code>change</code>是 双倍 数组，那么请你返回 <code>original</code>数组，否则请返回空数组。<code>original</code> 的元素可以以 任意 顺序返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：changed = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：一个可能的 original 数组为 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>] :</span><br><span class="line">- 将 <span class="number">1</span> 乘以 <span class="number">2</span> ，得到 <span class="number">1</span> * <span class="number">2</span> = <span class="number">2</span> 。</span><br><span class="line">- 将 <span class="number">3</span> 乘以 <span class="number">2</span> ，得到 <span class="number">3</span> * <span class="number">2</span> = <span class="number">6</span> 。</span><br><span class="line">- 将 <span class="number">4</span> 乘以 <span class="number">2</span> ，得到 <span class="number">4</span> * <span class="number">2</span> = <span class="number">8</span> 。</span><br><span class="line">其他可能的原数组方案为 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>] 或者 [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="section">changed</span> = [<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：<span class="section">changed</span> 不是一个双倍数组。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">输入：changed = [<span class="number">1</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：changed 不是一个双倍数组。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= changed.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= changed[i] &lt;= <span class="number">105</span>`</span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  排序</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 题目本身不是很难，细节处理稍微复杂点，处理过程如下：</span><br><span class="line">+ 首先我们需要判断数组的长度是否为偶数,如果数组的长度不是偶数,显然不可能是双倍数组.</span><br><span class="line">+ 其次我们需要处理特殊的元素$<span class="number">0</span>$,因为$<span class="number">0</span>$的两倍还是$<span class="number">0</span>$本身,因此我们知道双倍数组中$<span class="number">0</span>$的个数一定是偶数,如果不是偶数,则为肯定为非法的双倍数组．</span><br><span class="line"><span class="number">2.</span> 我们统计每个数字的个数,其中$cnt[i]$表示当前为$i$的元素有多少个,我们从小到大遍历每一个元素.</span><br><span class="line">+ 如果该元素 $i$ 的统计个数大于 $<span class="number">0</span>$,则我们将$<span class="number">2</span>*i$ 的个数减去$cnt[i]$,即$cnt[<span class="number">2</span>*i] = cnt[<span class="number">2</span>*i] - cnt[i]$;</span><br><span class="line">+ 如果该元素 $i$ 的统计个数大于$<span class="number">0</span>$,如果$<span class="number">2</span>*i$大于数组中元素的最大值，则我们可以认为该数组非法，直接返回空数组即可；</span><br><span class="line">+ 如果该元素 $i$ 的统计个数小于$<span class="number">0</span>$,则我们认为该元素非法,直接返回空数组即可.</span><br><span class="line"><span class="number">3.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度为$O(N\lg(N))$, 其中$N$为数组的长度.</span><br><span class="line">+ 空间复杂度为$O(N)$,其中$N$为数组的长度.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; findOriginalArray(vector&lt;<span class="built_in">int</span>&gt;&amp; changed) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = changed.size();</span><br><span class="line">        map&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; cnt;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : changed) &#123;</span><br><span class="line">            cnt[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>]%<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cnt[<span class="number">0</span>]/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">            ans.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt.erase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second &lt; <span class="number">0</span>) <span class="keyword">return</span> vector&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">            <span class="keyword">if</span>(v.second &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt.count(v.first*<span class="number">2</span>)) <span class="keyword">return</span> vector&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">                cnt[v.first*<span class="number">2</span>] -= v.second;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; v.second; ++i)&#123;</span><br><span class="line">                    ans.push_back(v.first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5861-出租车的最大盈利"><a href="#5861-出租车的最大盈利" class="headerlink" title="5861. 出租车的最大盈利"></a>5861. 出租车的最大盈利</h2><p>你驾驶出租车行驶在一条有 <code>n</code>个地点的路上。这 <code>n</code>个地点从近到远编号为 <code>1</code>到 <code>n</code> ，你想要从 <code>1</code> 开到 <code>n</code>，通过接乘客订单盈利。你只能沿着编号递增的方向前进`，不能改变方向。</p><p>乘客信息用一个下标从<code>0</code> 开始的二维数组 rides 表示，其中<code>rides[i] = [starti, endi, tipi]</code> 表示第 <code>i</code> 位乘客需要从地点 <code>starti</code>前往 <code>endi</code>，愿意支付 <code>tipi</code> 元的小费。</p><p>每一位 你选择接单的乘客 <code>i</code>，你可以 盈利 <code>endi - starti + tipi</code>元。你同时 最多 只能接一个订单。</p><p>给你 <code>n</code> 和 <code>rides</code> ，请你返回在最优接单方案下，你能盈利 最多 多少元。</p><p>注意：你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, rides = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：我们可以接乘客 <span class="number">0</span> 的订单，获得 <span class="number">5</span> - <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span> 元。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">20</span>, rides = [[<span class="number">1</span>,<span class="number">6</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>],[<span class="number">10</span>,<span class="number">12</span>,<span class="number">3</span>],[<span class="number">11</span>,<span class="number">12</span>,<span class="number">2</span>],[<span class="number">12</span>,<span class="number">15</span>,<span class="number">2</span>],[<span class="number">13</span>,<span class="number">18</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：我们可以接以下乘客的订单：</span><br><span class="line">- 将乘客 <span class="number">1</span> 从地点 <span class="number">3</span> 送往地点 <span class="number">10</span> ，获得 <span class="number">10</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">9</span> 元。</span><br><span class="line">- 将乘客 <span class="number">2</span> 从地点 <span class="number">10</span> 送往地点 <span class="number">12</span> ，获得 <span class="number">12</span> - <span class="number">10</span> + <span class="number">3</span> = <span class="number">5</span> 元。</span><br><span class="line">- 将乘客 <span class="number">5</span> 从地点 <span class="number">13</span> 送往地点 <span class="number">18</span> ，获得 <span class="number">18</span> - <span class="number">13</span> + <span class="number">1</span> = <span class="number">6</span> 元。</span><br><span class="line">我们总共获得 <span class="number">9</span> + <span class="number">5</span> + <span class="number">6</span> = <span class="number">20</span> 元。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= rides.length &lt;= 3 * 104</code></li><li><code>rides[i].length == 3</code></li><li><code>1 &lt;= starti &lt; endi &lt;= n</code></li><li><code>1 &lt;= tipi &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>非常典型，也非常简单的<code>dp</code>,题目中明确说明了每段行程最多只能带一个人,所以就非常简单的<code>dp</code>就搞定了．我们设$dp[i]$为到达第$i$个站点的最大收益,则我们可以知道递推如下:</li></ol><ul><li>如果从地点$i$到地点$i+1$载客为空时,则此时我们可以知道$dp[i+1] = dp[i]$;</li><li>如果我们知道到$i+1$载客时，则我们可以将所有载客到第$i+1$个地点时的乘客全部遍历一遍即可,我们假设第$k$个乘客的目的地为$i+1$,则此时我们可以知道:<script type="math/tex; mode=display">dp[i] = \max(dp[i],dp[rides[k][0]] + rides[k][1] - rides[k][0] + rides[k][2])</script></li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为$O(M+N)$,其中 $N$ 表示地点的个数. $M$ 表示乘客的个数．</li><li>空间复杂度分析:　时间复杂度为$O(M+N)$,其中 $N$ 表示地点的个数. $M$ 表示乘客的个数．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxTaxiEarnings</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rides)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = rides.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            arr[rides[i][<span class="number">1</span>]].push_back(i);   </span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> idx = arr[i][j];</span><br><span class="line">                dp[i] = max(dp[i],dp[rides[idx][<span class="number">0</span>]] + rides[idx][<span class="number">1</span>] - rides[idx][<span class="number">0</span>] + rides[idx][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5862-使数组连续的最少操作数"><a href="#5862-使数组连续的最少操作数" class="headerlink" title="5862. 使数组连续的最少操作数"></a>5862. 使数组连续的最少操作数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 任意 一个元素替换成 任意 整数。</p><p>如果 <code>nums</code> 满足以下条件，那么它是 连续的 ：</p><ul><li><code>nums</code> 中所有元素都是 互不相同 的。</li><li><code>nums</code> 中 最大 元素与 最小 元素的差等于 <code>nums.length - 1</code> 。<br>比方说，<code>nums = [4, 2, 5, 3]</code> 是 连续的 ，但是 <code>nums = [1, 2, 3, 5, 6]</code> 不是连续的 。</li></ul><p>请你返回使 <code>nums</code> 连续 的 最少 操作次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums 已经是连续的了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：一个可能的解是将最后一个元素变为 <span class="number">4</span> 。</span><br><span class="line">结果数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>] ，是连续数组。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：一个可能的解是：</span><br><span class="line">- 将第二个元素变为 <span class="number">2</span> 。</span><br><span class="line">- 将第三个元素变为 <span class="number">3</span> 。</span><br><span class="line">- 将第四个元素变为 <span class="number">4</span> 。</span><br><span class="line">结果数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，是连续数组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口　＋　二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1.　题目较为简单，首先我们需要将数组去重，我们试想一下，如果保证数组连续，则我们可以试想一下贪心算法，必定这个连续的空间一定会包含数组元素中的值，如果该连续空间不包含任何元素，则肯定不是最优解．</p><ol><li>我们假设区间左起点必定以数组中的某个元素为起点,则我们依次希望区间$[nums[i],nums[i] + n-1]$尽可能的包含最多的不相等的元素,因此我们只需要区间数组中的每个元素$nums[i]$构成的区间$[nums[i],nums[i] + n-1]$包含的不相等的数组元素最多即可最终的目的区间.</li><li>首先我们可以将数组元素去重,并且按照元素从小到大进行排序,排序后我们每次遍历区间$[nums[i],nums[i] + n-1]$,求出该区间包含的最多元素的个数$maxdiff$,剩余的元素则需要按照题目要求进行变换即可,最终返回结果为$n-maxdiff$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为$O(N\lg(N) + N)$,其中 $N$ 表示数组的长度, 我们需要排序话费的时间为$O(N\lg(N))$, 然后我们需要遍历每个元素,花费的时间为$O(N)$.</li><li>空间复杂度分析:　时间复杂度为$O(N)$,其中 $N$ 表示数组的长度.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        arr.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                arr.push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = upper_bound(arr.begin(),arr.end(),arr[i] + n<span class="number">-1</span>) - arr.begin() - i;</span><br><span class="line">            ans = min(ans,n-x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-61&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-61&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 61&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 61&lt;/h1&gt;&lt;p&gt;今天的题目都非常简单，基本上看一眼都有思路,感觉最后一题就是送分题，晚上坐火车没时间打卡，今天早上补上。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/09/19/wL2Zatf4UQB1TE3.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5859-差的绝对值为-K-的数对数目&quot;&gt;&lt;a href=&quot;#5859-差的绝对值为-K-的数对数目&quot; class=&quot;headerlink&quot; title=&quot;5859. 差的绝对值为 K 的数对数目&quot;&gt;&lt;/a&gt;5859. 差的绝对值为 K 的数对数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你返回数对&lt;code&gt;(i, j)&lt;/code&gt; 的数目，满足 &lt;code&gt;i &amp;lt; j&lt;/code&gt;且 &lt;code&gt;|nums[i] - nums[j]| == k&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 258</title>
    <link href="http://yoursite.com/2021/09/12/326/"/>
    <id>http://yoursite.com/2021/09/12/326/</id>
    <published>2021-09-12T05:35:47.973Z</published>
    <updated>2021-09-12T07:23:00.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-258"><a href="#leetcode-contest-258" class="headerlink" title="leetcode  contest 258"></a>leetcode  contest 258</h1><p>第四题还是不会,智商不够,刚开始准备用线段树来实现的.</p><h2 id="5867-反转单词前缀"><a href="#5867-反转单词前缀" class="headerlink" title="5867. 反转单词前缀"></a>5867. 反转单词前缀</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 0 开始的字符串 <code>word</code> 和一个字符<code>ch</code> 。找出 ch 第一次出现的下标 i ，反转 <code>word</code> 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 <code>word</code> 中不存在字符 <code>ch</code> ，则无需进行任何操作。</p><a id="more"></a><p>例如，如果 <code>word = &quot;abcdefd&quot;</code> 且 <code>ch = &quot;d&quot;</code> ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 <code>3</code> ）。结果字符串将会是 <code>&quot;dcbaefd&quot;</code> 。<br>返回 结果字符串 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"abcdefd"</span>, ch = <span class="string">"d"</span></span><br><span class="line">输出：<span class="string">"dcbaefd"</span></span><br><span class="line">解释：<span class="string">"d"</span> 第一次出现在下标 <span class="number">3</span> 。 </span><br><span class="line">反转从下标 <span class="number">0</span> 到下标 <span class="number">3</span>（含下标 <span class="number">3</span>）的这段字符，结果字符串是 <span class="string">"dcbaefd"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"xyxzxe"</span>, ch = <span class="string">"z"</span></span><br><span class="line">输出：<span class="string">"zxyxxe"</span></span><br><span class="line">解释：<span class="string">"z"</span> 第一次也是唯一一次出现是在下标 <span class="number">3</span> 。</span><br><span class="line">反转从下标 <span class="number">0</span> 到下标 <span class="number">3</span>（含下标 <span class="number">3</span>）的这段字符，结果字符串是 <span class="string">"zxyxxe"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"abcd"</span>, <span class="number">ch</span> = <span class="string">"z"</span></span><br><span class="line">输出：<span class="string">"abcd"</span></span><br><span class="line">解释：<span class="string">"z"</span> 不存在于 <span class="built_in">word</span> 中。</span><br><span class="line">无需执行反转操作，结果字符串是 <span class="string">"abcd"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 250</code></li><li><code>word</code> 由小写英文字母组成</li><li><code>ch</code> 是一个小写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reverse-prefix-of-word" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-prefix-of-word</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>查找第一个符合要求的字符的位置,然后反转字符串,然后返回即可.</li><li>时间复杂度为$O(N)$,空间复杂度为$O(1)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reversePrefix</span><span class="params">(<span class="built_in">string</span> word, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word[i] == ch)&#123;</span><br><span class="line">                x = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            reverse(word.begin(),word.begin()+x+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5868-可互换矩形的组数"><a href="#5868-可互换矩形的组数" class="headerlink" title="5868. 可互换矩形的组数"></a>5868. 可互换矩形的组数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>用一个下标从<code>0</code>开始的二维整数数组 <code>rectangles</code> 来表示 <code>n</code> 个矩形，其中 <code>rectangles[i] = [widthi, heighti]</code> 表示第 <code>i</code>个矩形的宽度和高度。</p><p>如果两个矩形 <code>i</code> 和 <code>j（i &lt; j）</code>的宽高比相同，则认为这两个矩形 可互换 。更规范的说法是，两个矩形满足 <code>widthi/heighti == widthj/heightj</code>（使用实数除法而非整数除法），则认为这两个矩形 可互换 。</p><p>计算并返回 <code>rectangles</code> 中有多少对 可互换 矩形。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[<span class="number">4</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">6</span>],[<span class="number">10</span>,<span class="number">20</span>],[<span class="number">15</span>,<span class="number">30</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：下面按下标（从 <span class="number">0</span> 开始）列出可互换矩形的配对情况：</span><br><span class="line">- 矩形 <span class="number">0</span> 和矩形 <span class="number">1</span> ：<span class="number">4</span>/<span class="number">8</span> == <span class="number">3</span>/<span class="number">6</span></span><br><span class="line">- 矩形 <span class="number">0</span> 和矩形 <span class="number">2</span> ：<span class="number">4</span>/<span class="number">8</span> == <span class="number">10</span>/<span class="number">20</span></span><br><span class="line">- 矩形 <span class="number">0</span> 和矩形 <span class="number">3</span> ：<span class="number">4</span>/<span class="number">8</span> == <span class="number">15</span>/<span class="number">30</span></span><br><span class="line">- 矩形 <span class="number">1</span> 和矩形 <span class="number">2</span> ：<span class="number">3</span>/<span class="number">6</span> == <span class="number">10</span>/<span class="number">20</span></span><br><span class="line">- 矩形 <span class="number">1</span> 和矩形 <span class="number">3</span> ：<span class="number">3</span>/<span class="number">6</span> == <span class="number">15</span>/<span class="number">30</span></span><br><span class="line">- 矩形 <span class="number">2</span> 和矩形 <span class="number">3</span> ：<span class="number">10</span>/<span class="number">20</span> == <span class="number">15</span>/<span class="number">30</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在成对的可互换矩形。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == rectangles.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>rectangles[i].length == 2</code></li><li><code>1 &lt;= widthi, heighti &lt;= 105</code><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/number-of-pairs-of-interchangeable-rectangles" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-pairs-of-interchangeable-rectangles</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序 + 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>我们利用公约数将其进行化简，然后统计即可．我们如果有　$x$个形式相同的矩形,则我们就用$\frac{n*(n-1)}{2}$种组合.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(n*\lg(n))$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">interchangeableRectangles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rectangles.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = __gcd(rectangles[i][<span class="number">0</span>],rectangles[i][<span class="number">1</span>]);</span><br><span class="line">            cnt[make_pair(rectangles[i][<span class="number">0</span>]/c,rectangles[i][<span class="number">1</span>]/c)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                ans += (v.second<span class="number">-1</span>)*v.second/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5869-两个回文子序列长度的最大乘积"><a href="#5869-两个回文子序列长度的最大乘积" class="headerlink" title="5869. 两个回文子序列长度的最大乘积"></a>5869. 两个回文子序列长度的最大乘积</h2><p>给你一个字符串 <code>s</code> ，请你找到 <code>s</code> 中两个 不相交回文子序列 ，使得它们长度的 乘积最大 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 不相交 的。</p><p>请你返回两个回文子序列长度可以达到的 最大乘积 。</p><p>子序列 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 回文字符串 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcodecom"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：最优方案是选择 <span class="string">"ete"</span> 作为第一个子序列，<span class="string">"cdc"</span> 作为第二个子序列。</span><br><span class="line">它们的乘积为 <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"bb"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最优方案为选择 <span class="string">"b"</span> （第一个字符）作为第一个子序列，<span class="string">"b"</span> （第二个字符）作为第二个子序列。</span><br><span class="line">它们的乘积为 <span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"accbcaxxcxx"</span></span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：最优方案为选择 <span class="string">"accca"</span> 作为第一个子序列，<span class="string">"xxcxx"</span> 作为第二个子序列。</span><br><span class="line">它们的乘积为 <span class="number">5</span> * <span class="number">5</span> = <span class="number">25</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= s.length &lt;= 12</code></li><li><code>s</code> 只含有小写英文字母。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩,子集遍历</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目其实非常简单,因为数据集很小,我们直接把数据集分成两个不相交的子集,然后在每个子集中找到最长的回文串子序列,然后将两个值进行相乘即可.需要预处理，哪些子集为回文字符串．</li><li>时间复杂度为 $O(ｎ*2^{n} + 3^{n})$,空间复杂度为 $O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            x = (x<span class="number">-1</span>)&amp;x;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr.push_back(s[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = curr.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr[l] == curr[r])&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) dp[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> x = __builtin_popcount(i);</span><br><span class="line">            <span class="keyword">int</span> res = ((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)^i;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = res; k != <span class="number">0</span>; k = (k<span class="number">-1</span>)&amp;res)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[k]) <span class="keyword">continue</span>;</span><br><span class="line">                y = max(y,__builtin_popcount(k));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,x*y);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5870-每棵子树内缺失的最小基因值"><a href="#5870-每棵子树内缺失的最小基因值" class="headerlink" title="5870. 每棵子树内缺失的最小基因值"></a>5870. 每棵子树内缺失的最小基因值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一棵根节点为 <code>0</code>的 家族树 ，总共包含 <code>n</code>个节点，节点编号为<code>0</code> 到 <code>n - 1</code>。给你一个下标从 <code>0</code>开始的整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code>的父节点。由于节点<code>0</code>是 根 ，所以 <code>parents[0] == -1</code> 。</p><p>总共有 <code>105</code> 个基因值，每个基因值都用 闭区间 <code>[1, 105]</code>中的一个整数表示。给你一个下标从<code>0</code> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code>是节点 <code>i</code> 的基因值，且基因值 互不相同 。</p><p>请你返回一个数组 <code>ans</code> ，长度为 <code>n</code> ，其中 <code>ans[i]</code>是以节点<code>i</code>为根的子树内 缺失 的 最小 基因值。</p><p>节点 <code>x</code>为根的 子树 包含节点 <code>x</code> 和它所有的 后代 节点。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>], nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：每个子树答案计算结果如下：</span><br><span class="line">- <span class="number">0</span>：子树包含节点 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，基因值分别为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 。<span class="number">5</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">1</span>：子树只包含节点 <span class="number">1</span> ，基因值为 <span class="number">2</span> 。<span class="number">1</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">2</span>：子树包含节点 [<span class="number">2</span>,<span class="number">3</span>] ，基因值分别为 [<span class="number">3</span>,<span class="number">4</span>] 。<span class="number">1</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">3</span>：子树只包含节点 <span class="number">3</span> ，基因值为 <span class="number">4</span> 。<span class="number">1</span>是缺失的最小基因值。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>], nums = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：每个子树答案计算结果如下：</span><br><span class="line">- <span class="number">0</span>：子树内包含节点 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，基因值分别为 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 。<span class="number">7</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">1</span>：子树内包含节点 [<span class="number">1</span>,<span class="number">2</span>] ，基因值分别为 [<span class="number">4</span>,<span class="number">6</span>] 。 <span class="number">1</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">2</span>：子树内只包含节点 <span class="number">2</span> ，基因值为 <span class="number">6</span> 。<span class="number">1</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">3</span>：子树内包含节点 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，基因值分别为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 。<span class="number">4</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">4</span>：子树内只包含节点 <span class="number">4</span> ，基因值为 <span class="number">1</span> 。<span class="number">2</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">5</span>：子树内只包含节点 <span class="number">5</span> ，基因值为 <span class="number">3</span> 。<span class="number">1</span> 是缺失的最小基因值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>], nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：所有子树都缺失基因值 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == parents.length == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li>对于 <code>i != 0</code>，满足 <code>0 &lt;= parents[i] &lt;= n - 1</code></li><li><code>parents[0] == -1</code></li><li><code>parents</code>表示一棵合法的树。</li><li><code>1 &lt;= nums[i] &lt;= 105</code></li><li><code>nums[i]</code> 互不相同。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目给的解法很好,但是非常抽象,且不容易理解,大致意思如下:</li></ol><ul><li>如果子树中不含有元素$1$,则该子树的缺失的最小基因值一定为$1$.</li><li>假设子树中含有元素$1$,则我们需要特殊处理.</li><li><ul><li>实际上我们可以看出首先我们可以把当前节点$X$为根的子树中含有$1$部分单独剔除来,则这时我们只需要求出子树中含有$1$的节点的最小缺失基因值即可.我们可以仔细分析哪些子树中含有元素$1$?<script type="math/tex; mode=display">root \rightarrow p_{1} \rightarrow p_{2} \rightarrow ... \rightarrow p_{m} \rightarrow 1</script></li></ul></li><li><ul><li>我们只需要依次求出上述节点的缺失最小基因值即可，我们可以采用递归的形式，先求出　$p_{m}$ 的所有子节点和最小确实基因,同时对该子树的所有节点进行标记,接着我们会返回上一层到达 $p_{m-1}$,我们求出该节点的最小缺失基因,同时再将其所有的子节点进行标记.</li></ul></li><li><ul><li>我们逐层的自底向上一直递归,机会把节点的所有基因值进行标记.从而可以求得该链上的所有最小缺失基因.</li></ul></li></ul><ol><li>复杂度分析:</li></ol><ul><li>空间复杂度分析: 时间复杂度分析$O(2*N)$,空间复杂度为$O(n)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; hasone;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[root] == <span class="number">1</span>)&#123;</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[root])&#123;</span><br><span class="line">            ret |= dfs1(v,tree,nums,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">            res[root] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hasone[root] = ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums)</span></span>&#123;</span><br><span class="line">        visit[nums[root]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[root])&#123;</span><br><span class="line">            dfs(v,tree,nums);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hasone[root]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[root])&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasone[v])&#123;</span><br><span class="line">                dfs2(v,tree,nums,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[root])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hasone[v])&#123;</span><br><span class="line">                dfs(v,tree,nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visit[nums[root]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(visit[now]) now++;</span><br><span class="line">        res[root] = now;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestMissingValueSubtree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parents, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = parents.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tree(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;hasone = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;visit = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;now = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parents[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                tree[parents[i]].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(<span class="number">0</span>,tree,nums,ans);</span><br><span class="line">        dfs2(<span class="number">0</span>,tree,nums,ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, mex;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; mp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != p) &#123;</span><br><span class="line">                dfs(v, u);</span><br><span class="line">                mex[u] = max(mex[u], mex[v]);</span><br><span class="line">                <span class="keyword">if</span> (mp[v].size() &gt; mp[u].size())</span><br><span class="line">                    swap(mp[u], mp[v]); </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : mp[v])</span><br><span class="line">                    mp[u].emplace(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[u].emplace(nums[u]);</span><br><span class="line">        <span class="keyword">while</span> (mp[u].count(mex[u]))</span><br><span class="line">            mex[u]++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestMissingValueSubtree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parents, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = parents.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        mex = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">        adj = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            adj[parents[i]].emplace_back(i);</span><br><span class="line">        mp = <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> mex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-258&quot;&gt;&lt;a href=&quot;#leetcode-contest-258&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 258&quot;&gt;&lt;/a&gt;leetcode  contest 258&lt;/h1&gt;&lt;p&gt;第四题还是不会,智商不够,刚开始准备用线段树来实现的.&lt;/p&gt;&lt;h2 id=&quot;5867-反转单词前缀&quot;&gt;&lt;a href=&quot;#5867-反转单词前缀&quot; class=&quot;headerlink&quot; title=&quot;5867. 反转单词前缀&quot;&gt;&lt;/a&gt;5867. 反转单词前缀&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 0 开始的字符串 &lt;code&gt;word&lt;/code&gt; 和一个字符&lt;code&gt;ch&lt;/code&gt; 。找出 ch 第一次出现的下标 i ，反转 &lt;code&gt;word&lt;/code&gt; 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 &lt;code&gt;word&lt;/code&gt; 中不存在字符 &lt;code&gt;ch&lt;/code&gt; ，则无需进行任何操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  LCCUP 2021</title>
    <link href="http://yoursite.com/2021/09/12/325/"/>
    <id>http://yoursite.com/2021/09/12/325/</id>
    <published>2021-09-12T05:07:57.283Z</published>
    <updated>2021-09-12T07:42:44.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-LCCUP-2021"><a href="#leetcode-LCCUP-2021" class="headerlink" title="leetcode  LCCUP 2021"></a>leetcode  LCCUP 2021</h1><p>本身前<code>4</code>题确实不是很难，第五题确实判断合法状态时要复杂一些。</p><h2 id="1-无人机方阵"><a href="#1-无人机方阵" class="headerlink" title="1. 无人机方阵"></a>1. 无人机方阵</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在 「力扣挑战赛」 开幕式的压轴节目 「无人机方阵」中，每一架无人机展示一种灯光颜色。 无人机方阵通过两种操作进行颜色图案变换：</p><p>调整无人机的位置布局<br>切换无人机展示的灯光颜色<br>给定两个大小均为 <code>N*M</code> 的二维数组 <code>source</code> 和 <code>target</code> 表示无人机方阵表演的两种颜色图案，由于无人机切换灯光颜色的耗能很大，请返回从 <code>source</code> 到 <code>target</code> 最少需要多少架无人机切换灯光颜色。</p><a id="more"></a><p>注意： 调整无人机的位置布局时无人机的位置可以随意变动。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：source = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">4</span>]], target = [[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最佳方案为</span><br><span class="line">将 [<span class="number">0</span>,<span class="number">1</span>] 处的无人机移动至 [<span class="number">0</span>,<span class="number">0</span>] 处；</span><br><span class="line">将 [<span class="number">0</span>,<span class="number">0</span>] 处的无人机移动至 [<span class="number">0</span>,<span class="number">1</span>] 处；</span><br><span class="line">将 [<span class="number">1</span>,<span class="number">0</span>] 处的无人机移动至 [<span class="number">1</span>,<span class="number">1</span>] 处；</span><br><span class="line">将 [<span class="number">1</span>,<span class="number">1</span>] 处的无人机移动至 [<span class="number">1</span>,<span class="number">0</span>] 处，其灯光颜色切换为颜色编号为 <span class="number">6</span> 的灯光；</span><br><span class="line">因此从source 到 target 所需要的最少灯光切换次数为 <span class="number">1</span>。</span><br><span class="line"><span class="number">8819</span>ccdd664e91c78cde3bba3c701986.gif</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：source = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]], target = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">仅需调整无人机的位置布局，便可完成图案切换。因此不需要无人机切换颜色</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == source.length == target.length</code></li><li><code>m == source[i].length == target[i].length</code></li><li><code>1 &lt;= n, m &lt;=100</code></li><li><code>1 &lt;= source[i][j], target[i][j] &lt;=10^4</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2021-fall/problems/0jQkd0/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2021-fall/problems/0jQkd0/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>统计每一种颜色,然后统计颜色原有的颜色与目标的颜色种类的差距即可.</li><li>时间复杂度$O(N)$, 空间复杂度为$O(M)$,其中$N$为无人机的数目,$M$为颜色的数目.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumSwitchingTimes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; source, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = source.size();</span><br><span class="line">        <span class="keyword">int</span> col = target[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnts(N);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cntt(N);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                cnts[source[i][j]]++;</span><br><span class="line">                cntt[target[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(cnts[i]-cntt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="2-心算挑战"><a href="#2-心算挑战" class="headerlink" title="2. 心算挑战"></a>2. 心算挑战</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>「力扣挑战赛」心算项目的挑战比赛中，要求选手从 <code>N</code> 张卡牌中选出 <code>cnt</code>张卡牌，若这 <code>cnt</code> 张卡牌数字总和为偶数，则选手成绩「有效」且得分为 <code>cnt</code> 张卡牌数字总和。<br>给定数组 <code>cards</code> 和 <code>cnt</code>，其中 <code>cards[i]</code> 表示第<code>i</code>张卡牌上的数字。 请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回 0。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cards = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>], cnt = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line"></span><br><span class="line">解释：选择数字为 <span class="number">1</span>、<span class="number">8</span>、<span class="number">9</span> 的这三张卡牌，此时可获得最大的有效得分 <span class="number">1</span>+<span class="number">8</span>+<span class="number">9</span>=<span class="number">18</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cards = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>], cnt = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：不存在获取有效得分的卡牌方案。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= cnt &lt;= cards.length &lt;= 10^5</code></li><li><code>1 &lt;= cards[i] &lt;= 1000</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2021-fall/problems/uOAnQW/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2021-fall/problems/uOAnQW/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目的关键在于总数为偶数，我们知道偶数可以分解为任意个偶数与偶数个奇数的和相加，因此我们尝试所有的偶数和奇数的组合即可．每次取最大的$2<em>k$个奇数,然后取最大的$cnt - 2</em>k$个偶数即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(N)$,空间复杂度为$O(N)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxmiumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cards, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cards.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr2;</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        sort(cards.begin(),cards.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cards[i]%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                arr1.push_back(cards[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr2.push_back(cards[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; sum1(arr1.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; sum2(arr2.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l1 = arr1.size();</span><br><span class="line">        <span class="keyword">int</span> l2 = arr2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.size(); ++i)&#123;</span><br><span class="line">            sum1[i+<span class="number">1</span>] = sum1[i] + arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.size(); ++i)&#123;</span><br><span class="line">            sum2[i+<span class="number">1</span>] = sum2[i] + arr2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> even = cnt - i;</span><br><span class="line">            <span class="keyword">int</span> odd = i;</span><br><span class="line">            <span class="keyword">if</span>(even &gt; arr1.size() || odd &gt; arr2.size()) <span class="keyword">continue</span>;</span><br><span class="line">            ans = max(ans,sum1[l1] - sum1[l1-even] + sum2[l2] - sum2[l2-odd]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="3-黑白翻转棋"><a href="#3-黑白翻转棋" class="headerlink" title="3. 黑白翻转棋"></a>3. 黑白翻转棋</h2><p>在 <code>n*m</code> 大小的棋盘中，有黑白两种棋子，黑棋记作字母<code>&quot;X&quot;</code>, 白棋记作字母 <code>&quot;O&quot;</code>，空余位置记作<code>&quot;.&quot;</code>。当落下的棋子与其他相同颜色的棋子在行、列或对角线完全包围（中间不存在空白位置）另一种颜色的棋子，则可以翻转这些棋子的颜色。</p><p>「力扣挑战赛」黑白翻转棋项目中，将提供给选手一个未形成可翻转棋子的棋盘残局，其状态记作 <code>chessboard</code>。若下一步可放置一枚黑棋，请问选手最多能翻转多少枚白棋。</p><p>注意：</p><p>若翻转白棋成黑棋后，棋盘上仍存在可以翻转的白棋，将可以 继续 翻转白棋<br>输入数据保证初始棋盘状态无可以翻转的棋子且存在空余位置<br>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：chessboard = [<span class="string">"....X."</span>,<span class="string">"....X."</span>,<span class="string">"XOOO.."</span>,<span class="string">"......"</span>,<span class="string">"......"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">可以选择下在 [<span class="number">2</span>,<span class="number">4</span>] 处，能够翻转白方三枚棋子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：chessboard = [<span class="string">".X."</span>,<span class="string">".O."</span>,<span class="string">"XO."</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">可以选择下在 [<span class="number">2</span>,<span class="number">2</span>] 处，能够翻转白方两枚棋子。</span><br><span class="line"><span class="number">2126</span>c1d21b1b9a9924c639d449cc6e65.gif</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：chessboard = [<span class="string">"......."</span>,<span class="string">"......."</span>,<span class="string">"......."</span>,<span class="string">"X......"</span>,<span class="string">".O....."</span>,<span class="string">"..O...."</span>,<span class="string">"....OOX"</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">可以选择下在 [<span class="number">6</span>,<span class="number">3</span>] 处，能够翻转白方四枚棋子。</span><br><span class="line"><span class="number">803</span>f2f04098b6174397d6c696f54d709.gif</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= chessboard.length, chessboard[i].length &lt;= 8</code></li><li><code>chessboard[i] 仅包含 &quot;.&quot;、&quot;O&quot; 和 &quot;X&quot;</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2021-fall/problems/fHi6rV/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2021-fall/problems/fHi6rV/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>暴力检测</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目因为数据量很小,感觉没有任何技巧, 我们只需要遍历所有可以放置黑棋的位置,放置黑棋后,然后我们对棋盘上的棋子进行合并和翻转,直到没有可以翻转的可能性位置.代码写的比较水,完全用暴力取检测行,列,对角线中是否存在可以合并的棋子.感觉完全不用技巧的题目,不是很喜欢这个题目.</li><li>时间复杂度为 $O(64<em>64</em>64*8)$,空间复杂度为 $O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board;</span><br><span class="line">    <span class="keyword">int</span> flip;</span><br><span class="line">    Node(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; board,<span class="keyword">int</span> flip)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;board = board;</span><br><span class="line">        <span class="keyword">this</span>-&gt;flip = flip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">flipChess</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; chessboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = chessboard.size();</span><br><span class="line">        <span class="keyword">int</span> col = chessboard[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chessboard[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    chessboard[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                    qu.push(Node(chessboard,<span class="number">0</span>));</span><br><span class="line">                    chessboard[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            Node curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            ans = max(ans,curr.flip);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> flip = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//check row flip</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;          </span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">                arr.push_back(last);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[i][j] != curr.board[i][last])&#123;</span><br><span class="line">                        arr.push_back(j);</span><br><span class="line">                        last = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[i][arr[j<span class="number">-1</span>]] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[i][arr[j]] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[i][arr[j+<span class="number">1</span>]] == <span class="string">'X'</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = arr[j]; k &lt; arr[j+<span class="number">1</span>]; ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[i][k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//check col flip</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;          </span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">                arr.push_back(last);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[j][i] != curr.board[last][i])&#123;</span><br><span class="line">                        arr.push_back(j);</span><br><span class="line">                        last = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j<span class="number">-1</span>]][i] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j]][i] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]][i] == <span class="string">'X'</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = arr[j]; k &lt; arr[j+<span class="number">1</span>]; ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[k][i] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//check diag flip</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row<span class="number">-2</span>; ++i)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> lastx = i;</span><br><span class="line">                <span class="keyword">int</span> lasty = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">                arr.push_back(x*col+y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; (x + j) &lt; row &amp;&amp; (y + j) &lt; col; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[x+j][y+j] != curr.board[lastx][lasty])&#123;</span><br><span class="line">                        arr.push_back((x+j)*col + y + j);</span><br><span class="line">                        lastx = x + j;</span><br><span class="line">                        lasty = y + j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j]/col][arr[j]%col] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j<span class="number">-1</span>]/col][arr[j<span class="number">-1</span>]%col] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]/col][arr[j+<span class="number">1</span>]%col] == <span class="string">'X'</span> )&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = arr[j]%col; k &lt; arr[j+<span class="number">1</span>]%col; ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[arr[j]/col + k - arr[j]%col][k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col<span class="number">-2</span>; ++i)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> lastx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> lasty = i;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> y = i;</span><br><span class="line">                arr.push_back(x*col+y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; (x + j) &lt; row &amp;&amp; (y + j) &lt; col; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[x+j][y+j] != curr.board[lastx][lasty])&#123;</span><br><span class="line">                        arr.push_back((x+j)*col + y + j);</span><br><span class="line">                        lastx = x + j;</span><br><span class="line">                        lasty = y + j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j]/col][arr[j]%col] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j<span class="number">-1</span>]/col][arr[j<span class="number">-1</span>]%col] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]/col][arr[j+<span class="number">1</span>]%col] == <span class="string">'X'</span> )&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = arr[j]%col; k &lt; arr[j+<span class="number">1</span>]%col; ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[arr[j]/col + k - arr[j]%col][k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> lastx = i;</span><br><span class="line">                <span class="keyword">int</span> lasty = col<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = col<span class="number">-1</span>;</span><br><span class="line">                arr.push_back(x*col+y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; (x + j) &lt; row &amp;&amp; (y - j) &gt;= <span class="number">0</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[x+j][y-j] != curr.board[lastx][lasty])&#123;</span><br><span class="line">                        arr.push_back((x+j)*col + y - j);</span><br><span class="line">                        lastx = x + j;</span><br><span class="line">                        lasty = y - j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j]/col][arr[j]%col] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j<span class="number">-1</span>]/col][arr[j<span class="number">-1</span>]%col] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]/col][arr[j+<span class="number">1</span>]%col] == <span class="string">'X'</span> )&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (arr[j+<span class="number">1</span>]/col - arr[j]/col); ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[arr[j]/col+k][arr[j]%col-k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> lastx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> lasty = i;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> y = i;</span><br><span class="line">                arr.push_back(x*col+y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; (x + j) &lt; row &amp;&amp; (y - j) &gt;= <span class="number">0</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[x+j][y-j] != curr.board[lastx][lasty])&#123;</span><br><span class="line">                        arr.push_back((x+j)*col + y - j);</span><br><span class="line">                        lastx = x + j;</span><br><span class="line">                        lasty = y - j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j]/col][arr[j]%col] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j<span class="number">-1</span>]/col][arr[j<span class="number">-1</span>]%col] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]/col][arr[j+<span class="number">1</span>]%col] == <span class="string">'X'</span> )&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (arr[j+<span class="number">1</span>]/col - arr[j]/col); ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[arr[j]/col+k][arr[j]%col-k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flip &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curr.flip += flip;</span><br><span class="line">                qu.push(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="4-玩具套圈"><a href="#4-玩具套圈" class="headerlink" title="4. 玩具套圈"></a>4. 玩具套圈</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>「力扣挑战赛」场地外，小力组织了一个套玩具的游戏。所有的玩具摆在平地上，<code>toys[i]</code> 以 <code>[xi,yi,ri]</code> 的形式记录了第 <code>i</code> 个玩具的坐标 <code>(xi,yi)</code> 和半径 <code>ri</code>。小扣试玩了一下，他扔了若干个半径均为 <code>r</code> 的圈，<code>circles[j]</code>记录了第<code>j</code> 个圈的坐标 <code>(xj,yj)</code>。套圈的规则如下：</p><p>若一个玩具被某个圈完整覆盖了（即玩具的任意部分均在圈内或者圈上），则该玩具被套中。<br>若一个玩具被多个圈同时套中，最终仅计算为套中一个玩具<br>请帮助小扣计算，他成功套中了多少玩具。</p><p>注意：</p><ul><li><p>输入数据保证任意两个玩具的圆心不会重合，但玩具之间可能存在重叠。<br>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：toys = [[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]], circles = [[<span class="number">4</span>,<span class="number">3</span>]], r = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释： 如图所示，仅套中一个玩具</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：toys = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>]], circles = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]], r = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释： 如图所示，套中两个玩具</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><p>提示：</p></li><li><p><code>1 &lt;= toys.length &lt;= 10^4</code></p></li><li><code>0 &lt;= toys[i][0], toys[i][1] &lt;= 10^9</code></li><li><code>1 &lt;= circles.length &lt;= 10^4</code></li><li><code>0 &lt;= circles[i][0], circles[i][1] &lt;= 10^9</code></li><li><code>1 &lt;= toys[i][2], r &lt;= 10</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2021-fall/problems/vFjcfV/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2021-fall/problems/vFjcfV/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>数学问题，咋一看题目挺吓人，关键是在于圈套的半径值只有　$[1,20]$ 之间,此时我们就可以利用数学的方法,来快速的检测出，每个玩具的周围是否存在可以将其完全套住的圈即可．</li><li>我们假设玩具的坐标为$[x_{1},y_{1}]$,玩具的的半径为$r_{1}$,圈的坐标为$[x_{2},y_{2}]$,圈的半径为 $r_{2}$,则此时我们根据数学的判定公式需要满足如下条件,才能使得圈可以完全覆盖住玩具:<script type="math/tex; mode=display">\sqrt{(x_{1}-x_{2})^{2} + (y_{1}-y_{2})^{2}} \le r_{2} - r_{1}</script>即两个圆心的距离小于等于二者的半径之差.</li><li>我们只需要检测在玩具的圆心位置$(x_{1}-10,y_{1}-10),(x_{1}+10,y_{1}+10)$的范围内是否存在满足两个圆覆盖的圆心,该圆心是否在圈中存在.</li><li>时间复杂度为 $O(20<em>20</em>N*\lg(M))$, 空间复杂度为 $O(M)$,其中 $N$ 为玩具的数目, $N$ 为圈的数目.</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">circleGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; toys, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; circles, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;pii&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : circles)&#123;</span><br><span class="line">            cnt.insert(make_pair(v[<span class="number">0</span>],v[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toys.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(toys[i][<span class="number">2</span>] &gt; r) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dx = <span class="number">-10</span>; dx &lt;= <span class="number">10</span>; ++dx)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> dy = <span class="number">-10</span>; dy &lt;= <span class="number">10</span>; ++dy)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((dx*dx + dy*dy) &lt;= (r - toys[i][<span class="number">2</span>])*(r - toys[i][<span class="number">2</span>]))&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = toys[i][<span class="number">0</span>] + dx;</span><br><span class="line">                        <span class="keyword">int</span> y = toys[i][<span class="number">1</span>] + dy;</span><br><span class="line">                        <span class="keyword">if</span>(cnt.count(make_pair(x,y)))&#123;</span><br><span class="line">                            valid = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(valid) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-十字路口的交通"><a href="#5-十字路口的交通" class="headerlink" title="5. 十字路口的交通"></a>5. 十字路口的交通</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>前往「力扣挑战赛」场馆的道路上，有一个拥堵的十字路口，该十字路口由两条双向两车道的路交叉构成。由于信号灯故障，交警需要手动指挥拥堵车辆。假定路口没有新的来车且一辆车从一个车道驶入另一个车道所需的时间恰好为一秒钟，长度为 <code>4</code> 的一维字符串数组<code>directions</code> 中按照 东、南、西、北 顺序记录了四个方向从最靠近路口到最远离路口的车辆计划开往的方向。其中：</p><ul><li>“E” 表示向东行驶；</li><li>“S” 表示向南行驶；</li><li>“W” 表示向西行驶；</li><li>“N” 表示向北行驶。<br>交警每秒钟只能指挥各个车道距离路口最近的一辆车，且每次指挥需要满足如下规则：</li></ul><p>同一秒钟内，一个方向的车道只允许驶出一辆车；<br>同一秒钟内，一个方向的车道只允许驶入一辆车；<br>同一秒钟内，车辆的行驶路线不可相交。<br>请返回最少需要几秒钟，该十字路口等候的车辆才能全部走完。</p><p>各个车道驶出的车辆可能的行驶路线如图所示：</p><p>注意：</p><ul><li>测试数据保证不会出现掉头行驶指令，即某一方向的行驶车辆计划开往的方向不会是当前车辆所在的车道的方向;</li><li>表示堵塞车辆行驶方向的字符串仅用大写字母 “E”，”N”，”W”，”S” 表示。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：directions = [<span class="string">"W"</span>,<span class="string">"N"</span>,<span class="string">"ES"</span>,<span class="string">"W"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 秒：东西方向排在最前的车先行，剩余车辆状态 [<span class="string">""</span>,<span class="string">"N"</span>,<span class="string">"S"</span>,<span class="string">"W"</span>]；</span><br><span class="line">第 <span class="number">2</span> 秒：南、西、北方向的车行驶，路口无等待车辆；</span><br><span class="line">因此最少需要 <span class="number">2</span> 秒，返回 <span class="number">2</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：directions = [<span class="string">"NS"</span>,<span class="string">"WE"</span>,<span class="string">"SE"</span>,<span class="string">"EW"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 秒：四个方向排在最前的车均可驶出；</span><br><span class="line">第 <span class="number">2</span> 秒：东南方向的车驶出，剩余车辆状态 [<span class="string">""</span>,<span class="string">""</span>,<span class="string">"E"</span>,<span class="string">"W"</span>]；</span><br><span class="line">第 <span class="number">3</span> 秒：西北方向的车驶出。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>directions.length = 4</code></li><li><code>0 &lt;= directions[i].length &lt;= 20</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/Y1VbOX" target="_blank" rel="noopener">https://leetcode-cn.com/problems/Y1VbOX</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP　或者　DFS记忆化搜索</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>感觉这个<code>dp</code>最大的难度在于如何判断四个方向出行的车是否合法,检测了半天感觉都有点问题．感觉判断方向是否合法的时候非常容易出错．</li><li>算法时间复杂度为 $O(64*N^{4})$.题目虽然不是很难,但是感觉判断条件非常容易出错.</li></ol></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dir;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; curr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp.count(curr)) <span class="keyword">return</span> dp[curr];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            tot += dir[i].size() - curr[i];           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot == <span class="number">0</span>)&#123;</span><br><span class="line">            dp[curr] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// check valid</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr[j] == dir[j].size())&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!valid) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// check if the direction is valid</span></span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="comment">// E -&gt; S</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//E -&gt; W</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//E -&gt; N</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">// S -&gt; W</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// S -&gt; N</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>))&#123;</span><br><span class="line">                <span class="comment">// W -&gt; E</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// W -&gt; N</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>))&#123;</span><br><span class="line">                <span class="comment">// N -&gt; E</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// N -&gt; S</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) curr[j] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = min(ret,<span class="number">1</span> + dfs(curr));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) curr[j] -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for(int i = 0; i &lt; 4; ++i)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;curr[i]&lt;&lt;":";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;ret&lt;&lt;endl;*/</span></span><br><span class="line">        dp[curr] = ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trafficCommand</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; directions)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directions.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : directions[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'E'</span>)&#123;</span><br><span class="line">                    arr[i].push_back(<span class="number">0</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'S'</span>)&#123;</span><br><span class="line">                    arr[i].push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'W'</span>)&#123;</span><br><span class="line">                    arr[i].push_back(<span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'N'</span>)&#123;</span><br><span class="line">                    arr[i].push_back(<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;dir = arr;</span><br><span class="line">        <span class="keyword">return</span> dfs(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-LCCUP-2021&quot;&gt;&lt;a href=&quot;#leetcode-LCCUP-2021&quot; class=&quot;headerlink&quot; title=&quot;leetcode  LCCUP 2021&quot;&gt;&lt;/a&gt;leetcode  LCCUP 2021&lt;/h1&gt;&lt;p&gt;本身前&lt;code&gt;4&lt;/code&gt;题确实不是很难，第五题确实判断合法状态时要复杂一些。&lt;/p&gt;&lt;h2 id=&quot;1-无人机方阵&quot;&gt;&lt;a href=&quot;#1-无人机方阵&quot; class=&quot;headerlink&quot; title=&quot;1. 无人机方阵&quot;&gt;&lt;/a&gt;1. 无人机方阵&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;在 「力扣挑战赛」 开幕式的压轴节目 「无人机方阵」中，每一架无人机展示一种灯光颜色。 无人机方阵通过两种操作进行颜色图案变换：&lt;/p&gt;&lt;p&gt;调整无人机的位置布局&lt;br&gt;切换无人机展示的灯光颜色&lt;br&gt;给定两个大小均为 &lt;code&gt;N*M&lt;/code&gt; 的二维数组 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;target&lt;/code&gt; 表示无人机方阵表演的两种颜色图案，由于无人机切换灯光颜色的耗能很大，请返回从 &lt;code&gt;source&lt;/code&gt; 到 &lt;code&gt;target&lt;/code&gt; 最少需要多少架无人机切换灯光颜色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 257</title>
    <link href="http://yoursite.com/2021/09/05/324/"/>
    <id>http://yoursite.com/2021/09/05/324/</id>
    <published>2021-09-05T09:42:41.722Z</published>
    <updated>2021-09-07T00:48:32.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-257"><a href="#leetcode-contest-257" class="headerlink" title="leetcode  contest 257"></a>leetcode  contest 257</h1><p>周赛的题目质量果真很高，第二题和第四题，确实出的非常好。</p><h2 id="5863-统计特殊四元组"><a href="#5863-统计特殊四元组" class="headerlink" title="5863. 统计特殊四元组"></a>5863. 统计特殊四元组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 下标从<code>0</code>开始 的整数数组 <code>nums</code>，返回满足下述条件的 不同 四元组<code>(a, b, c, d)</code> 的 数目 ：</p><ul><li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且<br><code>a &lt; b &lt; c &lt; d</code></li></ul><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：满足要求的唯一一个四元组是 (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) 因为 <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> == <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：[<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>] 中不存在满足要求的四元组。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：满足要求的 <span class="number">4</span> 个四元组如下：</span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span></span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>): <span class="number">1</span> + <span class="number">1</span> + <span class="number">3</span> == <span class="number">5</span></span><br><span class="line">- (<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>): <span class="number">1</span> + <span class="number">1</span> + <span class="number">3</span> == <span class="number">5</span></span><br><span class="line">- (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>): <span class="number">1</span> + <span class="number">1</span> + <span class="number">3</span> == <span class="number">5</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">4</span> &lt;= nums.length &lt;= <span class="number">50</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">100</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-257/problems/count-special-quadruplets/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力或者`hash`</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 由于题目数量很小，我们直接暴力 $<span class="number">4</span>$ 重循环即可解决。时间复杂度为 $O(n^&#123;<span class="number">4</span>&#125;)$,空间复杂度为$O(<span class="number">1</span>)$.</span><br><span class="line"><span class="number">2.</span> 另一种解法，我们可以利用 $hash$ 较少一层循环，时间复杂度为 $O(n^&#123;<span class="number">3</span>&#125;)$.</span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> countQuadruplets(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="built_in">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> m = k + <span class="number">1</span>; m &lt; n; ++m)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum == nums[m])&#123;</span><br><span class="line">                            ans++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5864-游戏中弱角色的数量"><a href="#5864-游戏中弱角色的数量" class="headerlink" title="5864. 游戏中弱角色的数量"></a>5864. 游戏中弱角色的数量</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 <code>properties</code> ，其中 <code>properties[i] = [attacki, defensei]</code> 表示游戏中第 <code>i</code>个角色的属性。</p><p>如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 <code>i</code> 弱于 存在的另一个角色<code>j</code>，那么 <code>attackj &gt; attacki</code> 且 <code>defensej &gt; defensei</code> 。</p><p>返回 弱角色 的数量。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties = [[<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在攻击和防御都严格高于其他角色的角色。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties = [[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">10</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= properties.length &lt;= 105</code></li><li><code>properties[i].length == 2</code></li><li><code>1 &lt;= attacki, defensei &lt;= 105</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-all-groups-of-farmland" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-groups-of-farmland</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序 + 贪心算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们将数组按照 $properties$ 的属性的从小到大进行排序。</li><li>我们从数组的后往前进行访问，我们每次保存当前已经访问过的元素的 $defensei$ 的最大值 $maxcurr$，我们每次访问 $attacki$ 相同的元素，如果当前元素的 $defensei$ 严格小于 $maxcurr$,则我们认为一定存在元素满足 $attackj &gt; attacki,defensej &gt; defensei$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(n\lg(n))$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfWeakCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = properties.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCurr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : properties) cnt[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> it = cnt.rbegin();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : it-&gt;second)&#123;</span><br><span class="line">            maxCurr = max(maxCurr,v);</span><br><span class="line">        &#125;</span><br><span class="line">        it++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;it != cnt.rend(); it++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : it-&gt;second)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v &lt; maxCurr) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : it-&gt;second)&#123;</span><br><span class="line">                maxCurr = max(maxCurr,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5865-访问-完所有房间的第一天"><a href="#5865-访问-完所有房间的第一天" class="headerlink" title="5865. 访问`完所有房间的第一天"></a>5865. 访问`完所有房间的第一天</h2><p>你需要访问<code>n</code>个房间，房间从 <code>0</code>到 <code>n - 1</code>编号。同时，每一天都有一个日期编号，从 <code>0</code>开始，依天数递增。你每天都会访问一个房间。</p><p>最开始的第 <code>0</code>天，你访问 <code>0</code>号房间。给你一个长度为<code>n</code>且 下标从 0 开始 的数组 <code>nextVisit</code> 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：</p><p>假设某一天，你访问 i 号房间。</p><ul><li>如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中<code>0 &lt;= nextVisit[i] &lt;= i</code>。</li><li>如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 <code>(i + 1) mod n</code>号房间。<br>请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 <code>109 + 7</code> 取余后的结果。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nextVisit = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 第 <span class="number">0</span> 天，你访问房间 <span class="number">0</span> 。访问 <span class="number">0</span> 号房间的总次数为 <span class="number">1</span> ，次数为奇数。</span><br><span class="line">  下一天你需要访问房间的编号是 nextVisit[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">- 第 <span class="number">1</span> 天，你访问房间 <span class="number">0</span> 。访问 <span class="number">0</span> 号房间的总次数为 <span class="number">2</span> ，次数为偶数。</span><br><span class="line">  下一天你需要访问房间的编号是 (<span class="number">0</span> + <span class="number">1</span>) mod <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">- 第 <span class="number">2</span> 天，你访问房间 <span class="number">1</span> 。这是你第一次完成访问所有房间的那天。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nextVisit = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">你每天访问房间的次序是 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...] 。</span><br><span class="line">第 <span class="number">6</span> 天是你访问完所有房间的第一天。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nextVisit = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">你每天访问房间的次序是 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,...] 。</span><br><span class="line">第 <span class="number">6</span> 天是你访问完所有房间的第一天。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nextVisit.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= nextVisit[i] &lt;= i</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-257/problems/first-day-where-you-have-been-in-all-the-rooms/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-257/problems/first-day-where-you-have-been-in-all-the-rooms/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题，动态规划</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目的思考过程非常有趣，主要有以下几点分析：</li></ol><ul><li>第 $i+1$ 号房间只能通过第 $i$ 号房间来访问,且第 $1$ 次访问 $i$号房间时,从 $[0,i-1]$ 号房间都被访问了偶数次.</li><li>第 $1$ 次访问 $i$ 号房间后,下一个访问的房间号一定为 $nextVisit[i]$, 而此时访问 $nextVisit[i]$ 号时的次数一定为奇数.</li><li>第 $2$ 次访问 $i$ 号房间后,下一个访问的房间号即为 $i+1$.</li><li>我们只关心访问房间的次数的奇数和偶数的性,我们不关心具体的次数. </li></ul><ol><li>我们设 $dp[i]$ 表示第一次访问第 $i$ 号房间时所需要花费的天数, 则我们可以推理出从 $nextVisit[i]$ 第一次访问到第 $i$ 号房间访问的时间间隔一定为: $dp[i] - dp[nextVisit[i]]$.假如我们在奇数次时访问了第 $nextVisit[i]$ 号房间,则此时我们如果要想再回到第 $i$ 号房间,则所需的花费刚好等于 $dp[i] - dp[nextVisit[i]]$.</li><li>因此我们可以推理如下:</li></ol><ul><li>我们如果想第一次到到达第 $i+1$ 号房间,则我们首先需要第 $1$ 次到达第 $i$ 号房间, 然后再到达第 $nextVisit[i]$ 号房间,然后再依次经过 $[nextVisit[i],nextVisit[i]+1,…,i]$ 最终第 $2$ 次到达第 $i$ 号房间,然后下一步即可到达第 $i+1$ 号房间,因此我们可以得到递推公式:<script type="math/tex; mode=display">dp[i+1] = 2 + dp[i] + dp[i] - dp[nextVisit[i]]</script></li></ul><ol><li>时间复杂度为 $O(n)$,空间复杂度为 $O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstDayBeenInAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nextVisit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nextVisit.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = (<span class="number">2</span> + <span class="number">2</span>*dp[i<span class="number">-1</span>] - dp[nextVisit[i<span class="number">-1</span>]] + mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5866-数组的最大公因数排序"><a href="#5866-数组的最大公因数排序" class="headerlink" title="5866. 数组的最大公因数排序"></a>5866. 数组的最大公因数排序</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，你可以在 <code>nums</code> 上执行下述操作 任意次 ：</p><p>如果 <code>gcd(nums[i], nums[j]) &gt; 1</code> ，交换 <code>nums[i] 和 nums[j]</code>的位置。其中 <code>gcd(nums[i], nums[j])</code> 是 <code>nums[i]</code> 和 <code>nums[j]</code> 的最大公因数。<br>如果能使用上述交换方式将 <code>nums</code> 按 非递减顺序 排列，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">21</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可以执行下述操作完成对 [<span class="number">7</span>,<span class="number">21</span>,<span class="number">3</span>] 的排序：</span><br><span class="line">- 交换 <span class="number">7</span> 和 <span class="number">21</span> 因为 gcd(<span class="number">7</span>,<span class="number">21</span>) = <span class="number">7</span> 。nums = [<span class="number">21</span>,<span class="number">7</span>,<span class="number">3</span>]</span><br><span class="line">- 交换 <span class="number">21</span> 和 <span class="number">3</span> 因为 gcd(<span class="number">21</span>,<span class="number">3</span>) = <span class="number">3</span> 。nums = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">21</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法完成排序，因为 <span class="number">5</span> 不能与其他元素交换。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">可以执行下述操作完成对 [<span class="number">10</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>] 的排序：</span><br><span class="line">- 交换 <span class="number">10</span> 和 <span class="number">15</span> 因为 gcd(<span class="number">10</span>,<span class="number">15</span>) = <span class="number">5</span> 。nums = [<span class="number">15</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">- 交换 <span class="number">15</span> 和 <span class="number">3</span> 因为 gcd(<span class="number">15</span>,<span class="number">3</span>) = <span class="number">3</span> 。nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">10</span>]</span><br><span class="line">- 交换 <span class="number">10</span> 和 <span class="number">15</span> 因为 gcd(<span class="number">10</span>,<span class="number">15</span>) = <span class="number">5</span> 。nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">3</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">2</span> &lt;= nums[i] &lt;= <span class="number">105</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/the-number-of-good-subsets</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  集合＋排序</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 首先我们思考一下,对于最大公约数大于 $<span class="number">1</span>$ 的两个位置可以任意交换,所以我们可以发现具有公因子的块中的元素位置是可以任意交换，我们首先需要将这些连通块找出来，然后将这些连通块内的数按照从小到大进行排序，然后检测排序后的结果是否为非递减排序．</span><br><span class="line"><span class="number">2.</span> 题目的难点在于如何找到所有具有大于 $<span class="number">1</span>$ 的质因子的数的集合,我们可以直接利用筛查法, 如果两个集合之间存在任意的两个元素具有大于 $<span class="number">1</span>$ 的公因子,则我们即可将这两个集合进行合并.总体来说这个题目出的很好,质量很高,既考了基本的数学方法,也考了集合,思考也非常综合的一个题目.</span><br><span class="line"><span class="number">3.</span> 复杂度分析:</span><br><span class="line">+ 时间负载度分析: 我们首先需要计算公约数筛查的复杂度分析,公约数的筛查的花费的时间约为:</span><br><span class="line">$$</span><br><span class="line">T_&#123;<span class="number">1</span>&#125; = \frac&#123;n&#125;&#123;<span class="number">2</span>&#125; + \frac&#123;n&#125;&#123;<span class="number">3</span>&#125; + \frac&#123;n&#125;&#123;<span class="number">4</span>&#125; + \frac&#123;n&#125;&#123;<span class="number">5</span>&#125; + ... + \frac&#123;n&#125;&#123;<span class="number">2</span>&#125; \approx n*(\log (n)<span class="number">-1</span>)\\</span><br><span class="line">$$</span><br><span class="line">每次筛查完成后需要进行集合合并所花费的时间为 $\log(n)$,最后我们还需要进行排序花费的时间复杂度为　$O(n \log(n))$,检查时花费的时间为 $O(n)$,因此总的时间复杂度为: $T = n*(\log (n)<span class="number">-1</span>)*\log(n) + n\log(n) + n = n*(\log(n))^&#123;<span class="number">2</span>&#125; + n = n*(\log(n))^&#123;<span class="number">2</span>&#125;$.</span><br><span class="line">+ 空间复杂度分析: 空间复杂度为　$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> find(vector&lt;<span class="built_in">int</span>&gt; &amp;f,<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x] != f[f[x]]) f[x] = find(f,f[x]);</span><br><span class="line">        <span class="keyword">return</span> f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bool</span> merge(vector&lt;<span class="built_in">int</span>&gt; &amp;f,<span class="built_in">int</span> x,<span class="built_in">int</span> y)&#123;</span><br><span class="line">        <span class="built_in">int</span> x1 = find(f,x);</span><br><span class="line">        <span class="built_in">int</span> y1 = find(f,y);</span><br><span class="line">        <span class="keyword">if</span>(x1 != y1) f[x1] = y1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">bool</span> gcdSort(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; pos(MAXN);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; fa(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            pos[nums[i]].push_back(i);</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">2</span>; k &lt; MAXN; ++k)&#123;</span><br><span class="line">            <span class="built_in">int</span> last = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = k; i &lt; MAXN; i += k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos[i].size() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; pos[i].size(); ++j)&#123;</span><br><span class="line">                    merge(fa,pos[i][j<span class="number">-1</span>],pos[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(last &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    merge(fa,last,pos[i].back());</span><br><span class="line">                &#125;</span><br><span class="line">                last = pos[i].back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; arr(MAXN);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr[find(fa,i)].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i].size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                vector&lt;<span class="built_in">int</span>&gt; idx = arr[i];</span><br><span class="line">                sort(idx.begin(),idx.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">int</span> a,<span class="keyword">const</span> <span class="built_in">int</span> b)&#123;</span><br><span class="line">                   <span class="keyword">return</span> nums[a] &lt; nums[b]; </span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr[i].size(); ++j)&#123;</span><br><span class="line">                    ans[arr[i][j]] = nums[idx[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i] &lt; ans[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-257&quot;&gt;&lt;a href=&quot;#leetcode-contest-257&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 257&quot;&gt;&lt;/a&gt;leetcode  contest 257&lt;/h1&gt;&lt;p&gt;周赛的题目质量果真很高，第二题和第四题，确实出的非常好。&lt;/p&gt;&lt;h2 id=&quot;5863-统计特殊四元组&quot;&gt;&lt;a href=&quot;#5863-统计特殊四元组&quot; class=&quot;headerlink&quot; title=&quot;5863. 统计特殊四元组&quot;&gt;&lt;/a&gt;5863. 统计特殊四元组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个 下标从&lt;code&gt;0&lt;/code&gt;开始 的整数数组 &lt;code&gt;nums&lt;/code&gt;，返回满足下述条件的 不同 四元组&lt;code&gt;(a, b, c, d)&lt;/code&gt; 的 数目 ：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums[a] + nums[b] + nums[c] == nums[d]&lt;/code&gt; ，且&lt;br&gt;&lt;code&gt;a &amp;lt; b &amp;lt; c &amp;lt; d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 60</title>
    <link href="http://yoursite.com/2021/09/05/323/"/>
    <id>http://yoursite.com/2021/09/05/323/</id>
    <published>2021-09-05T04:26:05.346Z</published>
    <updated>2021-09-05T07:11:05.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-60"><a href="#leetcode-biweekly-contest-60" class="headerlink" title="leetcode  biweekly contest 60"></a>leetcode  biweekly contest 60</h1><p>双周赛的题目，最后一题确实出的很好的题目，虽然带点技巧，但是确实非常不错。</p><h2 id="5846-找到数组的中间位置"><a href="#5846-找到数组的中间位置" class="headerlink" title="5846. 找到数组的中间位置"></a>5846. 找到数组的中间位置</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，请你找到 最左边 的中间位置 <code>middleIndex</code> （也就是所有可能中间位置下标最小的一个）。</p><a id="more"></a><p>中间位置 <code>middleIndex</code> 是满足 <code>nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]</code> 的数组下标。</p><p>如果 <code>middleIndex == 0</code> ，左边部分的和定义为 <code>0</code> 。类似的，如果 <code>middleIndex == nums.length - 1</code> ，右边部分的和定义为 <code>0</code> 。</p><p>请你返回满足上述条件 最左边 的 <code>middleIndex</code> ，如果不存在这样的中间位置，请你返回 <code>-1</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">下标 <span class="number">3</span> 之前的数字和为：<span class="number">2</span> + <span class="number">3</span> + <span class="number">-1</span> = <span class="number">4</span></span><br><span class="line">下标 <span class="number">3</span> 之后的数字和为：<span class="number">4</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-1</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">下标 <span class="number">2</span> 之前的数字和为：<span class="number">1</span> + <span class="number">-1</span> = <span class="number">0</span></span><br><span class="line">下标 <span class="number">2</span> 之后的数字和为：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">不存在符合要求的 middleIndex 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">下标 <span class="number">0</span> 之前的数字和为：<span class="number">0</span></span><br><span class="line">下标 <span class="number">0</span> 之后的数字和为：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-middle-index-in-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-middle-index-in-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单题目，滑动窗口即可，我们依次遍历每一个元素，然后比较该元素左边贺该元素右边的和是否相等。我们子数组的和的时候，我们可以利用前缀和即可。</li><li>算法时间复杂度为 $O(n)$,空间复杂度为 $O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMiddleIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[i] == (sum[n] - sum[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5847-找到所有的农场组"><a href="#5847-找到所有的农场组" class="headerlink" title="5847. 找到所有的农场组"></a>5847. 找到所有的农场组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code>开始，大小为 <code>m x n</code>的二进制矩阵 <code>land</code>，其中 <code>0</code> 表示一单位的森林土地，<code>1</code>表示一单位的农场土地。</p><p>为了让农场保持有序，农场土地之间以矩形的 农场组 的形式存在。每一个农场组都 仅 包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 不会 与另一个农场组的任何一块土地在四个方向上相邻。</p><p><code>land</code> 可以用坐标系统表示，其中 <code>land</code> 左上角坐标为 <code>(0, 0)</code> ，右下角坐标为 <code>(m-1, n-1)</code> 。请你找到所有 农场组 最左上角和最右下角的坐标。一个左上角坐标为 <code>(r1, c1)</code> 且右下角坐标为 <code>(r2, c2)</code> 的 农场组 用长度为 <code>4</code> 的数组 <code>[r1, c1, r2, c2]</code> 表示。</p><p>请你返回一个二维数组，它包含若干个长度为 <code>4</code> 的子数组，每个子数组表示 <code>land</code> 中的一个 农场组 。如果没有任何农场组，请你返回一个空数组。可以以 任意顺序 返回所有农场组。</p><p>示例 1：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：land = [[1,0,0],[0,1,1],[0,1,1]]</span><br><span class="line">输出：[[0,0,0,0],[1,1,2,2]]</span><br><span class="line">解释：</span><br><span class="line">第一个农场组的左上角为 land[<span class="string">0</span>][<span class="symbol">0</span>] ，右下角为 land[<span class="string">0</span>][<span class="symbol">0</span>] 。</span><br><span class="line">第二个农场组的左上角为 land[<span class="string">1</span>][<span class="symbol">1</span>] ，右下角为 land[<span class="string">2</span>][<span class="symbol">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：land = [[1,1],[1,1]]</span><br><span class="line">输出：[[0,0,1,1]]</span><br><span class="line">解释：</span><br><span class="line">第一个农场组左上角为 land[<span class="string">0</span>][<span class="symbol">0</span>] ，右下角为 land[<span class="string">1</span>][<span class="symbol">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：land = <span class="string">[[0]]</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">没有任何农场组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == land.length</code></li><li><code>n == land[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>land</code> 只包含 <code>0</code> 和 <code>1</code> 。</li><li>农场组都是 矩形 的形状。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-all-groups-of-farmland" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-groups-of-farmland</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们利用 ${BFS}$ 找到每个连通的子区域，然后判断该区域是否为矩形即可。</li><li>判断一个区域是否为矩形，可以用如下算法：</li></ol><ul><li>我们设矩形的左上角的坐标为 $(r1,c1)$,右下角的坐标为 $(r2,c2)$,则此时矩形中的元素应该为 $(r2-r1+1) \cdot (c2-c1+1)$.</li><li>我们此时判断该区域的个数 $total$ 是否与 $(r2-r1+1) \cdot (c2-c1+1)$ 相等.</li></ul><ol><li>时间复杂度为 $O(m<em>n)$，空间复杂度为$O(m</em>n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findFarmland(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; land) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = land.size();</span><br><span class="line">        <span class="keyword">int</span> col = land[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(land[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(visit[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> r1 = i;</span><br><span class="line">                <span class="keyword">int</span> c1 = j;</span><br><span class="line">                <span class="keyword">int</span> r2 = i;</span><br><span class="line">                <span class="keyword">int</span> c2 = j;</span><br><span class="line">                <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">                qu.push(i*col+j);</span><br><span class="line">                visit[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                    tot++;</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = curr/col + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = curr%col + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(land[x][y] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(visit[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                        r2 = max(r2,x);</span><br><span class="line">                        c2 = max(c2,y);</span><br><span class="line">                        r1 = min(r1,x);</span><br><span class="line">                        c1 = min(c1,y);</span><br><span class="line">                        visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">                        qu.push(x*col+y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> cnt = (r2-r1+<span class="number">1</span>)*(c2-c1+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(cnt == tot &amp;&amp; r1 == i &amp;&amp; c1 == j)&#123;</span><br><span class="line">                    ans.push_back(&#123;r1,c1,r2,c2&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5848-树上的操作"><a href="#5848-树上的操作" class="headerlink" title="5848. 树上的操作"></a>5848. 树上的操作</h2><p>给你一棵 <code>n</code> 个节点的树，编号从 <code>0</code>到 <code>n - 1</code> ，以父节点数组 <code>parent</code> 的形式给出，其中 <code>parent[i]</code> 是第 <code>i</code> 个节点的父节点。树的根节点为 <code>0</code>号节点，所以 <code>parent[0] = -1</code> ，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。</p><p>数据结构需要支持如下函数：</p><ul><li><code>Lock</code>：指定用户给指定节点 上锁 ，上锁后其他用户将无法给同一节点上锁。只有当节点处于未上锁的状态下，才能进行上锁操作。</li><li><code>Unlock</code>：指定用户给指定节点 解锁 ，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。</li><li><p><code>Upgrade</code>：指定用户给指定节点 上锁 ，并且将该节点的所有子孙节点 解锁 。只有如下 <code>3</code> 个条件 全部 满足时才能执行升级操作：<br>指定节点当前状态为未上锁。<br>指定节点至少有一个上锁状态的子孙节点（可以是 任意 用户上锁的）。<br>指定节点没有任何上锁的祖先节点。<br>请你实现 <code>LockingTree</code> 类：</p></li><li><p><code>LockingTree(int[] parent)</code> 用父节点数组初始化数据结构。</p></li><li><code>lock(int num, int user)</code> 如果 <code>id</code> 为 <code>user</code> 的用户可以给节点 <code>num</code> 上锁，那么返回 true ，否则返回 false 。如果可以执行此操作，节点 num 会被 id 为 user 的用户 上锁 。</li><li><code>unlock(int num, int user)</code> 如果 id 为 user 的用户可以给节点 num 解锁，那么返回 true ，否则返回 false 。如果可以执行此操作，节点 num 变为 未上锁 状态。</li><li><code>upgrade(int num, int user)</code> 如果 <code>id</code> 为 <code>user</code> 的用户可以给节点 <code>num</code> 升级，那么返回 <code>true</code> ，否则返回 <code>false</code>。如果可以执行此操作，节点 num 会被 升级 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"LockingTree"</span>, <span class="string">"lock"</span>, <span class="string">"unlock"</span>, <span class="string">"unlock"</span>, <span class="string">"lock"</span>, <span class="string">"upgrade"</span>, <span class="string">"lock"</span>]</span><br><span class="line">[[[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">输出：</span><br><span class="line">[<span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">LockingTree lockingTree = new LockingTree([<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]);</span><br><span class="line">lockingTree.lock(<span class="number">2</span>, <span class="number">2</span>);    <span class="comment">// 返回 true ，因为节点 2 未上锁。</span></span><br><span class="line">                           <span class="comment">// 节点 2 被用户 2 上锁。</span></span><br><span class="line">lockingTree.unlock(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 返回 false ，因为用户 3 无法解锁被用户 2 上锁的节点。</span></span><br><span class="line">lockingTree.unlock(<span class="number">2</span>, <span class="number">2</span>);  <span class="comment">// 返回 true ，因为节点 2 之前被用户 2 上锁。</span></span><br><span class="line">                           <span class="comment">// 节点 2 现在变为未上锁状态。</span></span><br><span class="line">lockingTree.lock(<span class="number">4</span>, <span class="number">5</span>);    <span class="comment">// 返回 true ，因为节点 4 未上锁。</span></span><br><span class="line">                           <span class="comment">// 节点 4 被用户 5 上锁。</span></span><br><span class="line">lockingTree.upgrade(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 返回 true ，因为节点 0 未上锁且至少有一个被上锁的子孙节点（节点 4）。</span></span><br><span class="line">                           <span class="comment">// 节点 0 被用户 1 上锁，节点 4 变为未上锁。</span></span><br><span class="line">lockingTree.lock(<span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 返回 false ，因为节点 0 已经被上锁了。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == parent.length</code></li><li><code>2 &lt;= n &lt;= 2000</code></li><li>对于 <code>i != 0</code>，满足 <code>0 &lt;= parent[i] &lt;= n - 1</code></li><li><code>parent[0] == -1</code></li><li><code>0 &lt;= num &lt;= n - 1</code></li><li><code>1 &lt;= user &lt;= 104</code></li><li><code>parent</code> 表示一棵合法的树。</li><li><code>lock</code> ，<code>unlock</code> 和 <code>upgrade</code> 的调用 总共 不超过 <code>2000</code>次。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/operations-on-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/operations-on-tree</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目看似比较简单，但是感觉出的还是比较有新意。</li><li>我们首先要建立树的关系，记录每个节点 $p$ 的父节点 $pa[p]$ 和子节点数组 $ch[p]$,同时设立另外单独的数组 $lockuser[p]$ 记录节点 $p$上锁的用户 $id$,同时另外记录两个数组 $chlock[p]$ 和 $palock[p]$,其中 $chlock[p]$ 表示节点 $p$ 的子节点中有多少个节点被 $lock$，$palock[p]$表示节点 $p$ 的父节点中有多少个节点被 $lock$。</li><li>具体算法如下：</li></ol><ul><li><code>lock(int num, int user)</code>：在<code>lock</code>操作时，首先判断该节点 $num$ 是否已经被 $lock$,如果被 $lock$ 则直接返回错误；如果没有被 $lock$,则我们直接将其 $lock$,同时将该节点 $num$ 的所有父节点的 $chlock$ 加 $1$, 同时将该节点 $num$ 的所有子节点的 $palock$ 加 $1$,。</li><li><code>unlock(int num, int user)</code>：在<code>unlock</code>操作时，首先判断该节点 $num$ 是否已经被 $lock$,如果未被 $lock$ 则直接返回错误；如果被 $lock$,则我们判断 $lockuser$ 是否与 $user$ 相等，如果相等则将其进行 $unlock$操作。直接将其 $unlock$,同时将该节点 $num$ 的所有父节点的 $chlock$ 减 $1$, 同时将该节点 $num$ 的所有子节点的 $palock$ 减 $1$,。</li><li><code>upgrade(int num, int user)</code>：首先判断该节点是否 $lock$,其次判断节点的 $palock$ 是否等于 $0$, 再次判断该节点的 $chlock$ 是否大于 $0$。首先我们需要将节点 $num$ 的所有父节点的 $chlock$ 加上 $1 - chlock[num]$,其次我们将该节点的所有子节点的全部设置为 $unlock$,同时将所有的子节点的 $chlock$ 设置为 $0$,所有子节点的 $palock$ 设置为 $1$。</li></ul><ol><li>算法的时间复杂度为 $O(n^{2})$,空间复杂度为 $O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LockingTree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parent) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = parent.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;pa = parent;</span><br><span class="line">        <span class="keyword">this</span>-&gt;palock = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;chlock = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;lockuser = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ch[parent[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addparent</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : ch[num])&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;palock[v] += x;</span><br><span class="line">            addparent(v,x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addchild</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="keyword">this</span>-&gt;pa[num];</span><br><span class="line">        <span class="keyword">while</span>(p &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;chlock[p] += x;</span><br><span class="line">            p = pa[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lockuser[num] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lockuser[num] = user;</span><br><span class="line">        </span><br><span class="line">        addchild(num,<span class="number">1</span>);</span><br><span class="line">        addparent(num,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lockuser[num] != user) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lockuser[num] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        addchild(num,<span class="number">-1</span>);</span><br><span class="line">        addparent(num,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">setparent</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : ch[num])&#123;</span><br><span class="line">            lockuser[v] = <span class="number">0</span>;</span><br><span class="line">            chlock[v] = <span class="number">0</span>;</span><br><span class="line">            palock[v] = x;</span><br><span class="line">            setparent(v,x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">upgrade</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lockuser[num] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(palock[num] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(chlock[num] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lockuser[num] = user;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span> - chlock[num];</span><br><span class="line">        addchild(num,x);</span><br><span class="line">        setparent(num,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pa;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ch;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; palock;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chlock;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lockuser;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LockingTree object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LockingTree* obj = new LockingTree(parent);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;lock(num,user);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;unlock(num,user);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;upgrade(num,user);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5849-好子集的数目"><a href="#5849-好子集的数目" class="headerlink" title="5849. 好子集的数目"></a>5849. 好子集的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。如果 <code>nums</code> 的一个子集中，所有元素的乘积可以用若干个 互不相同的质数 相乘得到，那么我们称它为 好子集 。</p><p>比方说，如果 <code>nums = [1, 2, 3, 4]</code>：<br><code>[2, 3] ，[1, 2, 3] 和 [1, 3]</code> 是 好 子集，乘积分别为 <code>6 = 2*3 ，6 = 2*3 和 3 = 3</code> 。<br><code>[1, 4]</code> 和<code>[4]</code>不是 好 子集，因为乘积分别为<code>4 = 2*2</code>和 <code>4 = 2*2</code>。<br>请你返回 <code>nums</code> 中不同的 好 子集的数目对 <code>109 + 7</code> 取余 的结果。</p><p><code>nums</code> 中的 子集 是通过删除<code>nums</code> 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：好子集为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>]：乘积为 <span class="number">2</span> ，可以表示为质数 <span class="number">2</span> 的乘积。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]：乘积为 <span class="number">6</span> ，可以表示为互不相同的质数 <span class="number">2</span> 和 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">3</span>]：乘积为 <span class="number">3</span> ，可以表示为质数 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">2</span>]：乘积为 <span class="number">2</span> ，可以表示为质数 <span class="number">2</span> 的乘积。</span><br><span class="line">- [<span class="number">2</span>,<span class="number">3</span>]：乘积为 <span class="number">6</span> ，可以表示为互不相同的质数 <span class="number">2</span> 和 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">3</span>]：乘积为 <span class="number">3</span> ，可以表示为质数 <span class="number">3</span> 的乘积。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：好子集为：</span><br><span class="line">- [<span class="number">2</span>]：乘积为 <span class="number">2</span> ，可以表示为质数 <span class="number">2</span> 的乘积。</span><br><span class="line">- [<span class="number">2</span>,<span class="number">3</span>]：乘积为 <span class="number">6</span> ，可以表示为互不相同质数 <span class="number">2</span> 和 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">2</span>,<span class="number">15</span>]：乘积为 <span class="number">30</span> ，可以表示为互不相同质数 <span class="number">2</span>，<span class="number">3</span> 和 <span class="number">5</span> 的乘积。</span><br><span class="line">- [<span class="number">3</span>]：乘积为 <span class="number">3</span> ，可以表示为质数 <span class="number">3</span> 的乘积。</span><br><span class="line">- [<span class="number">15</span>]：乘积为 <span class="number">15</span> ，可以表示为互不相同质数 <span class="number">3</span> 和 <span class="number">5</span> 的乘积。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 30</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/the-number-of-good-subsets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-number-of-good-subsets</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩 + 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>刚开始拿到这个题目感觉很奇怪，竟然没有思路，后来仔细想了一下，想出来了，我们利用状态压缩即可，当然这个状态压缩会稍微麻烦一点，题目中其实最重要的提示为 $1 \le  nums[i] \le 30$. 竟然每个元素都小于等于 $30$,由于子数组与数组元素的顺序无关，则我们可以将数组进行压缩，只存储每个元素出现的次数即可。</li><li>由于每个元素的大小都处于 $1 \le  nums[i] \le 30$ 之间，则我们应该首先可以求出在小于等于 $30$的质数的数组为：$[2,3,5,7,11,13,17,19,23,29]$, 我们看到质数最多只有 $10$个，因此我们可以知道不同的质数组合最多也只有 $2^{10}$ 种组合，因此我们想到可以用状态压缩$dp$.</li></ol><ul><li>我们设 $dp[i][mask]$ 表示当前小于等于 $i$ 的元素种，不同元素的乘积组合分解成不同的素数的组合状态刚好 $mask$ 时的个数。我们设将$num$ 分解为质数乘积的掩码为 $maks(num)$,则此时我们可以得到递推公式如下：<script type="math/tex; mode=display">dp[i+1][mask(i+1)|state] = (dp[i+1][mask(i+1)|state] + dp[i][state]*cnt[i+1]) \qquad (if \quad mask(i+1) \And state == 0)</script></li><li>因为题目中要求必须子集中的乘积分解为不同的质数，则必须满足 $mask(i+1) \And state == 0$,即表示元素 $i+1$ 与子集$state$ 之间无重复的质因子。</li><li>我们最终求出的结果为将所有可能的组合进行相加即可：<script type="math/tex; mode=display">ans = \sum_{i=0}^{2^{m}-1}dp[30][i]</script></li></ul></blockquote><ul><li>另外我们需要单独处理的是题目中 $1$ 的个数，由于题目明确说明如果两个子集删除的下标不同，那么它们被视为不同的子集,则我们知道所有不同素因子乘积的组合的总数目为 $ans$,则此时假设我们有 $cnt[1]$ 个 $1$,则我们知道对于 $1$ 的取法的种类有:<script type="math/tex; mode=display">\begin{aligned}count &= C_{cnt[1]}^{0} + C_{cnt[1]}^{1} + C_{cnt[1]}^{2} + ... + C_{cnt[1]}^{cnt[1]} \\&= 2^{cnt[1]}\end{aligned}</script>所有我们知道最终所有可能的组合应该为: <script type="math/tex; mode=display">ans = 2^{cnt[1]}*\sum_{i=0}^{2^{m}-1}dp[30][i]</script></li></ul><ol><li>复杂度分析：</li></ol><ul><li>时间复杂度为 $O(n*2^{m})$, 其中 $n$ 为数组中的最大元素， $m$为所有小于等于 $n$ 的质数的个数。</li><li>空间复杂度为 $O(n + 2^{m})$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = x;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>)&#123;</span><br><span class="line">                ret = (ret*curr)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfGoodSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = prime.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">1</span>&lt;&lt;m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt(<span class="number">31</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; valid(<span class="number">31</span>,<span class="literal">true</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cnt[nums[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">30</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j%(prime[i]*prime[i])) == <span class="number">0</span>)&#123;</span><br><span class="line">                    valid[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">30</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!valid[i]) <span class="keyword">continue</span>;</span><br><span class="line">             <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp = dp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i%prime[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    mask |= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;m); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mask&amp;j) <span class="keyword">continue</span>;</span><br><span class="line">                ndp[mask|j] = (ndp[mask|j] + dp[j]*cnt[i])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans = (ans*fastpow(<span class="number">2</span>,cnt[<span class="number">1</span>],mod))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-60&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-60&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 60&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 60&lt;/h1&gt;&lt;p&gt;双周赛的题目，最后一题确实出的很好的题目，虽然带点技巧，但是确实非常不错。&lt;/p&gt;&lt;h2 id=&quot;5846-找到数组的中间位置&quot;&gt;&lt;a href=&quot;#5846-找到数组的中间位置&quot; class=&quot;headerlink&quot; title=&quot;5846. 找到数组的中间位置&quot;&gt;&lt;/a&gt;5846. 找到数组的中间位置&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找到 最左边 的中间位置 &lt;code&gt;middleIndex&lt;/code&gt; （也就是所有可能中间位置下标最小的一个）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab6 Cow Pages</title>
    <link href="http://yoursite.com/2021/09/02/322/"/>
    <id>http://yoursite.com/2021/09/02/322/</id>
    <published>2021-09-02T02:55:41.241Z</published>
    <updated>2021-09-02T13:33:15.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cow-pages"><a href="#cow-pages" class="headerlink" title="cow pages"></a>cow pages</h1><p>感觉<code>cow lab</code>是我做的最纠结的<code>lab</code>了，代码量其实非常少，但是就是非常见简单的<code>20</code>~<code>30</code>行代码，就出了许多莫名奇妙的<code>bug</code>。<code>copy on write page</code>实现原理非常简单，父进程在创建子进程时，子进程只需要将父进程的所有的虚拟地址<code>拷贝</code>一份即可,此时子进程与父进程共享同样的物理页，子进程和父进程可以同时读取同样的物理页面；当子进程或者父进程需要将数据写回物理页时，则申请一块新的物理页，并将虚拟地址重新映射到新的物理页上。这样实现的好处有两点：</p><a id="more"></a><ul><li>可以节省内存，此时子进程与父进程可以有多个进行共享只读的物理页面，从而减少物理内存的使用。</li><li>可以加快子进程的创建效率，此时子进程不需要再重新申请物理页面，从而可以加快子进程的创建速度。<br>在这个<code>lab</code>实现的时候真心遇到各种坑，熬了不少夜，很多莫名奇妙的<code>bug</code>总是出现，可以记录下出现的各种<code>bug</code>。</li><li>出现<code>page fault</code>，且<code>scause = 2</code>，表示出现了错误的指令。</li><li>出现<code>page fault</code>,且<code>scause = 12</code>,表示出现了加载页面失败的错误。</li><li>程序在单核模式下运行正确，但在多核模式下就各种奇怪的问题。</li><li>程序莫名奇妙出现陷入死循环，卡住不动。<br><img src="https://i.loli.net/2021/09/02/rUC6nqydHvie1ND.png" alt><br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-cow-handin" target="_blank" rel="noopener">git repo</a></li></ul><h2 id="Implement-copy-on-write"><a href="#Implement-copy-on-write" class="headerlink" title="Implement copy-on write"></a>Implement copy-on write</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your task <span class="keyword">is</span> <span class="keyword">to</span> implement <span class="keyword">copy</span>-<span class="keyword">on</span>-<span class="built_in">write</span> fork <span class="keyword">in</span> <span class="keyword">the</span> xv6 kernel. You are done <span class="keyword">if</span> your modified kernel executes both <span class="keyword">the</span> cowtest <span class="keyword">and</span> usertests programs successfully.</span><br></pre></td></tr></table></figure><p>代码实现的话，总共分为四个部门:</p><ul><li><code>uvmcopy</code>时，此时我们需要将子进程的页表项中的所有虚拟地址全部映射到父进程的物理页面里面。</li><li><code>copyout</code>时，此时因为在系统内部调用文件读写时，此时则是通过<code>copy out</code>和<code>copy in</code>来实现的，此时我们则需要判断当前的页面是否为<code>cow page</code>，如果为<code>cow page</code>则需要重新申请物理内存页面，然后重新写入数据。h’t’y’y’y’y’y’y’y’y’y’y’y’y’y’y’y’y’y </li><li><code>usertrap</code>：在发生写入没有写权限的页面时，就会处罚<code>page fault</code>的<code>trap</code>，此时我们需要申请新的物理页面然后映射到虚拟地址上，然后再次重新执行该指令。</li><li><code>kalloc</code>: 在进行<code>kalloc</code>和<code>kfree</code>时，我们增加对物理页面内存的引用计数，如果一个物理页面被映射到多个虚拟地址上，则每增加一次映射，则将计数进行增加，每次进行<code>free</code>操作时，我们则将引用进行进行较少，当引用计数为<code>0</code>时，此时我们可以释放该物理页面，并进行回收。</li></ul><ol><li><code>usertrap</code>: 添加对trap的处理<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= MAXVA || (va &lt;= PGROUNDDOWN(p-&gt;trapframe-&gt;sp) &amp;&amp; va &gt;= PGROUNDDOWN(p-&gt;trapframe-&gt;sp) - PGSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测pte的flag</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcowalloc(p-&gt;pagetable, va) != <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>vm：</li></ol><ul><li>子进程复制时，对物理内存页进行标记<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">uvmcopy(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"uvmcopy: pte should exist"</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"uvmcopy: page not present"</span>);</span><br><span class="line"></span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear PTE_W and mark the page as cow page.</span></span><br><span class="line">    <span class="keyword">if</span>(flags &amp; PTE_W)&#123;</span><br><span class="line">      flags = (flags | PTE_COW) &amp; (~PTE_W);</span><br><span class="line">      *pte = PA2PTE(pa) | flags;</span><br><span class="line">    &#125;</span><br><span class="line">    krefinc((<span class="keyword">void</span>*)pa);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>检测是否为<code>cow page</code>,如果是<code>cow page</code>则申请新的物理页，加进来。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">uvmcowalloc(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">if</span> (pa == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  flags = PTE_FLAGS(*pte);</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; PTE_COW)&#123;  </span><br><span class="line">    flags = (flags &amp; ~PTE_COW) | PTE_W;</span><br><span class="line">    <span class="keyword">char</span> *ka = kalloc();</span><br><span class="line">    <span class="keyword">if</span> (ka == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    memmove(ka, (<span class="keyword">char</span>*)pa, PGSIZE);</span><br><span class="line">    kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">    *pte = PA2PTE((uint64)ka) | flags;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>copyout</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">copyout(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="keyword">if</span> (uvmcowalloc(pagetable, va0) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>kalloc</code>函数处理：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint32 <span class="title">krefcount</span><span class="params">(<span class="keyword">void</span> *pa)</span></span>&#123;</span><br><span class="line">uint32 ret = <span class="number">0</span>;</span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">ret = kmem.refcount[PA2IDX(pa)];</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">krefinc</span><span class="params">(<span class="keyword">void</span> *pa)</span></span>&#123;</span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">kmem.refcount[PA2IDX(pa)]++;</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">krefdec</span><span class="params">(<span class="keyword">void</span> *pa)</span></span>&#123;</span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">kmem.refcount[PA2IDX(pa)]--;</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul><li>当我们遇到<code>fork</code>时我们如何处理？</li><li><ul><li>我们依次拷贝父进程的所有虚拟地址空间，同时将子进程的虚拟地址全部隐射到父进程的物理页面，并同时将父进程和子进程的页面全部标记为<code>cow page</code>。假设父进程的页面已经全部都为<code>cow page</code>,则此时我们只需要设置子进程的页面标志即可。</li></ul></li><li>当父进程或子进程写<code>cow page</code>时，我们如何处理？</li><li><ul><li>父进程或子进程写<code>cow page</code>时，我们直接申请一个新的物理页，并将虚拟地址映射到新的物理页上即可。</li></ul></li><li>引用计数的数组长度？</li><li><ul><li>引用数组，如果直接选择的话，实际上我们可以选择长度为$\frac{PHYSTOP}{4096}$。但是实际上没有必要，实际上我们可以看到大于$kernelbase$以上的高地址位都被内核给占用了，不会分配给用户进程，实际上这些物理页面被分配后，永远不会再被别的进程占用和分配。因此实际上我们的长度可以设定为$\frac{PHYSTOP-KERNELBASE}{4096}$.</li></ul></li><li>为什么我们需要处理<code>copy out</code>?</li><li><code>cow page</code>写入时如何处理？</li><li><ul><li><code>cow page</code>写入时会发生<code>trap</code>，因为此时该物理页并没有写入的标志，此时我们则需要捕获<code>trap</code>，然后进行处理。</li></ul></li><li>当<code>cow page</code>被子进程复制时，如何处理?</li><li><ul><li>我们直接进行将地址进行映射。</li></ul></li><li>当前<code>cow page</code>的引用计数？</li><li><ul><li>当<code>cow page</code>的<code>reference</code>大于<code>1</code>时，则我们可以知道该页面可能被多个进程映射，则此时我们按照正常的<code>cow page</code>处理即可。</li></ul></li><li><ul><li>当<code>cow page</code>的<code>reference</code>等于<code>1</code>时，则我们可以知道该页面只被一个进程映射，则此时我们可以还是按照正常的进程申请物理页面然后映射；其实我们还有另一种办法，直接恢复该页面的标记，将该物理页面标记为正常的页面，可读可写即可。</li></ul></li><li><ul><li>我们进行<code>kfree</code>时，会对引用计数减一操作，引用计数如果大于<code>1</code>时，则我们此时不做任何操作。当<code>reference</code>等于<code>0</code>时，则我们可以知道该页面未被任何一个进程引用，则可以对其进行释放。</li></ul></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;cow-pages&quot;&gt;&lt;a href=&quot;#cow-pages&quot; class=&quot;headerlink&quot; title=&quot;cow pages&quot;&gt;&lt;/a&gt;cow pages&lt;/h1&gt;&lt;p&gt;感觉&lt;code&gt;cow lab&lt;/code&gt;是我做的最纠结的&lt;code&gt;lab&lt;/code&gt;了，代码量其实非常少，但是就是非常见简单的&lt;code&gt;20&lt;/code&gt;~&lt;code&gt;30&lt;/code&gt;行代码，就出了许多莫名奇妙的&lt;code&gt;bug&lt;/code&gt;。&lt;code&gt;copy on write page&lt;/code&gt;实现原理非常简单，父进程在创建子进程时，子进程只需要将父进程的所有的虚拟地址&lt;code&gt;拷贝&lt;/code&gt;一份即可,此时子进程与父进程共享同样的物理页，子进程和父进程可以同时读取同样的物理页面；当子进程或者父进程需要将数据写回物理页时，则申请一块新的物理页，并将虚拟地址重新映射到新的物理页上。这样实现的好处有两点：&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 256</title>
    <link href="http://yoursite.com/2021/08/23/321/"/>
    <id>http://yoursite.com/2021/08/23/321/</id>
    <published>2021-08-23T15:22:32.728Z</published>
    <updated>2021-09-02T12:32:38.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-256"><a href="#leetcode-contest-256" class="headerlink" title="leetcode contest 256"></a>leetcode contest 256</h1><p>本周的周赛题目难度始终，不过前三题确实比较简单。最后一题是之前某个题目的变形，确实不好想到。</p><h2 id="5854-学生分数的最小差值"><a href="#5854-学生分数的最小差值" class="headerlink" title="5854. 学生分数的最小差值"></a>5854. 学生分数的最小差值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 下标从 <code>0</code> 开始 的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code>名学生的分数。另给你一个整数 <code>k</code> 。</p><p>从数组中选出任意<code>k</code>名学生的分数，使这<code>k</code>个分数间 最高分 和 最低分 的 差值 达到 最小化 。</p><a id="more"></a><p>返回可能的 最小差值 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">90</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：选出 <span class="number">1</span> 名学生的分数，仅有 <span class="number">1</span> 种方法：</span><br><span class="line">- [<span class="number">90</span>] 最高分和最低分之间的差值是 <span class="number">90</span> - <span class="number">90</span> = <span class="number">0</span></span><br><span class="line">可能的最小差值是 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：选出 <span class="number">2</span> 名学生的分数，有 <span class="number">6</span> 种方法：</span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">9</span> - <span class="number">4</span> = <span class="number">5</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">9</span> - <span class="number">1</span> = <span class="number">8</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">9</span> - <span class="number">7</span> = <span class="number">2</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">4</span> - <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">7</span> - <span class="number">4</span> = <span class="number">3</span></span><br><span class="line">- [<span class="number">9</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] 最高分和最低分之间的差值是 <span class="number">7</span> - <span class="number">1</span> = <span class="number">6</span></span><br><span class="line">可能的最小差值是 <span class="number">2</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= k &lt;= nums.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">105</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   排序 + 滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 我们遍历所有可能的最小值即可。我们首先将所有学生的分数按照从小到大排名，找到第`i`个排名与第`i+k<span class="number">-1</span>`个排名的成绩之间的最小值即可。因为我们知道任意选择`nums[i]`作为已选则的`k`个学生中的最小分数，则使得最高分和最低分的差值最小的话，则我们应该选择最大值为$nums[i+k<span class="number">-1</span>]$.</span><br><span class="line"><span class="number">2.</span> 算法时间复杂度为$O(nlg + n)$,空间复杂度为$O(<span class="number">1</span>)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minimumDifference(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= n-k; ++i)&#123;</span><br><span class="line">            ans = min(ans,nums[i+k<span class="number">-1</span>]-nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5855-找出数组中的第-K-大整数"><a href="#5855-找出数组中的第-K-大整数" class="headerlink" title="5855. 找出数组中的第 K 大整数"></a>5855. 找出数组中的第 K 大整数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>nums</code> 和一个整数 <code>k</code> 。<code>nums</code> 中的每个字符串都表示一个不含前导零的整数。</p><p>返回 <code>nums</code> 中表示第 <code>k</code> 大整数的字符串。</p><p>注意：重复的数字在统计时会视为不同元素考虑。例如，如果 <code>nums</code> 是 <code>[&quot;1&quot;,&quot;2&quot;,&quot;2&quot;]</code>，那么 <code>&quot;2&quot;</code> 是最大的整数，”2” 是第二大的整数，”1” 是第三大的整数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"3"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"10"</span>], k = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"3"</span></span><br><span class="line">解释：</span><br><span class="line">nums 中的数字按非递减顺序排列为 [<span class="string">"3"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"10"</span>]</span><br><span class="line">其中第 <span class="number">4</span> 大整数是 <span class="string">"3"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"2"</span>,<span class="string">"21"</span>,<span class="string">"12"</span>,<span class="string">"1"</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"2"</span></span><br><span class="line">解释：</span><br><span class="line">nums 中的数字按非递减顺序排列为 [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"12"</span>,<span class="string">"21"</span>]</span><br><span class="line">其中第 <span class="number">3</span> 大整数是 <span class="string">"2"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"0"</span>,<span class="string">"0"</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">解释：</span><br><span class="line">nums 中的数字按非递减顺序排列为 [<span class="string">"0"</span>,<span class="string">"0"</span>]</span><br><span class="line">其中第 <span class="number">2</span> 大整数是 <span class="string">"0"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>1 &lt;= nums[i].length &lt;= 100</code></li><li><code>nums[i]</code> 仅由数字组成</li><li><code>nums[i]</code> 不含任何前导零</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-kth-largest-integer-in-the-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-kth-largest-integer-in-the-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们将字符串数组按照字符串转换后的整数的大小进行排序。</li><li>排序比较方法如下：</li></ol><ul><li>如果字符串$a$与$b$的长度不相等，则长度较大的转换为整数后较大。</li><li>如果字符串$a$与$b$的长度相等，则比较两个字符串的字典序，字典序较大的转换为整数后较大。</li></ul><ol><li>算法的时间复杂度为 $O(n\lg n*m)$,其中 $n$ 为字符串数组的长度，$m$ 为字符串的平均长度。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">kthLargestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a,<span class="keyword">const</span> <span class="built_in">string</span> &amp;b)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a.size() == b.size())&#123;</span><br><span class="line">               <span class="keyword">return</span> a &gt; b;</span><br><span class="line">           &#125;           </span><br><span class="line">            <span class="keyword">return</span> a.size() &gt; b.size();</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5856-完成任务的最少工作时间段"><a href="#5856-完成任务的最少工作时间段" class="headerlink" title="5856. 完成任务的最少工作时间段"></a>5856. 完成任务的最少工作时间段</h2><p>你被安排了 <code>n</code> 个任务。任务需要花费的时间用长度为 <code>n</code>的整数数组 <code>tasks</code> 表示，第 i 个任务需要花费 <code>tasks[i]</code> 小时完成。一个 工作时间段 中，你可以 至多 连续工作 <code>sessionTime</code> 个小时，然后休息一会儿。</p><p>你需要按照如下条件完成给定任务：</p><p>如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。<br>完成一个任务后，你可以 立马 开始一个新的任务。<br>你可以按 任意顺序 完成任务。<br>给你<code>tasks</code> 和 <code>sessionTime</code>，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。</p><p>测试数据保证 <code>sessionTime</code> 大于等于 <code>tasks[i]</code> 中的 最大值 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], sessionTime = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以在两个工作时间段内完成所有任务。</span><br><span class="line">- 第一个工作时间段：完成第一和第二个任务，花费 <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> 小时。</span><br><span class="line">- 第二个工作时间段：完成第三个任务，花费 <span class="number">3</span> 小时。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>], sessionTime = <span class="number">8</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你可以在两个工作时间段内完成所有任务。</span><br><span class="line">- 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 <span class="number">3</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">8</span> 小时。</span><br><span class="line">- 第二个工作时间段，完成最后一个任务，花费 <span class="number">1</span> 小时。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], sessionTime = <span class="number">15</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你可以在一个工作时间段以内完成所有任务。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == tasks.length</code></li><li><code>1 &lt;= n &lt;= 14</code></li><li><code>1 &lt;= tasks[i] &lt;= 10</code></li><li><code>max(tasks[i]) &lt;= sessionTime &lt;= 15</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的求掩码组合的动态规划，我们设$dp[mask]$表示$mask$代表的二进制编码所表示的任务组合下所花费的最小的 $sessionTime$的数量。</li><li>则我们可以知道如下<code>dp</code>的递推公式:<script type="math/tex; mode=display">dp[mask] = max(dp[mask],dp[mask^state] + 1)</script>其中$state$所表示的任务能够在$1$个$sessionTime$里面完成，这就需要我们进行预处理即可，我们预处理所有可能在 $sessionTime$ 里面完成的任务组合。</li><li>遍历所有的状态返回即可。</li><li>时间复杂度为$O(n*2^{n} + 3^{n})$，空间复杂度为$O(2^{n})$,其中$n$为任务的数量。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSessions</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tasks, <span class="keyword">int</span> sessionTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tasks.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; valid(<span class="number">1</span>&lt;&lt;n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        valid[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr += tasks[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt;= sessionTime)&#123;</span><br><span class="line">                valid[i] = <span class="literal">true</span>;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">0</span>; j = (j<span class="number">-1</span>)&amp;i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid[i^j])&#123;</span><br><span class="line">                    dp[i] = min(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5857-不同的好子序列数目"><a href="#5857-不同的好子序列数目" class="headerlink" title="5857. 不同的好子序列数目"></a>5857. 不同的好子序列数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串<code>binary</code>。 <code>binary</code>的一个 子序列 如果是 非空 的且没有 前导 0 （除非数字是 “0” 本身），那么它就是一个 好 的子序列。</p><p>请你找到<code>binary</code>不同好子序列 的数目。</p><ul><li>比方说，如果 <code>binary = &quot;001&quot;</code>，那么所有 好 子序列为<code>[&quot;0&quot;, &quot;0&quot;, &quot;1&quot;]</code>，所以 不同 的好子序列为 <code>&quot;0&quot;</code> 和 <code>&quot;1&quot;</code>。 注意，子序列 “00” ，”01” 和 <code>&quot;001&quot;</code> 不是好的，因为它们有前导 0 。<br>请你返回<code>binary</code>中 不同好子序列 的数目。由于答案可能很大，请将它对 109 + 7 取余 后返回。</li></ul><p>一个 子序列 指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。</p><p>示例 1：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">binary </span>= <span class="string">"001"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：好的二进制子序列为 [<span class="string">"0"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>] 。</span><br><span class="line">不同的好子序列为 <span class="string">"0"</span> 和 <span class="string">"1"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">binary </span>= <span class="string">"11"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：好的二进制子序列为 [<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"11"</span>] 。</span><br><span class="line">不同的好子序列为 <span class="string">"1"</span> 和 <span class="string">"11"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">binary </span>= <span class="string">"101"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：好的二进制子序列为 [<span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"10"</span>, <span class="string">"11"</span>, <span class="string">"101"</span>] 。</span><br><span class="line">不同的好子序列为 <span class="string">"0"</span> ，<span class="string">"1"</span> ，<span class="string">"10"</span> ，<span class="string">"11"</span> 和 <span class="string">"101"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= binary.length &lt;= 105</code></li><li><code>binary</code> 只含有 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-unique-good-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-unique-good-subsequences</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目确实挺难想到这个递推关系。我们设 $dp[i][x]$ 表示当前字符串前 $i$ 个字符中以 $x$ 为结尾的字符串的好子字符串的数目，则我们可以知道递推关系如下：</li></ol><ul><li>当$s[i] == 0$时，则此时以 $1$ 为结尾的字符串的数目保持不变，我们可以在所有的好的字符串的末尾都加上 $0$,且单独的 $0$ 也为一个可能的字符串：<script type="math/tex; mode=display">dp[i+1][0] = dp[i][0] + dp[i][1] + 1 \\dp[i+1][1] = dp[i][1]</script></li><li>当$s[i] == 1$时，则此时以 $0$ 为结尾的字符串的数目保持不变，我们可以在所有的好的字符串的末尾都加上 $1$,且单独的 $1$也为一个可能的字符串：<script type="math/tex; mode=display">dp[i+1][0] = dp[i][0] \\dp[i+1][1] = dp[i][0] + dp[i][1] + 1</script></li></ul><ol><li>我们首先将字符串进行反转，此时因为字符串前导不能为 $0$，所以我们只需要求出当前的字符串中以 $1$为结尾的字符串的好子字符串的数目，同时再加上单独的 $0$即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfUniqueGoodSubsequences</span><span class="params">(<span class="built_in">string</span> binary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = binary.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">bool</span> has_zero = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">2</span>);</span><br><span class="line">        reverse(binary.begin(),binary.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = binary[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span>)&#123; </span><br><span class="line">                has_zero = <span class="literal">true</span>;</span><br><span class="line">                dp[<span class="number">0</span>] = (<span class="number">1</span> + dp[<span class="number">0</span>] + dp[<span class="number">1</span>])%mod;</span><br><span class="line">                dp[<span class="number">1</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[<span class="number">0</span>] = dp[<span class="number">0</span>];</span><br><span class="line">                dp[<span class="number">1</span>] = (<span class="number">1</span> + dp[<span class="number">0</span>] + dp[<span class="number">1</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(has_zero)&#123;</span><br><span class="line">            dp[<span class="number">1</span>] = (dp[<span class="number">1</span>] + <span class="number">1</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-256&quot;&gt;&lt;a href=&quot;#leetcode-contest-256&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 256&quot;&gt;&lt;/a&gt;leetcode contest 256&lt;/h1&gt;&lt;p&gt;本周的周赛题目难度始终，不过前三题确实比较简单。最后一题是之前某个题目的变形，确实不好想到。&lt;/p&gt;&lt;h2 id=&quot;5854-学生分数的最小差值&quot;&gt;&lt;a href=&quot;#5854-学生分数的最小差值&quot; class=&quot;headerlink&quot; title=&quot;5854. 学生分数的最小差值&quot;&gt;&lt;/a&gt;5854. 学生分数的最小差值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个 下标从 &lt;code&gt;0&lt;/code&gt; 开始 的整数数组 &lt;code&gt;nums&lt;/code&gt; ，其中 &lt;code&gt;nums[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt;名学生的分数。另给你一个整数 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;从数组中选出任意&lt;code&gt;k&lt;/code&gt;名学生的分数，使这&lt;code&gt;k&lt;/code&gt;个分数间 最高分 和 最低分 的 差值 达到 最小化 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab5 Lazy Alloaction</title>
    <link href="http://yoursite.com/2021/08/22/320/"/>
    <id>http://yoursite.com/2021/08/22/320/</id>
    <published>2021-08-22T10:33:01.039Z</published>
    <updated>2021-08-24T12:56:03.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lazy-alloaction"><a href="#lazy-alloaction" class="headerlink" title="lazy alloaction"></a>lazy alloaction</h1><p>感觉这个<code>lab</code>是最近感觉最容易的<code>lab</code>了，只花了一天就完成了<code>lab</code>，还是感谢网络资源，感谢各位后浪们的付出，将课件翻译成中文版，翻译的质量很好，通过阅读<code>lecture</code>即可很快的熟悉相关的<code>lazy allocation</code>的原理描述，利用<code>trap</code>来实现。我们再来仔细看一下<code>trap</code>的原理：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中断现场-&gt;保存现场-&gt; 处理trap -&gt;恢复现场-&gt;恢复运行</span><br></pre></td></tr></table></figure><br>利用<code>trap</code>我们可以进行相关的指令跳转，来执行我们需要的操作，执行完成之后，我们再恢复指令重新执行。所以我们可以利用<code>trap</code>来进行<code>lazy allocation</code>.按需申请物理内存资源，我们在申请内存时，可以先对只对该虚拟地址<code>va</code>进行标记，如果实际的程序需要进行访问该<code>va</code>时，我们再申请实际的物理内存页进行映射，映射完成后我们再恢复指令运行。<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-lazy-handin" target="_blank" rel="noopener">git repo</a></p><a id="more"></a><h2 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk"></a>Eliminate allocation from sbrk</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your first task is to <span class="keyword">delete</span> page allocation <span class="keyword">from</span> the sbrk(n) <span class="keyword">system</span> <span class="keyword">call</span> implementation, which <span class="keyword">is</span> the <span class="keyword">function</span> sys_sbrk() <span class="keyword">in</span> sysproc.c. The sbrk(n) <span class="keyword">system</span> <span class="keyword">call</span> grows the process<span class="string">'s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process'</span>s <span class="keyword">size</span> (myproc()-&gt;sz) <span class="keyword">by</span> n <span class="keyword">and</span> <span class="keyword">return</span> the <span class="keyword">old</span> size. It should <span class="keyword">not</span> <span class="keyword">allocate</span> <span class="keyword">memory</span> <span class="comment">-- so you should delete the call to growproc() (but you still need to increase the process's size!).</span></span><br></pre></td></tr></table></figure><p>这个非常容易实现，我们只需要在<code>sys_sbrk</code>函数内部对地址进行标记，标记该进程已经拥有该地址空间即可。<br>我们可以仔细分析一下内存<br><img src="https://i.loli.net/2021/08/24/OoGUsINFqVa62cy.png" alt><br>我们可以看到代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sbrk(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;sz + n &gt; MAXVA) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  p-&gt;sz += n;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modify the code <span class="keyword">in</span> trap.c <span class="keyword">to</span> respond <span class="keyword">to</span> a<span class="built_in"> page </span>fault <span class="keyword">from</span><span class="built_in"> user </span>space by mapping a newly-allocated<span class="built_in"> page </span>of physical memory at the faulting address, <span class="keyword">and</span> then returning back <span class="keyword">to</span><span class="built_in"> user </span>space <span class="keyword">to</span> let the process continue executing. You should <span class="builtin-name">add</span> your code just before the printf call that produced the <span class="string">"usertrap(): ..."</span> message. Modify whatever other xv6 kernel code you need <span class="keyword">to</span> <span class="keyword">in</span> order <span class="keyword">to</span> <span class="builtin-name">get</span> echo hi <span class="keyword">to</span> work.</span><br></pre></td></tr></table></figure><ul><li>实现在发生<code>trap</code>时我们时，我们首先判断发生<code>trap</code>时的地址是否合法，如果合法则我们认为该内存是<code>lazy allocation</code>，此时我们就<code>kalloc</code>一页实际的物理内存，然后进行映射，映射完成后，我们将<code>trap</code>恢复时执行的指令地址设置为$sepc$寄存器中的地址，CPU会从再次从发生<code>trap</code>的指令处开始执行。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 pcode = r_scause();</span><br><span class="line">uint64 va = r_stval();</span><br><span class="line">uint64 epc = r_sepc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// page fault, valid virtual address, 记录trap发生的原因</span></span><br><span class="line">  <span class="keyword">if</span>(pcode == <span class="number">15</span> || pcode == <span class="number">13</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(va &gt;= p-&gt;sz || va &lt;= p-&gt;trapframe-&gt;sp || va &gt; MAXVA)&#123;</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// alloc a page</span></span><br><span class="line"><span class="keyword">char</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapper a page for va</span></span><br><span class="line"><span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">kfree(mem);</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore epc</span></span><br><span class="line">p-&gt;trapframe-&gt;epc = epc;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修改<code>uvmunmap</code>时，我们在页表中<code>walk</code>时一旦发现该<code>virtual address</code>无法找到对应的物理页时，则我们此时直接跳过，而不是直接<code>panic</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">uvmunmap(<span class="keyword">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="keyword">int</span> do_free)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"uvmunmap: not aligned"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// 未找到该地址</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">"uvmunmap: not a leaf"</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">We've supplied you <span class="keyword">with</span> lazytests, an xv6 <span class="keyword">user</span> program that tests <span class="keyword">some</span> specific situations that may stress your lazy <span class="keyword">memory</span> allocator. <span class="keyword">Modify</span> your kernel code so that <span class="keyword">all</span> <span class="keyword">of</span> <span class="keyword">both</span> lazytests <span class="keyword">and</span> usertests pass.</span><br><span class="line">Handle negative sbrk() arguments.</span><br><span class="line"><span class="keyword">Kill</span> a process <span class="keyword">if</span> it page-faults <span class="keyword">on</span> a <span class="keyword">virtual</span> <span class="keyword">memory</span> address higher <span class="keyword">than</span> <span class="keyword">any</span> allocated <span class="keyword">with</span> sbrk().</span><br><span class="line">Handle the <span class="keyword">parent</span>-<span class="keyword">to</span>-<span class="keyword">child</span> <span class="keyword">memory</span> copy <span class="keyword">in</span> fork() correctly.</span><br><span class="line">Handle the <span class="keyword">case</span> <span class="keyword">in</span> which a process passes a valid address <span class="keyword">from</span> sbrk() <span class="keyword">to</span> a <span class="keyword">system</span> <span class="keyword">call</span> such <span class="keyword">as</span> <span class="keyword">read</span> <span class="keyword">or</span> write, but the <span class="keyword">memory</span> <span class="keyword">for</span> that address has <span class="keyword">not</span> yet been allocated.</span><br><span class="line">Handle <span class="keyword">out</span>-<span class="keyword">of</span>-<span class="keyword">memory</span> correctly: <span class="keyword">if</span> kalloc() fails <span class="keyword">in</span> the page fault <span class="keyword">handler</span>, <span class="keyword">kill</span> the <span class="keyword">current</span> process.</span><br><span class="line">Handle faults <span class="keyword">on</span> the invalid page below the <span class="keyword">user</span> stack.</span><br></pre></td></tr></table></figure></li><li>我们发现在进行<code>usertests</code>，<code>sbrkarg</code>这个测试结果一直过不了，页没有报<code>usertrap</code>的错误，仔细跟踪了一下代码，发现它是调用了<code>sys_write</code>操作，而<code>sys_write</code>最终调用了<code>copyin</code>的操作，仔细检查一下<code>copyin</code>的函数发现它是直接在页表中读取操作，<code>walkaddr</code>时报错，所以直接返回<code>-1</code>。所以我们需要修改<code>walkaddr</code>函数，我们发现当前的地址没有在页表中找到时，则取申请一页新的物理页，然后将其映射到新的物理地址中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">walkaddr(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"><span class="keyword">if</span>(va &gt;= p-&gt;sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// malloc a new page</span></span><br><span class="line"><span class="keyword">char</span> *mem = kalloc();</span><br><span class="line"><span class="keyword">if</span>(mem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// map a page for the new address</span></span><br><span class="line"><span class="keyword">if</span>(mappages(pagetable,PGROUNDDOWN(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">kfree(mem);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (uint64)mem;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>我们最后还需要注意的提示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handle faults on the invalid page below the user <span class="built_in">stack</span>.</span><br></pre></td></tr></table></figure>我们首先看一下系统用户进程的栈空间分布？<br>我们知道在栈的空件是从高地址往低地址增长的，如果我们发现栈的空间大小一个<code>page</code>，栈的地址空间为<code>1~4096</code>,因为所有的进程都是用户初始化进程的子进程，在子进程复制时，同时会复制父进程的栈空间。我们在进行<code>sbrk</code>操作时，实际扩充的进程的<code>heap</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">userinit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init's instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first "return" from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">"initcode"</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Handle faults on the invalid page below the user stack.</code></li></ul><ol><li><code>user stack</code>：user stack主要作为用户程序在<code>userspace</code>执行时需要的栈空间，当我们在用户空间执行用户的程序时，这时<code>sp</code>寄存器指向的就是<code>user stack</code>。</li><li><code>kernel stack</code>：<code>kernel stack</code>主要用户进程在系统调用时，切换到内核时执行内核的系统函数时，则这时<code>kernel space</code>执行时需要的栈空间，当系统调用发生时，则会发生<code>trap</code>，此时系统会切换<code>pc</code>到内核的函数调用，则此时我们执行内核函数时所需要的栈即为<code>kernel stack</code>。我们可以看到<code>kstack</code>之间有一个<code>guard page</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process's kernel stack</span></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br></pre></td></tr></table></figure></li><li><code>stack</code>相邻的地方都有一个<code>guard page</code>，为了防止<code>stack</code>越界，访问<code>guard page</code>时就会报错。我们可以看到在<code>exec</code>函数执行时，代码和数据加装在完成后，会紧接着申请两个物理页，一个作为<code>guard page</code>,一个作为<code>stack</code>。当然方式比较奇怪：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line"><span class="comment">// Use the second as the user stack.</span></span><br><span class="line">sz = PGROUNDUP(sz);</span><br><span class="line">uint64 sz1;</span><br><span class="line"><span class="comment">// malloc 2 page</span></span><br><span class="line"><span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">sz = sz1;</span><br><span class="line"><span class="comment">// 将第一个page标志位去掉</span></span><br><span class="line">uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">sp = sz;</span><br><span class="line">stackbase = sp - PGSIZE;</span><br></pre></td></tr></table></figure></li><li><code>Handle faults on the invalid page below the user stack.</code>我们只需要检测当前的<code>va</code>是否处在<code>guard page</code>中。我们知道<code>guard page</code>的地址范围为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackbase = PGROUNDDOWN(p-&gt;trapframe-&gt;sp) \\</span><br><span class="line">stackbase - PGSIZE \le va \le stackbase</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page fault, valid virtual address</span></span><br><span class="line">  <span class="keyword">if</span>(pcode == <span class="number">15</span> || pcode == <span class="number">13</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(va &gt;= (<span class="built_in">stack</span><span class="number">-2</span>*PGSIZE) &amp;&amp; va &lt; (<span class="built_in">stack</span>-PGSIZE))&#123;</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(va &gt;= p-&gt;sz || va &gt; MAXVA)&#123;</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(mappages(p-&gt;pagetable,PGROUNDDOWN(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">kfree(mem);</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;trapframe-&gt;epc = epc;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lazy-alloaction&quot;&gt;&lt;a href=&quot;#lazy-alloaction&quot; class=&quot;headerlink&quot; title=&quot;lazy alloaction&quot;&gt;&lt;/a&gt;lazy alloaction&lt;/h1&gt;&lt;p&gt;感觉这个&lt;code&gt;lab&lt;/code&gt;是最近感觉最容易的&lt;code&gt;lab&lt;/code&gt;了，只花了一天就完成了&lt;code&gt;lab&lt;/code&gt;，还是感谢网络资源，感谢各位后浪们的付出，将课件翻译成中文版，翻译的质量很好，通过阅读&lt;code&gt;lecture&lt;/code&gt;即可很快的熟悉相关的&lt;code&gt;lazy allocation&lt;/code&gt;的原理描述，利用&lt;code&gt;trap&lt;/code&gt;来实现。我们再来仔细看一下&lt;code&gt;trap&lt;/code&gt;的原理：&lt;br&gt;&lt;figure class=&quot;highlight clean&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;中断现场-&amp;gt;保存现场-&amp;gt; 处理trap -&amp;gt;恢复现场-&amp;gt;恢复运行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;利用&lt;code&gt;trap&lt;/code&gt;我们可以进行相关的指令跳转，来执行我们需要的操作，执行完成之后，我们再恢复指令重新执行。所以我们可以利用&lt;code&gt;trap&lt;/code&gt;来进行&lt;code&gt;lazy allocation&lt;/code&gt;.按需申请物理内存资源，我们在申请内存时，可以先对只对该虚拟地址&lt;code&gt;va&lt;/code&gt;进行标记，如果实际的程序需要进行访问该&lt;code&gt;va&lt;/code&gt;时，我们再申请实际的物理内存页进行映射，映射完成后我们再恢复指令运行。&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/MIT6.S081/tree/main/lab-lazy-handin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git repo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 乐鑫科技</title>
    <link href="http://yoursite.com/2021/08/22/319/"/>
    <id>http://yoursite.com/2021/08/22/319/</id>
    <published>2021-08-22T10:32:52.855Z</published>
    <updated>2021-08-23T02:55:54.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-乐鑫科技"><a href="#leetcode-contest-乐鑫科技" class="headerlink" title="leetcode  contest 乐鑫科技"></a>leetcode  contest 乐鑫科技</h1><p>题目还不错，但是难度不算很高。</p><h2 id="乐鑫01-录取分数线"><a href="#乐鑫01-录取分数线" class="headerlink" title="乐鑫01. 录取分数线"></a>乐鑫01. 录取分数线</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个浮点数数组 <code>scores</code>，其中 <code>scores[i]</code> 表示第 <code>i</code> 个考生的高考分数。<br>现在请你求出某大学的录取分数线，该大学的录取分数线恰好为将所有考生按高考分数由高到低排序后第 <code>k</code> 名考生的高考分数。</p><a id="more"></a><p>注意： <code>scores[i]</code> 恰好为 <code>0.5</code> 的倍数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">k = <span class="number">5</span>, scores = [<span class="number">150</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">550</span>,<span class="number">450</span>,<span class="number">450</span>,<span class="number">500</span>,<span class="number">555.5</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">500</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">将所有考生按高考分数由高到低排序后第 <span class="number">5</span> 名考生的高考分数为 <span class="number">500</span>。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">k = <span class="number">4</span>, scores = [<span class="number">723</span>,<span class="number">699</span>,<span class="number">510</span>,<span class="number">488.5</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">488.5</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">将所有考生按高考分数由高到低排序后第 <span class="number">4</span> 名考生的高考分数为 <span class="number">488.5</span>。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= scores.lengths &lt;= 10^5</code></li><li><code>0 &lt;= scores[i] &lt;=750</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/espressif-2021/problems/QXquF0/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/espressif-2021/problems/QXquF0/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序即可，然后取相应的排名。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAdmissionLine</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; scores)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = scores.size();</span><br><span class="line">        sort(scores.begin(),scores.end());</span><br><span class="line">        <span class="keyword">return</span> scores[n-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="乐鑫02-调整电平"><a href="#乐鑫02-调整电平" class="headerlink" title="乐鑫02. 调整电平"></a>乐鑫02. 调整电平</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>某实验逻辑电路中，初始时有<code>cnt</code> 个观测点处于低电平状态。</p><p>对于某个观测点的电平调整意味着：如果观测点处于低电平，会被调整为高电平；而观测点处于高电平，会被调整为低电平。</p><ul><li><p>第 1 轮，每个观测点调整一次电平。即，所有观测点处于高电平；</p></li><li><p>第 2 轮，每两个观测点调整一次电平。即，第 1、3、5 … 个观察点不调整，第 2、4、6 … 个观察点调整；</p></li><li><p>第 3 轮，每三个观测点调整一次电平。即，第 1、2、4、5 … 个观察点不调整，第 3、6 … 个观察点调整；</p></li><li><p>第 i 轮，每 i 观测点调整一次电平。 而第 cnt 轮，你只调整最后一个观测点的电平。</p></li><li><p>请找出 <code>cnt</code> 轮之后有多少处于高电平状态的观测点。</p></li></ul><p>示例 1：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：cnt = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：</span><br><span class="line">初始时, 电平状态为 <span class="string">[低, 低, 低，低]</span>,</span><br><span class="line">第一轮后, 电平状态 <span class="string">[高, 高, 高, 高]</span>,</span><br><span class="line">第二轮后, 电平状态 <span class="string">[高, 低, 高, 低]</span>,</span><br><span class="line">第三轮后, 电平状态 <span class="string">[高, 低, 低, 低]</span>,</span><br><span class="line">第四轮后, 电平状态 <span class="string">[高, 低, 低, 高]</span>, </span><br><span class="line"></span><br><span class="line">最终有 <span class="number">2</span> 个处于高电平状态的观测点，因此返回 <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入：cnt = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：cnt = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">0</span> &lt;= cnt &lt;= <span class="number">109</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/espressif-2021/problems/i4tX1E/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学问题</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 刚开始看到这个题目确实没有什么思路，后来仔细转化提交一下，我们可以看到每次遇到某个数的约数，则该点就会变化一次电平，一个数有多少个约数就会变换多少次电平。</span><br><span class="line"><span class="number">2.</span> 只有当某个数变换电平的次数为奇数时，才会出现高电平，仔细分析一下，我们发现只有平方数才有奇数个约数，所以我们找到所有小于等于`cnt`的平方数的个数即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> adjustLevel(<span class="built_in">int</span> cnt) &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="乐鑫03-签到序列"><a href="#乐鑫03-签到序列" class="headerlink" title="乐鑫03. 签到序列"></a>乐鑫03. 签到序列</h2><p>在某活动现场打卡处，活动参与者需要 按照到达顺序 依次领取并在签到簿上填下自己的排队编号（排队编号从 <code>1</code>开始），将签到簿上的排队编号依次首尾相连可以得到形如 <code>&quot;123456789101112...&quot;</code> 的 签到序列 ，请返回 签到序列 中的第 k 位数字。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">6</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：签到序列 <span class="string">"12345678910..."</span>中的第 <span class="number">6</span> 位数字是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">20</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：签到序列 <span class="string">"123456789101112131415..."</span>中的第 <span class="number">20</span> 位数字是 <span class="number">1</span>。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= k &lt;= 231-1</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/espressif-2021/problems/fSghVj/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/espressif-2021/problems/fSghVj/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的数学问题，我们可以看到数字长度为<code>i</code>的数字的个数为：<script type="math/tex; mode=display">dp[i] = 9 (i= 1) \\dp[i] = 10^{i} - 10^{i-1} (i\neq 0) \\num[i] = i*dp[i]</script></li></ol></blockquote><ol><li>所以我们可以利用求和公式，快速的找到当前数所在的数字的位数,然后找到当前数字的实际数应该是多少，这个即是纯粹的数学问题。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthNum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr;</span><br><span class="line">        arr.push_back(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">15</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="built_in">pow</span>(<span class="number">10</span>,i) - <span class="number">1</span> - sum;</span><br><span class="line">            arr.push_back(curr);</span><br><span class="line">            sum += curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; arr[i]*(i+<span class="number">1</span>))&#123;</span><br><span class="line">                k -= arr[i]*(i+<span class="number">1</span>);</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> c = k%(i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> x = k/(i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">                    x = sum + x;</span><br><span class="line">                    <span class="keyword">return</span> to_string(x).back() - <span class="string">'0'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    x = sum + x + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> to_string(x)[c<span class="number">-1</span>] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="乐鑫04-自行车拉力赛"><a href="#乐鑫04-自行车拉力赛" class="headerlink" title="乐鑫04. 自行车拉力赛"></a>乐鑫04. 自行车拉力赛</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>自行车拉力赛的选手从起点出发，计划前往距离起点 num 公里处的终点。</p><p>自行车上配有一个用于给轮胎降温用的容量无限的水箱，在出发时水箱中有 <code>initWater</code> 升水，并且选手每骑行一公里就需要消耗一升水用于给轮胎降温。</p><p>在比赛路线途中设有若干个补给站，以 [与起点的距离,水量] 的格式记录于二维数组 <code>supplyStations</code> 中。当选手抵达补给站时，可选择是否对水箱进行补水，若选择补水，则会将该补水站当前水量全部补入水箱中。</p><p>请返回选手抵达终点至少需要的补水次数。若无法抵达终点，则返回 -1。</p><p>注意：</p><p>若选手抵达补给站时水箱剩余水量为 0，可在此补水；<br>若选手抵达终点时水箱剩余水量为 0，视作抵达目的地。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num =<span class="number">10</span>, initWater = <span class="number">11</span>, supplyStations = [[<span class="number">5</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无需加水就可直接到达终点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">572</span>, initWater = <span class="number">200</span>, supplyStations = [[<span class="number">200</span>,<span class="number">156</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：即使选择在第一个补给站加水也无法抵达终点。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">200</span>, initWater = <span class="number">11</span>, supplyStations = [[<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">100</span>],[<span class="number">10</span>,<span class="number">189</span>],[<span class="number">11</span>,<span class="number">30</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：以下是一种可行的方案：</span><br><span class="line">出发时水箱中水量为 <span class="number">11</span> 升；</span><br><span class="line">骑行来到距起点 <span class="number">5</span> 公里处的补给站，不选择加水，此时水箱中的水量为 <span class="number">6</span> 升；</span><br><span class="line">骑行来到距起点 <span class="number">6</span> 公里处的补给站，不选择加水，此时水箱中的水量为 <span class="number">5</span> 升；</span><br><span class="line">骑行来到距起点 <span class="number">10</span> 公里处的补给站，选择加水，此时水箱中的水量为 <span class="number">190</span> 升；</span><br><span class="line">骑行来到距起点 <span class="number">11</span> 公里处的补给站，不选择加水，此时水箱中的水量为 <span class="number">189</span> 升；</span><br><span class="line">到达终点，此时水箱中的水量为 <span class="number">0</span> 升。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= num, initWater, supplyStations[i][<span class="number">1</span>] &lt;= <span class="number">10</span>^<span class="number">9</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= supplyStations.length &lt;= <span class="number">500</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt; supplyStations[<span class="number">0</span>][<span class="number">0</span>] &lt; supplyStations[<span class="number">1</span>][<span class="number">0</span>] &lt; ... &lt; supplyStations[supplyStations.length<span class="number">-1</span>][<span class="number">0</span>] &lt; num`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/find-array-given-subset-sums</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  dp或者优先级队列</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 我们首先看一下`dp`的解法，非常简单，我们设`dp[i][j]`表示为到达第`i`个补给站，且加水`j`次后，水箱拥有的最大的水量，则我们可以知道递推关系：</span><br><span class="line">+ 假设我们前`i<span class="number">-1</span>`个站点已经补充过`j`次了，则此时我们在`i`个站点则不应该再补充水。</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j] - (supplyStations[i][<span class="number">0</span>] - supplyStations[i<span class="number">-1</span>][<span class="number">0</span>])) </span><br><span class="line">$$</span><br><span class="line">+ 假设我们前`i<span class="number">-1</span>`个站点已经补充过`j<span class="number">-1</span>`次，则此时我们在`i`个站点则需要补充水。</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>] - (supplyStations[i][<span class="number">0</span>] - supplyStations[i<span class="number">-1</span>][<span class="number">0</span>]) + supplyStations[i][<span class="number">1</span>])</span><br><span class="line">$$</span><br><span class="line"><span class="number">2.</span> 我们从最小的`<span class="number">0</span>`开始测试，到达第`n`个站点时，如果剩余的最大水量能够支撑其到达终点，则我们认为可以满足条件。</span><br><span class="line"><span class="number">3.</span> 优先级队列。</span><br><span class="line">### 代码</span><br><span class="line">+ dp</span><br><span class="line">```c++</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minSupplyTimes(<span class="built_in">int</span> num, <span class="built_in">int</span> initWater, vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; supplyStations) &#123;</span><br><span class="line">        <span class="built_in">int</span> m = supplyStations.size();</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; dp(m+<span class="number">1</span>,vector&lt;long long&gt;(m+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; dist;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(initWater &gt;= num) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            dist.push_back(supplyStations[i][<span class="number">0</span>] - curr);</span><br><span class="line">            curr = supplyStations[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = initWater;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(initWater &gt;= supplyStations[i<span class="number">-1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">                        dp[i][j] = initWater - supplyStations[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i<span class="number">-1</span> &gt;= j &amp;&amp; dp[i<span class="number">-1</span>][j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &gt;= dist[i<span class="number">-1</span>])&#123;</span><br><span class="line">                            dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j] - dist[i<span class="number">-1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &gt;= dist[i<span class="number">-1</span>])&#123;</span><br><span class="line">                            dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>] - dist[i<span class="number">-1</span>] + supplyStations[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[m][i] + supplyStations[m<span class="number">-1</span>][<span class="number">0</span>] &gt;= num)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-乐鑫科技&quot;&gt;&lt;a href=&quot;#leetcode-contest-乐鑫科技&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 乐鑫科技&quot;&gt;&lt;/a&gt;leetcode  contest 乐鑫科技&lt;/h1&gt;&lt;p&gt;题目还不错，但是难度不算很高。&lt;/p&gt;&lt;h2 id=&quot;乐鑫01-录取分数线&quot;&gt;&lt;a href=&quot;#乐鑫01-录取分数线&quot; class=&quot;headerlink&quot; title=&quot;乐鑫01. 录取分数线&quot;&gt;&lt;/a&gt;乐鑫01. 录取分数线&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个浮点数数组 &lt;code&gt;scores&lt;/code&gt;，其中 &lt;code&gt;scores[i]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个考生的高考分数。&lt;br&gt;现在请你求出某大学的录取分数线，该大学的录取分数线恰好为将所有考生按高考分数由高到低排序后第 &lt;code&gt;k&lt;/code&gt; 名考生的高考分数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 59</title>
    <link href="http://yoursite.com/2021/08/22/318/"/>
    <id>http://yoursite.com/2021/08/22/318/</id>
    <published>2021-08-22T10:31:52.677Z</published>
    <updated>2021-08-23T03:36:47.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-59"><a href="#leetcode-biweekly-contest-59" class="headerlink" title="leetcode biweekly contest 59"></a>leetcode biweekly contest 59</h1><p>双周赛的题目质量很高，出的非常不错的题目</p><h2 id="5850-找出数组的最大公约数"><a href="#5850-找出数组的最大公约数" class="headerlink" title="5850. 找出数组的最大公约数"></a>5850. 找出数组的最大公约数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>使用特殊打字机键入单词的最少时间<br>有一个特殊打字机，它由一个 圆盘 和一个 指针 组成， 圆盘上标有小写英文字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code>。只有 当指针指向某个字母时，它才能被键入。指针 初始时 指向字符 <code>&#39;a&#39;</code> 。</li></ol><a id="more"></a><p>每一秒钟，你可以执行以下操作之一：</p><p>将指针 顺时针 或者 逆时针 移动一个字符。<br>键入指针 当前 指向的字符。<br>给你一个字符串 word ，请你返回键入 word 所表示单词的 最少 秒数 。</p><p>示例 1：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "abc"</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">单词按如下操作键入：</span><br><span class="line">-<span class="ruby"> 花 <span class="number">1</span> 秒键入字符 <span class="string">'a'</span> <span class="keyword">in</span> <span class="number">1</span> ，因为指针初始指向 <span class="string">'a'</span> ，故不需移动指针。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒将指针顺时针移到 <span class="string">'b'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'b'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒将指针顺时针移到 <span class="string">'c'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'c'</span> 。</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "bza"</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">单词按如下操作键入：</span><br><span class="line">-<span class="ruby"> 花 <span class="number">1</span> 秒将指针顺时针移到 <span class="string">'b'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'b'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">2</span> 秒将指针逆时针移到 <span class="string">'z'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'z'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒将指针顺时针移到 <span class="string">'a'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'a'</span> 。</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "zjpc"</span><br><span class="line">输出：34</span><br><span class="line">解释：</span><br><span class="line">单词按如下操作键入：</span><br><span class="line">-<span class="ruby"> 花 <span class="number">1</span> 秒将指针逆时针移到 <span class="string">'z'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'z'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">10</span> 秒将指针顺时针移到 <span class="string">'j'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'j'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">6</span> 秒将指针顺时针移到 <span class="string">'p'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'p'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">13</span> 秒将指针逆时针移到 <span class="string">'c'</span> 。</span></span><br><span class="line"><span class="ruby">- 花 <span class="number">1</span> 秒键入字符 <span class="string">'c'</span> 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 100</code></li><li><code>word</code> 只包含小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-time-to-type-word-using-special-typewriter" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-time-to-type-word-using-special-typewriter</a><br>n### 题意</p><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们每次取$min(diff,26-diff)$即可，暴力检测，算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToType</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> curr = <span class="string">'a'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff = <span class="built_in">abs</span>(c-curr);</span><br><span class="line">            ans += min(diff,<span class="number">26</span>-diff);</span><br><span class="line">            curr = c;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5835-最大方阵和"><a href="#5835-最大方阵和" class="headerlink" title="5835. 最大方阵和"></a>5835. 最大方阵和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>n x n</code> 的整数方阵 <code>matrix</code> 。你可以执行以下操作 任意次 ：</p><p>选择 <code>matrix</code> 中 相邻 两个元素，并将它们都 乘以 <code>-1</code> 。<br>如果两个元素有 公共边 ，那么它们就是 相邻 的。</p><p>你的目的是 最大化 方阵元素的和。请你在执行以上操作之后，返回方阵的 最大 和。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">-1</span>],[<span class="number">-1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：我们可以执行以下操作使和等于 <span class="number">4</span> ：</span><br><span class="line">- 将第一行的 <span class="number">2</span> 个元素乘以 <span class="number">-1</span> 。</span><br><span class="line">- 将第一列的 <span class="number">2</span> 个元素乘以 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：我们可以执行以下操作使和等于 <span class="number">16</span> ：</span><br><span class="line">- 将第二行的最后 <span class="number">2</span> 个元素乘以 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>2 &lt;= n &lt;= 250</code></li><li><code>-105 &lt;= matrix[i][j] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-matrix-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-matrix-sum</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>几个重要结论：</li></ol><ul><li>我们可以通过变换，将正负号在任意元素中惊醒传递，类似于图的边。</li><li>如果存在元素为$0$,则我们总可以将负号传递给元素$0$,则此时矩阵中所有元素均为非负整数;</li><li>如果存在偶数个负数，则我们总可以通过传递，将其全部变为正数；</li><li>如果存在奇数个负数，则我们总可以通过传递，最终只剩下一个负数。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxMatrixSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minval = INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                ans += <span class="built_in">abs</span>(matrix[i][j]);</span><br><span class="line">                minval = min(minval,<span class="built_in">abs</span>(matrix[i][j]));</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>) zero++;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] &lt; <span class="number">0</span>) neg++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((neg%<span class="number">2</span>) &amp;&amp; zero == <span class="number">0</span>) <span class="keyword">return</span> ans - <span class="number">2</span>*minval;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5836-到达目的地的方案数"><a href="#5836-到达目的地的方案数" class="headerlink" title="5836. 到达目的地的方案数"></a>5836. 到达目的地的方案数</h2><p>你在一个城市里，城市由<code>n</code>个路口组成，路口编号为<code>0</code>到<code>n - 1</code> ，某些路口之间有 双向 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。</p><p>给你一个整数 <code>n</code>和二维整数数组 <code>roads</code> ，其中<code>roads[i] = [ui, vi, timei]</code> 表示在路口 <code>ui</code> 和 <code>vi</code> 之间有一条需要花费 <code>timei</code> 时间才能通过的道路。你想知道花费 最少时间 从路口 <code>0</code> 出发到达路口<code>n - 1</code>的方案数。</p><p>请返回花费 最少时间 到达目的地的 路径数目 。由于答案可能很大，将结果对 <code>109 + 7</code> 取余 后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, roads = [[<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：从路口 <span class="number">0</span> 出发到路口 <span class="number">6</span> 花费的最少时间是 <span class="number">7</span> 分钟。</span><br><span class="line">四条花费 <span class="number">7</span> 分钟的路径分别为：</span><br><span class="line">- <span class="number">0</span> ➝ <span class="number">6</span></span><br><span class="line">- <span class="number">0</span> ➝ <span class="number">4</span> ➝ <span class="number">6</span></span><br><span class="line">- <span class="number">0</span> ➝ <span class="number">1</span> ➝ <span class="number">2</span> ➝ <span class="number">5</span> ➝ <span class="number">6</span></span><br><span class="line">- <span class="number">0</span> ➝ <span class="number">1</span> ➝ <span class="number">3</span> ➝ <span class="number">5</span> ➝ <span class="number">6</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, roads = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">10</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：只有一条从路口 <span class="number">0</span> 到路口 <span class="number">1</span> 的路，花费 <span class="number">10</span> 分钟。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 200</code></li><li><code>n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li><li><code>roads[i].length == 3</code></li><li><code>0 &lt;= ui, vi &lt;= n - 1</code></li><li><code>1 &lt;= timei &lt;= 109</code></li><li><code>ui != vi</code></li><li>任意两个路口之间至多有一条路。</li><li>从任意路口出发，你能够到达其他任意路口</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-arrive-at-destination" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-arrive-at-destination</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra + dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们可以利用<code>dijistra</code>算法，求出从<code>0</code>点到各点的最短距离。</li><li>其次为了保证<code>dp</code>的正确性，即每个点的顺序访问时满足从前到后，则我们需要将每个点按照该点到<code>0</code>点的距离大小进行排序。</li><li>其次我们即可使用<code>dp</code>的算法，每次发现从当前点到下一点的距离刚好为最小值上，则将可能的路径数向后传递即可。</li><li>算法时间复杂度为$O(n^{2} + n + m)$,空间复杂度为$(n + m)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPaths</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = roads.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dist(n,LLONG_MAX);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: roads)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(&#123;v[<span class="number">0</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        qu.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.first])&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> cost = (<span class="keyword">long</span> <span class="keyword">long</span>)curr.second + v.second;</span><br><span class="line">                <span class="keyword">if</span>(dist[v.first] &gt; cost)&#123;</span><br><span class="line">                    dist[v.first] = cost;</span><br><span class="line">                    qu.push(&#123;v.first,cost&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr.push_back(&#123;dist[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = arr[i].second;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> c = arr[i].first;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(c + v.second == dist[v.first])&#123;</span><br><span class="line">                    dp[v.first] = (dp[v.first] + dp[x])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5837-划分数字的方案数"><a href="#5837-划分数字的方案数" class="headerlink" title="5837. 划分数字的方案数"></a>5837. 划分数字的方案数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你写下了若干 正整数 ，并将它们连接成了一个字符串  <code>num</code> 。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 非递减 的且 没有 任何数字有前导 0 。</p><p>请你返回有多少种可能的 正整数数组 可以得到字符串 <code>num</code> 。由于答案可能很大，将结果对 <code>109 + 7</code> 取余 后返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"327"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：以下为可能的方案：</span><br><span class="line"><span class="number">3</span>, <span class="number">27</span></span><br><span class="line"><span class="number">327</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"094"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不能有数字有前导 <span class="number">0</span> ，且所有数字均为正数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"0"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不能有数字有前导 <span class="number">0</span> ，且所有数字均为正数。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"9999999999999"</span></span><br><span class="line">输出：<span class="number">101</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 3500</code></li><li><code>num</code> 只含有数字 <code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code>。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-separate-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-separate-numbers</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本题难度较大，其实仔细思考了非常长的时间才有结果。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-59&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-59&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 59&quot;&gt;&lt;/a&gt;leetcode biweekly contest 59&lt;/h1&gt;&lt;p&gt;双周赛的题目质量很高，出的非常不错的题目&lt;/p&gt;&lt;h2 id=&quot;5850-找出数组的最大公约数&quot;&gt;&lt;a href=&quot;#5850-找出数组的最大公约数&quot; class=&quot;headerlink&quot; title=&quot;5850. 找出数组的最大公约数&quot;&gt;&lt;/a&gt;5850. 找出数组的最大公约数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用特殊打字机键入单词的最少时间&lt;br&gt;有一个特殊打字机，它由一个 圆盘 和一个 指针 组成， 圆盘上标有小写英文字母 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 到 &lt;code&gt;&amp;#39;z&amp;#39;&lt;/code&gt;。只有 当指针指向某个字母时，它才能被键入。指针 初始时 指向字符 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 255</title>
    <link href="http://yoursite.com/2021/08/22/317/"/>
    <id>http://yoursite.com/2021/08/22/317/</id>
    <published>2021-08-22T08:56:47.708Z</published>
    <updated>2021-08-22T13:06:41.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-255"><a href="#leetcode-contest-255" class="headerlink" title="leetcode contest 255"></a>leetcode contest 255</h1><p>周赛的第四题好难，没想出来，还算脑力不够，只能靠努力来补。<br><img src="https://i.loli.net/2021/08/22/PRk9gEplMtzKVQZ.png" alt></p><h2 id="5850-找出数组的最大公约数"><a href="#5850-找出数组的最大公约数" class="headerlink" title="5850. 找出数组的最大公约数"></a>5850. 找出数组的最大公约数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>找出数组的最大公约数 显示英文描述<br>给你一个整数数组 <code>nums</code> ，返回数组中最大数和最小数的 最大公约数 。</li></ol><p>两个数的 最大公约数 是能够被两个数整除的最大正整数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">nums 中最小的数是 <span class="number">2</span></span><br><span class="line">nums 中最大的数是 <span class="number">10</span></span><br><span class="line"><span class="number">2</span> 和 <span class="number">10</span> 的最大公约数是 <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">nums 中最小的数是 <span class="number">3</span></span><br><span class="line">nums 中最大的数是 <span class="number">8</span></span><br><span class="line"><span class="number">3</span> 和 <span class="number">8</span> 的最大公约数是 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">nums 中最小的数是 <span class="number">3</span></span><br><span class="line">nums 中最大的数是 <span class="number">3</span></span><br><span class="line"><span class="number">3</span> 和 <span class="number">3</span> 的最大公约数是 <span class="number">3</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= nums.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">1000</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-255/problems/find-greatest-common-divisor-of-array/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力检测</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 我们找到数组中的最大值和最小值，然后取公约数即可，简单题目。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findGCD(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> __gcd(nums[<span class="number">0</span>],nums.back());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="5851-找出不同的二进制字符串"><a href="#5851-找出不同的二进制字符串" class="headerlink" title="5851. 找出不同的二进制字符串"></a>5851. 找出不同的二进制字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>nums</code> ，该数组由<code>n</code> 个 互不相同 的二进制字符串组成，且每个字符串长度都是 <code>n</code>。请你找出并返回一个长度为 <code>n</code> 且 没有出现 在 <code>nums</code> 中的二进制字符串。如果存在多种答案，只需返回 任意一个 即可。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="string">"01"</span>,<span class="string">"10"</span>]</span><br><span class="line">输出：<span class="string">"11"</span></span><br><span class="line">解释：<span class="string">"11"</span> 没有出现在 nums 中。<span class="string">"00"</span> 也是正确答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="string">"00"</span>,<span class="string">"01"</span>]</span><br><span class="line">输出：<span class="string">"11"</span></span><br><span class="line">解释：<span class="string">"11"</span> 没有出现在 nums 中。<span class="string">"10"</span> 也是正确答案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"111"</span>,<span class="string">"011"</span>,<span class="string">"001"</span>]</span><br><span class="line">输出：<span class="string">"101"</span></span><br><span class="line">解释：<span class="string">"101"</span> 没有出现在 nums 中。<span class="string">"000"</span>、<span class="string">"010"</span>、<span class="string">"100"</span>、<span class="string">"110"</span> 也是正确答案。</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">提示：</span></span><br><span class="line"><span class="string">+ `</span>n == nums.length<span class="string">`</span></span><br><span class="line"><span class="string">+ `</span><span class="number">1</span> &lt;= n &lt;= <span class="number">16</span><span class="string">`</span></span><br><span class="line"><span class="string">+ `</span>nums[i].length == n<span class="string">`</span></span><br><span class="line"><span class="string">+ `</span>nums[i] 为 <span class="string">'0'</span> 或 <span class="string">'1'</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 地址</span></span><br><span class="line"><span class="string">https://leetcode-cn.com/problems/find-unique-binary-string</span></span><br><span class="line"><span class="string">### 题意</span></span><br><span class="line"><span class="string">&gt;  字符串编码</span></span><br><span class="line"><span class="string">### 思路</span></span><br><span class="line"><span class="string">1. 两种思路，我们直到字符串的编码只会在$0~(2^&#123;n&#125;-1)$中，我们在范围中找到一个在字符串中没有出现的数字接口，然后将其转换为字符串编码。</span></span><br><span class="line"><span class="string">2. 我们将字符串编码按照字典序的大小来排序，找到一个不存在的编码即可。</span></span><br><span class="line"><span class="string">### 代码</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">string</span> findDifferentBinaryString(<span class="keyword">vector</span>&lt;<span class="keyword">string</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums[<span class="number">0</span>].<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">string</span> ans;</span><br><span class="line">        unordered_set&lt;<span class="keyword">string</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(auto w : nums) cnt.insert(w);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">string</span> curr;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) curr.push_back(<span class="string">'0'</span>);       </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != <span class="number">0</span>; j = j/<span class="number">2</span>)&#123;</span><br><span class="line">                curr.push_back(<span class="string">'0'</span> + j%2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">string</span> zero;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-curr.<span class="keyword">size</span>(); ++j)&#123;</span><br><span class="line">                zero.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            curr = zero + curr;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(curr)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5852-最小化目标值与所选元素的差"><a href="#5852-最小化目标值与所选元素的差" class="headerlink" title="5852. 最小化目标值与所选元素的差"></a>5852. 最小化目标值与所选元素的差</h2><p>给你一个大小为 <code>m x n</code>的整数矩阵<code>mat</code>和一个整数<code>target</code> 。<br>从矩阵的 每一行 中选择一个整数，你的目标是 最小化 所有选中元素之 和 与目标值 <code>target</code>的 绝对差 。<br>返回 最小的绝对差 。<br><code>a</code> 和 <code>b</code>两数字的 绝对差 是 <code>a - b</code>的绝对值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]], target = <span class="number">13</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：一种可能的最优选择方案是：</span><br><span class="line">- 第一行选出 <span class="number">1</span></span><br><span class="line">- 第二行选出 <span class="number">5</span></span><br><span class="line">- 第三行选出 <span class="number">7</span></span><br><span class="line">所选元素的和是 <span class="number">13</span> ，等于目标值，所以绝对差是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]], target = <span class="number">100</span></span><br><span class="line">输出：<span class="number">94</span></span><br><span class="line">解释：唯一一种选择方案是：</span><br><span class="line">- 第一行选出 <span class="number">1</span></span><br><span class="line">- 第二行选出 <span class="number">2</span></span><br><span class="line">- 第三行选出 <span class="number">3</span></span><br><span class="line">所选元素的和是 <span class="number">6</span> ，绝对差是 <span class="number">94</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>]], target = <span class="number">6</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最优的选择方案是选出第一行的 <span class="number">7</span> 。</span><br><span class="line">绝对差是 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= m, n &lt;= 70</code></li><li><code>1 &lt;= mat[i][j] &lt;= 70</code></li><li><code>1 &lt;= target &lt;= 800</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimize-the-difference-between-target-and-chosen-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimize-the-difference-between-target-and-chosen-elements</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 背包算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>根据题意我们只需要求矩阵每一行数组所有可能的组合即可，然后求出所有可能的组合中与$target$的最小值即可。我们发现矩阵最大可能组合的和为$m<em>70$,也即为$4900$,所以这时我们假如使用背包的话其实很容易，算法的时间复杂度为$O(m</em>70<em>m</em>n)$,是在可以接受的范围内，有没有可以优化的空间？.</li><li>我们仔细观察一下，由于$target$的数量很小，由于矩阵中的每个元素的值都大于$0$,其实我们只关心组合的和处在$[0,2<em>target]$之间的可能性，如果没有处在$[0,2</em>target]$之间的组合，则此时其实我们可以推论得出矩阵中每一行的最小元素之和与$target$的绝对值之差最小。超过$2*target$，我们其实可以不同关心。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>|<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.   </span><br><span class="line">0       target   2*target</span><br></pre></td></tr></table></figure></li><li>求组合就非常简单了，我们设<code>dp[i][j] = 1</code>表示矩阵前<code>i</code>行元素取每一行元素组合得到的和为<code>j</code>存在，<code>dp[i][j] = 0</code>表示矩阵前<code>i</code>行元素取每一行元素组合得到的和为<code>j</code>不存在，则我们求出所有可能的组合。我们直到下面的组合的可能性推导：<script type="math/tex; mode=display">dp[i+1][j+mat[i+1][x]] = dp[i][j]</script>所以我们只需要直到上述的推理传递过程即可。</li><li>时间复杂度为$O(m<em>n</em>target<em>2$,空间复杂度为$O(target</em>2)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimizeTheDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> large = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">2</span>*target+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ndp(<span class="number">2</span>*target+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">            sort(mat[i].begin(),mat[i].end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>*target; ++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[k] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(k + mat[i][j] &lt;= <span class="number">2</span>*target)&#123;</span><br><span class="line">                            ndp[k + mat[i][j]] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            curr += mat[i][<span class="number">0</span>];</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">abs</span>(target-curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*target; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; <span class="number">0</span>)</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(target-i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5853-从子集的和还原数组"><a href="#5853-从子集的和还原数组" class="headerlink" title="5853. 从子集的和还原数组"></a>5853. 从子集的和还原数组</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>存在一个未知数组需要你进行还原，给你一个整数 n 表示该数组的长度。另给你一个数组 <code>sums</code> ，由未知数组中全部 <code>2n</code>个 子集的和 组成（子集中的元素没有特定的顺序）。<br>返回一个长度为 <code>n</code> 的数组 <code>ans</code> 表示还原得到的未知数组。如果存在 多种 答案，只需返回其中 任意一个 。<br>如果可以由数组 <code>arr</code> 删除部分元素（也可能不删除或全删除）得到数组 sub ，那么数组 <code>sub</code> 就是数组 <code>arr</code> 的一个 子集 。<code>sub</code>的元素之和就是 <code>arr</code> 的一个 子集的和 。一个空数组的元素之和为<code>0</code>。<br>注意：生成的测试用例将保证至少存在一个正确答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, sums = [<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>]</span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>] 能够满足给出的子集的和：</span><br><span class="line">- []：和是 <span class="number">0</span></span><br><span class="line">- [<span class="number">1</span>]：和是 <span class="number">1</span></span><br><span class="line">- [<span class="number">2</span>]：和是 <span class="number">2</span></span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>]：和是 <span class="number">3</span></span><br><span class="line">- [<span class="number">-3</span>]：和是 <span class="number">-3</span></span><br><span class="line">- [<span class="number">1</span>,<span class="number">-3</span>]：和是 <span class="number">-2</span></span><br><span class="line">- [<span class="number">2</span>,<span class="number">-3</span>]：和是 <span class="number">-1</span></span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>]：和是 <span class="number">0</span></span><br><span class="line">注意，[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>] 的任何排列和 [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">3</span>] 的任何排列都会被视作正确答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, sums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：唯一的正确答案是 [<span class="number">0</span>,<span class="number">0</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, sums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">5</span>] 能够满足给出的子集的和。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">15</span>`</span><br><span class="line">+ `sums.length == <span class="number">2</span>n`</span><br><span class="line">+ `<span class="number">-104</span> &lt;= sums[i] &lt;= <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/find-array-given-subset-sums</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学问题</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 参考从sums 中所有元素均为非负数子集sums恢复数组的做法，就可以很容易得出结论。这个题目没有做出来，参考了答案感觉确实非常好的值得思考的题目。</span><br><span class="line"><span class="number">2.</span> 我们假设数组中所有元素都为非负整数，则我们可以知道数组中最小的元素即为$sums[<span class="number">1</span>] - sums[<span class="number">0</span>]$.最终重要的退路如下：</span><br><span class="line">+ 第一个最小的元素肯定为$sums[<span class="number">1</span>] - sums[<span class="number">0</span>]$。</span><br><span class="line">+ 假设我们已经推出了数组的前`k`个最小的元素，则我们将属于这前`k`个元素的子集全部去掉，则此时剩下的元素中的最小值即为第`k+<span class="number">1</span>`个元素。</span><br><span class="line">+ 我们依次迭代即可得到第$<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.</span>..n$个元素。</span><br><span class="line"><span class="number">3.</span> 如果数组中出现负数时，则此时我们将所有元素都加上所有负数的和的绝对值$m$，此时即可将所有的元素变为正数,则此时$sums$中的所有元素即为所有正数元素的和。</span><br><span class="line"><span class="number">4.</span> 恢复元素时，我们测试所有可能元素的集合是否等于$m$,如果存在元素的集合的和为$m$,则我们将该集合中所有的元素取反即可，即可将所有的元素进行恢复。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; recoverArray(<span class="built_in">int</span> n, vector&lt;<span class="built_in">int</span>&gt;&amp; sums) &#123;</span><br><span class="line">        map&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; st;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : sums) &#123;</span><br><span class="line">            b = min(b,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) b = -b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : sums) st[b+v]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//remove zero</span></span><br><span class="line">        st[<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(st[<span class="number">0</span>] == <span class="number">0</span>) st.erase(<span class="number">0</span>);</span><br><span class="line">        ans.push_back(st.begin()-&gt;first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = (<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)); j &lt; (<span class="number">1</span>&lt;&lt;i); j++)&#123;</span><br><span class="line">                <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; i; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;k))&#123;</span><br><span class="line">                        curr += ans[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st[curr]--;</span><br><span class="line">                <span class="keyword">if</span>(st[curr] == <span class="number">0</span>) st.erase(curr);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(st.begin()-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) curr += ans[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == b)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) ans[j] = -ans[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-255&quot;&gt;&lt;a href=&quot;#leetcode-contest-255&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 255&quot;&gt;&lt;/a&gt;leetcode contest 255&lt;/h1&gt;&lt;p&gt;周赛的第四题好难，没想出来，还算脑力不够，只能靠努力来补。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/22/PRk9gEplMtzKVQZ.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5850-找出数组的最大公约数&quot;&gt;&lt;a href=&quot;#5850-找出数组的最大公约数&quot; class=&quot;headerlink&quot; title=&quot;5850. 找出数组的最大公约数&quot;&gt;&lt;/a&gt;5850. 找出数组的最大公约数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;找出数组的最大公约数 显示英文描述&lt;br&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，返回数组中最大数和最小数的 最大公约数 。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;两个数的 最大公约数 是能够被两个数整除的最大正整数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最小的数是 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最大的数是 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 的最大公约数是 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最小的数是 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最大的数是 &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; 的最大公约数是 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最小的数是 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums 中最大的数是 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 的最大公约数是 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ `&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;lt;= nums.length &amp;lt;= &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ `&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;= nums[i] &amp;lt;= &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 地址 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&lt;span class=&quot;comment&quot;&gt;//leetcode-cn.com/contest/weekly-contest-255/problems/find-greatest-common-divisor-of-array/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 题意&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;   暴力检测&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 思路&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 我们找到数组中的最大值和最小值，然后取公约数即可，简单题目。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```c++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; findGCD(vector&amp;lt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(nums.begin(),nums.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __gcd(nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],nums.back());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab4 Traps</title>
    <link href="http://yoursite.com/2021/08/19/316/"/>
    <id>http://yoursite.com/2021/08/19/316/</id>
    <published>2021-08-19T01:00:50.977Z</published>
    <updated>2021-08-20T14:10:21.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="traps"><a href="#traps" class="headerlink" title="traps"></a>traps</h1><p>最近封闭在家，没事干，只能刷题图开心，感觉MIT的lab刷起来真心是有意思，有挑战，难度很高，非常有思维挑战性，代码量倒是不是特别大。<br>特别<code>alarm</code>这个功能，思维确实比较牛逼，不过最重要的还算要看textbook，而不是忙着刷题，先把textbook看熟之后，再来刷题。<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-traps-handin" target="_blank" rel="noopener">git repo</a></p><h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><a id="more"></a><p>这个<code>lab</code>主要事熟悉risc-v汇编语言的基本语法，跟x86的语法很不同的是，函数的参数不是压入栈，而是存放在寄存器中，所以我们在调试时需要注意这个问题，典型的X86的栈如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">arg[n-1]</span><br><span class="line">arg[n-2]</span><br><span class="line">arg[n-3]</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">arg[0]</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">return address-----------&gt;frame pointer</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>   |</span><br><span class="line">prev  frame      |</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>   |</span><br><span class="line">saved register   |</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>   |</span><br><span class="line">Local variable   |</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>&lt;----|</span><br><span class="line"><span class="built_in">..</span></span><br><span class="line"><span class="built_in">..</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><br>risc-v的栈帧最大的区别就是函数的参数可能并不在栈上存储，可能在寄存器中存储。所以我觉得还算是非常容易理解的lab，采用risck gdb调试即可。</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p><code>backtrace</code>这一个lab可以说是为了能够深刻理解<code>stack machine</code>机制的设计的，每当调用函数时，首先需要将返回地址，之前的栈帧地址入栈，由于risck-v存储是以Little-Endian存储的，而栈空间的地址也是从高地址往低地址增长的，所以当前的栈帧的偏移8个字节即为<code>return address</code>，我们需要每次打印出返回地址，同时偏移16个字节则为前一个栈帧的地址，我们依次往前寻找，直到当前的栈帧的起始地址为<code>PGROUNDUP(fp)</code>，我们直到risc-v中每个栈空间的大小为4096byte，所以我们可以快速计算出栈顶和栈底的地址：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="keyword">bottom </span>= PGROUNDUP(<span class="built_in">fp</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>每次我们可以读寄存器fp即可得到当前栈的栈帧指向的地址，代码实现其实非常简单，但是需要仔细思考其中的原理。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add by mike meng</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">    uint64 fp = r_fp();</span><br><span class="line">uint64 bottom = PGROUNDUP(fp);</span><br><span class="line">uint64 address;</span><br><span class="line"><span class="keyword">char</span> path[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">int</span> line;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"backtrace:\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//printf("%p\n",*((uint64 *)(fp-8)));</span></span><br><span class="line">address = *((uint64 *)(fp<span class="number">-8</span>));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">ltaddr2line(address,path,&amp;line);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pc = %p, %s:%d\n"</span>,address,path,line);</span><br><span class="line">fp = *((uint64 *)(fp<span class="number">-16</span>));</span><br><span class="line">    <span class="keyword">if</span>(fp &gt;= bottom) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>这个<code>alarm</code>的lab还真心很难，想了很长时间没有想出来，后来看了好多参考书才有了一点眉目。首先需要了解<code>CPU</code>对于trap的处理原理，刚开始确实没有仔细阅读材料，导致浪费了很多时间。不过这门课程的视频课程讲的真心很好，感觉还是不能单看<code>textbook</code>。首先我们需要仔细理解<code>xv6</code>系统的<code>trap</code>的处理流程：<br><img src="https://i.loli.net/2021/08/20/UdOR1sVEX9xISYg.png" alt><br>上图为标准的syscall的处理流程。基本处理流程如下，<code>stvec</code>寄存器中设置的<code>trap</code>处理的入口地址处，一旦有<code>trap</code>需要处理时，首先CPU会把<code>PC</code>跳转到<code>stvec</code>寄存器设置的入口地址处,一般我们我们需要处理<code>usertrap</code>和<code>kernel trap</code>.trap的处理流程基本相似：<br><img src="https://i.loli.net/2021/08/20/HBkiRNlXGYn4sbU.png" alt></p><ul><li><code>kernel trap</code>：kernel trap主要处理设备的特殊中断请求。</li><li><code>usertrap</code>：user trap主要处理用户进程的trap处理。流程稍微复杂一点。最重要的两个函数为<code>usertrap</code>和<code>usertrapret</code>。我们仔细查找一下<code>usertrap</code>的入口函数，发现很难找到。实际上入口都是用汇编来完成，我们首先看一下<code>uservec</code>的具体内容用汇编实现的：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">#</span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="meta"># traps from user space start here,</span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="meta"># user page table.</span></span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process's p-&gt;trapframe is</span><br><span class="line">        <span class="meta"># mapped into user space, at TRAPFRAME.</span></span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">    <span class="meta"># swap a0 and sscratch</span></span><br><span class="line">        <span class="meta"># so that a0 is TRAPFRAME</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # 保存寄存器内容到TRAPFRAME所指向的地址上</span><br><span class="line">        <span class="meta"># save the user registers in TRAPFRAME</span></span><br><span class="line">        sd ra, <span class="number">40</span>(a0)</span><br><span class="line">        sd sp, <span class="number">48</span>(a0)</span><br><span class="line">        sd gp, <span class="number">56</span>(a0)</span><br><span class="line">        sd tp, <span class="number">64</span>(a0)</span><br><span class="line">        sd t0, <span class="number">72</span>(a0)</span><br><span class="line">        sd t1, <span class="number">80</span>(a0)</span><br><span class="line">        sd t2, <span class="number">88</span>(a0)</span><br><span class="line">        sd s0, <span class="number">96</span>(a0)</span><br><span class="line">        sd s1, <span class="number">104</span>(a0)</span><br><span class="line">        sd a1, <span class="number">120</span>(a0)</span><br><span class="line">        sd a2, <span class="number">128</span>(a0)</span><br><span class="line">        sd a3, <span class="number">136</span>(a0)</span><br><span class="line">        sd a4, <span class="number">144</span>(a0)</span><br><span class="line">        sd a5, <span class="number">152</span>(a0)</span><br><span class="line">        sd a6, <span class="number">160</span>(a0)</span><br><span class="line">        sd a7, <span class="number">168</span>(a0)</span><br><span class="line">        sd s2, <span class="number">176</span>(a0)</span><br><span class="line">        sd s3, <span class="number">184</span>(a0)</span><br><span class="line">        sd s4, <span class="number">192</span>(a0)</span><br><span class="line">        sd s5, <span class="number">200</span>(a0)</span><br><span class="line">        sd s6, <span class="number">208</span>(a0)</span><br><span class="line">        sd s7, <span class="number">216</span>(a0)</span><br><span class="line">        sd s8, <span class="number">224</span>(a0)</span><br><span class="line">        sd s9, <span class="number">232</span>(a0)</span><br><span class="line">        sd s10, <span class="number">240</span>(a0)</span><br><span class="line">        sd s11, <span class="number">248</span>(a0)</span><br><span class="line">        sd t3, <span class="number">256</span>(a0)</span><br><span class="line">        sd t4, <span class="number">264</span>(a0)</span><br><span class="line">        sd t5, <span class="number">272</span>(a0)</span><br><span class="line">        sd t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">        # 将a0用户的寄存器保存到frame上</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, <span class="number">112</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span></span><br><span class="line">        ld sp, <span class="number">8</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span><br><span class="line">        ld tp, <span class="number">32</span>(a0)</span><br><span class="line"></span><br><span class="line">        # 将usertrap的入口地址写给a0</span><br><span class="line">        <span class="meta"># load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span></span><br><span class="line">        ld t0, <span class="number">16</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span></span><br><span class="line">        # 将kernel的pagetable写入到satp寄存器，并刷新页表</span><br><span class="line">        ld t1, <span class="number">0</span>(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        <span class="meta"># table does not specially map p-&gt;tf.</span></span><br><span class="line"></span><br><span class="line">        # 跳转到usertrap()</span><br><span class="line">        <span class="meta"># jump to usertrap(), which does not return</span></span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>大致就是保存寄存器到<code>tramfram</code>上,然后<code>kstack</code>的地址写入sp寄存器，将hartid标记位写入到寄存器中，将<code>kernel</code>的页表写入到<code>satp</code>寄存器中，然后跳转到<code>usertrap</code>中，usertrap函数以下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取当前模式，是否为 user trap</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  <span class="comment">// interrupts process will be set to kernelvec.</span></span><br><span class="line">  <span class="comment">// 将trap的入口设置为kernel trap</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  <span class="comment">// 保存当前的pc值</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//if the interrupts is system call</span></span><br><span class="line">  <span class="comment">// 判断当前的trap类型</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;<span class="comment">// 系统调用</span></span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    <span class="comment">// 如果为系统调用，则将恢复的PC指向它的下一个指令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    <span class="comment">//open interrrupt</span></span><br><span class="line">    <span class="comment">// 关闭 trap，打开中断处理</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line"><span class="comment">// system call</span></span><br><span class="line">    <span class="comment">// 处理系统调用</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常trap,则直接关闭当前进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p-&gt;alarmworking &amp;&amp; p-&gt;alarminterval &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  p-&gt;alarmtick++;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarmtick == p-&gt;alarminterval)&#123;</span><br><span class="line"><span class="comment">//p-&gt;alarmhandler();</span></span><br><span class="line"><span class="comment">//p-&gt;alarmretaddr = p-&gt;trapframe-&gt;epc;</span></span><br><span class="line"><span class="comment">// we set the epc point  to the alarm handler</span></span><br><span class="line"><span class="comment">// when we leave from the trap process,we will get to the alarm handler</span></span><br><span class="line">memmove(&amp;p-&gt;alarmtrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarmhandler;</span><br><span class="line">    p-&gt;alarmtick = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarmworking = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复</span></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>userret</code>：我们从<code>userret</code>的相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">        <span class="meta"># userret(TRAPFRAME, pagetable)</span></span><br><span class="line">        <span class="meta"># switch from kernel to user.</span></span><br><span class="line">        <span class="meta"># usertrapret() calls here.</span></span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, <span class="keyword">for</span> satp.</span><br><span class="line"></span><br><span class="line">        <span class="meta"># switch to the user page table.</span></span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># put the saved user a0 in sscratch, so we</span></span><br><span class="line">        <span class="meta"># can swap it with our a0 (TRAPFRAME) in the last step.</span></span><br><span class="line">        ld t0, <span class="number">112</span>(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore all but a0 from TRAPFRAME</span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld sp, <span class="number">48</span>(a0)</span><br><span class="line">        ld gp, <span class="number">56</span>(a0)</span><br><span class="line">        ld tp, <span class="number">64</span>(a0)</span><br><span class="line">        ld t0, <span class="number">72</span>(a0)</span><br><span class="line">        ld t1, <span class="number">80</span>(a0)</span><br><span class="line">        ld t2, <span class="number">88</span>(a0)</span><br><span class="line">        ld s0, <span class="number">96</span>(a0)</span><br><span class="line">        ld s1, <span class="number">104</span>(a0)</span><br><span class="line">        ld a1, <span class="number">120</span>(a0)</span><br><span class="line">        ld a2, <span class="number">128</span>(a0)</span><br><span class="line">        ld a3, <span class="number">136</span>(a0)</span><br><span class="line">        ld a4, <span class="number">144</span>(a0)</span><br><span class="line">        ld a5, <span class="number">152</span>(a0)</span><br><span class="line">        ld a6, <span class="number">160</span>(a0)</span><br><span class="line">        ld a7, <span class="number">168</span>(a0)</span><br><span class="line">        ld s2, <span class="number">176</span>(a0)</span><br><span class="line">        ld s3, <span class="number">184</span>(a0)</span><br><span class="line">        ld s4, <span class="number">192</span>(a0)</span><br><span class="line">        ld s5, <span class="number">200</span>(a0)</span><br><span class="line">        ld s6, <span class="number">208</span>(a0)</span><br><span class="line">        ld s7, <span class="number">216</span>(a0)</span><br><span class="line">        ld s8, <span class="number">224</span>(a0)</span><br><span class="line">        ld s9, <span class="number">232</span>(a0)</span><br><span class="line">        ld s10, <span class="number">240</span>(a0)</span><br><span class="line">        ld s11, <span class="number">248</span>(a0)</span><br><span class="line">        ld t3, <span class="number">256</span>(a0)</span><br><span class="line">        ld t4, <span class="number">264</span>(a0)</span><br><span class="line">        ld t5, <span class="number">272</span>(a0)</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># restore user a0, and save TRAPFRAME in sscratch</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># return to user mode and user pc.</span></span><br><span class="line">        <span class="meta"># usertrapret() set up sstatus and sepc.</span></span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p>处理流程为首先将用户的页表切换到寄存器中，然后从<code>trapframe</code>中取出已经保存的值，将其恢复到寄存器中，然后将<code>trapframe</code>进行恢复到默认值，将PC的值恢复到之前的值，指令将会继续之前的PC的值进行执行。</p></li><li><p>我们实际在处理sigalarm时，首先需要将<code>sigalarm</code>和<code>sigalarmret</code>函数处理加入到<code>system call</code>中，然后在处理<code>usertrap</code>时，首先我们需要处理来自<code>timer</code>的trap,此时我们可以将<code>trap</code>恢复后的<code>pc</code>指向<code>alarmhandler</code>函数，我们运行时，即可发现可以运行<code>handler</code>函数，但是运行完成后，发现出了不少问题。我们仔细思考就可以发现，因为<code>PC</code>指向的指令地址改变后，我们可以仔细分析一下，函数执行时，我们看到当前栈帧返回时会返回正确的地址，因为此时<code>RA</code>寄存器存放的为正确的return address.但是periodic函数在执行过程中可能会将其中的寄存器污染，所以会出现<code>alarm</code>打印逻辑出错。所以我们在执行<code>handler</code>时，必须要将相关的寄存器进行保存，保存完成后再执行<code>handler</code>，执行完成<code>handler</code>后，我们再恢复寄存器，同时恢复<code>pc</code>.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">periodic()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="number">0</span>:<span class="number">1141</span>                addisp,sp,<span class="number">-16</span></span><br><span class="line">   <span class="number">2</span>:e406                sdra,<span class="number">8</span>(sp)</span><br><span class="line">   <span class="number">4</span>:e022                sds0,<span class="number">0</span>(sp)</span><br><span class="line">   <span class="number">6</span>:<span class="number">0800</span>                addis0,sp,<span class="number">16</span></span><br><span class="line">  count = count + <span class="number">1</span>;</span><br><span class="line">   <span class="number">8</span>:<span class="number">00001797</span>          auipca5,<span class="number">0x1</span></span><br><span class="line">   c:d407a783          lwa5,<span class="number">-704</span>(a5) # d48 &lt;count&gt;</span><br><span class="line">  <span class="number">10</span>:<span class="number">2785</span>                addiwa5,a5,<span class="number">1</span></span><br><span class="line">  <span class="number">12</span>:<span class="number">00001717</span>          auipca4,<span class="number">0x1</span></span><br><span class="line">  <span class="number">16</span>:d2f72b23          swa5,<span class="number">-714</span>(a4) # d48 &lt;count&gt;</span><br><span class="line">  printf(<span class="string">"alarm!\n"</span>);</span><br><span class="line">  <span class="number">1</span>a:<span class="number">00001517</span>          auipca0,<span class="number">0x1</span></span><br><span class="line">  <span class="number">1</span>e:b6650513          addia0,a0,<span class="number">-1178</span> # b80 &lt;malloc+<span class="number">0xea</span>&gt;</span><br><span class="line">  <span class="number">22</span>:<span class="number">00001097</span>          auipcra,<span class="number">0x1</span></span><br><span class="line">  <span class="number">26</span>:<span class="number">9</span>b6080e7          jalr<span class="number">-1610</span>(ra) # <span class="number">9</span>d8 &lt;printf&gt;</span><br><span class="line">  sigreturn();</span><br><span class="line">  <span class="number">2</span>a:<span class="number">00000097</span>          auipcra,<span class="number">0x0</span></span><br><span class="line">  <span class="number">2</span>e:<span class="number">6</span>c6080e7          jalr<span class="number">1734</span>(ra) # <span class="number">6f</span>0 &lt;sigreturn&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>刚开始我的想法是再申请一个物理页，然后用汇编将所有的寄存器的值，都保存到这个新申请的物理页中，待到函数执行完成后，我们再利用系统调用，将该物理页中保存的值再重新加载到寄存器中，刚开始想着是模仿<code>userret</code>和<code>uservec</code>的汇编代码来模仿实现。后来感觉太复杂了，看了提示之后，在进入<code>alarm handler</code>之前所有的寄存器其实都已经全部保存在tramp fram中，我们可以申请新的tramp fram结构，在<code>usertrapret</code>恢复寄存器时，暂时不恢复寄存器的值，只是将<code>PC</code>的值进行跳转。在<code>alarmreturn</code>时，此时我们再将已经保存的tramp fram中的寄存器和<code>PC</code>的值全部切换回去即可。</li></ul><ol><li><code>alarm</code>时，我们将handler和interval进行指定保存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ticks;</span><br><span class="line">    uint64 ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(argaddr(<span class="number">1</span>,&amp;ptr) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br><span class="line">p-&gt;alarmworking = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarminterval = ticks;</span><br><span class="line">p-&gt;alarmhandler = (func)ptr;</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>执行trap时，如果当前的ticks达到<code>alarminterval</code>时，则我们首先将<code>PC</code>的返回值替换为<code>handler</code>的入口地址，同时将当前<code>trap frame</code>的值进行保存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p-&gt;alarmworking &amp;&amp; p-&gt;alarminterval &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  p-&gt;alarmtick++;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarmtick == p-&gt;alarminterval)&#123;</span><br><span class="line"><span class="comment">//p-&gt;alarmhandler();</span></span><br><span class="line"><span class="comment">//p-&gt;alarmretaddr = p-&gt;trapframe-&gt;epc;</span></span><br><span class="line"><span class="comment">// we set the epc point  to the alarm handler</span></span><br><span class="line"><span class="comment">// when we leave from the trap process,we will get to the alarm handler</span></span><br><span class="line">memmove(&amp;p-&gt;alarmtrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarmhandler;</span><br><span class="line">    p-&gt;alarmtick = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarmworking = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>执行<code>sigreturn</code>时，则我们将保存的<code>tramfram</code>切换回去即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;alarmworking)&#123;</span><br><span class="line">memmove(p-&gt;trapframe,&amp;p-&gt;alarmtrap,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    p-&gt;alarmworking = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-challenge"><a href="#Optional-challenge" class="headerlink" title="Optional challenge"></a>Optional challenge</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print <span class="keyword">the</span> names <span class="keyword">of</span> <span class="keyword">the</span> functions <span class="keyword">and</span> <span class="built_in">line</span> numbers <span class="keyword">in</span> backtrace() instead <span class="keyword">of</span> numerical addresses</span><br></pre></td></tr></table></figure>按照要求对<code>backtrace</code>进行扩展，使得其能够打印出相应的文件和行号，刚开始拿到这个以为很简单，但是实际上实现起来还是挺复杂。主要查找的信息来源于<code>addr2line</code>的实现，在github上找了一堆实现<code>addr2line</code>的代码，后来发现一个<code>c++</code>还凑合，就拿过来读了一下，然后通过查找<code>debug_line</code>的具体参数定义，然后找到dwarf 3.0的标准，对战标准和代码把相关的功能全部重新移植到xv6上，虽然代码写的很烂，但是凑合还能用吧，其中<code>debug</code>的时间还挺长。具体实现原理如下：</li><li>改写makefile,把生成kernel的elf文件做到文件系统中，然后系统运行后，通过用户进程调用函数读取和解析elf文件，这里最大的坑是用户进程未初始化时，我直接用内核读取文件，发现会<code>panic</code>,后来仔细检查了很多遍，发现因为在内核文件的读取都会加载进程的文件锁，而这时用户进行还未初始化，这时如果去调用mypoc函数就会出现指针跑飞的问题。解决办法只有等待用户进行调度起来后，可以单独起一个用户进程读取和解析elf文件。</li><li>系统起来后，在内核空间中从文件系统读取elf文件，找到.debug_line这个section，然后按照dwarf 3.0的标准来解析header和opcode，具体可以Google相关的标准，标准本身还是挺复杂的，具体实现时参考这个github的代码：<a href="https://github.com/evmar/maddr" target="_blank" rel="noopener">https://github.com/evmar/maddr</a> ，里面解析opcode时有不少小bug，关键时刻还算看标准靠谱。</li><li>解析完成后，将解析生成的matrix放入到数组中，然后我们对line table按照地址从小到大进行排序，我们解析的line table中也可以看到每行代码可能会对应多个<code>instruction</code>，我们直到<code>pc</code>每次递增的。每次进行查询时，我们在line table表中查找小于等于等于给定地址p的第一个元素，然后返回查询结果即可，查询结果包含了文件名和行号，返回给trace即可。</li><li>熬了几天夜，终于把功能基本实现了，总体来说还算非常蛋疼的功能。<br><img src="https://i.loli.net/2021/08/20/hlpDCfavUjYydiR.png" alt></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;traps&quot;&gt;&lt;a href=&quot;#traps&quot; class=&quot;headerlink&quot; title=&quot;traps&quot;&gt;&lt;/a&gt;traps&lt;/h1&gt;&lt;p&gt;最近封闭在家，没事干，只能刷题图开心，感觉MIT的lab刷起来真心是有意思，有挑战，难度很高，非常有思维挑战性，代码量倒是不是特别大。&lt;br&gt;特别&lt;code&gt;alarm&lt;/code&gt;这个功能，思维确实比较牛逼，不过最重要的还算要看textbook，而不是忙着刷题，先把textbook看熟之后，再来刷题。&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/MIT6.S081/tree/main/lab-traps-handin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git repo&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;RISC-V-assembly&quot;&gt;&lt;a href=&quot;#RISC-V-assembly&quot; class=&quot;headerlink&quot; title=&quot;RISC-V assembly&quot;&gt;&lt;/a&gt;RISC-V assembly&lt;/h2&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 254</title>
    <link href="http://yoursite.com/2021/08/11/314/"/>
    <id>http://yoursite.com/2021/08/11/314/</id>
    <published>2021-08-11T02:42:04.552Z</published>
    <updated>2021-08-15T13:26:34.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-254"><a href="#leetcode-contest-254" class="headerlink" title="leetcode contest 254"></a>leetcode contest 254</h1><p>本周的题目的难度始终，难度不是很大，第三题竟然犯了个很坑爹错误，竟然把乘方数也取模了，结果一直结果不对。结果一直卡壳，以为我的算法错误。<br><img src="https://i.loli.net/2021/08/15/XuFZObePsBH1LwM.png" alt></p><h2 id="5843-作为子字符串出现在单词中的字符串数目"><a href="#5843-作为子字符串出现在单词中的字符串数目" class="headerlink" title="5843. 作为子字符串出现在单词中的字符串数目"></a>5843. 作为子字符串出现在单词中的字符串数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>patterns</code> 和一个字符串 <code>word</code> ，统计 <code>patterns</code> 中有多少个字符串是 <code>word</code> 的子字符串。返回字符串数目。</p><a id="more"></a><p>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：patterns = [<span class="string">"a"</span>,<span class="string">"abc"</span>,<span class="string">"bc"</span>,<span class="string">"d"</span>], <span class="built_in">word</span> = <span class="string">"abc"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">- <span class="string">"a"</span> 是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">- <span class="string">"abc"</span> 是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">- <span class="string">"bc"</span> 是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">- <span class="string">"d"</span> 不是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">patterns 中有 <span class="number">3</span> 个字符串作为子字符串出现在 <span class="built_in">word</span> 中。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：patterns = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>], <span class="built_in">word</span> = <span class="string">"aaaaabbbbb"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- <span class="string">"a"</span> 是 <span class="string">"aaaaabbbbb"</span> 的子字符串。</span><br><span class="line">- <span class="string">"b"</span> 是 <span class="string">"aaaaabbbbb"</span> 的子字符串。</span><br><span class="line">- <span class="string">"c"</span> 不是 <span class="string">"aaaaabbbbb"</span> 的字符串。</span><br><span class="line">patterns 中有 <span class="number">2</span> 个字符串作为子字符串出现在 <span class="built_in">word</span> 中。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：patterns = [<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>], word = <span class="comment">"ab"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：patterns 中的每个字符串都作为子字符串出现在 word <span class="comment">"ab"</span> 中。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= patterns.length &lt;= 100</code></li><li><code>1 &lt;= patterns[i].length &lt;= 100</code></li><li><code>1 &lt;= word.length &lt;= 100</code></li><li><code>patterns[i]</code> 和 <code>word</code> 由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测字符串里面是否含有特定的字符串，用<code>stl</code>库函数<code>find</code>即可。算法时间复杂度为$O(n)$,算法空间复杂度为$O(1)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfStrings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; patterns, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : patterns)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word.find(p) != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5832-构造元素不等于两相邻元素平均值的数组"><a href="#5832-构造元素不等于两相邻元素平均值的数组" class="headerlink" title="5832. 构造元素不等于两相邻元素平均值的数组"></a>5832. 构造元素不等于两相邻元素平均值的数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 下标从 0 开始 的数组 <code>nums</code> ，数组由若干 互不相同的 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 不等于 其两侧相邻元素的 平均值 。</p><p>更公式化的说法是，重新排列的数组应当满足这一属性：对于范围 <code>1 &lt;= i &lt; nums.length - 1</code> 中的每个 <code>i</code> ，<code>(nums[i-1] + nums[i+1]) / 2</code>不等于 <code>nums[i]</code> 均成立 。</p><p>返回满足题意的任一重排结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">1</span>, nums[i] = <span class="number">2</span>, 两相邻元素平均值为 (<span class="number">1</span>+<span class="number">4</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br><span class="line">i=<span class="number">2</span>, nums[i] = <span class="number">4</span>, 两相邻元素平均值为 (<span class="number">2</span>+<span class="number">5</span>) / <span class="number">2</span> = <span class="number">3.5</span></span><br><span class="line">i=<span class="number">3</span>, nums[i] = <span class="number">5</span>, 两相邻元素平均值为 (<span class="number">4</span>+<span class="number">3</span>) / <span class="number">2</span> = <span class="number">3.5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">1</span>, nums[i] = <span class="number">7</span>, 两相邻元素平均值为 (<span class="number">9</span>+<span class="number">6</span>) / <span class="number">2</span> = <span class="number">7.5</span></span><br><span class="line">i=<span class="number">2</span>, nums[i] = <span class="number">6</span>, 两相邻元素平均值为 (<span class="number">7</span>+<span class="number">2</span>) / <span class="number">2</span> = <span class="number">4.5</span></span><br><span class="line">i=<span class="number">3</span>, nums[i] = <span class="number">2</span>, 两相邻元素平均值为 (<span class="number">6</span>+<span class="number">0</span>) / <span class="number">2</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始想了很长时间，后来想了一种简单办法，首先我们将数组按照从小到大排序，数组索引从<code>0</code>开始，然后我们将奇数位的数与前一个数进行交换，这样我们即可满足如下：</li></ol><ul><li>对于索引为奇数位的元素我们发现一定满足：<script type="math/tex; mode=display">nums[i] < nums[i-1] \\nums[i] < nums[i+1] \\nums[i-1] + nums[i+1] > nums[i]*2</script></li><li>对于索引为偶数位的元素我们发现一定满足：<script type="math/tex; mode=display">nums[i] > nums[i-1] \\nums[i] > nums[i+1] \\nums[i-1] + nums[i+1] < nums[i]*2 \\</script></li></ul><ol><li>时间复杂度为$O(nlgn + n)$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rearrangeArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>)&#123;</span><br><span class="line">           swap(nums[i<span class="number">-1</span>],nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5844-数组元素的最小非零乘积"><a href="#5844-数组元素的最小非零乘积" class="headerlink" title="5844. 数组元素的最小非零乘积"></a>5844. 数组元素的最小非零乘积</h2><p>给你一个正整数 <code>p</code>。你有一个下标从 1 开始的数组 <code>nums</code>，这个数组包含范围<code>[1, 2p - 1]</code>内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次：</p><p>从 <code>nums</code>中选择两个元素 <code>x</code> 和 <code>y</code>  。<br>选择 x 中的一位与 <code>y</code> 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。<br>比方说，如果<code>x = 1101</code>且 <code>y = 0011</code>，交换右边数起第 2 位后，我们得到 <code>x = 1111</code> 和 <code>y = 0001</code> 。</p><p>请你算出进行以上操作 任意次 以后，<code>nums</code> 能得到的 最小非零 乘积。将乘积对 <code>109 + 7</code> 取余 后返回。</p><p>注意：答案应为取余 之前 的最小值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：p = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：nums = [<span class="number">1</span>] 。</span><br><span class="line">只有一个元素，所以乘积为该元素。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：p = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：nums = [<span class="number">01</span>, <span class="number">10</span>, <span class="number">11</span>] 。</span><br><span class="line">所有交换要么使乘积变为 <span class="number">0</span> ，要么乘积与初始乘积相同。</span><br><span class="line">所以，数组乘积 <span class="number">1</span> * <span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span> 已经是最小值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：p = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1512</span></span><br><span class="line">解释：nums = [<span class="number">001</span>, <span class="number">010</span>, <span class="number">011</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">111</span>]</span><br><span class="line">- 第一次操作中，我们交换第二个和第五个元素最左边的数位。</span><br><span class="line">    - 结果数组为 [<span class="number">001</span>, <span class="number">110</span>, <span class="number">011</span>, <span class="number">100</span>, <span class="number">001</span>, <span class="number">110</span>, <span class="number">111</span>] 。</span><br><span class="line">- 第二次操作中，我们交换第三个和第四个元素中间的数位。</span><br><span class="line">    - 结果数组为 [<span class="number">001</span>, <span class="number">110</span>, <span class="number">001</span>, <span class="number">110</span>, <span class="number">001</span>, <span class="number">110</span>, <span class="number">111</span>] 。</span><br><span class="line">数组乘积 <span class="number">1</span> * <span class="number">6</span> * <span class="number">1</span> * <span class="number">6</span> * <span class="number">1</span> * <span class="number">6</span> * <span class="number">7</span> = <span class="number">1512</span> 是最小乘积。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= p &lt;= 60</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们仔细观察一下，实际上最后发现所有的数，交换之后最终成为如下形式时，乘积最小：<script type="math/tex; mode=display">000...0001,111...1110,000...0001,111...1110,...,000...0001,111...1110,111...1111</script></li><li>我们知道这种类似的分布以后我们只需数出$(000…0001,111…1110)$数对的数目即可，我们知道从$1$到$2^{p}-1$总共$2^{p-1}-1$对，因此我们可以知道最终的求和公式为如下：<script type="math/tex; mode=display">ans = (2^{p} -1)*(2^{p}-2)^{2^{p-1}-1}</script></li><li>算法负责度为$O(n)$.比赛中竟然把乘方数进行取模，结果怎么算结果都不对。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>) ans = (ans*curr)%mod;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNonZeroProduct</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = fastpow(<span class="number">2</span>,p,mod)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> y = (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;(p<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> fastpow(x<span class="number">-1</span>,y<span class="number">-1</span>,mod)*x%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5845-你能穿过矩阵的最后一天"><a href="#5845-你能穿过矩阵的最后一天" class="headerlink" title="5845. 你能穿过矩阵的最后一天"></a>5845. 你能穿过矩阵的最后一天</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 1 开始的二进制矩阵，其中 <code>0</code> 表示陆地，<code>1</code> 表示水域。同时给你 <code>row</code> 和 <code>col</code> 分别表示矩阵中行和列的数目。</p><p>一开始在第 0 天，整个 矩阵都是 陆地 。但每一天都会有一块新陆地被 水 淹没变成水域。给你一个下标从 1 开始的二维数组 <code>cells</code> ，其中 <code>cells[i] = [ri, ci]</code> 表示在第 <code>i</code> 天，第<code>ri</code> 行 <code>ci</code> 列（下标都是从 1 开始）的陆地会变成 水域 （也就是 0 变成 1 ）。</p><p>你想知道从矩阵最 上面 一行走到最 下面 一行，且只经过陆地格子的 最后一天 是哪一天。你可以从最上面一行的 任意 格子出发，到达最下面一行的 任意 格子。你只能沿着 四个 基本方向移动（也就是上下左右）。</p><p>请返回只经过陆地格子能从最 上面 一行走到最 下面 一行的 最后一天 。</p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">2</span>, col = <span class="number">2</span>, cells = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：上图描述了矩阵从第 <span class="number">0</span> 天开始是如何变化的。</span><br><span class="line">可以从最上面一行到最下面一行的最后一天是第 <span class="number">2</span> 天。</span><br></pre></td></tr></table></figure><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">2</span>, col = <span class="number">2</span>, cells = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：上图描述了矩阵从第 <span class="number">0</span> 天开始是如何变化的。</span><br><span class="line">可以从最上面一行到最下面一行的最后一天是第 <span class="number">1</span> 天。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">3</span>, col = <span class="number">3</span>, cells = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：上图描述了矩阵从第 <span class="number">0</span> 天开始是如何变化的。</span><br><span class="line">可以从最上面一行到最下面一行的最后一天是第 <span class="number">3</span> 天。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= row, col &lt;= 2 * 104</code></li><li><code>4 &lt;= row * col &lt;= 2 * 104</code></li><li><code>cells.length == row * col</code></li><li><code>1 &lt;= ri &lt;= row</code></li><li><code>1 &lt;= ci &lt;= col</code></li><li><code>cells</code> 中的所有格子坐标都是 唯一 的。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/last-day-where-you-can-still-cross" target="_blank" rel="noopener">https://leetcode-cn.com/problems/last-day-where-you-can-still-cross</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 集合</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>二分查找，我们通过<code>bfs</code>检测矩阵的上下是否联通，二分查找需要耗费的时间为$lg(n)$,每次检测需要耗费的时间为$O(row<em>col)$,这种算法较为简单，算法时间复杂度为$O(row</em>col*lgn).</li><li>我们采用倒序的检测方法，每次将水域变成陆地，可以看到假如存在陆地满足上下连通，即是最后一天。此时我们用集合检测即可。实际只需要一点小技巧即可。</li><li>总的来说这题难度较低，不是很难的题目。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; touchButtom,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; touchUp,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">        <span class="keyword">if</span>(x1 &lt; y1)&#123;</span><br><span class="line">            f[x1] = y1;</span><br><span class="line">            touchButtom[y1] = touchButtom[y1]||touchButtom[x1];</span><br><span class="line">            touchUp[y1] = touchUp[y1]||touchUp[x1];</span><br><span class="line">            touchButtom[x1] = touchButtom[x1]||touchButtom[y1];</span><br><span class="line">            touchUp[x1] = touchUp[x1]||touchUp[y1];         </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x1 &gt; y1)&#123;</span><br><span class="line">            f[y1] = x1;</span><br><span class="line">            touchButtom[x1] = touchButtom[x1]||touchButtom[y1];</span><br><span class="line">            touchUp[x1] = touchUp[x1]||touchUp[y1];</span><br><span class="line">            touchButtom[y1] = touchButtom[y1]||touchButtom[x1];</span><br><span class="line">            touchUp[y1] = touchUp[y1]||touchUp[x1];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(touchButtom[y1] &amp;&amp; touchUp[y1]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">latestDayToCross</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cells)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cells.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; grid(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; touchButtom(row*col,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; touchUp(row*col,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(row*col,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cells.size(); ++i)&#123;</span><br><span class="line">            cells[i][<span class="number">0</span>]--;</span><br><span class="line">            cells[i][<span class="number">1</span>]--;</span><br><span class="line">            grid[cells[i][<span class="number">0</span>]][cells[i][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            touchUp[i] = <span class="literal">true</span>;</span><br><span class="line">            touchButtom[(row<span class="number">-1</span>)*col+i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row*col; ++i) f[i] = i;     </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = d[k][<span class="number">0</span>] + i;</span><br><span class="line">                        <span class="keyword">int</span> y = d[k][<span class="number">1</span>] + j;</span><br><span class="line">                        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(uni(f,touchButtom,touchUp,i*col+j,x*col+y))&#123;</span><br><span class="line">                                <span class="keyword">return</span> n;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cells[i][<span class="number">0</span>] + d[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = cells[i][<span class="number">1</span>] + d[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(uni(f,touchButtom,touchUp,cells[i][<span class="number">0</span>]*col + cells[i][<span class="number">1</span>],x*col+y))&#123;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            grid[cells[i][<span class="number">0</span>]][cells[i][<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-254&quot;&gt;&lt;a href=&quot;#leetcode-contest-254&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 254&quot;&gt;&lt;/a&gt;leetcode contest 254&lt;/h1&gt;&lt;p&gt;本周的题目的难度始终，难度不是很大，第三题竟然犯了个很坑爹错误，竟然把乘方数也取模了，结果一直结果不对。结果一直卡壳，以为我的算法错误。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/XuFZObePsBH1LwM.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5843-作为子字符串出现在单词中的字符串数目&quot;&gt;&lt;a href=&quot;#5843-作为子字符串出现在单词中的字符串数目&quot; class=&quot;headerlink&quot; title=&quot;5843. 作为子字符串出现在单词中的字符串数目&quot;&gt;&lt;/a&gt;5843. 作为子字符串出现在单词中的字符串数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;patterns&lt;/code&gt; 和一个字符串 &lt;code&gt;word&lt;/code&gt; ，统计 &lt;code&gt;patterns&lt;/code&gt; 中有多少个字符串是 &lt;code&gt;word&lt;/code&gt; 的子字符串。返回字符串数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 253</title>
    <link href="http://yoursite.com/2021/08/08/313/"/>
    <id>http://yoursite.com/2021/08/08/313/</id>
    <published>2021-08-08T07:36:53.218Z</published>
    <updated>2021-08-08T08:19:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-253"><a href="#leetcode-contest-253" class="headerlink" title="leetcode contest 253"></a>leetcode contest 253</h1><p>本周题目都是手速场，确实难度太低了。</p><h2 id="5838-检查字符串是否为数组前缀"><a href="#5838-检查字符串是否为数组前缀" class="headerlink" title="5838. 检查字符串是否为数组前缀"></a>5838. 检查字符串是否为数组前缀</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>words</code>，请你判断 <code>s</code> 是否为 <code>words</code> 的 前缀字符串 。</p><p>字符串 <code>s</code> 要成为 <code>words</code>的 前缀字符串 ，需要满足：<code>s</code>可以由 <code>words</code> 中的前 <code>k</code>（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 <code>words.length</code> 。</p><a id="more"></a><p>如果 <code>s</code> 是<code>words</code>的 前缀字符串 ，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"iloveleetcode"</span>, <span class="attr">words</span> = [<span class="string">"i"</span>,<span class="string">"love"</span>,<span class="string">"leetcode"</span>,<span class="string">"apples"</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">s 可以由 <span class="string">"i"</span>、<span class="string">"love"</span> 和 <span class="string">"leetcode"</span> 相连得到。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"iloveleetcode"</span>, <span class="attr">words</span> = [<span class="string">"apples"</span>,<span class="string">"i"</span>,<span class="string">"love"</span>,<span class="string">"leetcode"</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：</span><br><span class="line">数组的前缀相连无法得到 s 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 20</code></li><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>words[i]</code> 和 <code>s</code> 仅由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-58/problems/delete-characters-to-make-fancy-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-58/problems/delete-characters-to-make-fancy-string/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>求出字符串数组中所有可能的前缀，然后与目标字符串进行比较即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPrefixString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                curr += words[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5839-移除石子使总数最小"><a href="#5839-移除石子使总数最小" class="headerlink" title="5839. 移除石子使总数最小"></a>5839. 移除石子使总数最小</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>piles</code> ，数组 下标从 <code>0</code> 开始 ，其中 <code>piles[i]</code> 表示第 <code>i</code> 堆石子中的石子数量。另给你一个整数<code>k</code> ，请你执行下述操作 恰好 <code>k</code> 次：</p><p>选出任一石子堆 <code>piles[i]</code>，并从中 移除 <code>floor(piles[i] / 2)</code> 颗石子。<br>注意：你可以对 同一堆 石子多次执行此操作。</p><p>返回执行<code>k</code> 次操作后，剩下石子的 最小 总数。</p><p><code>floor(x)</code> 为 小于 或 等于<code>x</code>的 最大 整数。（即，对 <code>x</code>向下取整）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：可能的执行情景如下：</span><br><span class="line">- 对第 <span class="number">2</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">- 对第 <span class="number">0</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">剩下石子的总数为 <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：可能的执行情景如下：</span><br><span class="line">- 对第 <span class="number">2</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>] 。</span><br><span class="line">- 对第 <span class="number">3</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>] 。</span><br><span class="line">- 对第 <span class="number">0</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>] 。</span><br><span class="line">剩下石子的总数为 <span class="number">12</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= piles.length &lt;= 105</code></li><li><code>1 &lt;= piles[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-253/problems/remove-stones-to-minimize-the-total/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-253/problems/remove-stones-to-minimize-the-total/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>每次从队列中取出最大的元素，然后去掉最大元素的一半，然后将剩余的元素重新放入到队列中，典型的优先级队列。</li><li>时间复杂度为$O(Klgn)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStoneSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            pq.push(piles[i]);</span><br><span class="line">            ans += piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.empty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            ans -= (curr/<span class="number">2</span>);</span><br><span class="line">            pq.push(curr-(curr/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5840-使字符串平衡的最小交换次数"><a href="#5840-使字符串平衡的最小交换次数" class="headerlink" title="5840. 使字符串平衡的最小交换次数"></a>5840. 使字符串平衡的最小交换次数</h2><p>给你一个字符串<code>s</code> ，下标从 <code>0</code> 开始 ，且长度为偶数<code>n</code>。字符串 恰好 由 <code>n / 2</code>个开括号 <code>&#39;[&#39;</code> 和 <code>n / 2</code>个闭括号<code>&#39;]&#39;</code> 组成。</p><p>只有能满足下述所有条件的字符串才能称为 平衡字符串 ：</p><ul><li>字符串是一个空字符串，或者</li><li>字符串可以记作 <code>AB</code>，其中 <code>A</code> 和 <code>B</code> 都是 平衡字符串 ，或者</li><li>字符串可以写成<code>[C]</code> ，其中<code>C</code> 是一个 平衡字符串 。<br>你可以交换 任意 两个下标所对应的括号 任意 次数。</li></ul><p>返回使<code>s</code>变成 平衡字符串 所需要的 最小 交换次数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"][]["</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：交换下标 <span class="number">0</span> 和下标 <span class="number">3</span> 对应的括号，可以使字符串变成平衡字符串。</span><br><span class="line">最终字符串变成 <span class="string">"[[]]"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "]]][[["</span><br><span class="line">输出：2</span><br><span class="line">解释：执行下述操作可以使字符串变成平衡字符串：</span><br><span class="line"><span class="bullet">- </span>交换下标 0 和下标 4 对应的括号，s = "[<span class="string"></span>]][[]" 。</span><br><span class="line"><span class="bullet">- </span>交换下标 1 和下标 5 对应的括号，s = "[<span class="string">[</span>][<span class="symbol"></span>]]" 。</span><br><span class="line">最终字符串变成 "[<span class="string">[</span>][<span class="symbol"></span>]]" 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"[]"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：这个字符串已经是平衡字符串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == s.length</code></li><li><code>2 &lt;= n &lt;= 106</code></li><li><code>n</code>为偶数</li><li><code>s[i]</code> 为<code>&#39;[&#39;</code> 或 <code>&#39;]&#39;</code></li><li>开括号 <code>&#39;[&#39;</code> 的数目为 <code>n / 2</code> ，闭括号 <code>&#39;]&#39;</code> 的数目也是 <code>n / 2</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-58/problems/minimum-total-space-wasted-with-k-resizing-operations/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-58/problems/minimum-total-space-wasted-with-k-resizing-operations/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>本质即为括号匹配问题，我们检测如果发现右括号<code>]</code>没有匹配时，则从字符串的末尾找到一个<code>[</code>来进行交换。</li><li>算法时间复杂度为$O(n)$,空间复杂度为$O(1)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr--;</span><br><span class="line">                <span class="keyword">if</span>(curr &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(r &gt; i &amp;&amp; s[r] == <span class="string">']'</span>) r--;</span><br><span class="line">                    swap(s[i],s[r]);</span><br><span class="line">                    ans++;</span><br><span class="line">                    curr += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5841-找出到每个位置为止最长的有效障碍赛跑路线"><a href="#5841-找出到每个位置为止最长的有效障碍赛跑路线" class="headerlink" title="5841. 找出到每个位置为止最长的有效障碍赛跑路线"></a>5841. 找出到每个位置为止最长的有效障碍赛跑路线</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你打算构建一些障碍赛跑路线。给你一个 下标从<code>0</code> 开始 的整数数组 <code>obstacles</code> ，数组长度为 n ，其中 <code>obstacles[i]</code> 表示第 i 个障碍的高度。</p><p>对于每个介于 0 和 <code>n - 1</code> 之间（包含 <code>0</code>和 <code>n - 1</code>）的下标  i ，在满足下述条件的前提下，请你找出 <code>obstacles</code> 能构成的最长障碍路线的长度：</p><p>你可以选择下标介于 0 到 <code>i</code>之间（包含 0 和 i）的任意个障碍。<br>在这条路线中，必须包含第 <code>i</code>个障碍。<br>你必须按障碍在 <code>obstacles</code>中的 出现顺序 布置这些障碍。<br>除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。<br>返回长度为 n 的答案数组 <code>ans</code> ，其中 <code>ans[i]</code> 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：每个位置的最长有效障碍路线是：</span><br><span class="line">- i = <span class="number">0</span>: [<span class="number">1</span>], [<span class="number">1</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] 长度为 <span class="number">2</span></span><br><span class="line">- i = <span class="number">2</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 长度为 <span class="number">3</span></span><br><span class="line">- i = <span class="number">3</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 长度为 <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：每个位置的最长有效障碍路线是：</span><br><span class="line">- i = <span class="number">0</span>: [<span class="number">2</span>], [<span class="number">2</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">1</span>: [<span class="number">2</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">2</span>] 长度为 <span class="number">2</span></span><br><span class="line">- i = <span class="number">2</span>: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">1</span>] 长度为 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：每个位置的最长有效障碍路线是：</span><br><span class="line">- i = <span class="number">0</span>: [<span class="number">3</span>], [<span class="number">3</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">1</span>: [<span class="number">3</span>,<span class="number">1</span>], [<span class="number">1</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">2</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>], [<span class="number">3</span>,<span class="number">5</span>] 长度为 <span class="number">2</span>, [<span class="number">1</span>,<span class="number">5</span>] 也是有效的障碍赛跑路线</span><br><span class="line">- i = <span class="number">3</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] 长度为 <span class="number">3</span>, [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>] 也是有效的障碍赛跑路线</span><br><span class="line">- i = <span class="number">4</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>], [<span class="number">3</span>,<span class="number">4</span>] 长度为 <span class="number">2</span>, [<span class="number">1</span>,<span class="number">4</span>] 也是有效的障碍赛跑路线</span><br><span class="line">- i = <span class="number">5</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] 长度为 <span class="number">2</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == obstacles.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= obstacles[i] &lt;= <span class="number">107</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/count-number-of-special-subsequences</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  LIS问题</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 典型的LIS问题变形，常见的`LIS`问题中要求每个元素严格递增，但在本题中要求后一个元素大于等于前一个元素。我们用`dp[i]`表示长度为`i+<span class="number">1</span>`的非递减数组中的最后一个元素。我们每次遇到当前元素`curr`时，则我们在已经组成元素查找第一个比`curr`大的元素，并用`curr`去替换该元素，即可得到以`curr`为结尾的最长递增序列。熟悉`lis`问题的人则会对改题目很容易理解。</span><br><span class="line"><span class="number">2.</span> 时间复杂度为$O(nlgn)$,空间复杂度为$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; longestObstacleCourseAtEachPosition(vector&lt;<span class="built_in">int</span>&gt;&amp; obstacles) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = obstacles.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; lcs;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">auto</span> it = upper_bound(lcs.begin(),lcs.end(),obstacles[i]);</span><br><span class="line">            <span class="keyword">if</span>(it == lcs.end())&#123;</span><br><span class="line">                ans[i] = lcs.size() + <span class="number">1</span>;</span><br><span class="line">                lcs.push_back(obstacles[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i] = it - lcs.begin() + <span class="number">1</span>;</span><br><span class="line">                *it = obstacles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-253&quot;&gt;&lt;a href=&quot;#leetcode-contest-253&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 253&quot;&gt;&lt;/a&gt;leetcode contest 253&lt;/h1&gt;&lt;p&gt;本周题目都是手速场，确实难度太低了。&lt;/p&gt;&lt;h2 id=&quot;5838-检查字符串是否为数组前缀&quot;&gt;&lt;a href=&quot;#5838-检查字符串是否为数组前缀&quot; class=&quot;headerlink&quot; title=&quot;5838. 检查字符串是否为数组前缀&quot;&gt;&lt;/a&gt;5838. 检查字符串是否为数组前缀&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个字符串数组 &lt;code&gt;words&lt;/code&gt;，请你判断 &lt;code&gt;s&lt;/code&gt; 是否为 &lt;code&gt;words&lt;/code&gt; 的 前缀字符串 。&lt;/p&gt;&lt;p&gt;字符串 &lt;code&gt;s&lt;/code&gt; 要成为 &lt;code&gt;words&lt;/code&gt;的 前缀字符串 ，需要满足：&lt;code&gt;s&lt;/code&gt;可以由 &lt;code&gt;words&lt;/code&gt; 中的前 &lt;code&gt;k&lt;/code&gt;（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 &lt;code&gt;words.length&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
