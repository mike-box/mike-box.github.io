<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-08T22:39:42.207Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 196周比赛</title>
    <link href="http://yoursite.com/2020/07/05/178/"/>
    <id>http://yoursite.com/2020/07/05/178/</id>
    <published>2020-07-05T15:55:47.305Z</published>
    <updated>2020-07-08T22:39:42.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="196周比赛"><a href="#196周比赛" class="headerlink" title="196周比赛"></a>196周比赛</h1><p>对于我这种菜鸟级别的选手来说，感觉题目还是挺难的，<code>hard</code>题目依旧不会做。只能说自己是个勤奋的人，但不是个聪明的人。</p><h2 id="5452-判断能否形成等差数列"><a href="#5452-判断能否形成等差数列" class="headerlink" title="5452. 判断能否形成等差数列"></a>5452. 判断能否形成等差数列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数字数组 <code>arr</code> 。</p><p>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。</p><p>如果可以重新排列数组形成等差数列，请返回 <code>true</code>；否则，返回 <code>false</code> 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：对数组重新排序得到 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>] 或者 [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>] ，任意相邻两项的差分别为 <span class="number">2</span> 或 <span class="number">-2</span> ，可以形成等差数列。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法通过重新排序得到等差数列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= arr.length &lt;= 1000</code></li><li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接排序即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[i]-arr[i<span class="number">-1</span>]) != (arr[i<span class="number">-1</span>]-arr[i<span class="number">-2</span>])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5453-所有蚂蚁掉下来前的最后一刻"><a href="#5453-所有蚂蚁掉下来前的最后一刻" class="headerlink" title="5453. 所有蚂蚁掉下来前的最后一刻"></a>5453. 所有蚂蚁掉下来前的最后一刻</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有一块木板，长度为<code>n</code>个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。</p><p>当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。</p><p>而当蚂蚁在某一时刻 <code>t</code>到达木板的一端时，它立即从木板上掉下来。</p><p>给你一个整数<code>n</code>和两个整数数组 <code>left</code>以及<code>right</code>。两个数组分别标识向左或者向右移动的蚂蚁在 <code>t = 0</code> 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, left = [<span class="number">4</span>,<span class="number">3</span>], right = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：如上图所示：</span><br><span class="line">-下标 <span class="number">0</span> 处的蚂蚁命名为 A 并向右移动。</span><br><span class="line">-下标 <span class="number">1</span> 处的蚂蚁命名为 B 并向右移动。</span><br><span class="line">-下标 <span class="number">3</span> 处的蚂蚁命名为 C 并向左移动。</span><br><span class="line">-下标 <span class="number">4</span> 处的蚂蚁命名为 D 并向左移动。</span><br><span class="line">请注意，蚂蚁在木板上的最后时刻是 t = <span class="number">4</span> 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = <span class="number">4.0000000001</span> 时，木板上没有蚂蚁）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, left = [], right = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：所有蚂蚁都向右移动，下标为 <span class="number">0</span> 的蚂蚁需要 <span class="number">7</span> 秒才能从木板上掉落。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, left = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], right = []</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：所有蚂蚁都向左移动，下标为 <span class="number">7</span> 的蚂蚁需要 <span class="number">7</span> 秒才能从木板上掉落。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, left = [<span class="number">5</span>], right = [<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：t = <span class="number">1</span> 秒时，两只蚂蚁将回到初始位置，但移动方向与之前相反。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, left = [<span class="number">6</span>], right = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>0 &lt;= left.length &lt;= n + 1</code></li><li><code>0 &lt;= left[i] &lt;= n</code></li><li><code>0 &lt;= right.length &lt;= n + 1</code></li><li><code>0 &lt;= right[i] &lt;= n</code></li><li><code>1 &lt;= left.length + right.length &lt;= n + 1</code></li><li><code>left</code>和 <code>right</code>中的所有值都是唯一的，并且每个值 只能出现在二者之一 中。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank" target="_blank" rel="noopener">https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常类似于一个非常著名的小学奥数题目，信鸽的问题。比如这个信鸽飞行问题：(<a href="http://www.aoshu.com/e/20180811/5b6e80c6679a2.shtml" target="_blank" rel="noopener">http://www.aoshu.com/e/20180811/5b6e80c6679a2.shtml</a>)</li><li>不管图中有多少只蚂蚁，实际上最终的时间是由最左边且走向向右和最右边且方向向左的两只方向相对的蚂蚁决定的。类似于这样。因为两只蚂蚁调头，并且两只蚂蚁的移动速度相等，则实际就相当于两只蚂蚁调头实际等价于两只蚂蚁直接越过对方。所以总的时间只与某个蚂蚁的最长掉落时间有关。</li><li>我们求出所有蚂蚁的掉落时间，取其中最大的掉落时间即可。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLastMoment</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; left, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.size(); ++i) ans = max(ans,left[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right.size(); ++i) ans = max(ans,n-right[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5454-统计全-1-子矩形"><a href="#5454-统计全-1-子矩形" class="headerlink" title="5454. 统计全 1 子矩形"></a>5454. 统计全 1 子矩形</h2><p>给你一个只包含 <code>0</code>和<code>1</code>的 <code>rows * columns</code> 矩阵 <code>mat</code> ，请你返回有多少个 子矩形 的元素全部都是 1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">6</span> 个 <span class="number">1</span>x1 的矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">1</span>x2 的矩形。</span><br><span class="line">有 <span class="number">3</span> 个 <span class="number">2</span>x1 的矩形。</span><br><span class="line">有 <span class="number">1</span> 个 <span class="number">2</span>x2 的矩形。</span><br><span class="line">有 <span class="number">1</span> 个 <span class="number">3</span>x1 的矩形。</span><br><span class="line">矩形数目总共 = <span class="number">6</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">13</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">8</span> 个 <span class="number">1</span>x1 的子矩形。</span><br><span class="line">有 <span class="number">5</span> 个 <span class="number">1</span>x2 的子矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">1</span>x3 的子矩形。</span><br><span class="line">有 <span class="number">4</span> 个 <span class="number">2</span>x1 的子矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">2</span>x2 的子矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">3</span>x1 的子矩形。</span><br><span class="line">有 <span class="number">1</span> 个 <span class="number">3</span>x2 的子矩形。</span><br><span class="line">矩形数目总共 = <span class="number">8</span> + <span class="number">5</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= rows &lt;= 150</code></li><li><code>1 &lt;= columns &lt;= 150</code></li><li><code>0 &lt;= mat[i][j] &lt;= 1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-submatrices-with-all-ones</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的还是非常好，看似这种很简单的题目，但是背后的思考技巧，值得深入思考和思索，时间复杂度为O(n^3).首先看到题目中给定的数量范围即可知道本题的实际的时间复杂度应该为<code>O(n^3)</code>或者 <code>O(n^2lgn)</code>.</li><li>如图<img src="https://mike-box.github.io/images/181-1.png" alt="1">所示,我们每次求出以坐标(i,j)为右下角的顶点的所有矩形个数，<code>rectange(i,j)</code>.<script type="math/tex; mode=display">sum = \sum_{i = 0}^{row-1}\sum_{j=0}^{col-1}rectange(i,j)</script></li><li>求这个有点技巧，我们先求出高度为h且右下角的顶点为(i,j)的矩形个数为<code>rectange(i,j，h)</code>，如图<img src="https://mike-box.github.io/images/181-2.png" alt="2">所示。<script type="math/tex; mode=display">sum = \sum_{i = 0}^{row-1}\sum_{j=0}^{col-1}\sum_{h=1}^{i} rectange(i,j,h)</script>我们只需要求出高位为h的矩形的最大宽度即可。<script type="math/tex; mode=display">w(i,j,h) = min(w(i,j,k)_{k=1}^{h-1})</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">1</span> + (j == <span class="number">0</span> ? <span class="number">0</span>:dp[i][j<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> maxColum = col;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span> &amp;&amp; dp[k][j] &gt; <span class="number">0</span>; --k)&#123;</span><br><span class="line">                    maxColum = min(maxColum,dp[k][j]);</span><br><span class="line">                    ans += maxColum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5455-最多-K-次交换相邻数位后得到的最小整数"><a href="#5455-最多-K-次交换相邻数位后得到的最小整数" class="headerlink" title="5455. 最多 K 次交换相邻数位后得到的最小整数"></a>5455. 最多 K 次交换相邻数位后得到的最小整数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>num</code>和一个整数 <code>k</code>。其中，<code>num</code>表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 数位 。</p><p>你可以交换这个整数相邻数位的数字 最多 <code>k</code>次。</p><p>请你返回你能得到的最小整数，并以字符串形式返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"4321"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"1342"</span></span><br><span class="line">解释：<span class="number">4321</span> 通过 <span class="number">4</span> 次交换相邻数位得到最小整数的步骤如上图所示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"100"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"010"</span></span><br><span class="line">解释：输出可以包含前导 <span class="number">0</span> ，但输入保证不会有前导 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">num</span> = <span class="string">"36789"</span>, <span class="attr">k</span> = <span class="number">1000</span></span><br><span class="line">输出：<span class="string">"36789"</span></span><br><span class="line">解释：不需要做任何交换。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">num</span> = <span class="string">"22"</span>, <span class="attr">k</span> = <span class="number">22</span></span><br><span class="line">输出：<span class="string">"22"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">num</span> = <span class="string">"9438957234785635408"</span>, <span class="attr">k</span> = <span class="number">23</span></span><br><span class="line">输出：<span class="string">"0345989723478563548"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 30000</code></li><li><code>num</code> 只包含 数字 且不含有 前导 <code>0</code> 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目本身用暴力法很简单，只需要在当前数位<code>i</code>后的<code>k</code>个位置内找到比<code>num[i]</code>小的最小数即可，然后交换，并同时将数位往后移动即可。这个题目确实是个高质量的好题，需要仔细思考和思索，但是遇到这类题目往往都歇菜，需要<code>ACM</code>经验的人，需要对<code>segmentTree</code>应用非常熟悉才可以。</li><li>我们可以以公式代替：<script type="math/tex; mode=display">num[i] = min(num[j]_{j=i+1}^{min(i+k,n-1)})</script>即在连续的k个位置中找到最小的num[i]。</li><li>这题的难点在于找到<code>num[i]</code>后续<code>K</code>位内的目标数<code>num[j]</code>以后,需要对<code>(i+1,j-1)</code>都需要将其索引往后移动一位，这点如何在线性时间复杂度内完成，是完成本题的关键。<br>如图<img src="https://mike-box.github.io/images/181-3.png" alt="3">所示，我们的实际移动示意如图所示。</li><li>难点在于segmentTree的使用，需要仔细学习，该题目用的树状数组可以很快解决。，大概是第2次遇到树状数组的题目了。参考这个<a href="https://www.cnblogs.com/findview/archive/2019/08/01/11281628.html" target="_blank" rel="noopener">博客</a>，写的非常明白。定义数组如下：<br><img src="https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png" alt="1"><br>我们知道设原始数组为<code>A[1...n]</code>。则我们新设置数组C如下令：<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">C</span>[<span class="number">1</span>] = <span class="symbol">A</span>[<span class="number">1</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">2</span>] = <span class="symbol">A</span>[<span class="number">1</span>] + <span class="symbol">A</span>[<span class="number">2</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">3</span>] = <span class="symbol">A</span>[<span class="number">3</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">4</span>] = <span class="symbol">A</span>[<span class="number">1</span>] + <span class="symbol">A</span>[<span class="number">2</span>] + <span class="symbol">A</span>[<span class="number">3</span>] + <span class="symbol">A</span>[<span class="number">4</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">5</span>] = <span class="symbol">A</span>[<span class="number">5</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">6</span>] = <span class="symbol">A</span>[<span class="number">5</span>] + <span class="symbol">A</span>[<span class="number">6</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">7</span>] = <span class="symbol">A</span>[<span class="number">7</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">8</span>] = <span class="symbol">A</span>[<span class="number">1</span>] + <span class="symbol">A</span>[<span class="number">2</span>] + <span class="symbol">A</span>[<span class="number">3</span>] + <span class="symbol">A</span>[<span class="number">4</span>] + <span class="symbol">A</span>[<span class="number">5</span>] + <span class="symbol">A</span>[<span class="number">6</span>] + <span class="symbol">A</span>[<span class="number">7</span>] + <span class="symbol">A</span>[<span class="number">8</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>实际可以归纳为：<script type="math/tex; mode=display">C[i] = A[i - 2^{k}+1] + A[i - 2^{k}+2] + ... + A[i] \\C[i] = \sum_{j = i-2^{k}+1}^{i}A[j]</script>另一个关键是，如果我们需要求出前<code>i</code>项的前缀和，这个才是树状数组的精髓，通过上述的推理如何实现？实际仔细分析一下：<br><img src="https://bkimg.cdn.bcebos.com/pic/960a304e251f95ca5e588459cf177f3e660952ab?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="2"><br>给定<code>i</code>,我们如何知道前<code>i</code>项的前缀和由后缀数组的哪几项组成？<br>举两个例子m7和m6（sum(i)表示求编号为i的前缀和）</li></ol><ul><li>m==7 sum(7) = C7 + C6 + C4<br>那么我们是怎么得到编号7是由哪几个C[i]求和得到呢（C4, C6, C7怎么得到的），这里有介绍一种巧妙的方法：<br>对于查询的m，将它转换成二进制后，不断对末尾的1的位置进行-1的操作，直到全部为0停止<br>7的二进制为0111（C7得到），那么先对0111的末尾1的位置-1，得到0110 == 6（C6得到），再对0110末尾1位置-1，得到0100 == 4（C4得到），最后对0100末尾1位置-1后得到0000（结束信号），计算停止，至此C7，C6，C4全部得到，求和后就是m == 7时它的前缀和。</li><li>m==6 sum(6) = C6 + C4<br>m == 6时也是一样，先转成2进制等于0110，经过两次变换后为0100（C4）和0000（结束信号），那么求和后同样也得到了预计的结果</li></ul><script type="math/tex; mode=display">sum[i] = C[i] + C[i-2^{k_{1}}] + C[i-2^{k_{1}}-2^{k_{2}}] + ...+</script><p>即每次将<code>i</code>上低位的1去掉。<br>其中<code>k</code>为数字<code>i</code>最低位连续0的个数。可以通过快速计算得到$2^{k}$.</p><script type="math/tex; mode=display">2^{k} = i\&(-i)</script><p>其中的原因如下：<br>这里利用的负数的存储特性，负数是以补码存储的，对于整数运算 x&amp;(-x)有：<br>● 当x为0时，即 0 &amp; 0，结果为0；<br>●当x为奇数时，最后一个比特位为1，取反加1没有进位，故x和-x除最后一位外前面的位正好相反，按位与结果为0。结果为1。<br>●当x为偶数，且为2的m次方时，x的二进制表示中只有一位是1（从右往左的第m+1位），其右边有m位0，故x取反加1后，从右到左第有m个0，第m+1位及其左边全是1。这样，x&amp; (-x) 得到的就是x。<br>●当x为偶数，却不为2的m次方的形式时，可以写作x= y * (2^k)。其中，y的最低位为1。实际上就是把x用一个奇数左移k位来表示。这时，x的二进制表示最右边有k个0，从右往左第k+1位为1。当对x取反时，最右边的k位0变成1，第k+1位变为0；再加1，最右边的k位就又变成了0，第k+1位因为进位的关系变成了1。左边的位因为没有进位，正好和x原来对应的位上的值相反。二者按位与，得到：第k+1位上为1，左边右边都为0。结果为2^k。<br>总结一下：x&amp;(-x)，当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。以代码形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>知道了以上基层我们可以通过树状数组干很多事情，最重要的即为可以进行区间求合和查询。比如加我们在数组中的某个数更新了<code>num</code>.则我们只需要向上跟新即可，即更新<code>arr[i]</code>的父节点即可, 我们向上循环查找它的父节点，即每次加上<code>lowbit</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span>&#123;    <span class="comment">//在i位置加上k</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        c[i] += k;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如何求该数组的前<code>i</code>项的前缀和？我们不断的减去<code>i</code>的最低位<code>1</code>即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;        <span class="comment">//求A[1 - i]的和</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        res += c[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>假设求区间[i,j]的和，则我们可以利用两个前缀和的组合实现即可。<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="name">i</span>,j) = getsum(<span class="name">j</span>) - getsum(<span class="name">i-1</span>)</span><br></pre></td></tr></table></figure></li><li>区间更新如何实现？</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ul><li>暴力<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minInteger</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = 0; i &lt; n &amp;&amp; k &gt; <span class="number">0</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n &amp;&amp; j &lt;= i + k; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] &lt; num[t])&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = num[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j &gt; i; --j)&#123;</span><br><span class="line">                num[j] = num[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            num[i] = c;</span><br><span class="line">            k -= t - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>SegmentTree<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) &#123;</span><br><span class="line">        ret += c[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minInteger</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; pos(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'0'</span>;</span><br><span class="line">            pos[x].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; pick(n);</span><br><span class="line">        fill(c, c + N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) add(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (m) &#123;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos[k].empty()) <span class="keyword">continue</span>;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="string">'0'</span> + k);</span><br><span class="line">                <span class="keyword">int</span> x = pos[k].front();</span><br><span class="line">                <span class="keyword">int</span> cnt = query(x);</span><br><span class="line">                <span class="keyword">if</span> (m &gt;= cnt) &#123;</span><br><span class="line">                    m -= cnt;</span><br><span class="line">                    add(x + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                    ret += c;</span><br><span class="line">                    pick[x] = <span class="literal">true</span>;</span><br><span class="line">                    pos[k].pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!found) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pick[i]) ret += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minInteger</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pqs stores the location of each digit.</span></span><br><span class="line">        List&lt;Queue&lt;Integer&gt;&gt; pqs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            pqs.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); ++i) &#123;</span><br><span class="line">            pqs.get(num.charAt(i) - <span class="string">'0'</span>).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = <span class="string">""</span>;</span><br><span class="line">        SegmentTree seg = <span class="keyword">new</span> SegmentTree(num.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); ++i) &#123;</span><br><span class="line">            <span class="comment">// At each location, try to place 0....9</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt;= <span class="number">9</span>; ++digit) &#123;</span><br><span class="line">                <span class="comment">// is there any occurrence of digit left?</span></span><br><span class="line">                <span class="keyword">if</span> (pqs.get(digit).size() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// yes, there is a occurrence of digit at pos</span></span><br><span class="line">                    Integer pos = pqs.get(digit).peek();</span><br><span class="line"><span class="comment">// Since few numbers already shifted to left, this `pos` might be outdated.</span></span><br><span class="line">                    <span class="comment">// we try to find how many number already got shifted that were to the left of pos.</span></span><br><span class="line">                    <span class="keyword">int</span> shift = seg.getCountLessThan(pos);</span><br><span class="line">                    <span class="comment">// (pos - shift) is number of steps to make digit move from pos to i.</span></span><br><span class="line">                    <span class="keyword">if</span> (pos - shift &lt;= k) &#123;</span><br><span class="line">                        k -= pos - shift;</span><br><span class="line">                        seg.add(pos); <span class="comment">// Add pos to our segment tree.</span></span><br><span class="line">                        pqs.get(digit).remove();</span><br><span class="line">                        ans += digit;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nodes;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span> * (max)];</span><br><span class="line">            n = max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            addUtil(num, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addUtil</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; l || num &gt; r) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                nodes[node]++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            addUtil(num, l, mid, <span class="number">2</span> * node + <span class="number">1</span>);</span><br><span class="line">            addUtil(num, mid + <span class="number">1</span>, r, <span class="number">2</span> * node + <span class="number">2</span>);</span><br><span class="line">            nodes[node] = nodes[<span class="number">2</span> * node + <span class="number">1</span>] + nodes[<span class="number">2</span> * node + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Essentialy it tells number of numbers &lt; num.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCountLessThan</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getUtil(<span class="number">0</span>, num, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getUtil</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (qr &lt; l || ql &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">return</span> nodes[node];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> getUtil(ql, qr, l, mid, <span class="number">2</span> * node + <span class="number">1</span>) + getUtil(ql, qr, mid + <span class="number">1</span>, r, <span class="number">2</span> * node + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;196周比赛&quot;&gt;&lt;a href=&quot;#196周比赛&quot; class=&quot;headerlink&quot; title=&quot;196周比赛&quot;&gt;&lt;/a&gt;196周比赛&lt;/h1&gt;&lt;p&gt;对于我这种菜鸟级别的选手来说，感觉题目还是挺难的，&lt;code&gt;hard&lt;/code&gt;题目依旧不会做。只能说自己是个勤奋的人，但不是个聪明的人。&lt;/p&gt;&lt;h2 id=&quot;5452-判断能否形成等差数列&quot;&gt;&lt;a href=&quot;#5452-判断能否形成等差数列&quot; class=&quot;headerlink&quot; title=&quot;5452. 判断能否形成等差数列&quot;&gt;&lt;/a&gt;5452. 判断能否形成等差数列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数字数组 &lt;code&gt;arr&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。&lt;/p&gt;&lt;p&gt;如果可以重新排列数组形成等差数列，请返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2020年下半年计划（7月）</title>
    <link href="http://yoursite.com/2020/07/05/177/"/>
    <id>http://yoursite.com/2020/07/05/177/</id>
    <published>2020-07-05T14:36:53.225Z</published>
    <updated>2020-07-08T09:51:59.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020年全年计划"><a href="#2020年全年计划" class="headerlink" title="2020年全年计划"></a>2020年全年计划</h1><p>2020年已经过完半年，还有许多目标并未达成，希望自己能够快速的反思和反省自己。以下为2020年下半年的计划总结和全年总结，希望自己能够达成全年目标。通过量化的列举自己的目标和计划来督促自己的年度计划实现。</p><h3 id="个人学习计划"><a href="#个人学习计划" class="headerlink" title="个人学习计划"></a>个人学习计划</h3><h4 id="书籍阅读计划"><a href="#书籍阅读计划" class="headerlink" title="书籍阅读计划"></a>书籍阅读计划</h4><p>今年计划完完成阅读书籍20本，目前已经阅读大概5本左右，几年阅读量严重不达标，不知道是因为工作忙的原因还是因为哪些原因导致阅读量不够，需要继续督促自己完成年度目标任务和计划。列表如下：</p><a id="more"></a><div class="table-container"><table><thead><tr><th>序号</th><th>书籍名称</th><th>进度</th><th>种类</th></tr></thead><tbody><tr><td>1</td><td>少有人走的路</td><td>90%</td><td>心理学相关</td></tr><tr><td>2</td><td>人性的幽微</td><td>100%</td><td>心理学与个人成长相关</td></tr><tr><td>3</td><td>睡眠革命</td><td>100%</td><td>个人习惯养成</td></tr><tr><td>4</td><td>每周工作4小时</td><td>20%</td><td>个人成长系列</td></tr><tr><td>5</td><td>佐贺的超级阿嬷</td><td>100%</td><td>个人纪实成长</td></tr><tr><td>6</td><td>郭鹤年自传</td><td>100%</td><td>个人自传</td></tr><tr><td>7</td><td>自私的基因</td><td>%</td><td></td></tr><tr><td>8</td><td>爱弥儿</td><td>%</td><td></td></tr><tr><td>9</td><td>李光耀观天下</td><td>%</td><td></td></tr><tr><td>10</td><td>金字塔原理</td><td>%</td><td></td></tr><tr><td>11</td><td>怎样解题</td><td>%</td><td></td></tr><tr><td>12</td><td>火与烬</td><td>%</td><td></td></tr><tr><td>13</td><td>人类简史</td><td>%</td><td></td></tr><tr><td>14</td><td>从0到无穷大</td><td>%</td><td></td></tr><tr><td>15</td><td>走出自己的天空</td><td>100%</td><td></td></tr><tr><td>16</td><td></td><td>%</td><td></td></tr><tr><td>17</td><td></td><td>%</td><td></td></tr><tr><td>18</td><td></td><td>%</td><td></td></tr><tr><td>19</td><td></td><td>%</td><td></td></tr><tr><td>20</td><td></td><td>%</td></tr></tbody></table></div><h4 id="课程学习计划"><a href="#课程学习计划" class="headerlink" title="课程学习计划"></a>课程学习计划</h4><p>今年的课程学习我想主要以公开课相关课程学习，计划今年要学习20门以上公开课学习。计划学习人文类的课程和计算机技术的相关课程，以下是大概今年的30门课程计划，计划列表如下，以后每个月会定时更新自己的进度。</p><div class="table-container"><table><thead><tr><th>序号</th><th>课程名称</th><th>进度</th><th>类别</th><th>完成时间</th></tr></thead><tbody><tr><td>1</td><td>Learning How to Learn: Powerful mental tools to help you master tough subjects</td><td>100%</td><td>人文社科类</td><td>2020.1</td></tr><tr><td>2</td><td>algorithmic-toolbox</td><td>100%</td><td>computer scinece</td><td>2020.5</td></tr><tr><td>3</td><td>algorithms-on-strings</td><td>100%</td><td>computer scinece</td><td>2020.4</td></tr><tr><td>4</td><td>algorithms-on-graphs</td><td>100%</td><td>computer scinece</td><td>2020.5</td></tr><tr><td>5</td><td>algorithms-part2</td><td>100%</td><td>computer scinece</td><td>2020.3</td></tr><tr><td>6</td><td>data-structures</td><td>100%</td><td>computer scinece</td><td>2020.6</td></tr><tr><td>7</td><td>algorithms-part1</td><td>100%</td><td>computer scinece</td><td>2020.3</td></tr><tr><td>8</td><td>programming-languages partA</td><td>100%</td><td>computer scinece</td><td>2020.6</td></tr><tr><td>9</td><td>programming-languages partB</td><td>30%</td><td>computer scinece</td><td></td></tr><tr><td>10</td><td>programming-languages partC</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>11</td><td>Build a Modern Computer from First Principles: From Nand to Tetris I</td><td>62%</td><td>computer scinece</td><td>2020.7.5</td></tr><tr><td>12</td><td>Build a Modern Computer from First Principles: From Nand to Tetris II</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>13</td><td>Machine-learning-techniques</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>14</td><td>Machine Learning Foundations</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>15</td><td>哈佛大学公开课: 学习失败碎剪</td><td>0%</td><td></td><td></td></tr><tr><td>16</td><td>哈佛大学公开课：立大志</td><td>0%</td><td></td><td></td></tr><tr><td>17</td><td>哈佛大学公开课：领袖心理学</td><td>0%</td><td></td><td></td></tr><tr><td>18</td><td>哈佛大学公开课：科学与烹饪</td><td>0%</td><td></td><td></td></tr><tr><td>19</td><td>哈佛大学公开课：积极心理学碎剪</td><td>0%</td><td></td><td></td></tr><tr><td>20</td><td>哈佛大学公开课：幸福课</td><td>0%</td><td></td><td></td></tr><tr><td>21</td><td>MIT 6.82 opertion system</td><td>0%</td><td></td><td></td></tr><tr><td>22</td><td>MIT 6.824 distribution System</td><td>0%</td><td></td><td></td></tr><tr><td>23</td><td>MIT DatabaseT Systems:</td><td>0%</td><td></td><td></td></tr><tr><td>24</td><td>MIT Advances in Computer Vision</td><td>0%</td><td></td><td></td></tr><tr><td>25</td><td>Javascript</td><td>0%</td><td></td><td></td></tr><tr><td>26</td><td>TensorFlow in Practice</td><td>0%</td><td></td><td></td></tr><tr><td>27</td><td>MIT:  Structure and Interpretation of Computer Programs</td><td>0%</td><td></td><td></td></tr><tr><td>28</td><td>Princeton : An Introduction to the Analysis of Algorithms</td><td>0%</td><td></td><td></td></tr><tr><td>29</td><td>MIT 6.851</td><td>0%</td><td></td><td></td></tr><tr><td>30</td><td>MIT Multicore Programming Primer</td><td>0%</td><td></td></tr></tbody></table></div><h4 id="考证认证"><a href="#考证认证" class="headerlink" title="考证认证"></a>考证认证</h4><ul><li>完成雅思认证</li><li>完成GRE认证</li><li>完成SAT考试<h4 id="刷题计划"><a href="#刷题计划" class="headerlink" title="刷题计划"></a>刷题计划</h4></li></ul><p>　　仔细看了许多所谓的刷题平台，实际上感觉单纯的枯燥的刷题实在是对进步不大，因为单纯的刷题很容易让人产生枯燥和烦躁的感觉，因为只有自己孤单一个人刷题，遇到问题也没有人跟你一起讨论，一起想解决办法。<br>　　我觉得CP练习的最好方式就是以考代练，先过一遍基础的理论和基础的题目，然后通过不断的参加定期的contest练习，反思的思考，跟他人讨论，总结，反馈，我觉得这样才是进步较快，一方面能够避免单纯刷题的枯燥；另一方面通过参加contest，适当的能够提高自己的紧张感觉，强迫自己思考的快速；第三，因为contest结束之后都有很多人参与一起讨论问题的解法，可以快速的学习他人的解题思路和方法，与高手交流才能快速进步；第四，contest都是定期举行，可以非常有效的防止刷题的偷懒，强迫自己定期的练习和提高，给人以监督感。以上四点我认为是<code>contest</code>作为练习的最大有点。在youtube上看到几个牛人都是定期参加各自<code>contest</code>，来保持自己的水平。<br>　　总和看来，我觉得以下三个平台适合新手难度的平台，<code>leetcode</code>适合程序员面试，<code>Atcoder</code>和<code>codeforces</code> 适合<code>CP</code>初级选手练习，上面有许多非常好的题目和牛人，是一个值得终身去学习和跟随的平台。特别是强调的是，这三个平台的社区都运营的很好，在上面能够碰到许多牛人，能够跟大牛一起讨论学习进步，学习他们的解题思路，学习他们的学习方法，这才是最关键的。</p><ul><li><strong>Leetcode contest</strong></li></ul><div class="table-container"><table><thead><tr><th>index</th><th>contest</th><th>sloveed</th><th>Rank</th><th>review</th></tr></thead><tbody><tr><td>1</td><td>contest 194</td><td>3</td><td>101</td><td>yes</td></tr><tr><td>2</td><td>biweekly contest 29</td><td>3</td><td>275</td><td>yes</td></tr><tr><td>3</td><td>contest 195</td><td>3</td><td>195</td><td>yes</td></tr><tr><td>4</td><td>contest 196</td><td>2</td><td>2138</td><td>yes</td></tr><tr><td>5</td><td>biweekly contest 30</td><td></td><td></td><td></td></tr><tr><td>6</td><td>contest 197</td><td></td><td></td><td></td></tr><tr><td>7</td><td>contest 198</td><td></td><td></td><td></td></tr><tr><td>8</td><td>biweekly contest 31</td><td></td><td></td><td></td></tr><tr><td>9</td><td>contest 199</td><td></td><td></td><td></td></tr><tr><td>10</td><td>contest 200</td><td></td><td></td></tr></tbody></table></div><ul><li><strong>Codeforces contest</strong></li></ul><div class="table-container"><table><thead><tr><th>index</th><th>contest</th><th>sloveed</th><th>Rank</th><th>review</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><strong>Atbeginner contest</strong></li></ul><div class="table-container"><table><thead><tr><th>index</th><th>contest</th><th>sloveed</th><th>Rank</th><th>review</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></div><h3 id="个人理财计划"><a href="#个人理财计划" class="headerlink" title="个人理财计划"></a>个人理财计划</h3><ul><li><strong>积蓄</strong></li><li><strong>基金</strong></li><li><strong>美股投资</strong></li><li><strong>平台</strong></li></ul><h3 id="个人健康计划"><a href="#个人健康计划" class="headerlink" title="个人健康计划"></a>个人健康计划</h3><ul><li>游泳计划</li><li>健身计划</li></ul><h3 id="个人家庭计划"><a href="#个人家庭计划" class="headerlink" title="个人家庭计划"></a>个人家庭计划</h3><ul><li>放假计划安排</li><li>出游计划安排</li><li>儿女学习安排</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2020年全年计划&quot;&gt;&lt;a href=&quot;#2020年全年计划&quot; class=&quot;headerlink&quot; title=&quot;2020年全年计划&quot;&gt;&lt;/a&gt;2020年全年计划&lt;/h1&gt;&lt;p&gt;2020年已经过完半年，还有许多目标并未达成，希望自己能够快速的反思和反省自己。以下为2020年下半年的计划总结和全年总结，希望自己能够达成全年目标。通过量化的列举自己的目标和计划来督促自己的年度计划实现。&lt;/p&gt;&lt;h3 id=&quot;个人学习计划&quot;&gt;&lt;a href=&quot;#个人学习计划&quot; class=&quot;headerlink&quot; title=&quot;个人学习计划&quot;&gt;&lt;/a&gt;个人学习计划&lt;/h3&gt;&lt;h4 id=&quot;书籍阅读计划&quot;&gt;&lt;a href=&quot;#书籍阅读计划&quot; class=&quot;headerlink&quot; title=&quot;书籍阅读计划&quot;&gt;&lt;/a&gt;书籍阅读计划&lt;/h4&gt;&lt;p&gt;今年计划完完成阅读书籍20本，目前已经阅读大概5本左右，几年阅读量严重不达标，不知道是因为工作忙的原因还是因为哪些原因导致阅读量不够，需要继续督促自己完成年度目标任务和计划。列表如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人计划" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>为什么要学习著名大学的Open Course</title>
    <link href="http://yoursite.com/2020/07/05/176/"/>
    <id>http://yoursite.com/2020/07/05/176/</id>
    <published>2020-07-04T23:51:36.928Z</published>
    <updated>2020-07-04T23:51:42.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要学习国外大学的公开课"><a href="#为什么要学习国外大学的公开课" class="headerlink" title="为什么要学习国外大学的公开课"></a>为什么要学习国外大学的公开课</h2><p>今年的课程学习我想主要以公开课相关课程学习，计划今年要学习20门以上公开课学习。为什么要学习大学的公开课，因为目前市面上许多课程的深度和难度不够，我仔细研究和分析了一下，发现世界著名大学的公开课的质量是最好的，为什么它的质量最好：</p><h3 id="1-学习深度较好"><a href="#1-学习深度较好" class="headerlink" title="1. 学习深度较好"></a>1. 学习<strong>深度较好</strong></h3><p>不愧为世界知名学府，很多课程的深度很好，理论性讲解的特别深入，不像市面上许多XX课程只是浮在表面，告诉你该怎么做，但是从来没有告诉你为什么这样做，以及这样做到底有什么好处，这是我选择国外公开课课程作为我主要学习的内容的重要原因之一。目前市面上到处充斥着XX技术解密，XX工程实践，绝大部分都是浮在表面讲使用知识，并没有深入到理论中。<br>我也曾经在所谓的极客时间上付费买过一些课程，学了一两个课程以后，就全部扔到角落里，实在是提不起来兴趣。但是现在再仔细回想起来，这些本来就是营销，所谓的知识付费可能就是一个XX骗局。每个XX课程的特点是起一个很高大上和很流行的技术名称，让人觉得是XX技术热点，然后挂一个技术履历和学历都看似很鲜亮的成功人士简介，然人觉得似乎很高大上，吸引众多刚入门的”小学生”们乖乖上缴智商税。这些所谓的XX课程最大的问题是绝大部分都是所谓的工作经验总结，缺少背后的理论支持，所谓的课程也绝大部分都是文字课程，文字课程的自主学习效率是最低的，因为没有互动性，另一方面这些许多课程的练习和project都没有提供一个正确的评价系统，许多课程只是简单的学习完成了，并没有一个明确的评价标准以检验自己到底有没有正在的掌握这些知识，课程练习题目也没有给出正确的参考答案，缺少作业设计。计算机这门科学是一门实践性较强的课程，“show me the code，talk is cheap”，只有通过扎实的project或者exam才能真正的掌握一门知识或者理论。</p><a id="more"></a><h3 id="2-知识正确性"><a href="#2-知识正确性" class="headerlink" title="2.知识正确性"></a>2.<strong>知识正确性</strong></h3><p>“授之以鱼，不如授之以渔”。没有正确的知识，。却发现部分课程中许多地方错误百出，漏洞百出，可能许多所谓的课程作者自己都没有搞清楚许多细节，难免误导学习者。比如我上过《工业界的python实践》这门课程，作者上来就讲一达通看似很高大上的python的高级特性，却从来没有从读者的角度来思考很多语言学的问题和背后这样设计的原理和思考，感觉就是python的高级特性介绍，学这些东西真心不如自己看“python guide”。毫不客气的说，许多著名大学的课程绝大部分都由该领域的资深教授来讲解，他们的理论深度和知识的正确性几乎可以不容置疑。随着年龄的增长，我越来越喜欢探索许多技术和知识背后的数学理论和历史发展来源问题，利用数学这个工具来理解和分析许多行业知识，当然也越来越体会到数学的重要性。长期的坚持“正确”的知识学习，才能带来事半功倍的效果，如果知识的源头或者接受的信息都错误了，那带来的后果是必然在学习的道路上越走越远。</p><h3 id="3-好的project"><a href="#3-好的project" class="headerlink" title="3. 好的project"></a>3. 好的<strong>project</strong></h3><p>我特别喜欢著名大学的课程的重要原因之一是绝大部分计算机课程都带有非常好的<code>project</code>资源，绝大部分的<code>project</code>难度非常高，感觉比许多真实的<code>project</code>的难度都高，因为在国内绝大部分的工作都不需要像这些课程里面讲解的重新造一遍难度很高轮子，商业公司里面绝大部分都是重复利用这些已经做好的基础轮子技术，大部分商业公司把自己的技术都聚焦在商业业务实践上。实际上这些大学的许多project非常具有含金量的，通过完成这些非常<code>tough</code>的project，对自己的思维提升非常好，对于背后的原理知识掌握非常好。曾经遇到过几个project，从题目都看不懂到最后完成达到100%的testcase全过，那种愉悦感是工作中的某些<code>crond</code>体会不到的，还记得学习<code>princeton</code>算法课程中的几个project,从一开始连最基本的java语法都不知道，到最后掌握基本的<code>java</code>语法，并且最后因为。现在每次选择公开课时，一定要选择哪些带有非常好的且评价很高的<code>project</code>越来学习。另一方面通过这些难度很高的project，你需要自己去找资料找到这些问题的解决方法，要么去网上搜索相关论文，要么在论坛求助，要么查找书籍，要么可以在<code>youtube</code>上搜索相关知识视频学习，要么自己的深入思考，通过这些<code>tough</code>的project的锻炼非常提高你的<code>problem sloving</code>能力，其实这跟<code>compective programing</code>的锻炼的能力相似，非常锻炼自己独立思考问题的能力。</p><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><p>非常推荐常见的公开课学习平台：</p><ol><li>coursera：(<a href="https://www.coursera.org/" target="_blank" rel="noopener">https://www.coursera.org/</a>)</li><li>ocw:(<a href="https://ocw.mit.edu/" target="_blank" rel="noopener">https://ocw.mit.edu/</a>)</li><li>网易公开课:(<a href="http://open.163.com/" target="_blank" rel="noopener">http://open.163.com/</a>)</li><li>可汗学院：(<a href="https://www.khanacademy.org/" target="_blank" rel="noopener">https://www.khanacademy.org/</a>)</li><li>openedx: (<a href="https://open.edx.org/" target="_blank" rel="noopener">https://open.edx.org/</a>)</li><li>cmu:(<a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx" target="_blank" rel="noopener">https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx</a>)</li><li>cmu lab:(<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">http://csapp.cs.cmu.edu/3e/labs.html</a>)</li><li>archive: (<a href="https://archive.org/search.php?query=subject%3A%22UC+Berkeley%22" target="_blank" rel="noopener">https://archive.org/search.php?query=subject%3A%22UC+Berkeley%22</a>)</li><li>SCIP:(<a href="https://github.com/DeathKing/Learning-SICP" target="_blank" rel="noopener">https://github.com/DeathKing/Learning-SICP</a>)</li><li>UCbreakly : (<a href="http://webcast.berkeley.edu/" target="_blank" rel="noopener">http://webcast.berkeley.edu/</a>)</li><li>UW : (<a href="https://courses.cs.washington.edu/courses/cse421/06au/" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse421/06au/</a>)</li><li>UW ：(<a href="https://courses.cs.washington.edu/courses/cse341/13sp/#lectures" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse341/13sp/#lectures</a>)</li><li>UCSD : (<a href="https://podcast.ucsd.edu/default.aspx" target="_blank" rel="noopener">https://podcast.ucsd.edu/default.aspx</a>)</li><li>Youtube : (<a href="https://www.youtube.com/" target="_blank" rel="noopener">https://www.youtube.com/</a>)<br>当然这些以上这些绝大部分都需要翻墙才能观看和学习，推荐一个翻墙软件，发条云：(<a href="http://www.fatiaoyun.live/aff.php?aff=15540)，这个翻墙软件比较稳定，需要付费，大概一年也就不到200块钱，每个月50G的流量，其实足够个人学习应用了，youtube流畅毫无压力。" target="_blank" rel="noopener">http://www.fatiaoyun.live/aff.php?aff=15540)，这个翻墙软件比较稳定，需要付费，大概一年也就不到200块钱，每个月50G的流量，其实足够个人学习应用了，youtube流畅毫无压力。</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要学习国外大学的公开课&quot;&gt;&lt;a href=&quot;#为什么要学习国外大学的公开课&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习国外大学的公开课&quot;&gt;&lt;/a&gt;为什么要学习国外大学的公开课&lt;/h2&gt;&lt;p&gt;今年的课程学习我想主要以公开课相关课程学习，计划今年要学习20门以上公开课学习。为什么要学习大学的公开课，因为目前市面上许多课程的深度和难度不够，我仔细研究和分析了一下，发现世界著名大学的公开课的质量是最好的，为什么它的质量最好：&lt;/p&gt;&lt;h3 id=&quot;1-学习深度较好&quot;&gt;&lt;a href=&quot;#1-学习深度较好&quot; class=&quot;headerlink&quot; title=&quot;1. 学习深度较好&quot;&gt;&lt;/a&gt;1. 学习&lt;strong&gt;深度较好&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;不愧为世界知名学府，很多课程的深度很好，理论性讲解的特别深入，不像市面上许多XX课程只是浮在表面，告诉你该怎么做，但是从来没有告诉你为什么这样做，以及这样做到底有什么好处，这是我选择国外公开课课程作为我主要学习的内容的重要原因之一。目前市面上到处充斥着XX技术解密，XX工程实践，绝大部分都是浮在表面讲使用知识，并没有深入到理论中。&lt;br&gt;我也曾经在所谓的极客时间上付费买过一些课程，学了一两个课程以后，就全部扔到角落里，实在是提不起来兴趣。但是现在再仔细回想起来，这些本来就是营销，所谓的知识付费可能就是一个XX骗局。每个XX课程的特点是起一个很高大上和很流行的技术名称，让人觉得是XX技术热点，然后挂一个技术履历和学历都看似很鲜亮的成功人士简介，然人觉得似乎很高大上，吸引众多刚入门的”小学生”们乖乖上缴智商税。这些所谓的XX课程最大的问题是绝大部分都是所谓的工作经验总结，缺少背后的理论支持，所谓的课程也绝大部分都是文字课程，文字课程的自主学习效率是最低的，因为没有互动性，另一方面这些许多课程的练习和project都没有提供一个正确的评价系统，许多课程只是简单的学习完成了，并没有一个明确的评价标准以检验自己到底有没有正在的掌握这些知识，课程练习题目也没有给出正确的参考答案，缺少作业设计。计算机这门科学是一门实践性较强的课程，“show me the code，talk is cheap”，只有通过扎实的project或者exam才能真正的掌握一门知识或者理论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人学习" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="个人学习" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 195周周赛</title>
    <link href="http://yoursite.com/2020/06/28/175/"/>
    <id>http://yoursite.com/2020/06/28/175/</id>
    <published>2020-06-28T13:58:44.283Z</published>
    <updated>2020-06-28T13:58:51.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="195周比赛"><a href="#195周比赛" class="headerlink" title="195周比赛"></a>195周比赛</h1><p><img src="https://mike-box.github.io/images/178-1.png" alt="1"><br>本周周赛时系统出了故障导致一直出问题，还是同样的三题选手，最后一道题目不会做。</p><h2 id="5448-判断路径是否相交"><a href="#5448-判断路径是否相交" class="headerlink" title="5448. 判断路径是否相交"></a>5448. 判断路径是否相交</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>path</code>，其中 <code>path[i]</code>的值可以是<code>&#39;N&#39;、&#39;S&#39;、&#39;E&#39;</code>或者 <code>&#39;W&#39;</code>，分别表示向北、向南、向东、向西移动一个单位。</p><a id="more"></a><p>机器人从二维平面上的原点 <code>(0, 0)</code>处开始出发，按 <code>path</code>所指示的路径行走。</p><p>如果路径在任何位置上出现相交的情况，也就是走到之前已经走过的位置，请返回 <code>True</code> ；否则，返回 <code>False</code>。</p><p>示例 1：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">path</span> = <span class="string">"NES"</span></span><br><span class="line">输出：<span class="literal">false</span> </span><br><span class="line">解释：该路径没有在任何位置相交。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">path</span> = <span class="string">"NESWW"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：该路径经过原点两次。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= path.length &lt;= 10^4</li><li>path 仅由 {‘N’, ‘S’, ‘E’, ‘W} 中的字符组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/path-crossing" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-crossing</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力hash</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中明确说了每次只走一步，所以我们直接保存已经走过的痕迹，然后用set直接查询即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPathCrossing</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        cnt.insert(make_pair(x,y));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : path)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'N'</span>)&#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'S'</span>)&#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'E'</span>)&#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'W'</span>)&#123;</span><br><span class="line">                x--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(make_pair(x,y))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            cnt.insert(make_pair(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5449-检查数组对是否可以被-k-整除"><a href="#5449-检查数组对是否可以被-k-整除" class="headerlink" title="5449. 检查数组对是否可以被 k 整除"></a>5449. 检查数组对是否可以被 k 整除</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code>和一个整数 <code>k</code> ，其中数组长度是偶数，值为 <code>n</code>。</p><p>现在需要把数组恰好分成<code>n / 2</code>对，以使每对数字的和都能够被 k 整除。</p><p>如果存在这样的分法，请返回 <code>True</code> ；否则，返回 <code>False</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], k = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：划分后的数字对为 (<span class="number">1</span>,<span class="number">9</span>),(<span class="number">2</span>,<span class="number">8</span>),(<span class="number">3</span>,<span class="number">7</span>),(<span class="number">4</span>,<span class="number">6</span>) 以及 (<span class="number">5</span>,<span class="number">10</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], k = <span class="number">7</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：划分后的数字对为 (<span class="number">1</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>) 以及 (<span class="number">3</span>,<span class="number">4</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], k = <span class="number">10</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法在将数组中的数字分为三对的同时满足每对数字和能够被 <span class="number">10</span> 整除的条件。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">-10</span>,<span class="number">10</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">3</span>,<span class="number">-4</span>,<span class="number">4</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>arr.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>n</code> 为偶数</li><li><code>-10^9 &lt;= arr[i] &lt;= 10^9</code></li><li><code>1 &lt;= k &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 取模</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>统计数组中所有的数对k取模的结果x，再比较<code>x</code>的数目是否与<code>k-x</code>的数目是否相等即可。</li><li>因为在实际的分组中，只有余数为<code>x</code>的数与余数为<code>k-x</code>的数才能组成符合条件的一对数。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canArrange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(k,<span class="number">0</span>);        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : arr)&#123;</span><br><span class="line">            cnt[(v%k + k)%k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>]%<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (k/<span class="number">2</span>); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] != cnt[k-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5450-满足条件的子序列数目"><a href="#5450-满足条件的子序列数目" class="headerlink" title="5450. 满足条件的子序列数目"></a>5450. 满足条件的子序列数目</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code>。</p><p>请你统计并返回 <code>nums</code>中能满足其最小元素与最大元素的 和 小于或等于 <code>target</code> 的 非空 子序列的数目。</p><p>由于答案可能很大，请将结果对 <code>10^9 + 7</code>取余后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">9</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有 <span class="number">4</span> 个子序列满足该条件。</span><br><span class="line">[<span class="number">3</span>] -&gt; 最小元素 + 最大元素 &lt;= target (<span class="number">3</span> + <span class="number">3</span> &lt;= <span class="number">9</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">5</span>] -&gt; (<span class="number">3</span> + <span class="number">5</span> &lt;= <span class="number">9</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] -&gt; (<span class="number">3</span> + <span class="number">6</span> &lt;= <span class="number">9</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>] -&gt; (<span class="number">3</span> + <span class="number">6</span> &lt;= <span class="number">9</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：有 <span class="number">6</span> 个子序列满足该条件。（nums 中可以有重复数字）</span><br><span class="line">[<span class="number">3</span>] , [<span class="number">3</span>] , [<span class="number">3</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">6</span>] , [<span class="number">3</span>,<span class="number">6</span>] , [<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">12</span></span><br><span class="line">输出：<span class="number">61</span></span><br><span class="line">解释：共有 <span class="number">63</span> 个非空子序列，其中 <span class="number">2</span> 个不满足条件（[<span class="number">6</span>,<span class="number">7</span>], [<span class="number">7</span>]）</span><br><span class="line">有效序列总数为（<span class="number">63</span> - <span class="number">2</span> = <span class="number">61</span>）</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>], target = <span class="number">16</span></span><br><span class="line">输出：<span class="number">127</span></span><br><span class="line">解释：所有非空子序列都满足条件 (<span class="number">2</span>^<span class="number">7</span> - <span class="number">1</span>) = <span class="number">127</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li><li><code>1 &lt;= target &lt;= 10^6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序 + 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>排序即可，每次找到以<code>nums[i]</code>为最小值的子序列数目。</li><li>利用二分查找找到子序列的最右端即可，则以<code>nums[i]</code>为最小值起点，且最大长度为<code>k</code>的子序列的数目为:<script type="math/tex; mode=display">count_{i} = 2^{k-1}</script></li><li>总的数目即为：<script type="math/tex; mode=display">sum = \sum_{i=1}^{n}2^{len(i)}</script></li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; pow2(<span class="number">100001</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; ++i)&#123;</span><br><span class="line">            pow2[i] = curr;</span><br><span class="line">            curr = (curr*<span class="number">2</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = upper_bound(nums.begin(),nums.end(),target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it == nums.begin()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((--it) &lt; (nums.begin() + i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = it - (nums.begin()+i);</span><br><span class="line">            ans = (ans + pow2[len])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5451-满足不等式的最大值"><a href="#5451-满足不等式的最大值" class="headerlink" title="5451. 满足不等式的最大值"></a>5451. 满足不等式的最大值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>points</code> 和一个整数<code>k</code> 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 <code>x</code> 的值从小到大排序。也就是说 <code>points[i] = [xi, yi]</code>，并且在<code>1 &lt;= i &lt; j &lt;= points.length</code>的前提下， <code>xi &lt; xj</code>总成立。</p><p>请你找出 <code>yi + yj + |xi - xj|</code>的 最大值，其中 <code>|xi - xj| &lt;= k</code> 且 <code>1 &lt;= i &lt; j &lt;= points.length</code>。</p><p>题目测试数据保证至少存在一对能够满足 <code>|xi - xj| &lt;= k</code> 的点。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">10</span>],[<span class="number">6</span>,<span class="number">-10</span>]], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：前两个点满足 |xi - xj| &lt;= <span class="number">1</span> ，带入方程计算，则得到值 <span class="number">3</span> + <span class="number">0</span> + |<span class="number">1</span> - <span class="number">2</span>| = <span class="number">4</span> 。第三个和第四个点也满足条件，得到值 <span class="number">10</span> + <span class="number">-10</span> + |<span class="number">5</span> - <span class="number">6</span>| = <span class="number">1</span> 。</span><br><span class="line">没有其他满足条件的点，所以返回 <span class="number">4</span> 和 <span class="number">1</span> 中最大的那个。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">9</span>,<span class="number">2</span>]], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：只有前两个点满足 |xi - xj| &lt;= <span class="number">3</span> ，带入方程后得到值 <span class="number">0</span> + <span class="number">0</span> + |<span class="number">0</span> - <span class="number">3</span>| = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= points.length &lt;= 10^5</code></li><li><code>points[i].length == 2</code></li><li><code>-10^8 &lt;= points[i][0], points[i][1] &lt;= 10^8</code></li><li><code>0 &lt;= k &lt;= 2 * 10^8</code></li><li>对于所有的<code>1 &lt;= i &lt; j &lt;= points.length</code> ，<code>points[i][0] &lt; points[j][0]</code> 都成立。也就是说，<code>xi</code> 是严格递增的。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/max-value-of-equation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-value-of-equation</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>优先级队列</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>最后一题竟然没有想出来，真的做出来感觉也太简单了点。。。</li><li>实在是思路重要，而不是刷题。拿到一个题目首先分析改用什么算法。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a,pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxValueOfEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : points)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!pq.empty() &amp;&amp; v[<span class="number">0</span>] - pq.top().second &gt; k) pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(!pq.empty())&#123;</span><br><span class="line">                ans = max(ans,v[<span class="number">0</span>] + v[<span class="number">1</span>] + pq.top().first);</span><br><span class="line">            &#125;</span><br><span class="line">            pq.push(make_pair(v[<span class="number">1</span>]-v[<span class="number">0</span>],v[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;195周比赛&quot;&gt;&lt;a href=&quot;#195周比赛&quot; class=&quot;headerlink&quot; title=&quot;195周比赛&quot;&gt;&lt;/a&gt;195周比赛&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://mike-box.github.io/images/178-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周周赛时系统出了故障导致一直出问题，还是同样的三题选手，最后一道题目不会做。&lt;/p&gt;&lt;h2 id=&quot;5448-判断路径是否相交&quot;&gt;&lt;a href=&quot;#5448-判断路径是否相交&quot; class=&quot;headerlink&quot; title=&quot;5448. 判断路径是否相交&quot;&gt;&lt;/a&gt;5448. 判断路径是否相交&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;path&lt;/code&gt;，其中 &lt;code&gt;path[i]&lt;/code&gt;的值可以是&lt;code&gt;&amp;#39;N&amp;#39;、&amp;#39;S&amp;#39;、&amp;#39;E&amp;#39;&lt;/code&gt;或者 &lt;code&gt;&amp;#39;W&amp;#39;&lt;/code&gt;，分别表示向北、向南、向东、向西移动一个单位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 29周双周赛</title>
    <link href="http://yoursite.com/2020/06/28/174/"/>
    <id>http://yoursite.com/2020/06/28/174/</id>
    <published>2020-06-28T08:06:18.361Z</published>
    <updated>2020-06-28T08:06:24.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="29周双周比赛"><a href="#29周双周比赛" class="headerlink" title="29周双周比赛"></a>29周双周比赛</h1><p><img src="https://mike-box.github.io/images/177-1.png" alt="1"><br>本周双周赛前三题莫名奇妙的简单，10分钟搞定三道题，最后一道题目还是不会，看来还是思考的不够或者深度不够，实际也是智商不够。我觉得还是需要提高自己深度思考的能力，当然最后一题莫名奇妙的用贪心算法（按照树的深度和出度的优先顺序）解决了，虽然把问题解决了，但是仔细看了解答，原来这个解法是错误得，这个问题实际位NP-hard问题，所以基本上只能用暴力搜索。<br>其实自己思考来思考去，不得不承认自己在<code>compective programming</code>上没有太大得天赋，每次都是草草收场。之所以还能坚持每周参加周赛，我想最多得还是兴趣，虽然自己并不聪明，并没有天赋，但是如果从内心来说认可一些事，喜欢一些事，能够坚持也是自己得信念与收获，通过<code>CP</code>能够快速的锻炼自己的<code>problem sloving skills</code>,特别是<code>hard problem</code>，真的很难，需要自己能够深入思考一些问题，能够从复杂的条件或者暗示中隐约的得到一些思路，我觉得这个能力可能是<code>CP</code>带给我的最大的收获。</p><a id="more"></a><h2 id="5432-去掉最低工资和最高工资后的工资平均值"><a href="#5432-去掉最低工资和最高工资后的工资平均值" class="headerlink" title="5432. 去掉最低工资和最高工资后的工资平均值"></a>5432. 去掉最低工资和最高工资后的工资平均值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>salary</code> ，数组里每个数都是 唯一 的，其中 <code>salary[i]</code> 是第 <code>i</code> `个员工的工资。</p><p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：salary = [<span class="number">4000</span>,<span class="number">3000</span>,<span class="number">1000</span>,<span class="number">2000</span>]</span><br><span class="line">输出：<span class="number">2500.00000</span></span><br><span class="line">解释：最低工资和最高工资分别是 <span class="number">1000</span> 和 <span class="number">4000</span> 。</span><br><span class="line">去掉最低工资和最高工资以后的平均工资是 (<span class="number">2000</span>+<span class="number">3000</span>)/<span class="number">2</span>= <span class="number">2500</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：salary = [<span class="number">1000</span>,<span class="number">2000</span>,<span class="number">3000</span>]</span><br><span class="line">输出：<span class="number">2000.00000</span></span><br><span class="line">解释：最低工资和最高工资分别是 <span class="number">1000</span> 和 <span class="number">3000</span> 。</span><br><span class="line">去掉最低工资和最高工资以后的平均工资是 (<span class="number">2000</span>)/<span class="number">1</span>= <span class="number">2000</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：salary = [<span class="number">6000</span>,<span class="number">5000</span>,<span class="number">4000</span>,<span class="number">3000</span>,<span class="number">2000</span>,<span class="number">1000</span>]</span><br><span class="line">输出：<span class="number">3500.00000</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：salary = [<span class="number">8000</span>,<span class="number">9000</span>,<span class="number">2000</span>,<span class="number">3000</span>,<span class="number">6000</span>,<span class="number">1000</span>]</span><br><span class="line">输出：<span class="number">4750.00000</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= salary.length &lt;= 100</code></li><li><code>10^3 &lt;= salary[i] &lt;= 10^6</code></li><li><code>salary[i]</code> 是唯一的。</li><li>与真实值误差在 <code>10^-5</code> 以内的结果都将视为正确答案。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary" target="_blank" rel="noopener">https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        sort(salary.begin(),salary.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; salary.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            sum += salary[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum/(salary.size()<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5433-n-的第-k-个因子"><a href="#5433-n-的第-k-个因子" class="headerlink" title="5433. n 的第 k 个因子"></a>5433. n 的第 k 个因子</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个正整数 <code>n</code> 和 <code>k</code> 。</p><p>如果正整数 <code>i</code> 满足 <code>n % i == 0</code>，那么我们就说正整数<code>i</code>是整数 <code>n</code>的因子。</p><p>考虑整数 <code>n</code> 的所有因子，将它们 升序排列 。请你返回第<code>k</code> 个因子。如果 <code>n</code>的因子数少于<code>k</code>，请你返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">12</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">12</span>]，第 <span class="number">3</span> 个因子是 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>, <span class="number">7</span>] ，第 <span class="number">2</span> 个因子是 <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] ，只有 <span class="number">3</span> 个因子，所以我们应该返回 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>] ，第 <span class="number">1</span> 个因子为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1000</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">125</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">1000</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= n &lt;= 1000</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/the-kth-factor-of-n" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-kth-factor-of-n</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力即可。题目数据量太小，连素数因子筛选都不用，直接暴力即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthFactor</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factor;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i == <span class="number">0</span>)&#123;</span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5434-删掉一个元素以后全为-1-的最长子数组"><a href="#5434-删掉一个元素以后全为-1-的最长子数组" class="headerlink" title="5434. 删掉一个元素以后全为 1 的最长子数组"></a>5434. 删掉一个元素以后全为 1 的最长子数组</h2><p>给你一个二进制数组 <code>nums</code> ，你需要从中删掉一个元素。</p><p>请你在删掉元素的结果数组中，返回最长的且只包含 <code>1</code> 的非空子数组的长度。</p><p>如果不存在这样的子数组，请返回 0 。</p><p>提示 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：删掉位置 <span class="number">2</span> 的数后，[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 包含 <span class="number">3</span> 个 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：删掉位置 <span class="number">4</span> 的数字后，[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>] 的最长全 <span class="number">1</span> 子数组为 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你必须要删除一个元素。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>nums[i]</code>要么是 <code>0</code>要么是<code>1</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>此题跟<a href="https://leetcode-cn.com/problems/maximum-subarray-sum-with-one-deletion/" target="_blank" rel="noopener">1186</a>题目几乎一样，如果会做这个题目，这个题目基本上也就是小case。</li><li>设<code>left[i]</code>代表从<code>i</code>处往左侧最多的连续<code>1</code>的个数，<code>right[i]</code>代表从<code>i</code>处往右侧最多的连续<code>1</code>的个数，则：<script type="math/tex; mode=display">maxLen[i] = left[i-1] + right[i+1]</script></li><li>本题确实很简单，没有多少好说的。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*intial*/</span></span><br><span class="line">        left[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        right[n<span class="number">-1</span>] = arr[n<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">/*left*/</span></span><br><span class="line">        ans = max(left[<span class="number">0</span>],right[n<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[i] = arr[i] + max(<span class="number">0</span>,left[i<span class="number">-1</span>]);</span><br><span class="line">            ans = max(ans,left[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*right*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = arr[i] + max(<span class="number">0</span>,right[i+<span class="number">1</span>]);</span><br><span class="line">            ans = max(ans,right[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-2</span>; ++i)&#123;</span><br><span class="line">            ans = max(left[i<span class="number">-1</span>]+right[i+<span class="number">1</span>],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5435-并行课程-II"><a href="#5435-并行课程-II" class="headerlink" title="5435. 并行课程 II"></a>5435. 并行课程 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>表示某所大学里课程的数目，编号为 <code>1</code> 到 <code>n</code> ，数组 <code>dependencies</code> 中，<code>dependencies[i] = [xi, yi]</code> 表示一个先修课的关系，也就是课程<code>xi</code> 必须在课程 <code>yi</code>之前上。同时你还有一个整数 <code>k</code> 。</p><p>在一个学期中，你 最多 可以同时上<code>k</code>门课，前提是这些课的先修课在之前的学期里已经上过了。</p><p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, dependencies = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>]], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 <span class="number">2</span> 和课程 <span class="number">3</span> 。然后第二个学期上课程 <span class="number">1</span> ，第三个学期上课程 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, dependencies = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>]], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 <span class="number">2</span> 和 <span class="number">3</span>，第二学期上课程 <span class="number">4</span> ，第三学期上课程 <span class="number">1</span> ，第四学期上课程 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span>, dependencies = [], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 15</code></li><li><code>1 &lt;= k &lt;= n</code></li><li><code>0 &lt;= dependencies.length &lt;= n * (n-1) / 2</code></li><li><code>dependencies[i].length == 2</code></li><li><code>1 &lt;= xi, yi &lt;= n</code></li><li><code>xi != yi</code></li><li>所有先修关系都是不同的，也就是说 <code>dependencies[i] != dependencies[j]</code>。</li><li>题目输入的图是个有向无环图。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/parallel-courses-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/parallel-courses-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>状态压缩DP</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>其实拿到这个题目开始，看到<code>course</code>的最大数目只有15，刚开始想到的就是位图的状态压缩<code>dp</code>，因为最多有<code>2^15</code>个状态。数量级非常小，感觉应该刚好符合题意。但是状态压缩的递推公式没有想出来，因为需要降低数量级，但是状态压缩dp的解法没有想出来。</li><li>意外的用了贪心算法，即每次优先最大的出度和深度的节点出队列，竟然意外的题目全部AC了，但是早上起来看到答案解析，举出了反例，这个解法明显有错误的。所以归根到底还是要坚持自己一开始的解题思路，一旦解题思路错误，则不可能讲问题解决，所以从一开始的思考的深度度非常重要，解题思路正确才能得出。如何才能找到事物的本性，如何才能提高自己思考的深度，这是自己最最需要提高的。方向错误可能导致事情本身的解决方法错误，找到事物的本因，才能提出正确的解决办法，否则就是干着急不得要领，所以我们在面对问题时，首先做到的是应该多思考，而不是先动手，能够快速的找到正确的方法才能至关重要。</li><li>本题适用于状态压缩dp，用位图表示，总共最多只有15门课程，如果该课程已经完成，我们则用将课程<code>i</code>,即第<code>i</code>位置为<code>1</code>,最终我们求的是dp[(1&lt;&lt;n)-1]的最小值，即为最短时间。<br><a href="https://leetcode-cn.com/problems/parallel-courses-ii/solution/czhuang-tai-ya-suo-dong-tai-gui-hua-by-ujimatsu_ch/" target="_blank" rel="noopener">题解</a><br>4.该题完全利用dp的暴力搜索解决， 我们知道dp[i]代表当前已经学过所有课程状态为<code>i</code>的最短时间，我们计算学完所有的课程集合<code>i</code>后，我们还可以学习哪些课程的集合为<code>b</code>,假如课程集合<code>b</code>中的数目小于等于<code>k</code>，则我们可以直接在一个新的学期中将<code>b</code>中所有的课程都拿来学习。则这时：<script type="math/tex; mode=display">dp[i|b] = min(dp[i|b],dp[i] + 1)</script>否则如果课程集合<code>b</code>中的数目大于<code>k</code>，则我们从集合<code>b</code>中进行枚举，每次最多选出<code>k</code>个课程，假设集合<code>b</code>中有<code>m</code>个课程，则我们可以有以下的枚举种类，本质就是暴力将所有的课程排序可能进行遍历一遍：<script type="math/tex; mode=display">C_{m}^{k}</script>这个暴力过程就很有意思，直接将b从1开始进行遍历一遍即可，代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = b; j ; j = (j<span class="number">-1</span>)&amp;b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_popcount(j) == k)&#123;</span><br><span class="line">        dp[i|j] = min(dp[i|j],dp[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>所有的代码其实看起来很难得题目，实际需要仔细得琢磨和品味。这个题目还是非常不错的题目，需要值得思考的地方很多，需要仔细品味，难得见到许多经典的题目。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberOfSemesters</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dependencies, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; req(<span class="number">1</span>&lt;&lt;n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v:dependencies)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = v[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">            req[y]|= (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*计算完成当前的课程状态i后，后续的还可以完成哪些课程的集合*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(((i&gt;&gt;j&amp;<span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; (req[j]&amp;i) == req[j])&#123;</span><br><span class="line">                    b |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(__builtin_popcount(b) &lt;= k)&#123;</span><br><span class="line">                dp[i|b] = min(dp[i|b],dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = b; j ; j = (j<span class="number">-1</span>)&amp;b)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(__builtin_popcount(j) == k)&#123;</span><br><span class="line">                        dp[i|j] = min(dp[i|j],dp[i]+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;29周双周比赛&quot;&gt;&lt;a href=&quot;#29周双周比赛&quot; class=&quot;headerlink&quot; title=&quot;29周双周比赛&quot;&gt;&lt;/a&gt;29周双周比赛&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://mike-box.github.io/images/177-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周双周赛前三题莫名奇妙的简单，10分钟搞定三道题，最后一道题目还是不会，看来还是思考的不够或者深度不够，实际也是智商不够。我觉得还是需要提高自己深度思考的能力，当然最后一题莫名奇妙的用贪心算法（按照树的深度和出度的优先顺序）解决了，虽然把问题解决了，但是仔细看了解答，原来这个解法是错误得，这个问题实际位NP-hard问题，所以基本上只能用暴力搜索。&lt;br&gt;其实自己思考来思考去，不得不承认自己在&lt;code&gt;compective programming&lt;/code&gt;上没有太大得天赋，每次都是草草收场。之所以还能坚持每周参加周赛，我想最多得还是兴趣，虽然自己并不聪明，并没有天赋，但是如果从内心来说认可一些事，喜欢一些事，能够坚持也是自己得信念与收获，通过&lt;code&gt;CP&lt;/code&gt;能够快速的锻炼自己的&lt;code&gt;problem sloving skills&lt;/code&gt;,特别是&lt;code&gt;hard problem&lt;/code&gt;，真的很难，需要自己能够深入思考一些问题，能够从复杂的条件或者暗示中隐约的得到一些思路，我觉得这个能力可能是&lt;code&gt;CP&lt;/code&gt;带给我的最大的收获。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 194周比赛</title>
    <link href="http://yoursite.com/2020/06/22/173/"/>
    <id>http://yoursite.com/2020/06/22/173/</id>
    <published>2020-06-22T02:12:39.353Z</published>
    <updated>2020-06-22T02:23:12.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="194周比赛"><a href="#194周比赛" class="headerlink" title="194周比赛"></a>194周比赛</h1><p><img src="https://mike-box.github.io/images/175-1.png" alt="1"><br>本周周赛的题目还还是创出了新难度，题目全部AC的人数还不到100人。前三题确实有点难度，特别是第二题和第三题都比较绕，第四题除了暴力意外没有好思路。</p><h2 id="1486-数组异或操作"><a href="#1486-数组异或操作" class="headerlink" title="1486. 数组异或操作"></a>1486. 数组异或操作</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数，<code>n</code>和 <code>start</code>。</p><p>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code>。</p><a id="more"></a><p>请返回 <code>nums</code> 中所有元素按位异或（<code>XOR</code>）后得到的结果。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, start = <span class="number">0</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：数组 nums 为 [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]，其中 (<span class="number">0</span> ^ <span class="number">2</span> ^ <span class="number">4</span> ^ <span class="number">6</span> ^ <span class="number">8</span>) = <span class="number">8</span> 。</span><br><span class="line">     <span class="string">"^"</span> 为按位异或 XOR 运算符。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, start = <span class="number">3</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：数组 nums 为 [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]，其中 (<span class="number">3</span> ^ <span class="number">5</span> ^ <span class="number">7</span> ^ <span class="number">9</span>) = <span class="number">8.</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, start = <span class="number">7</span></span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, start = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>0 &lt;= start &lt;= 1000</code></li><li><code>n == nums.length</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xor-operation-in-an-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            res = res^(start+(i*<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1487-保证文件名唯一"><a href="#1487-保证文件名唯一" class="headerlink" title="1487. 保证文件名唯一"></a>1487. 保证文件名唯一</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的字符串数组 <code>names</code>。你将会在文件系统中创建<code>n</code>个文件夹：在第 <code>i</code>分钟，新建名为 <code>names[i]</code> 的文件夹。</p><p>由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以<code>(k)</code> 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。</p><p>返回长度为 <code>n</code> 的字符串数组，其中 <code>ans[i]</code>是创建第 <code>i</code> 个文件夹时系统分配给该文件夹的实际名称。</p><p>示例 1：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"pes"</span>,<span class="string">"fifa"</span>,<span class="string">"gta"</span>,<span class="string">"pes(2019)"</span>]</span><br><span class="line">输出：[<span class="string">"pes"</span>,<span class="string">"fifa"</span>,<span class="string">"gta"</span>,<span class="string">"pes(2019)"</span>]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line"><span class="string">"pes"</span> --&gt; 之前未分配，仍为 <span class="string">"pes"</span></span><br><span class="line"><span class="string">"fifa"</span> --&gt; 之前未分配，仍为 <span class="string">"fifa"</span></span><br><span class="line"><span class="string">"gta"</span> --&gt; 之前未分配，仍为 <span class="string">"gta"</span></span><br><span class="line"><span class="string">"pes(2019)"</span> --&gt; 之前未分配，仍为 <span class="string">"pes(2019)"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"gta"</span>,<span class="string">"gta(1)"</span>,<span class="string">"gta"</span>,<span class="string">"avalon"</span>]</span><br><span class="line">输出：[<span class="string">"gta"</span>,<span class="string">"gta(1)"</span>,<span class="string">"gta(2)"</span>,<span class="string">"avalon"</span>]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line"><span class="string">"gta"</span> --&gt; 之前未分配，仍为 <span class="string">"gta"</span></span><br><span class="line"><span class="string">"gta(1)"</span> --&gt; 之前未分配，仍为 <span class="string">"gta(1)"</span></span><br><span class="line"><span class="string">"gta"</span> --&gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 <span class="string">"gta(1)"</span> 也被占用，所以 k = <span class="number">2</span> 。实际创建的文件名为 <span class="string">"gta(2)"</span> 。</span><br><span class="line"><span class="string">"avalon"</span> --&gt; 之前未分配，仍为 <span class="string">"avalon"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"onepiece"</span>,<span class="string">"onepiece(1)"</span>,<span class="string">"onepiece(2)"</span>,<span class="string">"onepiece(3)"</span>,<span class="string">"onepiece"</span>]</span><br><span class="line">输出：[<span class="string">"onepiece"</span>,<span class="string">"onepiece(1)"</span>,<span class="string">"onepiece(2)"</span>,<span class="string">"onepiece(3)"</span>,<span class="string">"onepiece(4)"</span>]</span><br><span class="line">解释：当创建最后一个文件夹时，最小的正有效 k 为 <span class="number">4</span> ，文件名变为 <span class="string">"onepiece(4)"</span>。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"wano"</span>,<span class="string">"wano"</span>,<span class="string">"wano"</span>,<span class="string">"wano"</span>]</span><br><span class="line">输出：[<span class="string">"wano"</span>,<span class="string">"wano(1)"</span>,<span class="string">"wano(2)"</span>,<span class="string">"wano(3)"</span>]</span><br><span class="line">解释：每次创建文件夹 <span class="string">"wano"</span> 时，只需增加后缀中 k 的值即可。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"kaido"</span>,<span class="string">"kaido(1)"</span>,<span class="string">"kaido"</span>,<span class="string">"kaido(1)"</span>]</span><br><span class="line">输出：[<span class="string">"kaido"</span>,<span class="string">"kaido(1)"</span>,<span class="string">"kaido(2)"</span>,<span class="string">"kaido(1)(1)"</span>]</span><br><span class="line">解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= names.length &lt;= 5 * 10^4</code></li><li><code>1 &lt;= names[i].length &lt;= 20</code></li><li><code>names[i]</code>由小写英文字母、数字和/或圆括号组成。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/making-file-names-unique" target="_blank" rel="noopener">https://leetcode-cn.com/problems/making-file-names-unique</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目很无聊啊，用hash保存该文件名当前最大的统计数。</li><li>如果该名字没有出现过，则直接返回该文件名；如果该文件名出现，则找到该文件名为开头的最大整数索引，将其加入到文件名中的一部分即可，同时需要将最新的名字也要写入<code>hash</code>表中。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; getFolderNames(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; names) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt.count(names[i]))&#123;</span><br><span class="line">                res.push_back(names[i]);</span><br><span class="line">                cnt[names[i]] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cnt[names[i]] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(cnt.count(names[i] + <span class="string">"("</span> + to_string(x) + <span class="string">")"</span>)) x++;</span><br><span class="line">                <span class="built_in">string</span> newname = names[i] + <span class="string">"("</span> + to_string(x) + <span class="string">")"</span>;</span><br><span class="line">                res.push_back(newname);</span><br><span class="line">                cnt[names[i]] = x;</span><br><span class="line">                cnt[newname] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1488-避免洪水泛滥"><a href="#1488-避免洪水泛滥" class="headerlink" title="1488. 避免洪水泛滥"></a>1488. 避免洪水泛滥</h2><p>你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 <code>n</code>个湖泊下雨的时候，如果第 <code>n</code> 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。</p><p>给你一个整数数组 <code>rains</code> ，其中：</p><ul><li><code>rains[i] &gt; 0</code> 表示第 <code>i</code> 天时，第 <code>rains[i]</code> 个湖泊会下雨。</li><li><code>rains[i] == 0</code> 表示第 <code>i</code> 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。<br>请返回一个数组<code>ans</code> ，满足：</li><li><code>ans.length == rains.length</code></li><li>如果 <code>rains[i] &gt; 0</code>，那么<code>ans[i] == -1</code> 。</li><li>如果 <code>rains[i] == 0</code>，<code>ans[i]</code>是你第 <code>i</code> 天选择抽干的湖泊。</li><li>如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。</li></ul><p>请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生（详情请看示例 4）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：第一天后，装满水的湖泊包括 [<span class="number">1</span>]</span><br><span class="line">第二天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">第三天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">第四天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：第一天后，装满水的湖泊包括 [<span class="number">1</span>]</span><br><span class="line">第二天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">第三天后，我们抽干湖泊 <span class="number">2</span> 。所以剩下装满水的湖泊包括 [<span class="number">1</span>]</span><br><span class="line">第四天后，我们抽干湖泊 <span class="number">1</span> 。所以暂时没有装满水的湖泊了。</span><br><span class="line">第五天后，装满水的湖泊包括 [<span class="number">2</span>]。</span><br><span class="line">第六天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>]。</span><br><span class="line">可以看出，这个方案下不会有洪水发生。同时， [<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>] 也是另一个可行的没有洪水的方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：第二天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>]。我们可以在第三天抽干一个湖泊的水。</span><br><span class="line">但第三天后，湖泊 <span class="number">1</span> 和 <span class="number">2</span> 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">69</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">69</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">69</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：任何形如 [<span class="number">-1</span>,<span class="number">69</span>,x,y,<span class="number">-1</span>], [<span class="number">-1</span>,x,<span class="number">69</span>,y,<span class="number">-1</span>] 或者 [<span class="number">-1</span>,x,y,<span class="number">69</span>,<span class="number">-1</span>] 都是可行的解，其中 <span class="number">1</span> &lt;= x,y &lt;= <span class="number">10</span>^<span class="number">9</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">20</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：由于湖泊 <span class="number">20</span> 会连续下 <span class="number">2</span> 天的雨，所以没有没有办法阻止洪水。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= rains.length &lt;= 10^5</code></li><li><code>0 &lt;= rains[i] &lt;= 10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/avoid-flood-in-the-city" target="_blank" rel="noopener">https://leetcode-cn.com/problems/avoid-flood-in-the-city</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心 + 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们保存未下雨的天数，即可以抽干湖泊的日期<code>dry</code>。我们同时记录湖泊<code>i</code>在哪一天下了雨，记录为<code>rain[i]</code>。</li><li>当我们遇到湖泊<code>i</code>在第<code>j</code>天第二次下雨时，因为此时湖泊已经灌满了水，这时会肯定会发生洪水,此时我们应当在<code>[rain[i]+1,j-1]</code>之间从可以抽干水的日期<code>dry</code>中选择一天来抽干湖泊<code>i</code>,即：<script type="math/tex; mode=display">rain[i]+1 \le select_{i} \le j-1</script></li><li>但是选择日期的时候有一点比较关键，我们需要尽量选择靠前的天数，即在区间<code>[rain[i]+1,j-1]</code>中的最小日期,我们可以用二分查找在<code>O(lgn)</code>的时间复杂度内在<code>dry</code>集合中快速找到第一个大于<code>rain[i]</code>的数,我们可以利用有序集合的<code>upper_bound</code>函数。假如我们不选择靠前的天数可能会影响到后面的湖泊，导致后面的湖泊出现洪水。比如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>我们在第<code>6</code>天时，湖泊<code>1</code>如果不进行抽干，则该湖泊会导致洪水，而我们可以选择第<code>2</code>天或者第<code>5</code>天进行抽干湖泊<code>1</code>，但我们实际选择时选择第<code>2</code>天进行抽干湖泊<code>1</code>,否则会导致湖泊<code>2</code>没法进行抽干而产生洪水。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; avoidFlood(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rains) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = rains.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; flood;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; dry;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rains[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dry.insert(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rains[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flood.count(rains[i]))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dry.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">                    <span class="keyword">auto</span> it = dry.upper_bound(flood[rains[i]]);</span><br><span class="line">                    <span class="keyword">if</span>(it == dry.end()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">                    ans[*it] = rains[i];</span><br><span class="line">                    dry.erase(*it);</span><br><span class="line">                &#125;</span><br><span class="line">                flood[rains[i]] = i;</span><br><span class="line">                ans[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1489-找到最小生成树里的关键边和伪关键边"><a href="#1489-找到最小生成树里的关键边和伪关键边" class="headerlink" title="1489. 找到最小生成树里的关键边和伪关键边"></a>1489. 找到最小生成树里的关键边和伪关键边</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>n</code>个点的带权无向连通图，节点编号为 <code>0</code>到 <code>n-1</code> ，同时还有一个数组<code>edges</code>，其中<code>edges[i] = [fromi, toi, weighti]</code> 表示在 <code>fromi</code>和<code>toi</code>节点之间有一条带权无向边。最小生成树 <code>(MST)</code>是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p><p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果最小生成树中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p><p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">解释：上图描述了给定图。</span><br><span class="line">下图是所有的最小生成树。</span><br><span class="line"></span><br><span class="line">注意到第 <span class="number">0</span> 条边和第 <span class="number">1</span> 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。</span><br><span class="line">边 <span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span> 和 <span class="number">5</span> 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。</span><br></pre></td></tr></table></figure><br>示例 2 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">解释：可以观察到 <span class="number">4</span> 条边都有相同的权值，任选它们中的 <span class="number">3</span> 条可以形成一棵 MST 。所以 <span class="number">4</span> 条边都是伪关键边。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li><li><code>edges[i].length == 3</code></li><li><code>0 &lt;= fromi &lt; toi &lt; n</code></li><li><code>1 &lt;= weighti &lt;= 1000</code></li><li><code>所有 (fromi, toi) 数对都是互不相同的。</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>最小生成树算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><code>contest</code>时没有做出来，后来看了解答，感觉竟然时暴力<code>check</code>每条边。</li><li>首先跑一边最小生成树<code>kruskal</code>算法，求出最小生成树的<code>weight</code>为<code>best</code>.</li><li>如果去掉某条边<code>e</code>,再运行一遍最小生成树算法，如果发现求出的最小生成树的<code>weight</code>如果不等于<code>best</code>，则我们认为边<code>e</code>为<code>critical egde</code>.</li><li>如果我们在最小生成树中，初始化时每次加入某条边<code>e</code>（去掉<code>critical edge</code>),再运行一遍最小生成树算法，如果发现求出的最小生成树的<code>weight</code>如果等于<code>best</code>，则我们认为边<code>e</code>为<code>pseudo critical egde</code>.</li><li>题目非常暴力，不过当时竟然没有想到这种暴力解法，题目中最重要的提示为<code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code>,说明<code>edge</code>的数量级非常小，完全可以暴力<code>check</code>每条边，还是智商不够，没有<code>get</code>到<code>point</code>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != f[x]) x = f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">    <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">    f[x1] = y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findCriticalAndPseudoCriticalEdges(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">            edges[k].push_back(k);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edges.begin(), edges.end(),</span><br><span class="line">            [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; u, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">                <span class="keyword">return</span> u[<span class="number">2</span>] &lt; v[<span class="number">2</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[<span class="number">0</span>], y = e[<span class="number">1</span>], z = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (find(f,x) != find(f,y)) &#123;</span><br><span class="line">                best += z;</span><br><span class="line">                uni(f,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; best &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; retA, retB;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; A(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = edges[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = edges[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> w = edges[j][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(find(f,x) != find(f,y))&#123;</span><br><span class="line">                    uni(f,x,y);</span><br><span class="line">                    curr += w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr != best)&#123;</span><br><span class="line">                retA.push_back(edges[k][<span class="number">3</span>]);</span><br><span class="line">                A[k] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[k]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">            uni(f,edges[k][<span class="number">0</span>],edges[k][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> curr = edges[k][<span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = edges[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = edges[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> w = edges[j][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(find(f,x) != find(f,y))&#123;</span><br><span class="line">                    uni(f,x,y);</span><br><span class="line">                    curr += w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == best)&#123;</span><br><span class="line">                retB.push_back(edges[k][<span class="number">3</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;retA, retB&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;194周比赛&quot;&gt;&lt;a href=&quot;#194周比赛&quot; class=&quot;headerlink&quot; title=&quot;194周比赛&quot;&gt;&lt;/a&gt;194周比赛&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://mike-box.github.io/images/175-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周周赛的题目还还是创出了新难度，题目全部AC的人数还不到100人。前三题确实有点难度，特别是第二题和第三题都比较绕，第四题除了暴力意外没有好思路。&lt;/p&gt;&lt;h2 id=&quot;1486-数组异或操作&quot;&gt;&lt;a href=&quot;#1486-数组异或操作&quot; class=&quot;headerlink&quot; title=&quot;1486. 数组异或操作&quot;&gt;&lt;/a&gt;1486. 数组异或操作&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个整数，&lt;code&gt;n&lt;/code&gt;和 &lt;code&gt;start&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;数组 &lt;code&gt;nums&lt;/code&gt; 定义为：&lt;code&gt;nums[i] = start + 2*i&lt;/code&gt;（下标从 0 开始）且 &lt;code&gt;n == nums.length&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 193周比赛</title>
    <link href="http://yoursite.com/2020/06/14/172/"/>
    <id>http://yoursite.com/2020/06/14/172/</id>
    <published>2020-06-14T15:39:03.891Z</published>
    <updated>2020-06-14T15:39:08.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="193周比赛"><a href="#193周比赛" class="headerlink" title="193周比赛"></a>193周比赛</h1><p><img src="https://mike-box.github.io/images/174-1.png" alt="1"><br>本周周赛的题目还是出的非常好，有一定的难度和拔高，部分经典问题非常值得探讨。比较坑的是竟然第三题连二分查找都忘了，用了一个非常复杂的办法，虽然AC了，但是效率和性能并不高。</p><h2 id="55436-一维数组的动态和"><a href="#55436-一维数组的动态和" class="headerlink" title="55436. 一维数组的动态和"></a>55436. 一维数组的动态和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code>。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]…nums[i])</code>。</p><a id="more"></a><p>请返回 <code>nums</code>的动态和。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>]</span><br><span class="line">解释：动态和计算过程为 [<span class="number">1</span>, <span class="number">1</span>+<span class="number">2</span>, <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>, <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">解释：动态和计算过程为 [<span class="number">1</span>, <span class="number">1</span>+<span class="number">1</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">16</span>,<span class="number">17</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/running-sum-of-1d-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目没啥好说的，直接相加即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; runningSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            res.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5437-不同整数的最少数目"><a href="#5437-不同整数的最少数目" class="headerlink" title="5437. 不同整数的最少数目"></a>5437. 不同整数的最少数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code>和一个整数 <code>k</code> 。现需要从数组中恰好移除<code>k</code>个元素，请找出移除后数组中不同整数的最少数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：移除 <span class="number">1</span> 个 <span class="number">4</span> ，数组中只剩下 <span class="number">5</span> 一种整数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：先移除 <span class="number">4</span>、<span class="number">2</span> ，然后再移除两个 <span class="number">1</span> 中的任意 <span class="number">1</span> 个或者三个 <span class="number">3</span> 中的任意 <span class="number">1</span> 个，最后剩下 <span class="number">1</span> 和 <span class="number">3</span> 两种整数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^9</code></li><li><code>0 &lt;= k &lt;= arr.length</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/least-number-of-unique-integers-after-k-removals" target="_blank" rel="noopener">https://leetcode-cn.com/problems/least-number-of-unique-integers-after-k-removals</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>若要使的数的种类最少，则我们优先减少数量统计最少个数的数。</li><li>我们统计出所有数字的个数，然后按照个数从小到大进行排序，依次去掉数目的个数，直到达到<code>k</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remove = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; A;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : arr)&#123;</span><br><span class="line">            cnt[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            A.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(A.begin(),A.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">            k -= A[i].second;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= <span class="number">0</span>) remove++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> A.size() - remove;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5438-制作-m-束花所需的最少天数"><a href="#5438-制作-m-束花所需的最少天数" class="headerlink" title="5438. 制作 m 束花所需的最少天数"></a>5438. 制作 m 束花所需的最少天数</h2><p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code>。</p><p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 相邻的 <code>k</code> 朵花 。</p><p>花园中有 <code>n</code> 朵花，第 <code>i</code>朵花会在 <code>bloomDay[i]</code> 时盛开，恰好 可以用于 一束 花中。</p><p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>], m = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 <span class="number">3</span> 束花，每束只需要 <span class="number">1</span> 朵。</span><br><span class="line"><span class="number">1</span> 天后：[x, _, _, _, _]   <span class="comment">// 只能制作 1 束花</span></span><br><span class="line"><span class="number">2</span> 天后：[x, _, _, _, x]   <span class="comment">// 只能制作 2 束花</span></span><br><span class="line"><span class="number">3</span> 天后：[x, _, x, _, x]   <span class="comment">// 可以制作 3 束花，答案为 3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>], m = <span class="number">3</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：要制作 <span class="number">3</span> 束花，每束需要 <span class="number">2</span> 朵花，也就是一共需要 <span class="number">6</span> 朵花。而花园中只有 <span class="number">5</span> 朵花，无法满足制作要求，返回 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">7</span>], m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：要制作 <span class="number">2</span> 束花，每束需要 <span class="number">3</span> 朵。</span><br><span class="line">花园在 <span class="number">7</span> 天后和 <span class="number">12</span> 天后的情况如下：</span><br><span class="line"><span class="number">7</span> 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 <span class="number">3</span> 朵盛开的花制作第一束花。但不能使用后 <span class="number">3</span> 朵盛开的花，因为它们不相邻。</span><br><span class="line"><span class="number">12</span> 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">1000000000</span>,<span class="number">1000000000</span>], m = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1000000000</span></span><br><span class="line">解释：需要等 <span class="number">1000000000</span> 天才能采到花来制作花束</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>], m = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>bloomDay.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li><li><code>1 &lt;= m &lt;= 10^6</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口或者二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们将所有花的盛开时间按照先后进行排序。</li><li>我们设数组<code>left[i]</code>代表从<code>i</code>处开始左边有连续多少朵花已经开放，<code>right[i]</code>代表从<code>i</code>处开始右边有连续多少朵花已经开放，每次第<code>i</code>朵花开放时，则：<script type="math/tex; mode=display">\begin{array}{l}left[i] = left[i-1] + 1 \\\\right[i] = right[i+1] + 1\\\\right[i-left[i]+1] = left[i] + right[i] - 1 \\\\left[i+right[i]-1] = left[i] + right[i] - 1 \\\end{array}</script>新加入的第<code>i</code>朵盛开的花能否增加制作一束花，只需要判断如下条件即可：<script type="math/tex; mode=display">(left[i-1] \bmod k + right[i+1] \bmod k + 1) >= k</script>如果满足以上条件则我们将可以制作花束的统计数目进行加1.</li><li>判断当前统计数目大于m时即满足题目要求。</li><li>另外一种高效率的解法为二分查找，非常简单。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bloomDay.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; days;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            days[bloomDay[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : days)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : d.second)&#123;</span><br><span class="line">                right[x] = <span class="number">1</span>;</span><br><span class="line">                left[x] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; n - <span class="number">1</span>) right[x] += right[x+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &gt; <span class="number">0</span>) left[x] += left[x<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(((left[x]<span class="number">-1</span>)%k + (right[x]<span class="number">-1</span>)%k + <span class="number">1</span>) &gt;= k)&#123;</span><br><span class="line">                    curr++;</span><br><span class="line">                    <span class="keyword">if</span>(curr == m) <span class="keyword">return</span> d.first;</span><br><span class="line">                &#125;</span><br><span class="line">                right[x-left[x]+<span class="number">1</span>] = left[x] + right[x] - <span class="number">1</span>;</span><br><span class="line">                left[x+right[x]<span class="number">-1</span>] = left[x] + right[x] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k,<span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bloomDay.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bloomDay[i] &lt;= days)&#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                total += curr/k;</span><br><span class="line">                curr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total += curr/k;</span><br><span class="line">        <span class="keyword">return</span> total &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(bloomDay,m,k,mid))&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5188-树节点的第-K-个祖先"><a href="#5188-树节点的第-K-个祖先" class="headerlink" title="5188. 树节点的第 K 个祖先"></a>5188. 树节点的第 K 个祖先</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵树，树上有 <code>n</code>个节点，按从 <code>0</code> 到 <code>n-1</code> 编号。树以父节点数组的形式给出，其中 <code>parent[i]</code>是节点<code>i</code> 的父节点。树的根节点是编号为<code>0</code>的节点。<br>请你设计并实现<code>getKthAncestor(int node, int k)</code>函数，函数返回节点 <code>node</code>的第 <code>k</code>个祖先节点。如果不存在这样的祖先节点，返回 <code>-1</code>。<br>树节点的第<code>k</code>个祖先节点是从该节点到根节点路径上的第 <code>k</code> 个节点。</p><p>示例：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"TreeAncestor"</span>,<span class="string">"getKthAncestor"</span>,<span class="string">"getKthAncestor"</span>,<span class="string">"getKthAncestor"</span>]</span><br><span class="line">[[<span class="number">7</span>,[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">TreeAncestor treeAncestor = new TreeAncestor(<span class="number">7</span>, [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">treeAncestor.getKthAncestor(<span class="number">3</span>, <span class="number">1</span>);  <span class="comment">// 返回 1 ，它是 3 的父节点</span></span><br><span class="line">treeAncestor.getKthAncestor(<span class="number">5</span>, <span class="number">2</span>);  <span class="comment">// 返回 0 ，它是 5 的祖父节点</span></span><br><span class="line">treeAncestor.getKthAncestor(<span class="number">6</span>, <span class="number">3</span>);  <span class="comment">// 返回 -1 因为不存在满足要求的祖先节点</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= n &lt;= 5*10^4</code></li><li><code>parent[0] == -1</code> 表示编号为 <code>0</code>的节点是根节点。</li><li>对于所有的 <code>0 &lt; i &lt; n ，0 &lt;= parent[i] &lt; n</code>总成立</li><li><code>0 &lt;= node &lt; n</code></li><li>至多查询 <code>5*10^4</code>次</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>lca倍增</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>从来没有见过类似的题目，第一次见到，感觉真心牛逼，不过感觉后缀数组中的倍增有的一拼，后缀数组中的倍增排序算法更复杂。</li><li>首先需要理解这个递推关系,node的第k个父节点等于node的第x个父节点的第k-x个父节点。<script type="math/tex; mode=display">parent[node][k] = parent[parent[node][x]][k-x]</script>知道这个原理后我们就可以利用倍增原理,非常类似于求开方的计算方法，不断的进行除2迭代即可得到结果。<script type="math/tex; mode=display">parent[node][k] = parent[parent[node][\frac{k}{2}]][k-\frac{k}{2}]</script></li><li>我们可以很快的求出每个节点的2次幂的父节点。<script type="math/tex; mode=display">fa[x][i] = parent[x][2^{i}] \\\\fa[x][i+1] = parent[x][2^{i+1}]  \\\\parent[x][2^{i+1}]  = parent[parent[x][2^{i}]][2^{i}] = fa[fa[x][i]][i]</script>我们刚好即可利用上述的递推公式很快的求出所有距离为2次幂的节点。</li><li>我们实际计算时，将k进行2次幂的分解，我们知道k一定能够被分解为2次幂的组合。<script type="math/tex; mode=display">k = \sum_{i=1}^{m} 2^{x^{i}}</script><script type="math/tex; mode=display">parent[node][k] = parent[fa[node][x_{1}]][k-2^{x_{1}}] \\node_{1} = fa[node][x_{1}] \\parent[node][k] = parent[node_{1}][k-2^{x_{1}}]</script>我们依次按照上述的计算过程依次进行迭代，最终能够在O(lgk)的时间复杂度内求出最终的<code>k</code>个父节点。</li><li>第一次见到这个题目还是非常牛逼的。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeAncestor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">100005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeAncestor(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parent) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            fa[i][<span class="number">0</span>] = parent[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> ffa = fa[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(ffa &lt; <span class="number">0</span>) fa[i][j] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> fa[i][j] = fa[ffa][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthAncestor</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">while</span>(k &gt;= curr &amp;&amp; node &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                k -= curr;</span><br><span class="line">                node = fa[node][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TreeAncestor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TreeAncestor* obj = new TreeAncestor(n, parent);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getKthAncestor(node,k);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TreeAncestor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TreeAncestor* obj = new TreeAncestor(n, parent);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getKthAncestor(node,k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;193周比赛&quot;&gt;&lt;a href=&quot;#193周比赛&quot; class=&quot;headerlink&quot; title=&quot;193周比赛&quot;&gt;&lt;/a&gt;193周比赛&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://mike-box.github.io/images/174-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周周赛的题目还是出的非常好，有一定的难度和拔高，部分经典问题非常值得探讨。比较坑的是竟然第三题连二分查找都忘了，用了一个非常复杂的办法，虽然AC了，但是效率和性能并不高。&lt;/p&gt;&lt;h2 id=&quot;55436-一维数组的动态和&quot;&gt;&lt;a href=&quot;#55436-一维数组的动态和&quot; class=&quot;headerlink&quot; title=&quot;55436. 一维数组的动态和&quot;&gt;&lt;/a&gt;55436. 一维数组的动态和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt;。数组「动态和」的计算公式为：&lt;code&gt;runningSum[i] = sum(nums[0]…nums[i])&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 28周双比赛</title>
    <link href="http://yoursite.com/2020/06/14/171/"/>
    <id>http://yoursite.com/2020/06/14/171/</id>
    <published>2020-06-14T08:04:41.518Z</published>
    <updated>2020-06-14T09:30:14.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="28周双周赛"><a href="#28周双周赛" class="headerlink" title="28周双周赛"></a>28周双周赛</h1><p>前3题半个小时搞定，最后一题又是经典的DP，在最后20分钟想出来了解决办法，但是没有时间提交了，最终排名竟然还挺高152名。赛后又加班搞了半个小时搞定了。其中涉及到一个中位数的数学理论。感慨下还是智商不够高。<br><img src="https://mike-box.github.io/images/171-1.png" alt="1"><br>本周双周赛的第四题出的非常好，又有数学理论和dp相结合，题目非常经典，虽然当时没有做出来，但是赛后靠自己的理解没有看答案做出来了，我觉得每次做题锻炼自己独立思考问题的能力非常重要，而不是上来就看答案。</p><a id="more"></a><h2 id="5420-商品折扣后的最终价格"><a href="#5420-商品折扣后的最终价格" class="headerlink" title="5420. 商品折扣后的最终价格"></a>5420. 商品折扣后的最终价格</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>prices</code>，其中<code>prices[i]</code>是商店里第<code>i</code>件商品的价格。</p><p>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 <code>prices[j]</code>相等的折扣，其中 j 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code>的 最小下标 ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p><p>请你返回一个数组，数组中第 <code>i</code>个元素是折扣后你购买商品 i 最终需要支付的价格。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">商品 <span class="number">0</span> 的价格为 price[<span class="number">0</span>]=<span class="number">8</span> ，你将得到 prices[<span class="number">1</span>]=<span class="number">4</span> 的折扣，所以最终价格为 <span class="number">8</span> - <span class="number">4</span> = <span class="number">4</span> 。</span><br><span class="line">商品 <span class="number">1</span> 的价格为 price[<span class="number">1</span>]=<span class="number">4</span> ，你将得到 prices[<span class="number">3</span>]=<span class="number">2</span> 的折扣，所以最终价格为 <span class="number">4</span> - <span class="number">2</span> = <span class="number">2</span> 。</span><br><span class="line">商品 <span class="number">2</span> 的价格为 price[<span class="number">2</span>]=<span class="number">6</span> ，你将得到 prices[<span class="number">3</span>]=<span class="number">2</span> 的折扣，所以最终价格为 <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span> 。</span><br><span class="line">商品 <span class="number">3</span> 和 <span class="number">4</span> 都没有折扣。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">解释：在这个例子中，所有商品都没有折扣。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= prices.length &lt;= <span class="number">500</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= prices[i] &lt;= <span class="number">10</span>^<span class="number">3</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 这个题目没啥好说的，找到从`i+<span class="number">1</span>`处开始第一个比`arr[i]`小的数即可，两层循环，O(n^<span class="number">2</span>)复杂度。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; finalPrices(vector&lt;<span class="built_in">int</span>&gt;&amp; prices) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = prices.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; cut(n,<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cut[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[j] &lt;= prices[i])&#123;</span><br><span class="line">                    cut[i] = prices[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(prices[i] - cut[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5422-子矩形查询"><a href="#5422-子矩形查询" class="headerlink" title="5422. 子矩形查询"></a>5422. 子矩形查询</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>请你实现一个类 <code>SubrectangleQueries</code> ，它的构造函数的参数是一个 <code>rows x cols</code> 的矩形（这里用整数矩阵表示），并支持以下两种操作：</p><ul><li><ol><li>updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)</li></ol></li></ul><p>用 <code>newValue</code> 更新以 <code>(row1,col1)</code> 为左上角且以 <code>(row2,col2)</code>为右下角的子矩形。</p><ul><li><ol><li><code>getValue(int row, int col)</code></li></ol></li></ul><p>返回矩形中坐标 <code>(row,col)</code>的当前值。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"SubrectangleQueries"</span>,<span class="string">"getValue"</span>,<span class="string">"updateSubrectangle"</span>,<span class="string">"getValue"</span>,<span class="string">"getValue"</span>,<span class="string">"updateSubrectangle"</span>,<span class="string">"getValue"</span>,<span class="string">"getValue"</span>]</span><br><span class="line">[[[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null,<span class="number">1</span>,null,<span class="number">5</span>,<span class="number">5</span>,null,<span class="number">10</span>,<span class="number">5</span>]</span><br><span class="line">解释：</span><br><span class="line">SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]);  </span><br><span class="line"><span class="comment">// 初始的 (4x3) 矩形如下：</span></span><br><span class="line"><span class="comment">// 1 2 1</span></span><br><span class="line"><span class="comment">// 4 3 4</span></span><br><span class="line"><span class="comment">// 3 2 1</span></span><br><span class="line"><span class="comment">// 1 1 1</span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 返回 1</span></span><br><span class="line">subrectangleQueries.updateSubrectangle(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 此次更新后矩形变为：</span></span><br><span class="line"><span class="comment">// 5 5 5</span></span><br><span class="line"><span class="comment">// 5 5 5</span></span><br><span class="line"><span class="comment">// 5 5 5</span></span><br><span class="line"><span class="comment">// 5 5 5 </span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 返回 5</span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 返回 5</span></span><br><span class="line">subrectangleQueries.updateSubrectangle(<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 此次更新后矩形变为：</span></span><br><span class="line"><span class="comment">// 5   5   5</span></span><br><span class="line"><span class="comment">// 5   5   5</span></span><br><span class="line"><span class="comment">// 5   5   5</span></span><br><span class="line"><span class="comment">// 10  10  10 </span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 返回 10</span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 返回 5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"SubrectangleQueries"</span>,<span class="string">"getValue"</span>,<span class="string">"updateSubrectangle"</span>,<span class="string">"getValue"</span>,<span class="string">"getValue"</span>,<span class="string">"updateSubrectangle"</span>,<span class="string">"getValue"</span>]</span><br><span class="line">[[[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]]],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">20</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null,<span class="number">1</span>,null,<span class="number">100</span>,<span class="number">100</span>,null,<span class="number">20</span>]</span><br><span class="line">解释：</span><br><span class="line">SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]]);</span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 返回 1</span></span><br><span class="line">subrectangleQueries.updateSubrectangle(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 返回 100</span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 返回 100</span></span><br><span class="line">subrectangleQueries.updateSubrectangle(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">subrectangleQueries.getValue(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 返回 20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>最多有 500 次<code>updateSubrectangle</code>和 <code>getValue</code>操作。</li><li><code>1 &lt;= rows, cols &lt;= 100</code></li><li><code>rows == rectangle.length</code></li><li><code>cols == rectangle[i].length</code></li><li><code>0 &lt;= row1 &lt;= row2 &lt; rows</code></li><li><code>0 &lt;= col1 &lt;= col2 &lt; cols</code></li><li><code>1 &lt;= newValue, rectangle[i][j] &lt;= 10^9</code></li><li><code>0 &lt;= row &lt; rows</code></li><li><code>0 &lt;= col &lt; cols</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/subrectangle-queries" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subrectangle-queries</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目咋一看非常复杂，实际我们不用每次都去真正的实际改变矩阵的值，只需要去查询即可。</li><li>我们保存更新的列表，找到最近一次更新<code>(row,col)</code>的值即可，时间杂度读O<code>(n^2)</code>。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubrectangleQueries</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SubrectangleQueries(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangle) &#123;</span><br><span class="line">        matrix = rectangle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateSubrectangle</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        start.push_back(make_pair(row1,col1));</span><br><span class="line">        end.push_back(make_pair(row2,col2));</span><br><span class="line">        val.push_back(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row &gt;= start[i].first &amp;&amp; col &gt;= start[i].second &amp;&amp; </span><br><span class="line">               row &lt;= end[i].first &amp;&amp; col &lt;= end[i].second)&#123;</span><br><span class="line">                <span class="keyword">return</span> val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matrix[row][col];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; start;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; end;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SubrectangleQueries object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SubrectangleQueries* obj = new SubrectangleQueries(rectangle);</span></span><br><span class="line"><span class="comment"> * obj-&gt;updateSubrectangle(row1,col1,row2,col2,newValue);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;getValue(row,col);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5423-找两个和为目标值且不重叠的子数组"><a href="#5423-找两个和为目标值且不重叠的子数组" class="headerlink" title="5423. 找两个和为目标值且不重叠的子数组"></a>5423. 找两个和为目标值且不重叠的子数组</h2><p>给你一个整数数组 <code>arr</code> 和一个整数值 <code>target</code> 。</p><p>请你在<code>arr</code>中找 两个互不重叠的子数组 且它们的和都等于 <code>target</code>。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。</p><p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：只有两个子数组和为 <span class="number">3</span> （[<span class="number">3</span>] 和 [<span class="number">3</span>]）。它们的长度和为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], target = <span class="number">7</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：尽管我们有 <span class="number">3</span> 个互不重叠的子数组和为 <span class="number">7</span> （[<span class="number">7</span>], [<span class="number">3</span>,<span class="number">4</span>] 和 [<span class="number">7</span>]），但我们会选择第一个和第三个子数组，因为它们的长度和 <span class="number">2</span> 是最小值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：我们只有一个和为 <span class="number">6</span> 的子数组。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：我们无法找到和为 <span class="number">3</span> 的子数组。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：注意子数组 [<span class="number">1</span>,<span class="number">2</span>] 和 [<span class="number">2</span>,<span class="number">1</span>] 不能成为一个方案因为它们重叠了。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li><li><code>1 &lt;= target &lt;= 10^8</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们设<code>dp[i]</code>表示前<code>i</code>个元素中存在的连续子数组和为<code>target</code>的最小长度。</li><li>由于数组中所有的数都为正数，所以我们可以利用hash值来快速查询以索引<code>i</code>为结尾且和为<code>target</code>的连续子数组是否存在，如果存在则它的长度肯定是唯一的,我们可以利用<code>hash[sum-target]]</code>快速的得该连续子数组的最左的起点位置索引<code>j</code>，即可快速求出连续子数组的长度.我们用<code>len(target,i)</code>代表和为<code>target</code>且最右边的终点为索引<code>i</code>的连续子数组的长度。则可以得到公式为：<script type="math/tex; mode=display">\begin{array}{l}minSum = min(minSum,len(target,i) + dp[i-len(target,i)]) \quad (if \quad len(target,i) > 0) \\\\dp[i] = min(dp[i-1],len(target,i)) \quad (if \quad len(target,i) > 0) \\\end{array}</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSumOfLengths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> res = n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,n+<span class="number">1</span>);</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            cnt[sum] = i;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(sum-target))&#123;</span><br><span class="line">                <span class="keyword">int</span> prev = cnt[sum-target];</span><br><span class="line">                <span class="keyword">if</span>(prev &gt;= <span class="number">0</span> &amp;&amp; dp[prev] &lt;= n)&#123;</span><br><span class="line">                    res = min(i - prev + dp[prev],res);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = min(dp[i],i - prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5421-安排邮筒"><a href="#5421-安排邮筒" class="headerlink" title="5421. 安排邮筒"></a>5421. 安排邮筒</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个房屋数组houses 和一个整数<code>k</code>，其中 <code>houses[i]</code>是第 <code>i</code>栋房子在一条街上的位置，现需要在这条街上安排<code>k</code>个邮筒。</p><p>请你返回每栋房子与离它最近的邮筒之间的距离的 最小 总和。</p><p>答案保证在 32 位有符号整数范围以内。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">20</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：将邮筒分别安放在位置 <span class="number">3</span>， <span class="number">9</span> 和 <span class="number">20</span> 处。</span><br><span class="line">每个房子到最近邮筒的距离和为 |<span class="number">3</span><span class="number">-1</span>| + |<span class="number">4</span><span class="number">-3</span>| + |<span class="number">9</span><span class="number">-8</span>| + |<span class="number">10</span><span class="number">-9</span>| + |<span class="number">20</span><span class="number">-20</span>| = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">18</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：将邮筒分别安放在位置 <span class="number">3</span> 和 <span class="number">14</span> 处。</span><br><span class="line">每个房子到最近邮筒距离和为 |<span class="number">2</span><span class="number">-3</span>| + |<span class="number">3</span><span class="number">-3</span>| + |<span class="number">5</span><span class="number">-3</span>| + |<span class="number">12</span><span class="number">-14</span>| + |<span class="number">18</span><span class="number">-14</span>| = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：houses = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">10</span>], k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == houses.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= houses[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= n</code></li><li>数组 <code>houses</code> 中的整数互不相同。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/allocate-mailboxes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/allocate-mailboxes</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>题目出的非常好，中位数 + DP。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先这个题目需要了解一下背景知识，在一个已经排序的数列中，数列中所有元素与中位数绝对值之差的和最小:<script type="math/tex; mode=display">\begin{array}{l}A = [a_{1},a_{2},a_{3},...,a_{n}] \\\\minimum\sum_{i=1}^{n} |a_{i} - X| = \sum_{i=1}^{n} |a_{i} - A_{median}| \\\end{array}</script><script type="math/tex; mode=display">A_{median} = \left\{\begin{array}{l}a_{\frac{n+1}{2}} \quad n\pmod 2 = 1\\\\\frac{a_{\frac{n}{2}} +  a_{\frac{n}{2} + 1}}{2} \quad n\pmod 2 = 0\\\end{array}\right.</script>数列中所有的元素与平均和的差的平方和最小。<script type="math/tex; mode=display">\begin{array}{l}A = [a_{1},a_{2},a_{3},...,a_{n}] \\\\minimum\sum_{i=1}^{n} (a_{i} - X)^{2} = \sum_{i=1}^{n} |a_{i} - \overline{A}| \\\\\overline{A} = \frac{\sum_{i=1}^{n}a_{i}}{n} \\\end{array}</script></li><li>根据1的提示，我们可以很容易算出，如果在第<code>i</code>到<code>j</code>个<code>house</code>之间放置一个邮箱，那么该邮箱肯定放置在<code>house[i]</code>与<code>house[j]</code>的序列之间的中位数，很容易算出最小距离。我们假设<code>cost[i][j]</code>代表在<code>i</code>到<code>j</code>之间放置1个邮箱的最小距离之和，则：<script type="math/tex; mode=display">cost[i][j] = \sum_{k=i}^{j}abs(house[k]-A(i,j)_{median})</script></li><li>我们设递推公式<code>dp[i][j]</code>代表前<code>i</code>个house中放置<code>j</code>个邮箱的最小距离之和。我们只需要关心，新加入的第<code>j</code>个邮箱，有哪些<code>house</code>是到它的距离最短，假如我们已知最优解<code>dp[i][j]</code>,我们就需要去分别讨论有哪些<code>house</code>是以第<code>j</code>个邮箱为最近距离。则递推公式应该为:<script type="math/tex; mode=display">dp[i][j] = min(dp[i][j],dp[k][j-1] + cost[k+1][i]) \quad (k\in(j-1,i-1))</script></li><li>题目还是非常难的，需要仔细理解dp和部分数学定理。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = houses.size();</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        sort(houses.begin(),houses.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cost(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>((j-i+<span class="number">1</span>)%<span class="number">2</span> == <span class="number">0</span>) mid = (houses[(i+j)/<span class="number">2</span><span class="number">-1</span>] + houses[(i+j)/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> mid = houses[(i+j)/<span class="number">2</span><span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++k)&#123;</span><br><span class="line">                    cost[i][j] += <span class="built_in">abs</span>(houses[k<span class="number">-1</span>]-mid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = cost[<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = max(<span class="number">1</span>,j<span class="number">-1</span>); k &lt;= i - <span class="number">1</span>; ++k)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j],dp[k][j<span class="number">-1</span>] + cost[k+<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;28周双周赛&quot;&gt;&lt;a href=&quot;#28周双周赛&quot; class=&quot;headerlink&quot; title=&quot;28周双周赛&quot;&gt;&lt;/a&gt;28周双周赛&lt;/h1&gt;&lt;p&gt;前3题半个小时搞定，最后一题又是经典的DP，在最后20分钟想出来了解决办法，但是没有时间提交了，最终排名竟然还挺高152名。赛后又加班搞了半个小时搞定了。其中涉及到一个中位数的数学理论。感慨下还是智商不够高。&lt;br&gt;&lt;img src=&quot;https://mike-box.github.io/images/171-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周双周赛的第四题出的非常好，又有数学理论和dp相结合，题目非常经典，虽然当时没有做出来，但是赛后靠自己的理解没有看答案做出来了，我觉得每次做题锻炼自己独立思考问题的能力非常重要，而不是上来就看答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 192周比赛</title>
    <link href="http://yoursite.com/2020/06/07/170/"/>
    <id>http://yoursite.com/2020/06/07/170/</id>
    <published>2020-06-07T08:23:30.556Z</published>
    <updated>2020-06-08T13:25:34.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="192周双周赛"><a href="#192周双周赛" class="headerlink" title="192周双周赛"></a>192周双周赛</h1><p>最后一题又是经典的DP，中间某个小case过不去，一直卡了好长时间，最后在1：28提交正确，最终排名242名。感慨还是老了，脑袋转不动，其实这些题目本质就是考智商。<br><img src="https://mike-box.github.io/images/172-1.png" alt="1"></p><h2 id="5428-重新排列数组"><a href="#5428-重新排列数组" class="headerlink" title="5428. 重新排列数组"></a>5428. 重新排列数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code> ，数组中有<code>2n</code>个元素，按 <code>[x1,x2,...,xn,y1,y2,...,yn]</code> 的格式排列。</p><a id="more"></a><p>请你将数组按 <code>[x1,y1,x2,y2,...,xn,yn]</code> 格式重新排列，返回重排后的数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] </span><br><span class="line">解释：由于 x1=<span class="number">2</span>, x2=<span class="number">5</span>, x3=<span class="number">1</span>, y1=<span class="number">3</span>, y2=<span class="number">4</span>, y3=<span class="number">7</span> ，所以答案为 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 500</code></li><li><code>nums.length == 2n</code></li><li><code>1 &lt;= nums[i] &lt;= 10^3</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/shuffle-the-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-192/problems/shuffle-the-array/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>按照(i,n+i)的顺序依次压入数组即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shuffle(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">            res.push_back(nums[n+i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5429-数组中的-k-个最强值"><a href="#5429-数组中的-k-个最强值" class="headerlink" title="5429. 数组中的 k 个最强值"></a>5429. 数组中的 k 个最强值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code> 和一个整数<code>k</code> 。</p><p>设 m 为数组的中位数，只要满足下述两个前提之一，就可以判定 <code>arr[i]</code> 的值比 <code>arr[j]</code>的值更强：</p><ul><li><code>|arr[i] - m| &gt; |arr[j] - m|</code></li><li><code>|arr[i] - m| == |arr[j] - m|，且 arr[i] &gt; arr[j]</code><br>请返回由数组中最强的 k 个值组成的列表。答案可以以 任意顺序 返回。</li></ul><p>中位数 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 n ，那么中位数就是该有序列表（下标从 0 开始）中位于 <code>((n - 1) / 2)</code>的元素。</p><p>例如 <code>arr = [6, -3, 7, 2, 11]</code>，n = 5：数组排序后得到 <code>arr = [-3, 2, 6, 7, 11]</code>，数组的中间位置为<code>m = ((5 - 1) / 2) = 2</code>，中位数 arr[m] 的值为 6 。<br>例如 <code>arr = [-7, 22, 17, 3]</code>，<code>n = 4</code>：数组排序后得到<code>arr = [-7, 3, 17, 22]</code>，数组的中间位置为 <code>m = ((4 - 1) / 2) = 1</code> ，中位数 <code>arr[m]</code> 的值为 3 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">解释：中位数为 <span class="number">3</span>，按从强到弱顺序排序后，数组变为 [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]。最强的两个元素是 [<span class="number">5</span>, <span class="number">1</span>]。[<span class="number">1</span>, <span class="number">5</span>] 也是正确答案。</span><br><span class="line">注意，尽管 |<span class="number">5</span> - <span class="number">3</span>| == |<span class="number">1</span> - <span class="number">3</span>| ，但是 <span class="number">5</span> 比 <span class="number">1</span> 更强，因为 <span class="number">5</span> &gt; <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">解释：中位数为 <span class="number">3</span>, 按从强到弱顺序排序后，数组变为 [<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]。最强的两个元素是 [<span class="number">5</span>, <span class="number">5</span>]。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>], k = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">11</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">解释：中位数为 <span class="number">7</span>, 按从强到弱顺序排序后，数组变为 [<span class="number">11</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>]。</span><br><span class="line">[<span class="number">11</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>] 的任何排列都是正确答案。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">6</span>,<span class="number">-3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">11</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">-3</span>,<span class="number">11</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">-7</span>,<span class="number">22</span>,<span class="number">17</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">22</span>,<span class="number">17</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-10^5 &lt;= arr[i] &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= arr.length</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/the-k-strongest-values-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-192/problems/the-k-strongest-values-in-an-array/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>讲数组从小到达排序，求出中位数</li><li>按照与中位数的差的绝对值大小进行排序即可，二重排序即可，非常简单，太无聊了，这个题目。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first == b.first) <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getStrongest(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copy = arr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; A;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        </span><br><span class="line">        sort(copy.begin(),copy.end());</span><br><span class="line">        <span class="keyword">int</span> m = copy[(n<span class="number">-1</span>)/<span class="number">2</span>]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            A.push_back(make_pair(<span class="built_in">abs</span>(arr[i]-m),arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(A.begin(),A.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            res.push_back(A[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5430-设计浏览器历史记录"><a href="#5430-设计浏览器历史记录" class="headerlink" title="5430. 设计浏览器历史记录"></a>5430. 设计浏览器历史记录</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你有一个只支持单个标签页的 浏览器 ，最开始你浏览的网页是<code>homepage</code>，你可以访问其他的网站 <code>url</code> ，也可以在浏览历史中后退 <code>steps</code>步或前进 <code>steps</code> 步。</p><p>请你实现 BrowserHistory 类：</p><ul><li><code>BrowserHistory(string homepage)</code>，用 <code>homepage</code>初始化浏览器类。</li><li><code>void visit(string url)</code>从当前页跳转访问<code>url</code>对应的页面  。执行此操作会把浏览历史前进的记录全部删除。</li><li><code>string back(int steps)</code>在浏览历史中后退 <code>steps</code> 步。如果你只能在浏览历史中后退至多 x 步且 <code>steps &gt; x</code> ，那么你只后退 x 步。请返回后退 至多 <code>steps</code> 步以后的 <code>url</code> 。</li><li><code>string forward(int steps)</code>在浏览历史中前进 <code>steps</code> 步。如果你只能在浏览历史中前进至多 x 步且 steps &gt; x ，那么你只前进 x 步。请返回前进 至多 <code>steps</code>步以后的<code>url</code> 。</li></ul><p>示例：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"BrowserHistory"</span>,<span class="string">"visit"</span>,<span class="string">"visit"</span>,<span class="string">"visit"</span>,<span class="string">"back"</span>,<span class="string">"back"</span>,<span class="string">"forward"</span>,<span class="string">"visit"</span>,<span class="string">"forward"</span>,<span class="string">"back"</span>,<span class="string">"back"</span>]</span><br><span class="line">[[<span class="string">"leetcode.com"</span>],[<span class="string">"google.com"</span>],[<span class="string">"facebook.com"</span>],[<span class="string">"youtube.com"</span>],[<span class="number">1</span>],[<span class="number">1</span>],[<span class="number">1</span>],[<span class="string">"linkedin.com"</span>],[<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">7</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,<span class="string">"facebook.com"</span>,<span class="string">"google.com"</span>,<span class="string">"facebook.com"</span>,null,<span class="string">"linkedin.com"</span>,<span class="string">"google.com"</span>,<span class="string">"leetcode.com"</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="symbol">BrowserHistory</span> browserHistory = new <span class="symbol">BrowserHistory</span>(<span class="string">"leetcode.com"</span>);</span><br><span class="line">browserHistory.visit(<span class="string">"google.com"</span>);       // 你原本在浏览 <span class="string">"leetcode.com"</span> 。访问 <span class="string">"google.com"</span></span><br><span class="line">browserHistory.visit(<span class="string">"facebook.com"</span>);     // 你原本在浏览 <span class="string">"google.com"</span> 。访问 <span class="string">"facebook.com"</span></span><br><span class="line">browserHistory.visit(<span class="string">"youtube.com"</span>);      // 你原本在浏览 <span class="string">"facebook.com"</span> 。访问 <span class="string">"youtube.com"</span></span><br><span class="line">browserHistory.back(<span class="number">1</span>);                   // 你原本在浏览 <span class="string">"youtube.com"</span> ，后退到 <span class="string">"facebook.com"</span> 并返回 <span class="string">"facebook.com"</span></span><br><span class="line">browserHistory.back(<span class="number">1</span>);                   // 你原本在浏览 <span class="string">"facebook.com"</span> ，后退到 <span class="string">"google.com"</span> 并返回 <span class="string">"google.com"</span></span><br><span class="line">browserHistory.forward(<span class="number">1</span>);                // 你原本在浏览 <span class="string">"google.com"</span> ，前进到 <span class="string">"facebook.com"</span> 并返回 <span class="string">"facebook.com"</span></span><br><span class="line">browserHistory.visit(<span class="string">"linkedin.com"</span>);     // 你原本在浏览 <span class="string">"facebook.com"</span> 。 访问 <span class="string">"linkedin.com"</span></span><br><span class="line">browserHistory.forward(<span class="number">2</span>);                // 你原本在浏览 <span class="string">"linkedin.com"</span> ，你无法前进任何步数。</span><br><span class="line">browserHistory.back(<span class="number">2</span>);                   // 你原本在浏览 <span class="string">"linkedin.com"</span> ，后退两步依次先到 <span class="string">"facebook.com"</span> ，然后到 <span class="string">"google.com"</span> ，并返回 <span class="string">"google.com"</span></span><br><span class="line">browserHistory.back(<span class="number">7</span>);                   // 你原本在浏览 <span class="string">"google.com"</span>， 你只能后退一步到 <span class="string">"leetcode.com"</span> ，并返回 <span class="string">"leetcode.com"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= homepage.length &lt;= 20</code></li><li><code>1 &lt;= url.length &lt;= 20</code></li><li><code>1 &lt;= steps &lt;= 100</code></li><li><code>homepage</code> 和 <code>url</code> 都只包含 ‘.’ 或者小写英文字母。</li><li>最多调用 <code>5000</code> 次 <code>visit</code>， <code>back</code>和 <code>forward</code>函数。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 栈</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目很无聊，不晓得要考什么非常没有技巧。</li><li>很简单的栈操作即可，所有的pages都保存在栈中，每次保存back操作和forward操作的游标，一旦进行visit操作后，将当前游标后的元素全部从栈中删除即可。</li><li>每次进行back操作时不能超过0，每次进行forward操作时不能超过数组的现有长度。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BrowserHistory(<span class="built_in">string</span> homepage) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pages.push_back(homepage);</span><br><span class="line">        <span class="keyword">this</span>-&gt;last = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="built_in">string</span> url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pages.size()<span class="number">-1</span>; i &gt; last; --i)&#123;</span><br><span class="line">            pages.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        pages.push_back(url);</span><br><span class="line">        <span class="keyword">this</span>-&gt;last = pages.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        last  = max(last-steps,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pages[last];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        last = min(last + steps,<span class="keyword">int</span>(pages.size()<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> pages[last];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pages;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BrowserHistory object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BrowserHistory* obj = new BrowserHistory(homepage);</span></span><br><span class="line"><span class="comment"> * obj-&gt;visit(url);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;back(steps);</span></span><br><span class="line"><span class="comment"> * string param_3 = obj-&gt;forward(steps);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5431-给房子涂色-III"><a href="#5431-给房子涂色-III" class="headerlink" title="5431. 给房子涂色 III"></a>5431. 给房子涂色 III</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。</p><p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code>，它包含 5 个街区 <code>[{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p><p>给你一个数组 <code>houses</code> ，一个 <code>m * n</code>的矩阵 <code>cost</code> 和一个整数<code>target</code> ，其中：</p><ul><li><code>houses[i]</code>：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。</li><li><code>cost[i][j]</code>：是将第 i 个房子涂成颜色 <code>j+1</code> 的花费。<br>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 <code>-1</code>。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], cost = [[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">5</span>,<span class="number">1</span>]], m = <span class="number">5</span>, n = <span class="number">2</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：房子涂色方案为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">此方案包含 target = <span class="number">3</span> 个街区，分别是 [&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>,<span class="number">1</span>&#125;]。</span><br><span class="line">涂色的总花费为 (<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">5</span>) = <span class="number">9</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>], cost = [[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">5</span>,<span class="number">1</span>]], m = <span class="number">5</span>, n = <span class="number">2</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：有的房子已经被涂色了，在此基础上涂色方案为 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">此方案包含 target = <span class="number">3</span> 个街区，分别是 [&#123;<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>&#125;]。</span><br><span class="line">给第一个和最后一个房子涂色的花费为 (<span class="number">10</span> + <span class="number">1</span>) = <span class="number">11</span>。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], cost = [[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">10</span>]], m = <span class="number">5</span>, n = <span class="number">2</span>, target = <span class="number">5</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], cost = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]], m = <span class="number">4</span>, n = <span class="number">3</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：房子已经被涂色并组成了 <span class="number">4</span> 个街区，分别是 [&#123;<span class="number">3</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;] ，无法形成 target = <span class="number">3</span> 个街区。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == houses.length == cost.length</code></li><li><code>n == cost[i].length</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= target &lt;= m</code></li><li><code>0 &lt;= houses[i] &lt;= n</code></li><li><code>1 &lt;= cost[i][j] &lt;= 10^4</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/paint-house-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-192/problems/paint-house-iii/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>经典的DP</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>如果经常做DP相关的题目的话，这个题实际上就非常简单。但是细节考虑还是蛮复杂的。</li><li>我们首先需要得到递推公式，我们设<code>dp[i][j][k]</code>代表前<code>i</code>个<code>house</code>被染色分成了<code>j</code>个街区，且第<code>i</code>个街区被染成了第<code>k</code>种颜色的最小代价。</li><li>根据2的递推公式，我们实际上有两种情况需要单独进行讨论。</li></ol><ul><li>第i个<code>house</code>初始颜色在去年夏天已经被染成了颜色<code>c</code>,则这时<code>dp[i][j][c]</code>是可能存在的，其余<code>dp[i][j][x]且 x != c</code>为-1,且这时第<code>i</code>个house不能被染成其他颜色。<script type="math/tex; mode=display">dp[i][j][x] = \left\{\begin{array}{l}min(dp[i][j][x],dp[i-1][j][x])  \quad (x = c) \\\\min(dp[i][j][x],dp[i-1][j-1][y]) \quad (x = c \quad and \quad y \neq x)\\\\-1 \quad \quad (x \neq c)\end{array}\right.</script></li><li>第i个<code>house</code>初始颜色为<code>0</code>,这时第<code>i</code>个<code>house</code>可以被染成其他任何颜色。<script type="math/tex; mode=display">dp[i][j][x] = \left\{\begin{array}{l}min(dp[i][j][x],dp[i-1][j][x] + cost[i][x])   \\\\min(dp[i][j][x],dp[i-1][j-1][y] + cost[i][y])   \quad (y \neq x)\\\end{array}\right.</script></li></ul><ol><li>实际根据以上的递推公式很容易算法最后刚好满足<code>targe</code>个分区的最小代价。<script type="math/tex; mode=display">minCost = min(dp[m][target][x]) \quad x\in(1,2,3,...,n)</script></li><li>以上是针对第这个题目的详细题解，关键点的初始化必须将<code>dp[0][1][x],dp[0][0][x]</code>设为<code>0</code>。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">101</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cost, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;= n; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= target; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(houses[i<span class="number">-1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(houses[i<span class="number">-1</span>] == k) </span><br><span class="line">                            dp[i][j][houses[i<span class="number">-1</span>]] = min(dp[i][j][houses[i<span class="number">-1</span>]],dp[i<span class="number">-1</span>][j][houses[i<span class="number">-1</span>]]);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            dp[i][j][houses[i<span class="number">-1</span>]] = min(dp[i][j][houses[i<span class="number">-1</span>]],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++l)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(k == l)</span><br><span class="line">                                dp[i][j][k] = min(dp[i][j][k],dp[i<span class="number">-1</span>][j][k] + cost[i<span class="number">-1</span>][k<span class="number">-1</span>]);</span><br><span class="line">                            <span class="keyword">else</span> </span><br><span class="line">                                dp[i][j][k] = min(dp[i][j][k],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][l] + cost[i<span class="number">-1</span>][k<span class="number">-1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            res = min(res, dp[m][target][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">0x3f3f3f3f</span>?<span class="number">-1</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;192周双周赛&quot;&gt;&lt;a href=&quot;#192周双周赛&quot; class=&quot;headerlink&quot; title=&quot;192周双周赛&quot;&gt;&lt;/a&gt;192周双周赛&lt;/h1&gt;&lt;p&gt;最后一题又是经典的DP，中间某个小case过不去，一直卡了好长时间，最后在1：28提交正确，最终排名242名。感慨还是老了，脑袋转不动，其实这些题目本质就是考智商。&lt;br&gt;&lt;img src=&quot;https://mike-box.github.io/images/172-1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5428-重新排列数组&quot;&gt;&lt;a href=&quot;#5428-重新排列数组&quot; class=&quot;headerlink&quot; title=&quot;5428. 重新排列数组&quot;&gt;&lt;/a&gt;5428. 重新排列数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; ，数组中有&lt;code&gt;2n&lt;/code&gt;个元素，按 &lt;code&gt;[x1,x2,...,xn,y1,y2,...,yn]&lt;/code&gt; 的格式排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 算法课程</title>
    <link href="http://yoursite.com/2020/06/03/169/"/>
    <id>http://yoursite.com/2020/06/03/169/</id>
    <published>2020-06-03T05:09:50.568Z</published>
    <updated>2020-06-03T05:10:18.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，这个课程是数据结构的课程，当然对于数据结构这门课程基本的东西已经非常的熟悉了，。<br>对于特别需要独立思考的问题，适当建议对于卡到壳的时候，一定要先放一放，去外面散步或者多运动，只有这样利用自己的发散思维就能把问题解决出来，仔细思考一下这种思考模式，在《learning how to learn》课程中学到的知识应用到这些科学知识，真的是非常有用。<br>抽了大概一周的时间把课程《Data Structure》学习完了，这部分的课程有些还是非常难，最后的<code>splaytree</code>太复杂了，没有做完，总得来说质量还是非常高得，虽然里面得算法大部分都学过，还是继续温习了一遍，已经会得算法就没有仔细再重新学习掌握，主要把<code>hashtable</code>和<code>splaytree</code>又重新温习了一遍。最后得分是<code>85.90</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/WMMZ3YUHX4QA" target="_blank" rel="noopener">Data Structure</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Data%20Structrues" target="_blank" rel="noopener">source code</a></p><a id="more"></a><h2 id="week1-Basic-Data-Structures"><a href="#week1-Basic-Data-Structures" class="headerlink" title="week1.Basic Data Structures"></a>week1.Basic Data Structures</h2><p>basic data strucures主要是关于基本得队列、栈、链表的基本应用，题目还是有一些难度，如果对算法和数据结构不是很熟悉的话，对付<code>homework</code> 还是非常花时间的。</p><h3 id="1-1-Check-brackets-in-the-code"><a href="#1-1-Check-brackets-in-the-code" class="headerlink" title="1 1 Check brackets in the code"></a>1 1 Check brackets in the code</h3><p><strong>Input Format</strong>. Input contains one string 𝑆 which consists of big and small latin letters, digits, punctuation marks and brackets from the set []{}().<br><strong>Constraints</strong>. The length of 𝑆 is at least 1 and at most 105.<br><strong>Output Format</strong>. If the code in 𝑆 uses brackets correctly, output “Success” (without the quotes). Otherwise,<br>output the 1-based index of the first unmatched closing bracket, and if there are no unmatched closing<br>brackets, output the 1-based index of the first unmatched opening bracket.</p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> 经典的左右括号匹配问题</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>这题非常简单，用栈即可解决。遇到左括号入栈，遇到右括号如果与栈顶匹配，则出栈。<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bracket</span> &#123;</span></span><br><span class="line">    Bracket(<span class="keyword">char</span> type, <span class="keyword">int</span> position):</span><br><span class="line">        type(type),</span><br><span class="line">        position(position)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Matchc</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">'['</span> &amp;&amp; c == <span class="string">']'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">'&#123;'</span> &amp;&amp; c == <span class="string">'&#125;'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">'('</span> &amp;&amp; c == <span class="string">')'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> type;</span><br><span class="line">    <span class="keyword">int</span> position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, text);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span> &lt;Bracket&gt; opening_brackets_stack;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">0</span>; position &lt; text.length(); ++position) &#123;</span><br><span class="line">        <span class="keyword">char</span> next = text[position];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="string">'('</span> || next == <span class="string">'['</span> || next == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">            <span class="comment">// Process opening bracket, write your code here</span></span><br><span class="line">            opening_brackets_stack.push(Bracket(next,position+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="string">')'</span> || next == <span class="string">']'</span> || next == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">            <span class="comment">// Process closing bracket, write your code here</span></span><br><span class="line">            <span class="keyword">if</span>(opening_brackets_stack.empty()||!opening_brackets_stack.top().Matchc(next))&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;position+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            opening_brackets_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Printing answer, write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(opening_brackets_stack.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Success"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;opening_brackets_stack.top().position;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Compute-tree-height"><a href="#2-Compute-tree-height" class="headerlink" title="2 Compute tree height"></a>2 Compute tree height</h3><p><strong>Task</strong>. You are given a description of a rooted tree. Your task is to compute and output its height. Recall<br>that the height of a (rooted) tree is the maximum depth of a node, or the maximum distance from a<br>leaf to the root. You are given an arbitrary tree, not necessarily a binary tree.<br><strong>Input Format</strong>. The first line contains the number of nodes 𝑛. The second line contains 𝑛 integer numbers<br>from −1 to 𝑛 − 1 — parents of nodes. If the 𝑖-th one of them (0 ≤ 𝑖 ≤ 𝑛 − 1) is −1, node 𝑖 is the root,<br>otherwise it’s 0-based index of the parent of 𝑖-th node. It is guaranteed that there is exactly one root.<br>It is guaranteed that the input represents a tree.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105.<br><strong>Output Format</strong>. Output the height of the tree.</p><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>DFS</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol><li>经典的利用递归的DFS求数的高度。</li><li>用BFS实现也可以，层次遍历即可。<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    Node *parent;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Node *theParent)</span> </span>&#123;</span><br><span class="line">      parent = theParent;</span><br><span class="line">      parent-&gt;children.push_back(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main_with_large_stack_space</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> max_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line">  nodes.resize(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> child_index = <span class="number">0</span>; child_index &lt; n; child_index++) &#123;</span><br><span class="line">    <span class="keyword">int</span> parent_index;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; parent_index;</span><br><span class="line">    <span class="keyword">if</span>(parent_index == <span class="number">-1</span>) root = child_index;</span><br><span class="line">    <span class="keyword">if</span> (parent_index &gt;= <span class="number">0</span>)</span><br><span class="line">      nodes[child_index].setParent(&amp;nodes[parent_index]);</span><br><span class="line">    nodes[child_index].key = child_index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  qu.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">          qu.pop();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> v : nodes[curr].children)&#123;</span><br><span class="line">              qu.push(v-&gt;key);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      max_height++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;max_height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__APPLE__)</span></span><br><span class="line">  <span class="comment">// Allow larger stack space</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">rlim_t</span> kStackSize = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>;   <span class="comment">// min stack size = 16 MB</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  result = getrlimit(RLIMIT_STACK, &amp;rl);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (rl.rlim_cur &lt; kStackSize)</span><br><span class="line">      &#123;</span><br><span class="line">          rl.rlim_cur = kStackSize;</span><br><span class="line">          result = setrlimit(RLIMIT_STACK, &amp;rl);</span><br><span class="line">          <span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"setrlimit returned result = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> main_with_large_stack_space();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Network-packet-processing-simulation"><a href="#3-Network-packet-processing-simulation" class="headerlink" title="3 Network packet processing simulation"></a>3 Network packet processing simulation</h3><p><strong>Task</strong>. You are given a series of incoming network packets, and your task is to simulate their processing.<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Packets arrive <span class="keyword">in</span> some order. For <span class="keyword">each</span> packet <span class="built_in">number</span> 𝑖, you know <span class="keyword">the</span> <span class="built_in">time</span> when <span class="keyword">it</span> arrived 𝐴𝑖 <span class="keyword">and</span> <span class="keyword">the</span></span><br><span class="line"><span class="built_in">time</span> <span class="keyword">it</span> takes <span class="keyword">the</span> processor <span class="built_in">to</span> <span class="built_in">process</span> <span class="keyword">it</span> 𝑃𝑖 (both <span class="keyword">in</span> <span class="built_in">milliseconds</span>). There is only <span class="literal">one</span> processor, <span class="keyword">and</span> <span class="keyword">it</span></span><br><span class="line">processes <span class="keyword">the</span> incoming packets <span class="keyword">in</span> <span class="keyword">the</span> order <span class="keyword">of</span> their arrival. If <span class="keyword">the</span> processor started <span class="built_in">to</span> <span class="built_in">process</span> some</span><br><span class="line">packet, <span class="keyword">it</span> doesn’t interrupt <span class="keyword">or</span> <span class="built_in">stop</span> <span class="keyword">until</span> <span class="keyword">it</span> finishes <span class="keyword">the</span> processing <span class="keyword">of</span> this packet, <span class="keyword">and</span> <span class="keyword">the</span> processing <span class="keyword">of</span></span><br><span class="line">packet 𝑖 takes exactly 𝑃𝑖 <span class="built_in">milliseconds</span>.</span><br><span class="line">The computer processing <span class="keyword">the</span> packets has <span class="keyword">a</span> network buffer <span class="keyword">of</span> fixed size 𝑆. When packets arrive,</span><br><span class="line">they are stored <span class="keyword">in</span> <span class="keyword">the</span> buffer <span class="keyword">before</span> being processed. However, <span class="keyword">if</span> <span class="keyword">the</span> buffer is full when <span class="keyword">a</span> packet</span><br><span class="line">arrives (there are 𝑆 packets which have arrived <span class="keyword">before</span> this packet, <span class="keyword">and</span> <span class="keyword">the</span> computer hasn’t finished</span><br><span class="line">processing <span class="keyword">any</span> <span class="keyword">of</span> them), <span class="keyword">it</span> is dropped <span class="keyword">and</span> won’t be processed <span class="keyword">at</span> all. If several packets arrive <span class="keyword">at</span> <span class="keyword">the</span></span><br><span class="line">same <span class="built_in">time</span>, they are <span class="keyword">first</span> all stored <span class="keyword">in</span> <span class="keyword">the</span> buffer (some <span class="keyword">of</span> them may be dropped because <span class="keyword">of</span> that —</span><br><span class="line">those which are described later <span class="keyword">in</span> <span class="keyword">the</span> input). The computer processes <span class="keyword">the</span> packets <span class="keyword">in</span> <span class="keyword">the</span> order <span class="keyword">of</span></span><br><span class="line">their arrival, <span class="keyword">and</span> <span class="keyword">it</span> starts processing <span class="keyword">the</span> next available packet <span class="built_in">from</span> <span class="keyword">the</span> buffer <span class="keyword">as</span> soon <span class="keyword">as</span> <span class="keyword">it</span> finishes</span><br><span class="line">processing <span class="keyword">the</span> previous <span class="literal">one</span>. If <span class="keyword">at</span> some point <span class="keyword">the</span> computer is <span class="keyword">not</span> busy, <span class="keyword">and</span> there are no packets <span class="keyword">in</span></span><br><span class="line"><span class="keyword">the</span> buffer, <span class="keyword">the</span> computer just waits <span class="keyword">for</span> <span class="keyword">the</span> next packet <span class="built_in">to</span> arrive. Note that <span class="keyword">a</span> packet leaves <span class="keyword">the</span> buffer</span><br><span class="line"><span class="keyword">and</span> frees <span class="keyword">the</span> <span class="literal">space</span> <span class="keyword">in</span> <span class="keyword">the</span> buffer <span class="keyword">as</span> soon <span class="keyword">as</span> <span class="keyword">the</span> computer finishes processing <span class="keyword">it</span>.</span><br></pre></td></tr></table></figure><br><strong>Input Format</strong>. The first line of the input contains the size 𝑆 of the buffer and the number 𝑛 of incoming<br>network packets. Each of the next 𝑛 lines contains two numbers. 𝑖-th line contains the time of arrival<br>𝐴𝑖 and the processing time 𝑃𝑖 (both in milliseconds) of the 𝑖-th packet. It is guaranteed that the<br>sequence of arrival times is non-decreasing (however, it can contain the exact same times of arrival in<br>milliseconds — in this case the packet which is earlier in the input is considered to have arrived earlier).<br><strong>Constraints</strong>. All the numbers in the input are integers. 1 ≤ 𝑆 ≤ 105; 0 ≤ 𝑛 ≤ 105; 0 ≤ 𝐴𝑖 ≤ 106;<br>0 ≤ 𝑃𝑖 ≤ 103; 𝐴𝑖 ≤ 𝐴𝑖+1 for 1 ≤ 𝑖 ≤ 𝑛 − 1.<br><strong>Output Format</strong>. For each packet output either the moment of time (in milliseconds) when the processor<br>began processing it or −1 if the packet was dropped (output the answers for the packets in the same<br>order as the packets are given in the input).</p><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>队列</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>如果当前队列为空，则直接将当前的packet入队列，同时给出response。</li><li>如果当前队列不为空，则将所有处理时间小于当前达到时间的packet全部出队列。这时判断队列中缓存的packet数目是否达到最大长度，如果达到最大长度上线，则将当前到达的packet丢弃，否则直接入队列。</li><li>题目还是有点意思，稍微用点技巧，非常适合面试。</li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Request</span> &#123;</span></span><br><span class="line">    Request(<span class="keyword">int</span> arrival_time, <span class="keyword">int</span> process_time):</span><br><span class="line">        arrival_time(arrival_time),</span><br><span class="line">        process_time(process_time)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arrival_time;</span><br><span class="line">    <span class="keyword">int</span> process_time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Response</span> &#123;</span></span><br><span class="line">    Response(<span class="keyword">bool</span> dropped, <span class="keyword">int</span> start_time):</span><br><span class="line">        dropped(dropped),</span><br><span class="line">        start_time(start_time)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> dropped;</span><br><span class="line">    <span class="keyword">int</span> start_time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Buffer(<span class="keyword">int</span> size):</span><br><span class="line">        size_(size),</span><br><span class="line">        finish_time_()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">Process</span><span class="params">(<span class="keyword">const</span> Request &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span> arrive = request.arrival_time;</span><br><span class="line">        <span class="keyword">int</span> process = request.process_time;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!finish_time_.empty() &amp;&amp; arrive &gt;= finish_time_.front())&#123;</span><br><span class="line">            finish_time_.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(finish_time_.empty())&#123;</span><br><span class="line">            finish_time_.push_back(arrive + process);            </span><br><span class="line">            <span class="keyword">return</span> Response(<span class="literal">false</span>,arrive);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(finish_time_.size() == size_)&#123;</span><br><span class="line">                <span class="keyword">return</span> Response(<span class="literal">true</span>,arrive);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> last = finish_time_.back();</span><br><span class="line">                finish_time_.push_back(last + process);</span><br><span class="line">                <span class="keyword">return</span> Response(<span class="literal">false</span>,last);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; finish_time_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Request&gt; ReadRequests() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Request&gt; requests;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> arrival_time, process_time;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; arrival_time &gt;&gt; process_time;</span><br><span class="line">        requests.push_back(Request(arrival_time, process_time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requests;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Response&gt; ProcessRequests(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Request&gt; &amp;requests, Buffer *buffer) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Response&gt; responses;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requests.size(); ++i)</span><br><span class="line">        responses.push_back(buffer-&gt;Process(requests[i]));</span><br><span class="line">    <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintResponses</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Response&gt; &amp;responses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responses.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (responses[i].dropped ? <span class="number">-1</span> : responses[i].start_time) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Request&gt; requests = ReadRequests();</span><br><span class="line"></span><br><span class="line">    <span class="function">Buffer <span class="title">buffer</span><span class="params">(size)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Response&gt; responses = ProcessRequests(requests, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    PrintResponses(responses);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Extending-stack-interface"><a href="#4-Extending-stack-interface" class="headerlink" title="4 Extending stack interface"></a>4 Extending stack interface</h3><p><strong>Task</strong>. Implement a stack supporting the operations Push(), Pop(), and Max().<br><strong>Input Format</strong>. The first line of the input contains the number 𝑞 of queries. Each of the following 𝑞 lines<br>specifies a query of one of the following formats: push v, pop, or max.<br><strong>Constraints</strong>. 1 ≤ 𝑞 ≤ 400 000, 0 ≤ 𝑣 ≤ 105.<br><strong>Output Format</strong>. For each max query, output (on a separate line) the maximum value of the stack.</p><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>经典的最大栈，最小栈的问题</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>经典的最大栈和最小栈问题，不用再详细描述了。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max_element;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackWithMax</span> &#123;</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxElement;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(value);</span><br><span class="line">        <span class="keyword">if</span>(maxElement.empty())&#123;</span><br><span class="line">            maxElement.push_back(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxElement.back() &lt; value)&#123;</span><br><span class="line">                maxElement.push_back(value);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxElement.push_back(maxElement.back());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(<span class="built_in">stack</span>.size());</span><br><span class="line">        <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        maxElement.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        assert(<span class="built_in">stack</span>.size());</span><br><span class="line">        <span class="keyword">return</span> maxElement.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_queries = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num_queries;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> query;</span><br><span class="line">    <span class="built_in">string</span> value;</span><br><span class="line"></span><br><span class="line">    StackWithMax <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_queries; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; query;</span><br><span class="line">        <span class="keyword">if</span> (query == <span class="string">"push"</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; value;</span><br><span class="line">            <span class="built_in">stack</span>.Push(<span class="built_in">std</span>::stoi(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (query == <span class="string">"pop"</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.Pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (query == <span class="string">"max"</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">stack</span>.Max() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-Maximum-in-Sliding-Window"><a href="#5-Maximum-in-Sliding-Window" class="headerlink" title="5 Maximum in Sliding Window"></a>5 Maximum in Sliding Window</h3><p><strong>Input Format</strong>. The first line contains an integer 𝑛, the second line contains 𝑛 integers 𝑎1, . . . , 𝑎𝑛 separated by spaces, the third line contains an integer 𝑚.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105, 1 ≤ 𝑚 ≤ 𝑛, 0 ≤ 𝑎𝑖 ≤ 105 for all 1 ≤ 𝑖 ≤ 𝑛.<br><strong>Output Format</strong>. Output max{𝑎𝑖, . . . , 𝑎𝑖+𝑚−1} for every 1 ≤ 𝑖 ≤ 𝑛 − 𝑚 + 1.</p><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>滑动窗口</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>滑动窗口的最大值问题。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pii &amp; a,<span class="keyword">const</span> pii &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_sliding_window_naive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">const</span> &amp; A, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;pii&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qu.empty())&#123;</span><br><span class="line">            qu.push_back(make_pair(i,A[i]));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!qu.empty() &amp;&amp; A[i] &gt;= qu.back().second)&#123;</span><br><span class="line">                qu.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            qu.push_back(make_pair(i,A[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= w - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;qu.front().second&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">if</span>(qu.front().first &lt;= i - w + <span class="number">1</span>)&#123;</span><br><span class="line">                qu.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A.at(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">    max_sliding_window_naive(A, w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week2-Priority-Queues-and-Disjoint-Sets"><a href="#week2-Priority-Queues-and-Disjoint-Sets" class="headerlink" title="week2. Priority Queues and Disjoint Sets"></a>week2. Priority Queues and Disjoint Sets</h2><h3 id="1-Convert-array-into-heap"><a href="#1-Convert-array-into-heap" class="headerlink" title="1 Convert array into heap"></a>1 Convert array into heap</h3><p><strong>Task</strong>. The first step of the HeapSort algorithm is to create a heap from the array you want to sort. By the<br>way, did you know that algorithms based on Heaps are widely used for external sort, when you need<br>to sort huge files that don’t fit into memory of a computer?<br>Your task is to implement this first step and convert a given array of integers into a heap. You will<br>do that by applying a certain number of swaps to the array. Swap is an operation which exchanges<br>elements 𝑎𝑖 and 𝑎𝑗 of the array 𝑎 for some 𝑖 and 𝑗. You will need to convert the array into a heap using<br>only 𝑂(𝑛) swaps, as was described in the lectures. Note that you will need to use a min-heap instead<br>of a max-heap in this problem.<br><strong>Input Format</strong>. The first line of the input contains single integer 𝑛. The next line contains 𝑛 space-separated<br>integers 𝑎𝑖.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 100 000; 0 ≤ 𝑖, 𝑗 ≤ 𝑛 − 1; 0 ≤ 𝑎0, 𝑎1, . . . , 𝑎𝑛−1 ≤ 109. All 𝑎𝑖 are distinct.<br><strong>Output Format</strong>. The first line of the output should contain single integer 𝑚 — the total number of swaps.<br>𝑚 must satisfy conditions 0 ≤ 𝑚 ≤ 4𝑛. The next 𝑚 lines should contain the swap operations used<br>to convert the array 𝑎 into a heap. Each swap is described by a pair of integers 𝑖, 𝑗 — the 0-based<br>indices of the elements to be swapped. After applying all the swaps in the specified order the array<br>must become a heap, that is, for each 𝑖 where 0 ≤ 𝑖 ≤ 𝑛 − 1 the following conditions must be true:</p><ul><li><ol><li>If 2𝑖 + 1 ≤ 𝑛 − 1, then 𝑎𝑖 &lt; 𝑎2𝑖+1.</li></ol></li><li><ol><li>If 2𝑖 + 2 ≤ 𝑛 − 1, then 𝑎𝑖 &lt; 𝑎2𝑖+2.<br>Note that all the elements of the input array are distinct. Note that any sequence of swaps that has<br>length at most 4𝑛 and after which your initial array becomes a correct heap will be graded as correct.</li></ol></li></ul><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>经典的堆栈建立过程</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>此题考察堆的调整过程。经典的堆的建立过程，时间复杂度为:<script type="math/tex; mode=display">T(n) = O(\lg{\frac{n}{2}}) + O(\lg{\frac{n}{4}}) + ... = lg{n}</script><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data_;</span><br><span class="line">  <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; swaps_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WriteResponse</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; swaps_.size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; swaps_.size(); ++i) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; swaps_[i].first &lt;&lt; <span class="string">" "</span> &lt;&lt; swaps_[i].second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    data_.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; data_[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateSwaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    swaps_.clear();</span><br><span class="line">    <span class="comment">// The following naive implementation just sorts </span></span><br><span class="line">    <span class="comment">// the given sequence using selection sort algorithm</span></span><br><span class="line">    <span class="comment">// and saves the resulting sequence of swaps.</span></span><br><span class="line">    <span class="comment">// This turns the given array into a heap, </span></span><br><span class="line">    <span class="comment">// but in the worst case gives a quadratic number of swaps.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> replace by a more efficient implementation</span></span><br><span class="line">    <span class="keyword">int</span> n = data_.size();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (n<span class="number">-2</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j*<span class="number">2</span> &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = j*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = j*<span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; n ) m = l;</span><br><span class="line">            <span class="keyword">if</span>(r &lt; n &amp;&amp; data_[r] &lt; data_[m]) m = r;</span><br><span class="line">            <span class="keyword">if</span>(data_[j] &gt; data_[m])&#123;</span><br><span class="line">                swaps_.push_back(make_pair(j,m));</span><br><span class="line">                swap(data_[j],data_[m]);</span><br><span class="line">                j = m;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReadData();</span><br><span class="line">    GenerateSwaps();</span><br><span class="line">    WriteResponse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  HeapBuilder heap_builder;</span><br><span class="line">  heap_builder.Solve();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Parallel-processing"><a href="#2-Parallel-processing" class="headerlink" title="2 Parallel processing"></a>2 Parallel processing</h3><p><strong>Task</strong>. You have a program which is parallelized and uses 𝑛 independent threads to process the given list of 𝑚<br>jobs. Threads take jobs in the order they are given in the input. If there is a free thread, it immediately<br>takes the next job from the list. If a thread has started processing a job, it doesn’t interrupt or stop<br>until it finishes processing the job. If several threads try to take jobs from the list simultaneously, the<br>thread with smaller index takes the job. For each job you know exactly how long will it take any thread<br>to process this job, and this time is the same for all the threads. You need to determine for each job<br>which thread will process it and when will it start processing.<br><strong>Input Format</strong>. The first line of the input contains integers 𝑛 and 𝑚.<br>The second line contains 𝑚 integers 𝑡𝑖 — the times in seconds it takes any thread to process 𝑖-th job.<br>The times are given in the same order as they are in the list from which threads take jobs.<br>Threads are indexed starting from 0.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105; 1 ≤ 𝑚 ≤ 105; 0 ≤ 𝑡𝑖 ≤ 109.<br><strong>Output Format</strong>. Output exactly 𝑚 lines. 𝑖-th line (0-based index is used) should contain two spaceseparated<br>integers — the 0-based index of the thread which will process the 𝑖-th job and the time<br>in seconds when it will start processing that job.</p><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>优先级队列</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol><li>将所有worker的空闲时间压入优先级队列，按照空闲时间的起始先后进行排列。</li><li>我们每次分配任务时，从队列中取出最先出现空闲时间的<code>worker</code>，让其处理本次的<code>job</code>，处理完成后，同时将该<code>worker</code>的下次空闲时间入队列。</li><li>题目的难度适中，非常适合面试考试题目，我觉得能够讲出思路非常不错的题目。<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a,pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.second == b.second)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobQueue</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> num_workers_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; jobs_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; assigned_workers_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; start_times_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WriteResponse</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jobs_.size(); ++i) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; assigned_workers_[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; start_times_[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num_workers_ &gt;&gt; m;</span><br><span class="line">    jobs_.resize(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; jobs_[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AssignJobs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> replace this code with a faster algorithm.</span></span><br><span class="line">    assigned_workers_.resize(jobs_.size());</span><br><span class="line">    start_times_.resize(jobs_.size());</span><br><span class="line">    priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_workers_; ++i)&#123;</span><br><span class="line">        pq.push(make_pair(i,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jobs_.size(); ++i) &#123;</span><br><span class="line">        pii curr = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        assigned_workers_[i] = curr.first;</span><br><span class="line">        start_times_[i] = curr.second;</span><br><span class="line">        curr.second += jobs_[i];</span><br><span class="line">        pq.push(curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReadData();</span><br><span class="line">    AssignJobs();</span><br><span class="line">    WriteResponse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  JobQueue job_queue;</span><br><span class="line">  job_queue.Solve();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Merging-tables"><a href="#3-Merging-tables" class="headerlink" title="3 Merging tables"></a>3 Merging tables</h3><p><strong>Task</strong>. There are 𝑛 tables stored in some database. The tables are numbered from 1 to 𝑛. All tables share<br>the same set of columns. Each table contains either several rows with real data or a symbolic link to<br>another table. Initially, all tables contain data, and 𝑖-th table has 𝑟𝑖 rows. You need to perform 𝑚 of<br>the following operations:</p><ul><li><ol><li>Consider table number 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖. Traverse the path of symbolic links to get to the data. That is,<br>while 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 contains a symbolic link instead of real data do<br>𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 ← symlink(𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖)</li></ol></li><li><ol><li>Consider the table number 𝑠𝑜𝑢𝑟𝑐𝑒𝑖 and traverse the path of symbolic links from it in the same<br>manner as for 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖.</li></ol></li><li><ol><li>Now, 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 and 𝑠𝑜𝑢𝑟𝑐𝑒𝑖 are the numbers of two tables with real data. If 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 ̸=<br>𝑠𝑜𝑢𝑟𝑐𝑒𝑖, copy all the rows from table 𝑠𝑜𝑢𝑟𝑐𝑒𝑖 to table 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖, then clear the table 𝑠𝑜𝑢𝑟𝑐𝑒𝑖<br>and instead of real data put a symbolic link to 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 into it.</li></ol></li><li><ol><li>Print the maximum size among all 𝑛 tables (recall that size is the number of rows in the table).<br>If the table contains only a symbolic link, its size is considered to be 0.<br>See examples and explanations for further clarifications.</li></ol></li></ul><p><strong>Input Format</strong>. The first line of the input contains two integers 𝑛 and 𝑚 — the number of tables in the<br>database and the number of merge queries to perform, respectively.<br>The second line of the input contains 𝑛 integers 𝑟𝑖 — the number of rows in the 𝑖-th table.<br>Then follow 𝑚 lines describing merge queries. Each of them contains two integers 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 and<br>𝑠𝑜𝑢𝑟𝑐𝑒𝑖 — the numbers of the tables to merge.<br><strong>Constraints</strong>. 1 ≤ 𝑛,𝑚 ≤ 100 000; 0 ≤ 𝑟𝑖 ≤ 10 000; 1 ≤ 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖, 𝑠𝑜𝑢𝑟𝑐𝑒𝑖 ≤ 𝑛.<br><strong>Output Format</strong>. For each query print a line containing a single integer — the maximum of the sizes of all<br>tables (in terms of the number of rows) after the corresponding operation.</p><h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>带权重的并查集</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ol><li>经典的带权重的并查集，记住DSU合并的权重有几种计算方式，一种是按照<code>size</code>，另一种是按照<code>height</code>。</li><li>按照<code>size</code>为权重来进行集合合并时，惯例为才会将<code>size</code>小的集合合并到<code>size</code>集合中。</li><li>按照<code>height</code>为权重来进行集合合并时，惯例为才会将<code>height</code>小的集合合并到<code>height</code>大的集合中<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DisjointSetsElement</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> size, parent, rank;</span><br><span class="line"></span><br><span class="line">DisjointSetsElement(<span class="keyword">int</span> size = <span class="number">0</span>, <span class="keyword">int</span> parent = <span class="number">-1</span>, <span class="keyword">int</span> rank = <span class="number">0</span>):</span><br><span class="line">    size(size), parent(parent), rank(rank) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DisjointSets</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> max_table_size;</span><br><span class="line"><span class="built_in">vector</span> &lt;DisjointSetsElement&gt; sets;</span><br><span class="line"></span><br><span class="line">DisjointSets(<span class="keyword">int</span> size): size(size), max_table_size(<span class="number">0</span>), sets(size) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">sets[i].parent = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> table)</span> </span>&#123;</span><br><span class="line"><span class="comment">// find parent and compress path</span></span><br><span class="line"><span class="keyword">while</span>(sets[table].parent != table)&#123;</span><br><span class="line">table = sets[table].parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> destination, <span class="keyword">int</span> source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> realDestination = getParent(destination);</span><br><span class="line"><span class="keyword">int</span> realSource = getParent(source);</span><br><span class="line"><span class="keyword">if</span> (realDestination != realSource) &#123;</span><br><span class="line"><span class="comment">// merge two components</span></span><br><span class="line"><span class="comment">// use union by rank heuristic</span></span><br><span class="line">            <span class="comment">// update max_table_size</span></span><br><span class="line"><span class="keyword">if</span>(sets[realDestination].rank &gt; sets[realSource].rank)&#123;</span><br><span class="line">sets[realDestination].size += sets[realSource].size;</span><br><span class="line">sets[realSource].parent = realDestination;</span><br><span class="line">max_table_size = max(max_table_size,sets[realDestination].size);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">sets[realDestination].parent = realSource;</span><br><span class="line">sets[realSource].size += sets[realDestination].size;</span><br><span class="line">max_table_size = max(max_table_size,sets[realSource].size);</span><br><span class="line"><span class="keyword">if</span>(sets[realDestination].rank == sets[realSource].rank)&#123;</span><br><span class="line">sets[realSource].rank = sets[realDestination].rank  + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function">DisjointSets <span class="title">tables</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;table : tables.sets) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; table.size;</span><br><span class="line">tables.max_table_size = max(tables.max_table_size, table.size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> destination, source;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; destination &gt;&gt; source;</span><br><span class="line">                --destination;</span><br><span class="line">                --source;</span><br><span class="line"></span><br><span class="line">tables.merge(destination, source);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tables.max_table_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week3-Hash-Tables-and-Hash-Functions"><a href="#week3-Hash-Tables-and-Hash-Functions" class="headerlink" title="week3: Hash Tables and Hash Functions"></a>week3: Hash Tables and Hash Functions</h2><p>这一章主要是讲kmp算法和KR算法。有几道题目非常的经典和难，必须要掌握该算法的本质。前两道题目比较简单，就不在这里展开描述，后面三道题题目还是经典的面试题。</p><h3 id="3-Find-pattern-in-text"><a href="#3-Find-pattern-in-text" class="headerlink" title="3 Find pattern in text"></a>3 Find pattern in text</h3><ul><li><strong>Task</strong>. In this problem your goal is to implement the Rabin–Karp’s algorithm for searching the given pattern<br>in the given text.</li><li><strong>Input Format</strong>. There are two strings in the input: the pattern 𝑃 and the text 𝑇.<br>Constraints. 1 ≤ |𝑃| ≤ |𝑇| ≤ 5 · 105. The total length of all occurrences of 𝑃 in 𝑇 doesn’t exceed 108. The<br>pattern and the text contain only latin letters.</li><li><strong>Output Format</strong>. Print all the positions of the occurrences of 𝑃 in 𝑇 in the ascending order. Use 0-based<br>indexing of positions in the the text 𝑇.𝐺𝑒𝑛𝑜𝑚𝑒.<h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4>KMP算法或者KR算法。<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>在这里还是使用KR算法，其实这个算法如果理解10进制数的本质，就知道这个算法的本质含义，与我们所经常用的数位算法一样。<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> pattern, text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Data <span class="title">read_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Data data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; data.pattern &gt;&gt; data.text;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_occurrences</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; output)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; output.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; output[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_occurrences(<span class="keyword">const</span> Data&amp; input) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; s = input.pattern, t = input.text;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> n = t.size();</span><br><span class="line">    <span class="keyword">int</span> m = s.size();</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">263</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> h1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        h = (h*base + s[i])%mod;</span><br><span class="line">        h1 = (h1*base + t[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        b = (b*base)%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(h == h1) ans.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - m; ++i)&#123;</span><br><span class="line">        h1 = (h1 - t[i<span class="number">-1</span>]*b%mod + mod)%mod;</span><br><span class="line">        h1 = (h1*base + t[i+m<span class="number">-1</span>])%mod;</span><br><span class="line">        <span class="keyword">if</span>(h1 == h)&#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    print_occurrences(get_occurrences(read_input()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Substring-equality"><a href="#4-Substring-equality" class="headerlink" title="4 Substring equality"></a>4 Substring equality</h3><ul><li><strong>Input Format</strong>. The first line contains a string 𝑠 consisting of small Latin letters. The second line contains<br>the number of queries 𝑞. Each of the next 𝑞 lines specifies a query by three integers 𝑎, 𝑏, and 𝑙.</li><li><strong>Constraints</strong>. 1 ≤ |𝑠| ≤ 500 000. 1 ≤ 𝑞 ≤ 100 000. 0 ≤ 𝑎, 𝑏 ≤ |𝑠| − 𝑙 (hence the indices 𝑎 and 𝑏 are 0-based).</li><li><strong>Output Format</strong>. For each query, output “Yes” if 𝑠𝑎𝑠𝑎+1. . .𝑠𝑎+𝑙−1 = 𝑠𝑏𝑠𝑏+1. . .𝑠𝑏+𝑙−1 are equal, and “No”<br>otherwise.<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>典型的KR算法。</li><li>算出所有长度的hash值，比较hash值是否相等。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> base;</span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; hx;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; bx;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Solver(<span class="built_in">string</span> s) : s(s) &#123;</span><br><span class="line"><span class="comment">// initialization, precalculation</span></span><br><span class="line"><span class="keyword">int</span> n = s.size();</span><br><span class="line"><span class="keyword">this</span>-&gt;base = <span class="number">263</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;hx = <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;bx = <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">hx[i] = (hx[i<span class="number">-1</span>]*base + s[i<span class="number">-1</span>])%mod;</span><br><span class="line">bx[i] = (bx[i<span class="number">-1</span>]*base)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h1 = (hx[a+l] - hx[a]*bx[l]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h2 = (hx[b+l] - hx[b]*bx[l]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">if</span>(h1 == h2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s &gt;&gt; q;</span><br><span class="line"><span class="function">Solver <span class="title">solver</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b, l;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; l;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (solver.ask(a, b, l) ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-Longest-common-substring"><a href="#5-Longest-common-substring" class="headerlink" title="5 Longest common substring"></a>5 Longest common substring</h3><p><strong>Input Format</strong>. Every line of the input contains two strings 𝑠 and 𝑡 consisting of lower case Latin letters.<br><strong>Constraints</strong>. The total length of all 𝑠’s as well as the total length of all 𝑡’s does not exceed 100 000.<br><strong>Output Format</strong>. For each pair of strings 𝑠 and 𝑡𝑖, find its longest common substring and specify it by<br>outputting three integers: its starting position in 𝑠, its starting position in 𝑡 (both 0-based), and its<br>length. More formally, output integers 0 ≤ 𝑖 &lt; |𝑠|, 0 ≤ 𝑗 &lt; |𝑡|, and 𝑙 ≥ 0 such that 𝑠𝑖𝑠𝑖+1 · · · 𝑠𝑖+𝑙−1 =<br>𝑡𝑗 𝑡𝑗+1 · · · 𝑡𝑗+𝑙−1 and 𝑙 is maximal. (As usual, if there are many such triples with maximal 𝑙, output any<br>of them.)</p><h4 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h4><p>KR算法</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ol><li>leetcode周赛的原题，如果知道这个算法的，就知道这个题目非常简单，不知道该算法的就觉得非常难。或者后缀数组也可以实现该算法。<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span> &#123;</span></span><br><span class="line"><span class="keyword">size_t</span> i, j, len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Answer <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;t)</span> </span>&#123;</span><br><span class="line">Answer ans = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> m = s.size();</span><br><span class="line"><span class="keyword">int</span> n = t.size();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base1 = <span class="number">263</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod2 = <span class="number">100001611</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; hs1(m+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ht1(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; bx1(max(m,n)+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s.size() == <span class="number">0</span> || t.size() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max(m,n); ++i)&#123;</span><br><span class="line">bx1[i] = (bx1[i<span class="number">-1</span>]*base1)%mod1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">hs1[i] = (hs1[i<span class="number">-1</span>]*base1 + s[i<span class="number">-1</span>])%mod1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">ht1[i] = (ht1[i<span class="number">-1</span>]*base1 + t[i<span class="number">-1</span>])%mod1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> len,<span class="keyword">long</span> <span class="keyword">long</span> mod,Answer &amp; res)&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*calc string s*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m-len; ++i)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h = (hs1[i+len] - hs1[i]*bx1[len]%mod + mod)%mod;</span><br><span class="line">cnt[h] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*calc string t*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-len; ++i)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h = (ht1[i+len] - ht1[i]*bx1[len]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">if</span>(cnt.count(h))&#123;</span><br><span class="line">res.i = cnt[h];</span><br><span class="line">res.j = i;</span><br><span class="line">res.len = len;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = min(m,n);</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">Answer curr;</span><br><span class="line"><span class="keyword">if</span>(check(mid,mod1,curr))&#123;</span><br><span class="line">ans = curr;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">string</span> s, t;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t) &#123;</span><br><span class="line"><span class="keyword">auto</span> ans = solve(s, t);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans.i &lt;&lt; <span class="string">" "</span> &lt;&lt; ans.j &lt;&lt; <span class="string">" "</span> &lt;&lt; ans.len &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-Pattern-matching-with-mismatches"><a href="#6-Pattern-matching-with-mismatches" class="headerlink" title="6 Pattern matching with mismatches"></a>6 Pattern matching with mismatches</h3><p><strong>Task</strong>. For an integer parameter 𝑘 and two strings 𝑡 = 𝑡0𝑡1 · · · 𝑡𝑚−1 and 𝑝 = 𝑝0𝑝1 · · · 𝑝𝑛−1, we say that<br>𝑝 occurs in 𝑡 at position 𝑖 with at most 𝑘 mismatches if the strings 𝑝 and 𝑡[𝑖 : 𝑖 + 𝑝) = 𝑡𝑖𝑡𝑖+1 · · · 𝑡𝑖+𝑛−1<br>differ in at most 𝑘 positions.<br><strong>Input Format</strong>. Every line of the input contains an integer 𝑘 and two strings 𝑡 and 𝑝 consisting of lower<br>case Latin letters.<br><strong>Constraints</strong>. 0 ≤ 𝑘 ≤ 5, 1 ≤ |𝑡| ≤ 200 000, 1 ≤ |𝑝| ≤ min{|𝑡|, 100 000}. The total length of all 𝑡’s does not<br>exceed 200 000, the total length of all 𝑝’s does not exceed 100 000.<br><strong>Output Format</strong>. For each triple (𝑘, 𝑡, 𝑝), find all positions 0 ≤ 𝑖1 &lt; 𝑖2 &lt; · · · &lt; 𝑖𝑙 &lt; |𝑡| where 𝑝 occurs in 𝑡<br>with at most 𝑘 mismatches. Output 𝑙 and 𝑖1, 𝑖2, . . . , 𝑖𝑙.</p><h4 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h4><p>KR算法 + 二分查找</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ol><li>这个题目想了很长时间，我觉得最经典的莫过于二分查找算法的应用，关于两个字符串中查找K个字符的不同位置，竟然可以这么神奇的用二分查找算法可以在 $O(lgn)$时间复杂度内全部求出，这个真心太强大的工具了。</li><li>如果对这个题目感兴趣的同学，可以仔细思考下我提交的代码，非常的有意思。<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve(<span class="keyword">int</span> k, <span class="keyword">const</span> <span class="built_in">string</span> &amp;text, <span class="keyword">const</span> <span class="built_in">string</span> &amp;pattern) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="keyword">int</span> m = text.size();</span><br><span class="line"><span class="keyword">int</span> n = pattern.size();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">263</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ht(m+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; hp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; bx(m+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(text.size() == <span class="number">0</span> || text.size() == <span class="number">0</span> || m &lt; n)&#123;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">bx[i] = (bx[i<span class="number">-1</span>]*base)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">ht[i] = (ht[i<span class="number">-1</span>]*base + text[i<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">hp[i] = (hp[i<span class="number">-1</span>]*base + pattern[i<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> hashPattern = [&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line"><span class="keyword">int</span> l = y - x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> curr = (hp[y+<span class="number">1</span>] - hp[x]*bx[l]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> hashText = [&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line"><span class="keyword">int</span> l = y - x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> curr = (ht[y+<span class="number">1</span>] - ht[x]*bx[l]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m-n; ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = n<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"start from "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(start &gt; end) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> l = start;</span><br><span class="line"><span class="keyword">int</span> r = end;</span><br><span class="line"><span class="keyword">int</span> last = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(hashText(i+start,i+mid) != hashPattern(start,mid))&#123;</span><br><span class="line">last = mid;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">start = last + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;start&lt;&lt;":"&lt;&lt;end&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(start &gt; end || hashText(start+i,end+i) == hashPattern(start,end))&#123;</span><br><span class="line">pos.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">string</span> t, p;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; k &gt;&gt; t &gt;&gt; p) &#123;</span><br><span class="line"><span class="keyword">auto</span> a = solve(k, t, p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : a)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Binary-Search-Trees"><a href="#week4-Binary-Search-Trees" class="headerlink" title="week4 . Binary Search Trees"></a>week4 . Binary Search Trees</h2><h3 id="1-Binary-tree-traversals"><a href="#1-Binary-tree-traversals" class="headerlink" title="1 Binary tree traversals"></a>1 Binary tree traversals</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><strong>Task</strong>. You are given a rooted binary tree. Build and output its in-order, pre-order and post-order traversals.<br><strong>Input Format</strong>. The first line contains the number of vertices 𝑛. The vertices of the tree are numbered<br>from 0 to 𝑛 − 1. Vertex 0 is the root.<br>The next 𝑛 lines contain information about vertices 0, 1, …, 𝑛−1 in order. Each of these lines contains<br>three integers 𝑘𝑒𝑦𝑖, 𝑙𝑒𝑓𝑡𝑖 and 𝑟𝑖𝑔ℎ𝑡𝑖 — 𝑘𝑒𝑦𝑖 is the key of the 𝑖-th vertex, 𝑙𝑒𝑓𝑡𝑖 is the index of the left<br>child of the 𝑖-th vertex, and 𝑟𝑖𝑔ℎ𝑡𝑖 is the index of the right child of the 𝑖-th vertex. If 𝑖 doesn’t have<br>left or right child (or both), the corresponding 𝑙𝑒𝑓𝑡𝑖 or 𝑟𝑖𝑔ℎ𝑡𝑖 (or both) will be equal to −1.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105; 0 ≤ 𝑘𝑒𝑦𝑖 ≤ 109; −1 ≤ 𝑙𝑒𝑓𝑡𝑖, 𝑟𝑖𝑔ℎ𝑡𝑖 ≤ 𝑛 − 1. It is guaranteed that the input<br>represents a valid binary tree. In particular, if 𝑙𝑒𝑓𝑡𝑖 ̸= −1 and 𝑟𝑖𝑔ℎ𝑡𝑖 ̸= −1, then 𝑙𝑒𝑓𝑡𝑖 ̸= 𝑟𝑖𝑔ℎ𝑡𝑖. Also,<br>a vertex cannot be a child of two different vertices. Also, each vertex is a descendant of the root vertex.<br><strong>Output Format</strong>. Print three lines. The first line should contain the keys of the vertices in the in-order<br>traversal of the tree. The second line should contain the keys of the vertices in the pre-order traversal<br>of the tree. The third line should contain the keys of the vertices in the post-order traversal of the tree.</p><h4 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h4><p>二叉树的遍历</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ol><li>DFS递归遍历二叉树。</li><li>三种遍历方式，先序遍历，中序遍历，后续遍历<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ios_base;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeOrders</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">int</span> root;</span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; key;</span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    key.resize(n);</span><br><span class="line">    left.resize(n);</span><br><span class="line">    right.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; key[i] &gt;&gt; left[i] &gt;&gt; right[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">      dfs1(left[root],res);</span><br><span class="line">      res.push_back(key[root]);</span><br><span class="line">      dfs1(right[root],res);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; in_order() &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// Finish the implementation</span></span><br><span class="line">    <span class="comment">// You may need to add a new recursive method to do that</span></span><br><span class="line">    dfs1(<span class="number">0</span>,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">      res.push_back(key[root]);</span><br><span class="line">      dfs2(left[root],res);</span><br><span class="line">      dfs2(right[root],res);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; pre_order() &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;    </span><br><span class="line">    <span class="comment">// Finish the implementation</span></span><br><span class="line">    <span class="comment">// You may need to add a new recursive method to do that</span></span><br><span class="line">    dfs2(<span class="number">0</span>,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">      dfs3(left[root],res);</span><br><span class="line">      dfs3(right[root],res);</span><br><span class="line">      res.push_back(key[root]);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; post_order() &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// Finish the implementation</span></span><br><span class="line">    <span class="comment">// You may need to add a new recursive method to do that</span></span><br><span class="line">    dfs3(<span class="number">0</span>,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main_with_large_stack_space</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">  TreeOrders t;</span><br><span class="line">  t.read();</span><br><span class="line">  print(t.in_order());</span><br><span class="line">  print(t.pre_order());</span><br><span class="line">  print(t.post_order());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__APPLE__)</span></span><br><span class="line">  <span class="comment">// Allow larger stack space</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">rlim_t</span> kStackSize = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>;   <span class="comment">// min stack size = 16 MB</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  result = getrlimit(RLIMIT_STACK, &amp;rl);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (rl.rlim_cur &lt; kStackSize)</span><br><span class="line">      &#123;</span><br><span class="line">          rl.rlim_cur = kStackSize;</span><br><span class="line">          result = setrlimit(RLIMIT_STACK, &amp;rl);</span><br><span class="line">          <span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"setrlimit returned result = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> main_with_large_stack_space();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Is-it-a-binary-search-tree"><a href="#2-Is-it-a-binary-search-tree" class="headerlink" title="2 Is it a binary search tree?"></a>2 Is it a binary search tree?</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><strong>Task</strong>.<br>    You are given a binary tree with integers as its keys. You need to test whether it is a correct binary<br>    search tree. The definition of the binary search tree is the following: for any node of the tree, if its<br>    key is 𝑥, then for any node in its left subtree its key must be strictly less than 𝑥, and for any node in<br>    its right subtree its key must be strictly greater than 𝑥. In other words, smaller elements are to the<br>    left, and bigger elements are to the right. You need to check whether the given binary tree structure<br>    satisfies this condition. You are guaranteed that the input contains a valid binary tree. That is, it is a<br>    tree, and each node has at most two children.</p><h4 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h4><p>判定二叉树是否为二叉查找树</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ol><li>两个条件需要判定。</li><li>父节点的值一定大于左孩子，小于右孩子。</li><li>父节点的值一定大于左子树的最右边的节点，小于右子树的最左边的节点。<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> left;</span><br><span class="line">  <span class="keyword">int</span> right;</span><br><span class="line"></span><br><span class="line">  Node() : key(<span class="number">0</span>), left(<span class="number">-1</span>), right(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">  Node(<span class="keyword">int</span> key_, <span class="keyword">int</span> left_, <span class="keyword">int</span> right_) : key(key_), left(left_), right(right_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt;&amp; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = tree[root].left;</span><br><span class="line">    <span class="keyword">int</span> right = tree[root].right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> isLeaf = [&amp;](<span class="keyword">int</span> curr)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[curr].left == <span class="number">-1</span> &amp;&amp; tree[curr].right == <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isLeaf(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*check left*/</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">-1</span> &amp;&amp; tree[root].key &lt;= tree[left].key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(left != <span class="number">-1</span> &amp;&amp; !isLeaf(left))&#123;</span><br><span class="line">        left = tree[left].right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">-1</span> &amp;&amp; tree[left].key &gt;= tree[root].key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check right*/</span></span><br><span class="line">    <span class="keyword">if</span>(right != <span class="number">-1</span> &amp;&amp; tree[root].key &gt;= tree[right].key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(right != <span class="number">-1</span> &amp;&amp; !isLeaf(right))&#123;</span><br><span class="line">        right = tree[right].left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right != <span class="number">-1</span> &amp;&amp; tree[right].key &lt;= tree[root].key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(tree[root].left,tree)&amp;&amp;dfs(tree[root].right,tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBinarySearchTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Implement correct algorithm here</span></span><br><span class="line">  <span class="keyword">return</span> dfs(<span class="number">0</span>,tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nodes;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; nodes;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&gt; tree;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> key, left, right;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key &gt;&gt; left &gt;&gt; right;</span><br><span class="line">    tree.push_back(Node(key, left, right));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IsBinarySearchTree(tree)) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CORRECT"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"INCORRECT"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Is-it-a-binary-search-tree-Hard-version"><a href="#3-Is-it-a-binary-search-tree-Hard-version" class="headerlink" title="3 Is it a binary search tree? Hard version."></a>3 Is it a binary search tree? Hard version.</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p><strong>Task</strong>. You are given a binary tree with integers as its keys. You need to test whether it is a correct binary<br>search tree. Note that there can be duplicate integers in the tree, and this is allowed. The definition of<br>the binary search tree in such case is the following: for any node of the tree, if its key is 𝑥, then for any<br>node in its left subtree its key must be strictly less than 𝑥, and for any node in its right subtree its key<br>must be greater than or equal to 𝑥. In other words, smaller elements are to the left, bigger elements<br>are to the right, and duplicates are always to the right. You need to check whether the given binary<br>tree structure satisfies this condition. You are guaranteed that the input contains a valid binary tree.<br>That is, it is a tree, and each node has at most two children.</p><h4 id="题意-13"><a href="#题意-13" class="headerlink" title="题意"></a>题意</h4><p>判定二叉树是否为二叉查找树，这题跟第二题一样</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><ol><li>两个条件需要判定。</li><li>父节点的值一定大于左孩子，小于右孩子。</li><li>父节点的值一定大于左子树的最右边的节点，小于右子树的最左边的节点。<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> left;</span><br><span class="line">  <span class="keyword">int</span> right;</span><br><span class="line"></span><br><span class="line">  Node() : key(<span class="number">0</span>), left(<span class="number">-1</span>), right(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">  Node(<span class="keyword">int</span> key_, <span class="keyword">int</span> left_, <span class="keyword">int</span> right_) : key(key_), left(left_), right(right_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt;&amp; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = tree[root].left;</span><br><span class="line">    <span class="keyword">int</span> right = tree[root].right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> isLeaf = [&amp;](<span class="keyword">int</span> curr)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[curr].left == <span class="number">-1</span> &amp;&amp; tree[curr].right == <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isLeaf(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*check left*/</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">-1</span> &amp;&amp; tree[root].key &lt;= tree[left].key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(left != <span class="number">-1</span> &amp;&amp; !isLeaf(left))&#123;</span><br><span class="line">        left = tree[left].right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">-1</span> &amp;&amp; tree[left].key &gt;= tree[root].key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check right*/</span></span><br><span class="line">    <span class="keyword">if</span>(right != <span class="number">-1</span> &amp;&amp; tree[root].key &gt; tree[right].key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(right != <span class="number">-1</span> &amp;&amp; !isLeaf(right))&#123;</span><br><span class="line">        right = tree[right].left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right != <span class="number">-1</span> &amp;&amp; tree[right].key &lt; tree[root].key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(tree[root].left,tree)&amp;&amp;dfs(tree[root].right,tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBinarySearchTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Implement correct algorithm here</span></span><br><span class="line">  <span class="keyword">return</span> dfs(<span class="number">0</span>,tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nodes;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; nodes;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&gt; tree;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> key, left, right;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key &gt;&gt; left &gt;&gt; right;</span><br><span class="line">    tree.push_back(Node(key, left, right));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IsBinarySearchTree(tree))&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CORRECT"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"INCORRECT"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Set-with-range-sums"><a href="#4-Set-with-range-sums" class="headerlink" title="4 Set with range sums"></a>4 Set with range sums</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p><strong>Task</strong>. Implement a data structure that stores a set 𝑆 of integers with the following allowed operations:</p><ul><li><strong>add(𝑖)</strong> — add integer 𝑖 into the set 𝑆 (if it was there already, the set doesn’t change).</li><li><strong>del(𝑖)</strong> — remove integer 𝑖 from the set 𝑆 (if there was no such element, nothing happens).</li><li><strong>find(𝑖)</strong> — check whether 𝑖 is in the set 𝑆 or not.</li><li><strong>sum(𝑙, 𝑟)</strong> — output the sum of all elements 𝑣 in 𝑆 such that 𝑙 ≤ 𝑣 ≤ 𝑟.<h4 id="题意-14"><a href="#题意-14" class="headerlink" title="题意"></a>题意</h4>这题本意是用splay tree，但是对于splaytree的扭转确实太复杂，太难记了。</li></ul><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><ol><li>这题不用splaytree，完全可以用skiplist。</li><li>利用skiplist的插入时间复杂度为$O(lgn)$.</li><li>利用skiplist的删除时间复杂度为$O(lgn)$.</li><li>利用skiplist的find时间复杂度为$O(lgn)$.</li><li>利用skiplist的sum的时间复杂度为$O(lgn)$.</li><li>skiplist代码就没有实现，感兴趣可以找一下开源代码实现。<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据结构这个课程比前几个课程简单多了，前面几个算法课程的题目非常难，一度以为怀疑自己的智商，后来终于搞定了，基本上绝大部分都是100分，现在又要开始刷<code>standford</code>的算法课程，真心头大，真心痛苦。我想人总是会在痛苦和压力中成长起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Data-Structure&quot;&gt;&lt;a href=&quot;#Data-Structure&quot; class=&quot;headerlink&quot; title=&quot;Data Structure&quot;&gt;&lt;/a&gt;Data Structure&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，这个课程是数据结构的课程，当然对于数据结构这门课程基本的东西已经非常的熟悉了，。&lt;br&gt;对于特别需要独立思考的问题，适当建议对于卡到壳的时候，一定要先放一放，去外面散步或者多运动，只有这样利用自己的发散思维就能把问题解决出来，仔细思考一下这种思考模式，在《learning how to learn》课程中学到的知识应用到这些科学知识，真的是非常有用。&lt;br&gt;抽了大概一周的时间把课程《Data Structure》学习完了，这部分的课程有些还是非常难，最后的&lt;code&gt;splaytree&lt;/code&gt;太复杂了，没有做完，总得来说质量还是非常高得，虽然里面得算法大部分都学过，还是继续温习了一遍，已经会得算法就没有仔细再重新学习掌握，主要把&lt;code&gt;hashtable&lt;/code&gt;和&lt;code&gt;splaytree&lt;/code&gt;又重新温习了一遍。最后得分是&lt;code&gt;85.90&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/WMMZ3YUHX4QA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Data Structure&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Data%20Structrues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Data Structure》" scheme="http://yoursite.com/tags/%E3%80%8AData-Structure%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>数位DP</title>
    <link href="http://yoursite.com/2020/06/02/168/"/>
    <id>http://yoursite.com/2020/06/02/168/</id>
    <published>2020-06-02T05:08:51.385Z</published>
    <updated>2020-06-03T02:01:10.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h1><h2 id="1012-至少有-1-位重复的数字"><a href="#1012-至少有-1-位重复的数字" class="headerlink" title="1012. 至少有 1 位重复的数字"></a>1012. 至少有 1 位重复的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定正整数 N，返回小于等于 N 且具有至少 1 位重复数字的正整数的个数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">20</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：具有至少 <span class="number">1</span> 位重复数字的正数（&lt;= <span class="number">20</span>）只有 <span class="number">11</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">100</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：具有至少 <span class="number">1</span> 位重复数字的正数（&lt;= <span class="number">100</span>）有 <span class="number">11</span>，<span class="number">22</span>，<span class="number">33</span>，<span class="number">44</span>，<span class="number">55</span>，<span class="number">66</span>，<span class="number">77</span>，<span class="number">88</span>，<span class="number">99</span> 和 <span class="number">100</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1000</span></span><br><span class="line">输出：<span class="number">262</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= N &lt;= 10^9</code><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/numbers-with-repeated-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/numbers-with-repeated-digits</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3>数位dp<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></li></ul><ol><li>经典的数位dp问题，为了这个dp问题，想了很久才想明白，今天终于靠自己的努力，把这两道数位的dp的问题彻底弄清楚了，还是非常的复杂。</li><li>具体的数位dp问题如下:<br>数位动态规划是一类特殊的动态规划，它的形式一般为：<blockquote><p>给定下界$ ll $和上界 $rr$，求 $[l, r][l,r] $之间满足某一要求的元素个数。</p></blockquote></li></ol><p>在力扣平台上，数位动态规划的题目很少，典型的例子为 1012. 至少有 1 位重复的数字，即给定下界 $11$和上界 $NN$，求上下界之间满足「至少有 11 位重复数字」的元素个数。</p><p>我们如何解决数位动态规划的题目呢？一般来说，数位动态规划有一个特定的状态表达：</p><script type="math/tex; mode=display">f[\textit{pos}][\textit{stats}][\textit{bound}]</script><p>它表示：</p><ul><li><p>我们现在处理到了数的第 $\textit{pos}$ 位。在数位动态规划中，我们是从高位到低位，一位一位地处理数字的。例如当下界 $l = 13$，上界 $r = 678$时，我们会先将上下界的高位补零使得它们拥有相同的位数，即 $(l, r) = (013, 678)$。随后我们从高位开始进行动态规划；</p></li><li><p>在 $\textit{pos}$ 位之前的那些数的状态被压缩成了 $\textit{stats}$。这是什么意思呢？我们举一个简单的例子，假设我们现在想要求出在 $[l, r][l,r]$之间各位数字之和是 $55$ 的倍数的所有数，那么此时 $\textit{stats}$ 就可以表示为「在 $ \textit{pos}$ 位之前的那些数的数字之和对 55 取模的值」，这样我们只用一个整数就能够表示 $\textit{pos}$  位之前的状态。如果在第 $ \textit{pos}$ 位我们选择了数 dd，那么动态规划中的下一个状态就为 $f[\textit{pos} + 1][(\textit{stats} + d) \bmod 5][\ldots]$；</p></li><li><p>在 $pospos$ 位之前的那些数和上下界 $l$, $rl$,$r$ 的关系为 $\textit{bound}$。这又是什么意思呢？我们还是使用上面的那个例子，求出 $[013, 678][013,678]$内各位数字之和是 $55$ 的倍数的所有数。</p></li></ul><ul><li><ul><li>如果最高位的数字我们选择了 22，它和上下界的最高位数字没有任何关系，因此对于次高位的数字，我们可以在 [0, 9][0,9] 之间任意选择；</li></ul></li><li><ul><li>如果最高位的数字我们选择了 66，此时这个数字是「贴着」上界的，也就是说，对于次高位的数字，我们只能在 [0, 7][0,7] 之间选择，其中 77 就是上界的次高位的数字。如果我们选择了数字 88 或 99，那么整个数为 68_68_，无论最后一位怎么选择，都不可能在上下界的区间内；</li></ul></li><li><ul><li>如果最高位的数字我们选择了 00，此时这个数字是「贴着」下界的，也就是说，对于次高位的数字，我们只能在 [1, 9][1,9] 之间选择，其中 11 就是下界的次高位数字。如果我们选择了数字 00，那么整个数为 00_00_，无论最后一位怎么选择，都不可能在上下界的区间内；</li></ul></li></ul><ul><li><ul><li>此外，还有一种最为特殊的情况。如果上下界为 (l, r) = (123, 156)(l,r)=(123,156)，并且最高位我们选择了 11，那么此时这个数字既「贴着」上界，也「贴着」下界，对于次高位的数字，我们只能在 [2, 5][2,5] 之间选择，其中 22 是下界的次高位数字，55 是上界的次高位数字。</li></ul></li></ul><p>综上所述，\textit{bound}bound 共有 44 种不同的情况，我们可以给它们分别设定取值 $0, 1, 2, 3$:</p><ul><li><ul><li>如果和上下界没有任何关系，那么取值为 00，并且以后也不可能和上下界有关系；</li></ul></li><li><ul><li>如果「贴着」下界，那么取值为 11，并且只有当第 \textit{pos}pos 位取了下界对应位置的数字时，才会延续 11 值，否则会变为 00；</li></ul></li><li><ul><li>如果「贴着」上界，那么取值为 22，并且只有当第 \textit{pos}pos 位取了上界对应位置的数字时，才会延续 22 值，否则会变为 00；</li></ul></li><li><ul><li>如果同时「贴着」上下界，那么取值为 3，并且：</li></ul></li><li><ul><li><ul><li>如果 \textit{pos}pos 位同时取了上下界对应位置的数字（此时上下界对应位置的数字一定相同），那么延续 33 值；</li></ul></li></ul></li><li><ul><li><ul><li>如果 \textit{pos}pos 位取了下界对应位置的数字，那么会变为 11；</li></ul></li></ul></li><li><ul><li><ul><li>如果 \textit{pos}pos 位取了上界对应位置的数字，那么会变为 22；</li></ul></li></ul></li><li><ul><li><ul><li>其余情况会变为 00。</li></ul></li></ul></li><li><p>另一种理解方式是，\textit{bound}bound 是一个 22 位的二进制数，低位为 11 当且仅当「贴着」下界，高位为 11 当且仅当「贴着」上界。</p></li></ul><p>而对于 $f[\textit{pos}][\textit{stats}][\textit{bound}]$的值本身，它表示「满足上述条件的数的个数」。这样以来，我们可以使用记忆化搜索$（DFS + memo）$的方法进行动态规划，即</p><script type="math/tex; mode=display">f[\textit{pos}][\textit{stats}][\textit{bound}] = \sum_d f[\textit{pos + 1}][g_s(\textit{stats}, d)][g_b(\textit{bound}, d)]</script><p>其中 $d$ 为第 $\textit{pos}$ 位选择的数字；$g_b(\textit{bound}, d)$ 是关于 $\textit{bound}$ 的转移函数，例如上文中四个取值 $0, 1, 2, 30,1,2,3$ 之间的转化；$g_s(\textit{stats}$ 是关于 $ \textit{stats}$  的转移函数，例如上文中的 $(\textit{stats} + d) \bmod 5$。最终的答案存放在</p><script type="math/tex; mode=display">f[0][\textit{stats}_{\textit{init}}][3]</script><p>中，即满足「枚举到最高位、初始状态、同时贴着上下界（可以想象成更高位还可以补零，那么在最高位之前的数字都是贴着上下界的）」的数的个数，也就是需要求出的答案。</p><ol><li>在此题目中我们知道上线为数<code>n</code>,下限为<code>0</code>,我们判断用掩码存储当前数目中出现的数位，当新递增第<code>i</code>位的数字位<code>m</code>时，我们通过<code>bitTst</code>方法探测是否已经出现过该数字，如果出现则认为该数字重估。</li><li>利用上述的数位dp方法还是非常的复杂。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1024</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[N][P][M];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lower;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; upper;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bitTst</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((mask&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkNum</span><span class="params">(<span class="keyword">int</span> mask)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bitTst(mask,i)) res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> state,<span class="keyword">int</span> bound,<span class="keyword">int</span> zero)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == upper.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(checkNum(state) + zero == pos) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[pos][state][bound] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[pos][state][bound];</span><br><span class="line"></span><br><span class="line">        dp[pos][state][bound] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = (bound&amp;<span class="number">2</span>)? upper[pos] : <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bitTst(state,i)) <span class="keyword">continue</span>;            </span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[pos][state][bound] += dfs(pos+<span class="number">1</span>,state,<span class="number">0</span>,zero + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> nx_bound = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>((bound&amp;<span class="number">1</span>) &amp;&amp; i == lower[pos]) nx_bound |= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((bound&amp;<span class="number">2</span>) &amp;&amp; i == upper[pos]) nx_bound |= <span class="number">2</span>;</span><br><span class="line">                dp[pos][state][bound] += dfs(pos+<span class="number">1</span>,state|(<span class="number">1</span>&lt;&lt;i),nx_bound,zero);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[pos][state][bound];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDupDigitsAtMostN</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = n; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>)&#123;</span><br><span class="line">            upper.push_back(x%<span class="number">10</span>);</span><br><span class="line">            lower.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(upper.begin(),upper.end());</span><br><span class="line">        reverse(lower.begin(),lower.end());</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1397-找到所有好字符串"><a href="#1397-找到所有好字符串" class="headerlink" title="1397. 找到所有好字符串"></a>1397. 找到所有好字符串</h2><p>给你两个长度为<code>n</code> 的字符串 <code>s1</code> 和<code>s2</code> ，以及一个字符串 <code>evil</code> 。请你返回 好字符串 的数目。</p><p>好字符串 的定义为：它的长度为 n ，字典序大于等于 s1 ，字典序小于等于 <code>s2</code> ，且不包含 <code>evil</code> `为子字符串。</p><p>由于答案可能很大，请你返回答案对<code>10^9 + 7</code>取余的结果。</p><p>示例 1：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, s1 = <span class="string">"aa"</span>, s2 = <span class="string">"da"</span>, evil = <span class="string">"b"</span></span><br><span class="line">输出：<span class="number">51</span> </span><br><span class="line">解释：总共有 <span class="number">25</span> 个以 <span class="string">'a'</span> 开头的好字符串：<span class="string">"aa"</span>，<span class="string">"ac"</span>，<span class="string">"ad"</span>，<span class="params">...</span>，<span class="string">"az"</span>。还有 <span class="number">25</span> 个以 <span class="string">'c'</span> 开头的好字符串：<span class="string">"ca"</span>，<span class="string">"cc"</span>，<span class="string">"cd"</span>，<span class="params">...</span>，<span class="string">"cz"</span>。最后，还有一个以 <span class="string">'d'</span> 开头的好字符串：<span class="string">"da"</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">8</span>, <span class="built_in">s1</span> = <span class="string">"leetcode"</span>, <span class="built_in">s2</span> = <span class="string">"leetgoes"</span>, evil = <span class="string">"leet"</span></span><br><span class="line">输出：<span class="number">0</span> </span><br><span class="line">解释：所有字典序大于等于 <span class="built_in">s1</span> 且小于等于 <span class="built_in">s2</span> 的字符串都以 evil 字符串 <span class="string">"leet"</span> 开头。所以没有好字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">n</span> = <span class="number">2</span>, <span class="attr">s1</span> = <span class="string">"gx"</span>, <span class="attr">s2</span> = <span class="string">"gz"</span>, <span class="attr">evil</span> = <span class="string">"x"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s1.length == n</code></li><li><code>s2.length == n</code></li><li><code>s1 &lt;= s2</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>1 &lt;= evil.length &lt;= 50</code></li><li><code>所有字符串都只包含小写英文字母</code></li></ul><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/find-all-good-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-good-strings</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>KMP + 数位dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>思路还是非常的复杂，数位dp中的关键在于状态，此题目中状态存储的数据为当前已经匹配<code>evil</code>的最大长度。</li><li>我们可以利用kmp算法的匹配最长后缀，来线性时间的判断接受新字符后的下一个状态。</li><li>该题目非常的经典，需要经常翻看的题目。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[N][M][P];</span><br><span class="line">    <span class="keyword">int</span> dfa[M][<span class="number">27</span>];</span><br><span class="line">    <span class="built_in">string</span> s1;</span><br><span class="line">    <span class="built_in">string</span> s2;</span><br><span class="line">    <span class="built_in">string</span> evil;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> &amp; str)</span></span>&#123;</span><br><span class="line">        dfa[<span class="number">0</span>][str[<span class="number">0</span>]-<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt; str.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)&#123;</span><br><span class="line">                dfa[i][k] = dfa[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">            dfa[i][str[i]-<span class="string">'a'</span>] = i + <span class="number">1</span>;</span><br><span class="line">            j = dfa[j][str[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> state,<span class="keyword">int</span> bound)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == evil.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == s1.size()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[pos][state][bound] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[pos][state][bound];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> lower = (bound&amp;<span class="number">1</span>)?s1[pos] : <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">char</span> upper = (bound&amp;<span class="number">2</span>)?s2[pos] : <span class="string">'z'</span>;</span><br><span class="line">        dp[pos][state][bound] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch = lower; ch &lt;= upper; ++ch)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx_state = dfa[state][ch-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">int</span> nx_bound = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*lower bound*/</span></span><br><span class="line">            <span class="keyword">if</span>((bound&amp;<span class="number">1</span>) &amp;&amp; ch == s1[pos]) nx_bound |= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/*upper bound*/</span></span><br><span class="line">            <span class="keyword">if</span>((bound&amp;<span class="number">2</span>) &amp;&amp; ch == s2[pos]) nx_bound |= <span class="number">2</span>;</span><br><span class="line">            dp[pos][state][bound] += dfs(pos+<span class="number">1</span>,nx_state,nx_bound);</span><br><span class="line">            dp[pos][state][bound] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[pos][state][bound];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findGoodStrings</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> evil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = evil.size();</span><br><span class="line">        <span class="built_in">memset</span>(dfa,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfa));</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        kmp(evil);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>-&gt;s1 = s1;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s2 = s2;</span><br><span class="line">        <span class="keyword">this</span>-&gt;evil = evil;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;s</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数位dp&quot;&gt;&lt;a href=&quot;#数位dp&quot; class=&quot;headerlink&quot; title=&quot;数位dp&quot;&gt;&lt;/a&gt;数位dp&lt;/h1&gt;&lt;h2 id=&quot;1012-至少有-1-位重复的数字&quot;&gt;&lt;a href=&quot;#1012-至少有-1-位重复的数字&quot; class=&quot;headerlink&quot; title=&quot;1012. 至少有 1 位重复的数字&quot;&gt;&lt;/a&gt;1012. 至少有 1 位重复的数字&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定正整数 N，返回小于等于 N 且具有至少 1 位重复数字的正整数的个数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：具有至少 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 位重复数字的正数（&amp;lt;= &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;）只有 &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：具有至少 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 位重复数字的正数（&amp;lt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;）有 &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;33&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;55&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;66&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;77&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;262&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 191周比赛</title>
    <link href="http://yoursite.com/2020/05/31/167/"/>
    <id>http://yoursite.com/2020/05/31/167/</id>
    <published>2020-05-31T09:04:23.304Z</published>
    <updated>2020-05-31T15:10:33.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="191周双周赛"><a href="#191周双周赛" class="headerlink" title="191周双周赛"></a>191周双周赛</h1><p>最后一题DP很简单，结果在第三题上卡了好长时间，最后排名404名。</p><h2 id="5424-数组中两元素的最大乘积"><a href="#5424-数组中两元素的最大乘积" class="headerlink" title="5424. 数组中两元素的最大乘积"></a>5424. 数组中两元素的最大乘积</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 i 和 j，使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。</p><p>请你计算并返回该式的最大值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">12</span> </span><br><span class="line">解释：如果选择下标 i=<span class="number">1</span> 和 j=<span class="number">2</span>（下标从 <span class="number">0</span> 开始），则可以获得最大值，(nums[<span class="number">1</span>]<span class="number">-1</span>)*(nums[<span class="number">2</span>]<span class="number">-1</span>) = (<span class="number">4</span><span class="number">-1</span>)*(<span class="number">5</span><span class="number">-1</span>) = <span class="number">3</span>*<span class="number">4</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：选择下标 i=<span class="number">1</span> 和 j=<span class="number">3</span>（下标从 <span class="number">0</span> 开始），则可以获得最大值 (<span class="number">5</span><span class="number">-1</span>)*(<span class="number">5</span><span class="number">-1</span>) = <span class="number">16</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">12</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>1 &lt;= nums[i] &lt;= 10^3</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序取最大的两个元素</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序取最大的两个元素相乘<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> (nums[n<span class="number">-1</span>]<span class="number">-1</span>)*(nums[n<span class="number">-2</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5425-切割后面积最大的蛋糕"><a href="#5425-切割后面积最大的蛋糕" class="headerlink" title="5425. 切割后面积最大的蛋糕"></a>5425. 切割后面积最大的蛋糕</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>矩形蛋糕的高度为 h 且宽度为 w，给你两个整数数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code>，其中<code>horizontalCuts[i]</code>是从矩形蛋糕顶部到第  i 个水平切口的距离，类似地， <code>verticalCuts[j]</code> 是从矩形蛋糕的左侧到第 j 个竖直切口的距离。</p><p>请你按数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code> 中提供的水平和竖直位置切割后，请你找出 面积最大 的那份蛋糕，并返回其 面积 。由于答案可能是一个很大的数字，因此需要将结果对 <code>10^9 + 7</code> 取余后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：h = <span class="number">5</span>, w = <span class="number">4</span>, horizontalCuts = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], verticalCuts = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：h = <span class="number">5</span>, w = <span class="number">4</span>, horizontalCuts = [<span class="number">3</span>,<span class="number">1</span>], verticalCuts = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色和黄色的两份蛋糕面积最大。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：h = <span class="number">5</span>, w = <span class="number">4</span>, horizontalCuts = [<span class="number">3</span>], verticalCuts = [<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= h, w &lt;= 10^9</code></li><li><code>1 &lt;= horizontalCuts.length &lt; min(h, 10^5)</code></li><li><code>1 &lt;= verticalCuts.length &lt; min(w, 10^5)</code></li><li><code>1 &lt;= horizontalCuts[i] &lt; h</code></li><li><code>1 &lt;= verticalCuts[i] &lt; w</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>将所有的切口按照坐标的位置从小达到排序，找到切分的最大的高度和宽度，取乘积即可。</li><li>题目必须要注意的时溢出的问题，因为这个细节处理不好，提交错误了两次。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size();</span><br><span class="line">        <span class="keyword">int</span> n = B.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxW = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxH = <span class="number">0</span>;</span><br><span class="line">        sort(A.begin(),A.end());</span><br><span class="line">        sort(B.begin(),B.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            maxH = max(maxH,A[i]-x);</span><br><span class="line">            x = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxH = max(maxH,h-x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            maxW = max(maxW,B[i]-y);</span><br><span class="line">            y = B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxW = max(maxW,w-y);</span><br><span class="line">        res = ((<span class="keyword">long</span> <span class="keyword">long</span>)maxH*(<span class="keyword">long</span> <span class="keyword">long</span>)maxW)%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5426-重新规划路线"><a href="#5426-重新规划路线" class="headerlink" title="5426. 重新规划路线"></a>5426. 重新规划路线</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>n 座城市，从 0 到 <code>n-1</code> 编号，其间共有 <code>n-1</code> 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p><p>路线用<code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 表示从城市 a 到 b 的一条有向路线。</p><p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。</p><p>请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。</p><p>题目数据 保证 每个城市在重新规划路线方向后都能到达城市 0 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, connections = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, connections = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 5 * 10^4</code></li><li><code>connections.length == n-1</code></li><li><code>connections[i].length == 2</code></li><li><code>0 &lt;= connections[i][0], connections[i][1] &lt;= n-1</code></li><li><code>connections[i][0] != connections[i][1]</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>存储城市的连接图和它的逆向图，我们以0为起点，进行BFS，同时将每个点的正向图和逆向图的边全部都入队列，对于逆向图的边我们进行加1操作即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minReorder</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reverseGraph;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : connections)&#123;</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">            reverseGraph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        qu.push(<span class="number">0</span>);</span><br><span class="line">        visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : reverseGraph[curr])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                    res++;</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5427-两个盒子中球的颜色数相同的概率"><a href="#5427-两个盒子中球的颜色数相同的概率" class="headerlink" title="5427. 两个盒子中球的颜色数相同的概率"></a>5427. 两个盒子中球的颜色数相同的概率</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>桌面上有 2n 个颜色不完全相同的球，球上的颜色共有 k 种。给你一个大小为 k 的整数数组<code>balls</code>，其中 balls[i] 是颜色为 i 的球的数量。</p><p>所有的球都已经 随机打乱顺序 ，前 n 个球放入第一个盒子，后 n 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。</p><p>注意：这两个盒子是不同的。例如，两个球颜色分别为 a 和 b，盒子分别为 [] 和 ()，那么<code>[a] (b)</code> 和 <code>[b] (a)</code>这两种分配方式是不同的（请认真阅读示例 1 的解释部分）。</p><p>请计算「两个盒子中球的颜色数相同」的情况的概率。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1.00000</span></span><br><span class="line">解释：球平均分配的方式只有两种：</span><br><span class="line">- 颜色为 <span class="number">1</span> 的球放入第一个盒子，颜色为 <span class="number">2</span> 的球放入第二个盒子</span><br><span class="line">- 颜色为 <span class="number">2</span> 的球放入第一个盒子，颜色为 <span class="number">1</span> 的球放入第二个盒子</span><br><span class="line">这两种分配，两个盒子中球的颜色数都相同。所以概率为 <span class="number">2</span>/<span class="number">2</span> = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0.66667</span></span><br><span class="line">解释：球的列表为 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">随机打乱，得到 <span class="number">12</span> 种等概率的不同打乱方案，每种方案概率为 <span class="number">1</span>/<span class="number">12</span> ：</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span> / <span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">1</span> / <span class="number">3</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span> / <span class="number">1</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span> / <span class="number">3</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">3</span> / <span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span> / <span class="number">2</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">1</span> / <span class="number">1</span>,<span class="number">3</span>], [<span class="number">2</span>,<span class="number">1</span> / <span class="number">3</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">3</span> / <span class="number">1</span>,<span class="number">1</span>], [<span class="number">3</span>,<span class="number">1</span> / <span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">1</span> / <span class="number">2</span>,<span class="number">1</span>], [<span class="number">3</span>,<span class="number">2</span> / <span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。</span><br><span class="line">这 <span class="number">12</span> 种可能的随机打乱方式中的 <span class="number">8</span> 种满足「两个盒子中球的颜色数相同」。</span><br><span class="line">概率 = <span class="number">8</span>/<span class="number">12</span> = <span class="number">0.66667</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0.60000</span></span><br><span class="line">解释：球的列表为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]。要想显示所有 <span class="number">180</span> 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 <span class="number">108</span> 种情况是比较容易的。</span><br><span class="line">概率 = <span class="number">108</span> / <span class="number">180</span> = <span class="number">0.6</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0.30000</span></span><br><span class="line">解释：球的列表为 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]。要想显示所有 <span class="number">60</span> 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 <span class="number">18</span> 种情况是比较容易的。</span><br><span class="line">概率 = <span class="number">18</span> / <span class="number">60</span> = <span class="number">0.3</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">0.90327</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= balls.length &lt;= 8</code></li><li><code>1 &lt;= balls[i] &lt;= 6</code></li><li><code>sum(balls)</code>是偶数</li><li>答案与真实值误差在 <code>10^-5</code> 以内，则被视为正确答案</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls" target="_blank" rel="noopener">https://leetcode-cn.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们知道球的个数的数列为:<script type="math/tex; mode=display">A = [a_{0},a_{1},a_{2},a_{3},..,a_{n}]</script>则该数列所有可能的组合序列个数为：<script type="math/tex; mode=display">T_{a} = \frac{(\sum_{i=1}^{n}a_{i})!}{\prod_{i=1}^{n}(a_{i}!)}</script></li><li>我们可以直接用暴力法，因为该题的数目很小，我们直接可以用暴力，求出所有的球的颜色的组合数，python直接用笛卡儿积就可以搞定，比如我们假设目前该盒子中所有的球的颜色组合数目列表为:<script type="math/tex; mode=display">A = [a_{0},a_{1},a_{2},a_{3},..,a_{n}]</script>已知第一个盒子的球的颜色组合数列表为<script type="math/tex; mode=display">B = [b_{0},b_{1},b_{2},b_{3},..,b_{n}]</script>则另一个盒子中的球的颜色组合数目列表为<script type="math/tex; mode=display">C = [a_{0}-b_{0},a_{1}-b_{1},a_{2}-b_{2},a_{3}-b_{3},..,a_{n}-b_{n}]</script>如何才能满足题目中的条件呢，按照题目中要求第一个盒子和第二个盒子中的球的数目相等，且颜色种类相等。则需满足以下两个条件:<script type="math/tex; mode=display">\sum_{i=1}^{n}b_{i} = \sum_{i=1}^{n}a_{i}-b_{i} \\type(B) = type(C)</script>我们分别求出满足以上两个条件的组合的数列$B$，然后再求出数列$B$的组合数$T_{b}$,与数列$C$的组合数$T_{c}$.<script type="math/tex; mode=display">T_{b} = \frac{(\sum_{i=0}^{n}b_{i})!}{\prod_{i=0}^{n}(b_{i}!)} \\\qquad \\T_{c} = \frac{(\sum_{i=0}^{n}c_{i})!}{\prod_{i=0}^{n}(c_{i}!)} \\\qquad \\P_{b} = \frac{T_{b}*T_{c}}{T_{a}}</script></li><li>比如下面这个例子：<br>比如球得个数序列为：<br><code>B1, B2, B3 = 1, 2, 3</code><br>则第一个盒子中球的可能组合为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="keyword">and</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="keyword">and</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="keyword">and</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="keyword">and</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) <span class="keyword">and</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="keyword">and</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>但实际只有两个序列符合要求,两个序列中球的个数相等，且颜色数目也相等：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="keyword">and</span> (<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="keyword">and</span> (<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>因此：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = [M(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>) * M(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) + M(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) * M(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)]/ M(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>所以我们只需要暴力遍历所有可能的组合即可。</li><li>我们找到所有符合条件的序列$B$:<script type="math/tex; mode=display">[B_{0},B_{1},B_{2},...,B_{m}]</script>则总的概率$P$为：<script type="math/tex; mode=display">P = \sum_{i=0}^{m}P_{b_{i}}</script></li><li>我只能说<code>python</code>太强大了，这个暴力要是用C++真心得累死，用<code>python</code>几行就搞定。<br><a href="https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/discuss/661757/Python-10-Lines-90-Multionomial-coefficients-explained" target="_blank" rel="noopener">详见国际版</a></li><li>还有一种解法参考@cuiaoxiang的解法。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multinomial</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> factorial(sum(n))/prod([factorial(i) <span class="keyword">for</span> i <span class="keyword">in</span> n])</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getProbability</span><span class="params">(self, balls)</span>:</span></span><br><span class="line">        print(self.multinomial([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">        k, n, Q = len(balls), sum(balls)// <span class="number">2</span>, <span class="number">0</span></span><br><span class="line">        arrays = [range(<span class="number">0</span>,i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> balls]</span><br><span class="line">        t = list(product(*arrays))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t)):</span><br><span class="line">            <span class="keyword">if</span> sum(t[i]) == n <span class="keyword">and</span> t[i].count(<span class="number">0</span>) == t[-i<span class="number">-1</span>].count(<span class="number">0</span>):</span><br><span class="line">                Q += self.multinomial(t[i]) * self.multinomial(t[-i<span class="number">-1</span>]) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Q / self.multinomial(list(balls))</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> cnt, tot;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> sum, <span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == m) &#123;</span><br><span class="line">                cnt += (A == B) * p;</span><br><span class="line">                tot += p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a[pos] &amp;&amp; i + sum &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxtA = A + (i &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> nxtB = B + (a[pos] - i &gt; <span class="number">0</span>);</span><br><span class="line">            search(pos + <span class="number">1</span>, i + sum, nxtA, nxtB, p * C[a[pos]][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getProbability</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            C[i][i] = C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        n = a.size();</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : a) m += x;</span><br><span class="line">        m /= <span class="number">2</span>;</span><br><span class="line">        cnt = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">        search(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt / tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;191周双周赛&quot;&gt;&lt;a href=&quot;#191周双周赛&quot; class=&quot;headerlink&quot; title=&quot;191周双周赛&quot;&gt;&lt;/a&gt;191周双周赛&lt;/h1&gt;&lt;p&gt;最后一题DP很简单，结果在第三题上卡了好长时间，最后排名404名。&lt;/p&gt;&lt;h2 id=&quot;5424-数组中两元素的最大乘积&quot;&gt;&lt;a href=&quot;#5424-数组中两元素的最大乘积&quot; class=&quot;headerlink&quot; title=&quot;5424. 数组中两元素的最大乘积&quot;&gt;&lt;/a&gt;5424. 数组中两元素的最大乘积&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，请你选择数组的两个不同下标 i 和 j，使 &lt;code&gt;(nums[i]-1)*(nums[j]-1)&lt;/code&gt; 取得最大值。&lt;/p&gt;&lt;p&gt;请你计算并返回该式的最大值。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：如果选择下标 i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 和 j=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;（下标从 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 开始），则可以获得最大值，(nums[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)*(nums[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) = (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)*(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：选择下标 i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 和 j=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;（下标从 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 开始），则可以获得最大值 (&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)*(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 27周双周赛</title>
    <link href="http://yoursite.com/2020/05/31/166/"/>
    <id>http://yoursite.com/2020/05/31/166/</id>
    <published>2020-05-31T09:04:23.303Z</published>
    <updated>2020-05-31T09:04:28.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="27周双周赛"><a href="#27周双周赛" class="headerlink" title="27周双周赛"></a>27周双周赛</h1><p>最后一题DP很简单，结果在第三题上卡了好长时间，最后排名192名，还是水平很菜，我想只能靠自己一点点去提高。<br><img src="https://mike-box.github.io/images/167-1.png" alt="1"></p><h2 id="5408-通过翻转子数组使两个数组相等"><a href="#5408-通过翻转子数组使两个数组相等" class="headerlink" title="5408. 通过翻转子数组使两个数组相等"></a>5408. 通过翻转子数组使两个数组相等</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个长度相同的整数数组<code>target</code>和 <code>arr</code> 。</p><p>每一步中，你可以选择 <code>arr</code> 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。</p><a id="more"></a><p>如果你能让 <code>arr</code>变得与 <code>target</code> 相同，返回 <code>True</code>；否则，返回<code>False</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：你可以按照如下步骤使 arr 变成 target：</span><br><span class="line"><span class="number">1</span>- 翻转子数组 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>] ，arr 变成 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">2</span>- 翻转子数组 [<span class="number">4</span>,<span class="number">2</span>] ，arr 变成 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>- 翻转子数组 [<span class="number">4</span>,<span class="number">3</span>] ，arr 变成 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">7</span>], arr = [<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：arr 不需要做任何翻转已经与 target 相等。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">12</span>], arr = [<span class="number">12</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>], arr = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">11</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：arr 没有数字 <span class="number">9</span> ，所以无论如何也无法变成 target 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>target.length == arr.length</code></li><li><code>1 &lt;= target.length &lt;= 1000</code></li><li><code>1 &lt;= target[i] &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的就是排序后，看两个数组是否相等即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        sort(target.begin(),target.end());</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i] != arr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5409-检查一个字符串是否包含所有长度为-K-的二进制子串"><a href="#5409-检查一个字符串是否包含所有长度为-K-的二进制子串" class="headerlink" title="5409. 检查一个字符串是否包含所有长度为 K 的二进制子串"></a>5409. 检查一个字符串是否包含所有长度为 K 的二进制子串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 s 和一个整数 k 。</p><p>如果所有长度为 k 的二进制字符串都是 s 的子串，请返回 True ，否则请返回 False 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"00110110"</span>, k = <span class="number">2</span></span><br><span class="line">输出：true</span><br><span class="line">解释：长度为 <span class="number">2</span> 的二进制串包括 <span class="string">"00"</span>，<span class="string">"01"</span>，<span class="string">"10"</span> 和 <span class="string">"11"</span>。它们分别是 s 中下标为 <span class="number">0</span>，<span class="number">1</span>，<span class="number">3</span>，<span class="number">2</span> 开始的长度为 <span class="number">2</span> 的子串。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"00110"</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0110"</span>, <span class="attr">k</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：长度为 <span class="number">1</span> 的二进制串包括 <span class="string">"0"</span> 和 <span class="string">"1"</span>，显然它们都是 s 的子串。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0110"</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：长度为 <span class="number">2</span> 的二进制串 <span class="string">"00"</span> 没有出现在 s 中。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0000000001011100"</span>, <span class="attr">k</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 5 * 10^5</li><li>s 中只含 0 和 1 。</li><li>1 &lt;= k &lt;= 20</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>该字符串中所有长度为k的子串用set存储起来即可，最后查看set中元素的数量是否等于<code>2^k</code>。</li><li>如果希望能够更快一点，可以KR算法，直接将字符串转换为hash数字。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAllCodes</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-k; ++i)&#123;</span><br><span class="line">            cnt.insert(s.substr(i,k));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt.size() == (<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5410-课程安排-IV"><a href="#5410-课程安排-IV" class="headerlink" title="5410. 课程安排 IV"></a>5410. 课程安排 IV</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你总共需要上 n 门课，课程编号依次为 0 到 n-1 。</p><p>有的课会有直接的先修课程，比如如果想上课程 0 ，你必须先上课程 1 ，那么会以 [1,0] 数对的形式给出先修课程数对。</p><p>给你课程总数 n 和一个直接先修课程数对列表 <code>prerequisite</code>和一个查询对列表 queries 。</p><p>对于每个查询对 <code>queries[i]</code>，请判断<code>queries[i][0]</code> 是否是<code>queries[i][1]</code> 的先修课程。</p><p>请返回一个布尔值列表，列表中每个元素依次分别对应 <code>queries</code> 每个查询对的判断结果。</p><p>注意：如果课程 a 是课程 b 的先修课程且课程 b 是课程 c 的先修课程，那么课程 a 也是课程 c 的先修课程。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, prerequisites = [[<span class="number">1</span>,<span class="number">0</span>]], queries = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">true</span>]</span><br><span class="line">解释：课程 <span class="number">0</span> 不是课程 <span class="number">1</span> 的先修课程，但课程 <span class="number">1</span> 是课程 <span class="number">0</span> 的先修课程。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, prerequisites = [], queries = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">false</span>]</span><br><span class="line">解释：没有先修课程对，所以每门课程之间是独立的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, prerequisites = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]], queries = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, prerequisites = <span class="string">[[1,0],[2,0]]</span>, queries = <span class="string">[[0,1],[2,0]]</span></span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, prerequisites = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]], queries = [[<span class="number">0</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= prerequisite.length &lt;= (n * (n - 1) / 2)</code></li><li><code>0 &lt;= prerequisite[i][0], prerequisite[i][1] &lt; n</code></li><li><code>prerequisite[i][0] != prerequisite[i][1]</code></li><li>先修课程图中没有环。</li><li>先修课程图中没有重复的边。</li><li><code>1 &lt;= queries.length &lt;= 10^4</code></li><li><code>queries[i][0] != queries[i][1]</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/course-schedule-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule-iv</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> TOP排序或者Floyd</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始这个题目以为很简单，上来就直接BFS，然后毫无意外的超时。。</li><li>仔细分析了一下超时的原因。后来用了top排序，求所有课程的依赖关系，当每个课程的依赖关系是递进的，比如：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;B B-&gt;C 则 A-&gt;C</span><br></pre></td></tr></table></figure>我们根据top排序，求出所有B的依赖集合，同时C继承B的所有依赖即可即可。</li><li>类似于floy算法，算法复杂度稍微高一些，O(n^3),即可求解。我们已经知道依赖关系如下：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;B B-&gt;C</span><br></pre></td></tr></table></figure>则我们将所有B依赖的课程都查询一遍，加给C的依赖关系即可。详情可见Floyd-Warshall算法</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; checkIfPrerequisite(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Graph;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reverseGraph;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; require;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ret;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : prerequisites)&#123;</span><br><span class="line">            Graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">            reverseGraph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                qu.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : Graph[curr])&#123;</span><br><span class="line">                indegree[v]--;</span><br><span class="line">                require[v].insert(curr);</span><br><span class="line">                <span class="keyword">if</span>(indegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> e : reverseGraph[v])&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> x : require[e])&#123;</span><br><span class="line">                            require[v].insert(x);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : queries)&#123;</span><br><span class="line">            <span class="keyword">if</span>(require[v[<span class="number">1</span>]].count(v[<span class="number">0</span>]))&#123;</span><br><span class="line">                ret.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ret.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; checkIfPrerequisite(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v :  prerequisites)&#123;</span><br><span class="line">            dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][v[<span class="number">0</span>]])&#123;</span><br><span class="line">                    dp[i][v[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : queries)&#123;</span><br><span class="line">            res.push_back(dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; checkIfPrerequisite(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v :  prerequisites)&#123;</span><br><span class="line">            dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j] &amp;&amp; dp[j][k])&#123;</span><br><span class="line">                        dp[i][k] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : queries)&#123;</span><br><span class="line">            res.push_back(dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5411-摘樱桃-II"><a href="#5411-摘樱桃-II" class="headerlink" title="5411. 摘樱桃 II"></a>5411. 摘樱桃 II</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>rows x cols</code>的矩阵<code>grid</code>来表示一块樱桃地。 <code>grid</code> 中每个格子的数字表示你能获得的樱桃数目。</p><p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。</p><p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p><p>从格子 (i,j) 出发，机器人可以移动到格子 <code>(i+1, j-1)，(i+1, j) 或者 (i+1, j+1)</code> 。<br>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。<br>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。<br>两个机器人在任意时刻都不能移动到 grid 外面。<br>两个机器人最后都要到达 grid 最底下一行。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：机器人 <span class="number">1</span> 和机器人 <span class="number">2</span> 的路径在上图中分别用绿色和蓝色表示。</span><br><span class="line">机器人 <span class="number">1</span> 摘的樱桃数目为 (<span class="number">3</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">2</span>) = <span class="number">12</span> 。</span><br><span class="line">机器人 <span class="number">2</span> 摘的樱桃数目为 (<span class="number">1</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span>) = <span class="number">12</span> 。</span><br><span class="line">樱桃总数为： <span class="number">12</span> + <span class="number">12</span> = <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">解释：机器人 <span class="number">1</span> 和机器人 <span class="number">2</span> 的路径在上图中分别用绿色和蓝色表示。</span><br><span class="line">机器人 <span class="number">1</span> 摘的樱桃数目为 (<span class="number">1</span> + <span class="number">9</span> + <span class="number">5</span> + <span class="number">2</span>) = <span class="number">17</span> 。</span><br><span class="line">机器人 <span class="number">2</span> 摘的樱桃数目为 (<span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">3</span>) = <span class="number">11</span> 。</span><br><span class="line">樱桃总数为： <span class="number">17</span> + <span class="number">11</span> = <span class="number">28</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">22</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>rows == grid.length</code></li><li><code>cols == grid[i].length</code></li><li><code>2 &lt;= rows, cols &lt;= 70</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/cherry-pickup-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cherry-pickup-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>经典的DP，稍微转换下思路即可实现</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该题目是经典的DP，如果熟悉DP的同学这个题目还是非常简单。</li><li>设<code>dp[i][x][y]</code>表示到达第<code>i</code>行时，机器人1在第<code>x</code>列，机器人2在第<code>y</code>列的时取得最大值。因为我们知道机器人从<code>(i,j)</code>出发，机器人可以移动到格子 <code>(i+1, j-1)，(i+1, j)</code> 或者 <code>(i+1, j+1)</code>。则我们可以知道机器人在<code>(i,j)</code>坐标时，则只可能从前一行得<code>(i-1, j-1)，(i-1, j)，(i-1,j+1)</code>这三个坐标到达。因为两个机器人时同时前进一步得，则当机器人1在坐标<code>(i,x)</code>,则上一行机器人1的位置可能在<code>(i-1, x-1)，(i-1, x)，(i-1,x+1)</code>；则当机器人1在坐标<code>(i,y)</code>,则上一行机器人2的位置可能在<code>(i-1, y-1)，(i-1, y)，(i-1,y+1)</code>这三个位置。</li><li>则dp得递推公式为<script type="math/tex; mode=display">dp[i][x][y] = grid[i][x] + grid[i][y] + max\left\{\begin{aligned}dp[i-1][x-1][y-1]\\dp[i-1][x-1][y]\\dp[i-1][x-1][y+1]\\dp[i-1][x][y-1]\\dp[i-1][x][y]\\dp[i-1][x][y+1]\\dp[i-1][x+1][y-1]\\dp[i-1][x+1][y]\\dp[i-1][x+1][y+1]\\\end{aligned}\right.</script></li><li>实际上根据贪心元素，机器人1和机器人2不要在同一个格子进行摘樱桃。即<script type="math/tex">x \neq y</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">71</span>][<span class="number">71</span>][<span class="number">71</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cherryPickup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][col<span class="number">-1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] + grid[<span class="number">0</span>][col<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; col; ++k)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l1 = <span class="number">-1</span>; l1 &lt;= <span class="number">1</span>; ++l1)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> l2 = <span class="number">-1</span>; l2 &lt;= <span class="number">1</span>; ++l2)&#123;</span><br><span class="line">                            <span class="keyword">int</span> x = j + l1;</span><br><span class="line">                            <span class="keyword">int</span> y = k + l2;</span><br><span class="line">                            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; col &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; dp[i<span class="number">-1</span>][x][y] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                                dp[i][j][k] = max(dp[i][j][k],dp[i<span class="number">-1</span>][x][y]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j][k] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j == k)&#123;</span><br><span class="line">                            dp[i][j][k] += grid[i][j];</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            dp[i][j][k] += grid[i][j] + grid[i][k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                res = max(res,dp[row<span class="number">-1</span>][i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;27周双周赛&quot;&gt;&lt;a href=&quot;#27周双周赛&quot; class=&quot;headerlink&quot; title=&quot;27周双周赛&quot;&gt;&lt;/a&gt;27周双周赛&lt;/h1&gt;&lt;p&gt;最后一题DP很简单，结果在第三题上卡了好长时间，最后排名192名，还是水平很菜，我想只能靠自己一点点去提高。&lt;br&gt;&lt;img src=&quot;https://mike-box.github.io/images/167-1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5408-通过翻转子数组使两个数组相等&quot;&gt;&lt;a href=&quot;#5408-通过翻转子数组使两个数组相等&quot; class=&quot;headerlink&quot; title=&quot;5408. 通过翻转子数组使两个数组相等&quot;&gt;&lt;/a&gt;5408. 通过翻转子数组使两个数组相等&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个长度相同的整数数组&lt;code&gt;target&lt;/code&gt;和 &lt;code&gt;arr&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;每一步中，你可以选择 &lt;code&gt;arr&lt;/code&gt; 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 LCP2020 (组队赛)</title>
    <link href="http://yoursite.com/2020/05/29/165/"/>
    <id>http://yoursite.com/2020/05/29/165/</id>
    <published>2020-05-29T05:03:24.516Z</published>
    <updated>2020-05-29T05:03:32.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCP比赛"><a href="#LCP比赛" class="headerlink" title="LCP比赛"></a>LCP比赛</h1><p>LCP组队赛的题目真心难，接近ACM的比赛的水平了，比单人赛难多了，最终两个人的组合做出来了第一题和第二题，第三题和第四题全部超时。感觉自己的水平还是不够，平时还是应该有时间刷刷CF、GCJ、ATCODER才能提高水平。平时需要抓紧这几方面的练习。lc的题目还是难度太低了。</p><h2 id="LCP11"><a href="#LCP11" class="headerlink" title="LCP11"></a>LCP11</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。</p><a id="more"></a><p>小 <code>A</code> 和小 <code>B</code> 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。现在给定 n 名面试者的能力值 <code>scores</code>，设 X 代表小<code>A</code>和小<code>B</code>的浏览顺序中出现在同一位置的简历数，求 <code>X</code> 的期望。</p><p>提示：离散的非负随机变量的期望计算公式为 。在本题中，由于 X 的取值为 <code>0</code>到 <code>n</code> 之间，期望计算公式可以是 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：scores = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：scores = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：设两位面试者的编号为 <span class="number">0</span>, <span class="number">1</span>。由于他们的能力值都是 <span class="number">1</span>，小 A 和小 B 的浏览顺序都为从全排列 [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]] 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 [<span class="number">0</span>,<span class="number">1</span>] 或者 [<span class="number">1</span>,<span class="number">0</span>] ，那么出现在同一位置的简历数为 <span class="number">2</span> ，否则是 <span class="number">0</span> 。所以 X 的期望是 (<span class="number">2</span>+<span class="number">0</span>+<span class="number">2</span>+<span class="number">0</span>) * <span class="number">1</span>/<span class="number">4</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：scores = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= scores.length &lt;= 10^5</code></li><li><code>0 &lt;= scores[i] &lt;= 10^6</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/qi-wang-ge-shu-tong-ji" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qi-wang-ge-shu-tong-ji</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>经过分析，我们发现不同能力值的简历是不会互相影响的，所以问题可以简化为有一个长度为$n$的的数组，将里面的元素按照全排列随机排序后，问有多少个元素还在原位。设这个随机变量为 $x$ ，并且设$X_{i}$是第$i$个元素还在原位的 0-1 变量，即如果第$i$个元素还在原位,$X_{i} = 1$,否则 $X_{i} = 0$,每一个元素随机排序后还在原位的概率是$\frac{1}{n}$。<br>由期望的可加性，我们可以得到:<script type="math/tex; mode=display">E(X) = E(X_{0} + X_{1} + ... + X_{n-1}) = \sum_{0\le x \le n}EX_{i} = \frac{1}{n}*n = 1</script>我们发现$E(X)$跟数组元素的长度无关，所以我们只需要求这个数组中的不同数字的个数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expectNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; scores)</span> </span>&#123;</span><br><span class="line">        sort(scores.begin(), scores.end());</span><br><span class="line">        <span class="keyword">return</span> unique(scores.begin(), scores.end()) - scores.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-12-小张刷题计划"><a href="#LCP-12-小张刷题计划" class="headerlink" title="LCP 12. 小张刷题计划"></a>LCP 12. 小张刷题计划</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>为了提高自己的代码能力，小张制定了<code>LeetCode</code>刷题计划，他选中了 <code>LeetCode</code>题库中的<code>n</code>道题，编号从 <code>0</code> 到 <code>n-1</code>，并计划在 <code>m</code>天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。</p><p>在小张刷题计划中，小张需要用<code>time[i]</code>的时间完成编号<code>i</code>的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。</p><p>我们定义<code>m</code> 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：time = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 <span class="number">3</span> 的时间，并且这个值是最小的。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：time = [<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>], m = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。</span><br></pre></td></tr></table></figure></p><p>限制：</p><ul><li><code>1 &lt;= time.length &lt;= 10^5</code></li><li><code>1 &lt;= time[i] &lt;= 10000</code></li><li><code>1 &lt;= m &lt;= 1000</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中的数组的长度的级数为10的5次方。</li><li>我们用二分查找的办法找到最小时间。每次去检测当前的最小时间能否满足要求，关键点在与检测函数，检测函数实际也时一个简单的贪心算法。</li><li>我们在有限的时间约束下，每次剔除最大的花费时间。花费的天数能否小于等于<code>m</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; time,<span class="keyword">int</span> m,<span class="keyword">int</span> maxT)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = time.size();</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cost &lt;= m &amp;&amp; i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> maxCurr = <span class="number">0</span>;            </span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; curr &lt;= maxT)&#123;</span><br><span class="line">                curr += time[i];</span><br><span class="line">                maxCurr = max(maxCurr,time[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; curr &gt; maxT) curr -= maxCurr;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; curr + time[i] &lt;= maxT)&#123;</span><br><span class="line">                curr += time[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            cost++;</span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cost &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; time, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = time.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(time,m,mid))&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-13-寻宝"><a href="#LCP-13-寻宝" class="headerlink" title="LCP 13. 寻宝"></a>LCP 13. 寻宝</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 ‘S’ 表示），和唯一的宝藏地点（用 ‘T’ 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 ‘M’ 表示），只有所有机关均被触发，才可以拿到宝藏。</p><p>要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 ‘O’ 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。</p><p>迷宫中同样有一些墙壁（用 ‘#’ 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 ‘.’ 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。</p><p>我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。</p><p>示例 1：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [<span class="string">"S#O"</span>, <span class="string">"M.."</span>, <span class="string">"M.T"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line"></span><br><span class="line">解释：最优路线为： S-&gt;O, <span class="function"><span class="title">cost</span> = 4, 去搬石头 O-&gt;</span>第二行的M, <span class="function"><span class="title">cost</span> = 3, M机关触发 第二行的M-&gt;</span>O, <span class="function"><span class="title">cost</span> = 3, 我们需要继续回去 O 搬石头。 O-&gt;</span>第三行的M, <span class="function"><span class="title">cost</span> = 4, 此时所有机关均触发 第三行的M-&gt;</span>T, cost = <span class="number">2</span>，去T点拿宝藏。 总步数为<span class="number">16</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [<span class="string">"S<span class="subst">#O</span>"</span>, <span class="string">"M.#"</span>, <span class="string">"M.T"</span>]</span><br><span class="line"></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：我们无法搬到石头触发机关</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [<span class="string">"S<span class="subst">#O</span>"</span>, <span class="string">"M.T"</span>, <span class="string">"M.."</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">17</span></span><br><span class="line"></span><br><span class="line">解释：注意终点也是可以通行的。</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= maze.length &lt;= 100</code></li><li><code>1 &lt;= maze[i].length &lt;= 100</code></li><li><code>maze[i].length == maze[j].length</code></li><li><code>S</code> 和 <code>T</code>有且只有一个</li><li><code>0 &lt;= M</code>的数量 <code>&lt;= 16</code></li><li><code>0 &lt;= O</code>的数量 <code>&lt;= 40</code>，题目保证当迷宫中存在 <code>M</code>时，一定存在至少一个 <code>O</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/xun-bao" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xun-bao</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS + DP</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目还是非常复杂，中间需要处理的细节非常多。当时比赛的时候各种细节处理。</li><li>题目中要求从起点开始，拿到石头，然后打开所有开关后，然后再走到终点，我们可以看到所有的最短路径都是如下：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; O -&gt; M -&gt; O -&gt; M -&gt; O -&gt; M ...-&gt; T</span><br></pre></td></tr></table></figure>最短路径肯定是从起点开始拿到石头打开开关<code>M1</code>,拿起石头打开开关<code>M2</code>，直到所有的开关都打开，然后再走到终点<code>T</code>.</li><li>首先由于所有的石头都是无限的，可以重复多次拿取，我们应该实际有限取距离机关最近的石头，但是实际上应该是我们从一个开关，拿到石头，然后走向另一个开关，这个非常类似于<code>leetcode</code>上1293题：<a href="https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/" target="_blank" rel="noopener">网格中的最短路径</a>,如果做了这个题目的话，肯定对这个题有所了解。我们可以快速的通过BFS求出以下三种最短距离：</li></ol><ul><li>从起点<code>T</code>处开始拿到石头走到某个开关<code>M</code>的最短距离。</li><li>从任意的机关<code>Mx</code>处出发拿到石头走到任意其他机关<code>My</code>处的最短距离。</li><li>从任意的机关<code>M</code>处出发走到终点<code>T</code>的最短距离。<br>总的来说，最短路径实际分为以上三部分，求出以上三部分的和即为最短路径。</li></ul><ol><li>这道题目稍微复杂点，如果直接计算的话，所有的路径组合大概大概有<code>n!</code>数量级，这是肯定不可接受的，所以我们需要用<code>dp</code>，我们用位图掩码<code>mask</code>来表示当前哪些机关已经被打开。</li><li>我们设<code>dp[x][state]</code>表示最后一个经过的开关为<code>x</code>所有已经打开<code>state</code>开关的位图。则递推公式为：<script type="math/tex; mode=display">dp[y][state|(1<<y)] = min(dp[y][state|(1<<y)],dp[x][state] + distance(x,y))</script></li><li>我们按照上述的 动态规划，可以很快的求出从起点开始打开所有的机关的最短距离，时间复杂度为$O(m^2*2^m)$最后还需要再加上从最后一个机关到达终点<code>T</code>的距离。这道题得代码真心是又臭又长得。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> visit[<span class="number">101</span>][<span class="number">101</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bitTst</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((mask&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitSet</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mask|(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitClr</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mask&amp;(~(<span class="number">1</span>&lt;&lt;n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; maze,<span class="keyword">int</span> start,<span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; &amp; dist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = maze.size();</span><br><span class="line">        <span class="keyword">int</span> col = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; qu;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">        </span><br><span class="line">        qu.push(make_pair(start,<span class="number">0</span>));</span><br><span class="line">        visit[start/col][start%col][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dist[make_pair(start,start)] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> x = curr.first/col;</span><br><span class="line">                <span class="keyword">int</span> y = curr.first%col;</span><br><span class="line">                <span class="keyword">int</span> take = curr.second;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;x&lt;&lt;":"&lt;&lt;y&lt;&lt;":"&lt;&lt;take&lt;&lt;endl;</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + d[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + d[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(visit[nx][ny][take] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                        qu.push(make_pair(nx*col+ny,<span class="number">1</span>));</span><br><span class="line">                        visit[nx][ny][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'M'</span> &amp;&amp; take == <span class="number">1</span>)&#123;</span><br><span class="line">                        dist[make_pair(start,nx*col+ny)] = step + <span class="number">1</span>;</span><br><span class="line">                        qu.push(make_pair(nx*col+ny,take));</span><br><span class="line">                        visit[nx][ny][take] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        qu.push(make_pair(nx*col+ny,take));</span><br><span class="line">                        visit[nx][ny][take] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; maze,<span class="keyword">int</span> start,<span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; &amp; dist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = maze.size();</span><br><span class="line">        <span class="keyword">int</span> col = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">        qu.push(start);</span><br><span class="line">        visit[start/col][start%col][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dist[make_pair(start,start)] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="keyword">int</span> x = curr/col;</span><br><span class="line">                <span class="keyword">int</span> y = curr%col;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + d[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + d[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(visit[nx][ny][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'M'</span> || maze[nx][ny] == <span class="string">'S'</span>)&#123;</span><br><span class="line">                        dist[make_pair(start,nx*col+ny)] = step + <span class="number">1</span>;</span><br><span class="line">                        visit[nx][ny][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                        qu.push(nx*col+ny);  </span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        qu.push(nx*col+ny);</span><br><span class="line">                        visit[nx][ny][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            num = num&amp;(num<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimalSteps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; maze)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = maze.size();</span><br><span class="line">        <span class="keyword">int</span> col = maze[<span class="number">0</span>].size(); </span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; dist;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; locks;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j] == <span class="string">'S'</span>) start = i*col + j;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j] == <span class="string">'T'</span>) end = i*col + j;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j] == <span class="string">'M'</span>) locks.push_back(i*col+j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">/*bfs*/</span></span><br><span class="line">        bfs1(maze,start,dist);</span><br><span class="line">        bfs2(maze,end,dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.size(); ++i)&#123;</span><br><span class="line">            bfs1(maze,locks[i],dist);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = locks.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dist.count(make_pair(end,start))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> dist[make_pair(end,start)];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/*check if there has the way make two point connected*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dist.count(make_pair(start,locks[i]))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dist.count(make_pair(end,locks[i]))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!dist.count(make_pair(locks[i],locks[j]))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*dp*/</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>&lt;&lt;m,INT_MAX));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>&lt;&lt;i] = dist[make_pair(start,locks[i])];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bitTst(i,j))&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!bitTst(i,k))&#123;</span><br><span class="line">                            <span class="keyword">int</span> nx = bitSet(i,k);</span><br><span class="line">                            <span class="keyword">if</span>(dp[j][i] != INT_MAX)&#123;</span><br><span class="line">                                dp[k][nx] = min(dp[k][nx],dp[j][i] + dist[make_pair(locks[j],locks[k])]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">               </span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist.count(make_pair(end,locks[i])) &amp;&amp; dp[i][mask] != INT_MAX)&#123;</span><br><span class="line">                res = min(res,dp[i][mask] + dist[make_pair(end,locks[i])]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-14-切分数组"><a href="#LCP-14-切分数组" class="headerlink" title="LCP 14. 切分数组"></a>LCP 14. 切分数组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> ，小李想将<code>nums</code> 切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于 1 。为了减少他的工作量，请求出最少可以切成多少个子数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：最优切割为 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>] 和 [<span class="number">3</span>,<span class="number">3</span>] 。第一个子数组头尾数字的最大公约数为 <span class="number">2</span> ，第二个子数组头尾数字的最大公约数为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：只有一种可行的切割：[<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>2 &lt;= nums[i] &lt;= 10^6</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/qie-fen-shu-zu" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qie-fen-shu-zu</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  dp + 素数筛选</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目初始一看，感觉就我们就可以用 dp来做出来,我们用<code>dp[i]</code>来表示到达索引<code>i</code>处的最少切分量。dp的递推公式如下：<script type="math/tex; mode=display">dp[i] = min(dp[k-1] + 1,dp[i]) \qquad 0 \le k \le (i-1)  \qquad and  \qquad if(GCD(dp[k],dp[i]) \neq 1)</script></li><li>按照上面的思路可以很容易写出代码，代码的时间复杂度为O(n^2).</li><li>后来仔细看了官方的题解答案，感觉自己还是太水了，知道相关的解法。我们设dp[x]代表以切割的数组中最后一个切割第一个元素的包含质因数x为的最小分割数目,prev 代表加入当前元素之前的最小分割比如当我们加入元素num[i]时，我们已知<code>nums[i]</code>包含的质因子为<code>prime1,prime2,prime3,prime4,prime5</code>等一系列质因子.比如我们当前的数组分组如下：<script type="math/tex; mode=display">[a_{1},a_{2},...,a_{i}],[a_{i+1},a_{i+2},...,a_{j}] ,...,\\[a_{j+1},a_{j+2},...,a_{k}],[a_{k+1},a_{k+2},...,a_{m}]</script>我们假设最后一个分组的第一个元素为<script type="math/tex">a_{k+1}</script>,则假设<script type="math/tex">a_{k+1}</script>包含质因数<code>x</code>，则次时我们新加入一个元素<script type="math/tex">a_{n}</script>,它也包含有质因子x,则它可以直接并入到最后一个分组，此时我们的最小值可能为<code>n+1</code>,当然它也可能含有其他质数因子，比如<code>y,q,z</code>等，我们如果找到前面的分组中的首元素包含该质因子的，则我们就可以进行合并。<script type="math/tex; mode=display">dp[x] = min(dp[x],prev + 1) \\dp[prime1] = min(dp[prime1],prev + 1) \\dp[prime2] = min(dp[prime2],prev + 1) \\dp[prime3] = min(dp[prime3],prev + 1) \\dp[prime4] = min(dp[prime4],prev + 1) \\</script></li><li>首先我们需要求出每个数包含的最小质因子，然后我们就可以通过循环来找到该数目包含的所有质因子。求每个数的最小质因数需要一点技巧，当时也是看解答想明了很长时间。这个筛选的还是非常需要一点小技巧，可以再O(m + m)的时间复杂度内求出所有数目的最小质因子。从质数2开始搜索，如k为探测的最小的质数，则<code>1*k,2*k,3*k,4*k,5*k,...,n*k</code>的最小质因数均为<code>k</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*get prime*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxV; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(min_prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxV; j += i)&#123;</span><br><span class="line">            min_prime[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>动态规划时。我们需要求出一个数key的所有质因数，可以采用以下办法,这也是一个小技巧。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = key; x &gt; <span class="number">1</span>; x = x/min_prime[x])&#123;</span><br><span class="line">    <span class="comment">/* the mini dive prime*/</span></span><br><span class="line">    <span class="keyword">int</span> p = min_prime[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>整体的代码还是非常有技巧性的，这才是真是比赛需要的难度，leetcode平常的难度还是太低了。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> min_prime[<span class="number">1000010</span>], prime[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxV = *max_element(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; min_prime(maxV+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp_prime(maxV+<span class="number">1</span>,maxV);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*get prime*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxV; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min_prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxV; j += i)&#123;</span><br><span class="line">                    min_prime[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = min_prime[x];</span><br><span class="line">                dp[i] = min(dp[i],dp_prime[p]);</span><br><span class="line">                dp_prime[p] = min(dp_prime[p],dp[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">do</span>&#123;x = x/p;&#125;<span class="keyword">while</span>(x%p == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-15-游乐园的迷宫"><a href="#LCP-15-游乐园的迷宫" class="headerlink" title="LCP 15. 游乐园的迷宫"></a>LCP 15. 游乐园的迷宫</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> ，小李想将<code>nums</code> 切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于 1 。为了减少他的工作量，请求出最少可以切成多少个子数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：最优切割为 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>] 和 [<span class="number">3</span>,<span class="number">3</span>] 。第一个子数组头尾数字的最大公约数为 <span class="number">2</span> ，第二个子数组头尾数字的最大公约数为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：只有一种可行的切割：[<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>2 &lt;= nums[i] &lt;= 10^6</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/qie-fen-shu-zu" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qie-fen-shu-zu</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li></li><li><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LCP-16-游乐园的游览计划"><a href="#LCP-16-游乐园的游览计划" class="headerlink" title="LCP 16. 游乐园的游览计划"></a>LCP 16. 游乐园的游览计划</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3>又到了一年一度的春游时间，小吴计划去游乐场游玩 1 天，游乐场总共有 N 个游乐项目，编号从 0 到 N-1。小吴给每个游乐项目定义了一个非负整数值 value[i] 表示自己的喜爱值。两个游乐项目之间会有双向路径相连，整个游乐场总共有 M 条双向路径，保存在二维数组 edges中。 小吴计划选择一个游乐项目 A 作为这一天游玩的重点项目。上午小吴准备游玩重点项目 A 以及与项目 A 相邻的两个项目 B、C （项目A、B与C要求是不同的项目，且项目B与项目C要求相邻），并返回 A ，即存在一条 A-B-C-A 的路径。 下午，小吴决定再游玩重点项目 A以及与A相邻的两个项目 B’、C’，（项目A、B’与C’要求是不同的项目，且项目B’与项目C’要求相邻），并返回 A ，即存在一条 A-B’-C’-A 的路径。下午游玩项目 B’、C’ 可与上午游玩项目B、C存在重复项目。 小吴希望提前安排好游玩路径，使得喜爱值之和最大。请你返回满足游玩路径选取条件的最大喜爱值之和，如果没有这样的路径，返回 0。 注意：一天中重复游玩同一个项目并不能重复增加喜爱值了。例如：上下午游玩路径分别是 A-B-C-A与A-C-D-A 那么只能获得 value[A] + value[B] + value[C] + value[D] 的总和。</li></ol></blockquote><p>示例 1：</p><pre><code>输入：edges = [[0,1],[1,2],[0,2]], value = [1,2,3]输出：6解释：喜爱值之和最高的方案之一是 0-&gt;1-&gt;2-&gt;0 与 0-&gt;2-&gt;1-&gt;0 。重复游玩同一点不重复计入喜爱值，返回1+2+3=6</code></pre><p>示例 2：</p><pre><code>输入：edges = [[0,2],[2,1]], value = [1,2,5]输出：0解释：无满足要求的游玩路径，返回 0</code></pre><p>示例 3：</p><pre><code>输入：edges = [[0,1],[0,2],[0,3],[0,4],[0,5],[1,3],[2,4],[2,5],[3,4],[3,5],[4,5]], value = [7,8,6,8,9,7]输出：39解释：喜爱值之和最高的方案之一是 3-&gt;0-&gt;1-&gt;3 与 3-&gt;4-&gt;5-&gt;3 。喜爱值最高为 7+8+8+9+7=39</code></pre><p>限制：</p><pre><code>3 &lt;= value.length &lt;= 100001 &lt;= edges.length &lt;= 100000 &lt;= edges[i][0],edges[i][1] &lt; value.length0 &lt;= value[i] &lt;= 10000edges中没有重复的边edges[i][0] != edges[i][1]</code></pre><h3 id="地址-5"><a href="#地址-5" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/you-le-yuan-de-you-lan-ji-hua/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/you-le-yuan-de-you-lan-ji-hua/</a></p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li></li><li><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LCP比赛&quot;&gt;&lt;a href=&quot;#LCP比赛&quot; class=&quot;headerlink&quot; title=&quot;LCP比赛&quot;&gt;&lt;/a&gt;LCP比赛&lt;/h1&gt;&lt;p&gt;LCP组队赛的题目真心难，接近ACM的比赛的水平了，比单人赛难多了，最终两个人的组合做出来了第一题和第二题，第三题和第四题全部超时。感觉自己的水平还是不够，平时还是应该有时间刷刷CF、GCJ、ATCODER才能提高水平。平时需要抓紧这几方面的练习。lc的题目还是难度太低了。&lt;/p&gt;&lt;h2 id=&quot;LCP11&quot;&gt;&lt;a href=&quot;#LCP11&quot; class=&quot;headerlink&quot; title=&quot;LCP11&quot;&gt;&lt;/a&gt;LCP11&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 算法课程 《Algorithmic on Strings》</title>
    <link href="http://yoursite.com/2020/05/27/164/"/>
    <id>http://yoursite.com/2020/05/27/164/</id>
    <published>2020-05-27T09:22:51.199Z</published>
    <updated>2020-05-28T00:46:46.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithmic-On-Strings"><a href="#Algorithmic-On-Strings" class="headerlink" title="Algorithmic On Strings"></a>Algorithmic On Strings</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，这个课程是关于字符串相关算法，这个课程算法的部分题目非常的<code>tricky</code>,对于我这种智商普通人的来说，真心好多题目想了好几天才能够想出来，特别是关于后缀树的部分，还有后缀数组的部分，想了很长时间才把问题独立的想明白，我想独立思考的问题才是自己最大的收获。对于特别需要独立思考的问题，适当建议对于卡到壳的时候，一定要先放一放，去外面散步或者多运动，只有这样利用自己的发散思维就能把问题解决出来，仔细思考一下这种思考模式，在《learning how to learn》课程中学到的知识应用到这些科学知识，真的是非常有用。<br>课程《Algorithmic On Strings》学习完了，这部分的课程难度特别是后缀式和后缀数组相关的知识真心非常的难，好多题目非常的<code>trikly</code>，最后得分是<code>100</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/ESEG2K7DRVHP" target="_blank" rel="noopener">Algorithms on Strings</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20Strings" target="_blank" rel="noopener">source code</a></p><a id="more"></a><h2 id="week1-Suffix-Trees"><a href="#week1-Suffix-Trees" class="headerlink" title="week1 Suffix Trees"></a>week1 Suffix Trees</h2><h3 id="1-Problem-Construct-a-Trie-from-a-Collection-of-Patterns"><a href="#1-Problem-Construct-a-Trie-from-a-Collection-of-Patterns" class="headerlink" title="1 Problem: Construct a Trie from a Collection of Patterns"></a>1 Problem: Construct a Trie from a Collection of Patterns</h3><ul><li><strong>Construct</strong> a trie from a collection of patterns.</li><li><strong>Input Format</strong>. An integer 𝑛 and a collection of strings Patterns = {𝑝1, . . . , 𝑝𝑛} (each string is given on a<br>separate line).</li></ul><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> trie的构建</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>这题非常简单，直接构建即可。<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; edges;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;edges&gt; trie;</span><br><span class="line"></span><br><span class="line"><span class="function">trie <span class="title">build_trie</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; patterns)</span> </span>&#123;</span><br><span class="line">  trie t;</span><br><span class="line">  edges e;</span><br><span class="line"></span><br><span class="line">  t.push_back(e);</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">string</span> w : patterns)&#123;</span><br><span class="line">      <span class="keyword">int</span> node = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">char</span> c : w)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!t[node].count(c))&#123;</span><br><span class="line">              t.push_back(e);</span><br><span class="line">              t[node][c] = t.size()<span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          node = t[node][c];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; patterns;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    patterns.push_back(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  trie t = build_trie(patterns);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; t.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; j : t[i]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; j.second &lt;&lt; <span class="string">":"</span> &lt;&lt; j.first &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Problem-Implement-TrieMatching"><a href="#2-Problem-Implement-TrieMatching" class="headerlink" title="2 Problem: Implement TrieMatching"></a>2 Problem: Implement TrieMatching</h3><p><strong>Task</strong>. Implement TrieMatching algorithm.<br><strong>Input Format</strong>. The first line of the input contains a string Text, the second line contains an integer 𝑛,<br>each of the following 𝑛 lines contains a pattern from Patterns = {𝑝1, . . . , 𝑝𝑛}.</p><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>trie的match即可</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol><li>直接利用trie的match即可。<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> Letters =    <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> NA      =   <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> next [Letters];</span><br><span class="line"></span><br><span class="line">Node ()</span><br><span class="line">&#123;</span><br><span class="line">fill (next, next + Letters, NA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (next[<span class="number">0</span>] == NA &amp;&amp; next[<span class="number">1</span>] == NA &amp;&amp; next[<span class="number">2</span>] == NA &amp;&amp; next[<span class="number">3</span>] == NA);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">letterToIndex</span> <span class="params">(<span class="keyword">char</span> letter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (letter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'G'</span>: <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: assert (<span class="literal">false</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;  buildTrie(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; patterns)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; trie;</span><br><span class="line">Node node;</span><br><span class="line">trie.push_back(node);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>  p : patterns)&#123;</span><br><span class="line"><span class="keyword">int</span> curr  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c : p)&#123;</span><br><span class="line"><span class="keyword">int</span> idx = letterToIndex(c);</span><br><span class="line"><span class="keyword">if</span>(trie[curr].next[idx] == NA)&#123;</span><br><span class="line">trie.push_back(node);</span><br><span class="line">trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">curr = trie[curr].next[idx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> trie;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchTrie</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt; &amp; trie,<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; text.size(); ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> idx = letterToIndex(text[i]);</span><br><span class="line">curr = trie[curr].next[idx];</span><br><span class="line"><span class="keyword">if</span>(curr == NA) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[curr].isLeaf()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; solve (<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt;&amp; patterns)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; trie = buildTrie(patterns);</span><br><span class="line"><span class="comment">// write your code here</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.size(); ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(searchTrie(trie,text,i))&#123;</span><br><span class="line">result.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; patterns (n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; patterns[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">ans = solve (t, n, patterns);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) ans.size (); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; (<span class="keyword">int</span>) ans.size ())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Problem-Construct-the-Suffix-Tree-of-a-String"><a href="#4-Problem-Construct-the-Suffix-Tree-of-a-String" class="headerlink" title="4 Problem: Construct the Suffix Tree of a String"></a>4 Problem: Construct the Suffix Tree of a String</h3><p><strong>Task</strong>. Construct the suffix tree of a string.<br><strong>Input Format</strong>. A string Text ending with a “$” symbol.</p><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>直接建立压缩的suffix tree</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>这个题目当时卡壳的很久，好好的花时间把suffix Tree的建立过程要讲清楚一下。</li><li>因为题目中要求的为压缩的suffix trie,如果用未压缩的suffix trie则会出现超时。</li><li>我们首先看一个重要的操作的，求两个后缀的最长公共前缀，longest common prefix。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> l1,<span class="keyword">int</span> l2,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 &lt; <span class="number">0</span> || l2 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[l1+i] != text[l2+i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>比如字符<strong>ababac</strong>,后缀<strong>suffix[0] = ababac</strong>, 后缀 <strong>suffix[2] = abac</strong>，则上述的两个后缀的最长公共前缀长度为2.<br>我们从后往前对字符串<strong>ababac</strong>，进行建立它的后缀树。如下图所示<br><img src="https://mike-box.github.io/images/164-1.png" alt="1"></li><li>我们从根节点开始，每次计算当前后缀与当前节点的孩子节点的最长前缀，直到LCP计算结果为0，则这时直接将当前后缀作为叶子节点加入到树中。</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> Letters =    <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> NA      =   <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next [Letters];</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    Node ()&#123;</span><br><span class="line">        fill (next, next + Letters, NA);</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = NA;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Letters; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;next[i] == NA) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">letterToIndex</span> <span class="params">(<span class="keyword">char</span> letter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (letter)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'$'</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'G'</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>: <span class="keyword">return</span> <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: assert (<span class="literal">false</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Node&gt; trie;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; suffixTrie;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Build a suffix tree of the string text and return a vector</span></span><br><span class="line"><span class="comment">// with all of the labels of its edges (the corresponding </span></span><br><span class="line"><span class="comment">// substrings of the text) in any order.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> l1,<span class="keyword">int</span> l2,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 &lt; <span class="number">0</span> || l2 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[l1+i] != text[l2+i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComputeSuffixTreeEdges</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;pii&gt; result;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&gt; trie;</span><br><span class="line">  Node node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  trie.push_back(node);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">      <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n;)&#123;</span><br><span class="line">          <span class="keyword">int</span> idx = letterToIndex(text[j]);</span><br><span class="line">          <span class="keyword">int</span> next =  trie[curr].next[idx];      </span><br><span class="line">          <span class="keyword">if</span>(next == NA)&#123;</span><br><span class="line">              trie.push_back(node);</span><br><span class="line">              trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">              curr = trie[curr].next[idx];</span><br><span class="line">              trie[curr].start = j;</span><br><span class="line">              trie[curr].length = n-j;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">int</span> length = lcs(text,trie[next].start,j,trie[next].length);</span><br><span class="line">              <span class="keyword">if</span>(length == trie[next].length)&#123;</span><br><span class="line">                  curr = next;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  trie.push_back(node);</span><br><span class="line">                  trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">                  curr = trie[curr].next[idx];</span><br><span class="line">                  trie[curr].start = j;</span><br><span class="line">                  trie[curr].length = length;</span><br><span class="line">                  trie[next].start  += length;</span><br><span class="line">                  trie[next].length -= length;</span><br><span class="line">                  <span class="keyword">int</span> x = letterToIndex(text[trie[next].start]);</span><br><span class="line">                  trie[curr].next[x] = next;</span><br><span class="line">              &#125;</span><br><span class="line">              j = j + length;</span><br><span class="line">          &#125;          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; trie.size(); ++i)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;text.substr(trie[i].start,trie[i].length)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> text;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; text;</span><br><span class="line">  ComputeSuffixTreeEdges(text);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Advanced-Problem-Find-the-Shortest-Non-Shared-Substring-of"><a href="#5-Advanced-Problem-Find-the-Shortest-Non-Shared-Substring-of" class="headerlink" title="5 Advanced Problem: Find the Shortest Non-Shared Substring of"></a>5 Advanced Problem: Find the Shortest Non-Shared Substring of</h3><p>Two Strings<br><strong>Task</strong>. Find the shortest substring of one string that does not appear in another string.<br><strong>Input Format</strong>. Strings Text1 and Text2.</p><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>这个题目也很有意思。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>后缀树的应用有很多，我们可以利用后缀树的特性。</li><li>如果发现某个后缀树的节点的所有孩子节点不存在两个字符串的公共部分，则认为该节点符合要求。</li><li>实际判别的时候比较复杂。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> Letters =    <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> NA      =   <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next [Letters];</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    Node ()&#123;</span><br><span class="line">        fill (next, next + Letters, NA);</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = NA;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">letterToIndex</span> <span class="params">(<span class="keyword">char</span> letter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (letter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'G'</span>: <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'#'</span>: <span class="keyword">return</span> <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'$'</span>: <span class="keyword">return</span> <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: assert (<span class="literal">false</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Build a suffix tree of the string text and return a vector</span></span><br><span class="line"><span class="comment">// with all of the labels of its edges (the corresponding </span></span><br><span class="line"><span class="comment">// substrings of the text) in any order.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> l1,<span class="keyword">int</span> l2,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 &lt; <span class="number">0</span> || l2 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[l1+i] != text[l2+i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;Node&gt; &amp; trie,<span class="keyword">int</span> curr,<span class="keyword">int</span> length,<span class="built_in">string</span> &amp; text)</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> res;</span><br><span class="line"><span class="built_in">string</span> diff = text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(curr == NA) <span class="keyword">return</span> text;</span><br><span class="line"><span class="keyword">if</span>(trie[curr].start != NA &amp;&amp; trie[curr].start &lt; length)&#123;</span><br><span class="line">res.push_back(text[trie[curr].start]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(trie[curr].start != NA)&#123;</span><br><span class="line">res = text.substr(trie[curr].start,trie[curr].length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line"><span class="built_in">string</span> next = dfs(trie,trie[curr].next[i],length,text);</span><br><span class="line"><span class="keyword">if</span>(next.size() &lt; diff.size())&#123;</span><br><span class="line">diff = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span> <span class="params">(<span class="built_in">string</span> p, <span class="built_in">string</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> result = p;</span><br><span class="line"><span class="built_in">string</span> text = p + <span class="string">"#"</span> +  q  + <span class="string">"$"</span>;</span><br><span class="line"><span class="keyword">int</span> n = text.size();</span><br><span class="line"><span class="keyword">int</span> m = p.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&gt; trie;</span><br><span class="line">  Node node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement this function yourself</span></span><br><span class="line">trie.push_back(node);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"><span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n;)&#123;</span><br><span class="line"><span class="keyword">int</span> idx = letterToIndex(text[j]);</span><br><span class="line"><span class="keyword">int</span> next =  trie[curr].next[idx];      </span><br><span class="line"><span class="keyword">if</span>(next == NA)&#123;</span><br><span class="line">trie.push_back(node);</span><br><span class="line">trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">curr = trie[curr].next[idx];</span><br><span class="line">trie[curr].start = j;</span><br><span class="line">trie[curr].length = n-j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = lcs(text,trie[next].start,j,trie[next].length);</span><br><span class="line"><span class="keyword">if</span>(length == trie[next].length)&#123;</span><br><span class="line">curr = next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">trie.push_back(node);</span><br><span class="line">trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">curr = trie[curr].next[idx];</span><br><span class="line">trie[curr].start = trie[next].start;</span><br><span class="line">trie[curr].length = length;</span><br><span class="line">trie[next].start  += length;</span><br><span class="line">trie[next].length -= length;</span><br><span class="line"><span class="keyword">int</span> x = letterToIndex(text[trie[next].start]);</span><br><span class="line">trie[curr].next[x] = next;</span><br><span class="line">&#125;</span><br><span class="line">j = j + length;</span><br><span class="line">&#125;          </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dfs(trie,<span class="number">0</span>,m,text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> p;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line"><span class="built_in">string</span> q;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ans = solve (p, q);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><h3 id="1-Problem-Construct-the-Burrows–Wheeler-Transform-of-a-String"><a href="#1-Problem-Construct-the-Burrows–Wheeler-Transform-of-a-String" class="headerlink" title="1 Problem: Construct the Burrows–Wheeler Transform of a String"></a>1 Problem: Construct the Burrows–Wheeler Transform of a String</h3><p><strong>Task</strong>. Construct the Burrows–Wheeler transform of a string.<br><strong>Input Format</strong>. A string Text ending with a “$” symbol.</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>先利用count array算法对字符进行排序。</li><li>然后按照notebook中的参考算法编写代码即可。</li><li>count array作为一个非常重要的算法需要牢记，可以在<strong>O(n+R)</strong>的线性时间复杂度内完成数组的排序。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">istringstream</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> keys = <span class="string">"ACGT$"</span>;</span><br><span class="line"><span class="comment">// Preprocess the Burrows-Wheeler Transform bwt of some text</span></span><br><span class="line"><span class="comment">// and compute as a result:</span></span><br><span class="line"><span class="comment">//   * starts - for each character C in bwt, starts[C] is the first position </span></span><br><span class="line"><span class="comment">//       of this character in the sorted array of </span></span><br><span class="line"><span class="comment">//       all characters of the text.</span></span><br><span class="line"><span class="comment">//   * occ_count_before - for each character C in bwt and each position P in bwt,</span></span><br><span class="line"><span class="comment">//       occ_count_before[C][P] is the number of occurrences of character C in bwt</span></span><br><span class="line"><span class="comment">//       from position 0 to position P inclusive.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreprocessBWT</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; bwt, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; starts, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; occ_count_before)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Implement this function yourself</span></span><br><span class="line">    <span class="keyword">int</span> n = bwt.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">257</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; occ(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> text = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keys.size(); ++i)&#123;</span><br><span class="line">        occ_count_before[keys[i]] = occ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[bwt[i]+<span class="number">1</span>]++;</span><br><span class="line">        occ_count_before[bwt[i]][i+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : keys)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            occ_count_before[c][j+<span class="number">1</span>] += occ_count_before[c][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">        count[i+<span class="number">1</span>] += count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!starts.count(bwt[i]))  starts[bwt[i]] = count[bwt[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(auto c : keys)&#123;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;c&lt;&lt;":"&lt;&lt;starts[c]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;occ_count_before[c][i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the number of occurrences of string pattern in the text</span></span><br><span class="line"><span class="comment">// given only Burrows-Wheeler Transform bwt of the text and additional</span></span><br><span class="line"><span class="comment">// information we get from the preprocessing stage - starts and occ_counts_before.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountOccurrences</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="built_in">string</span>&amp; bwt, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; starts, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; occ_count_before)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  <span class="keyword">int</span> n = bwt.size();</span><br><span class="line">  <span class="keyword">int</span> m = pattern.size();</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> bottom = n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> curr = m<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(top &lt;= bottom)&#123;</span><br><span class="line">      <span class="keyword">if</span>(curr &lt; <span class="number">0</span>) <span class="keyword">return</span> bottom - top + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> c = pattern[curr--];</span><br><span class="line">      top = starts[c] + occ_count_before[c][top];</span><br><span class="line">      bottom = starts[c] + occ_count_before[c][bottom+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> bwt;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; bwt;</span><br><span class="line">  <span class="keyword">int</span> pattern_count;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; pattern_count;</span><br><span class="line">  <span class="comment">// Start of each character in the sorted list of characters of bwt,</span></span><br><span class="line">  <span class="comment">// see the description in the comment about function PreprocessBWT</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; starts;</span><br><span class="line">  <span class="comment">// Occurrence counts for each character and each position in bwt,</span></span><br><span class="line">  <span class="comment">// see the description in the comment about function PreprocessBWT</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; occ_count_before;</span><br><span class="line">  <span class="comment">// Preprocess the BWT once to get starts and occ_count_before.</span></span><br><span class="line">  <span class="comment">// For each pattern, we will then use these precomputed values and</span></span><br><span class="line">  <span class="comment">// spend only O(|pattern|) to find all occurrences of the pattern</span></span><br><span class="line">  <span class="comment">// in the text instead of O(|pattern| + |text|).</span></span><br><span class="line">  PreprocessBWT(bwt, starts, occ_count_before);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pi = <span class="number">0</span>; pi &lt; pattern_count; ++pi) &#123;</span><br><span class="line">    <span class="built_in">string</span> pattern;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; pattern;</span><br><span class="line">    <span class="keyword">int</span> occ_count = CountOccurrences(pattern, bwt, starts, occ_count_before);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, occ_count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Problem-Construct-the-Suffix-Array-of-a-String"><a href="#4-Problem-Construct-the-Suffix-Array-of-a-String" class="headerlink" title="4 Problem: Construct the Suffix Array of a String"></a>4 Problem: Construct the Suffix Array of a String</h3><p><strong>Task</strong>. Construct the suffix array of a string.<br><strong>Input Format</strong>. A string Text ending with a “$” symbol.</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>先建立后缀树，采用压缩的suffix trie即可。</li><li>然后我们通过中序遍历所有的叶子节点，即可得到suffix array。</li><li>这道题目需要对前面讲述的重点suffix tree的建立要非常熟悉，实际题目还是非常难做的。<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">InverseBWT</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; bwt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = bwt.size();</span><br><span class="line">  <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">257</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">string</span> text = <span class="string">""</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      count[bwt[i]+<span class="number">1</span>]++;</span><br><span class="line">      <span class="keyword">if</span>(bwt[i] == <span class="string">'$'</span>) row = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">      count[i+<span class="number">1</span>] += count[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      next[count[bwt[i]]++] = i; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      text.push_back(bwt[next[row]]);</span><br><span class="line">      row = next[row];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// write your code here</span></span><br><span class="line">  <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> bwt;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; bwt;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; InverseBWT(bwt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Algorithmic-Challenges"><a href="#week4-Algorithmic-Challenges" class="headerlink" title="week4: Algorithmic Challenges"></a>week4: Algorithmic Challenges</h2><p>总的来说这一章是字符串算法最难的，当时卡壳了几个星期才把所有的题目全部通过，其实有时候真的很难理解讲义中的算法，还是要落到实地，自己去写实际的代码才直到哪里存在坑，对算法实际的原理才能深入的理解。suffix array真心不容易。</p><h3 id="1-Problem-Find-All-Occurrences-of-a-Pattern-in-a-String"><a href="#1-Problem-Find-All-Occurrences-of-a-Pattern-in-a-String" class="headerlink" title="1 Problem: Find All Occurrences of a Pattern in a String"></a>1 Problem: Find All Occurrences of a Pattern in a String</h3><p>In this problem, we ask a simple question: how many times one string occurs as a substring of another?<br>Recall that different occurrences of a substring can overlap with each other. For example, ATA occurs three<br>times in CGATATATCCATAG.</p><ul><li><strong>Task</strong>. Find all occurrences of a pattern in a string.</li><li><strong>Input Format</strong>. Strings 𝑃𝑎𝑡𝑡𝑒𝑟𝑛 and 𝐺𝑒𝑛𝑜𝑚𝑒.<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>KMP算法，熟悉kmp算法模式匹配的话，这个题目非常简单。</li><li>只是讲义中的kmp算法跟我们平常用的方法有一些不同。不用计算next数组，直接计算最长后缀。<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> Letters =   <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> NA      =   <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">letterToIndex</span> <span class="params">(<span class="keyword">char</span> letter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (letter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'G'</span>: <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: assert (<span class="literal">false</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all occurrences of the pattern in the text and return a</span></span><br><span class="line"><span class="comment">// vector with all positions in the text (starting from 0) where </span></span><br><span class="line"><span class="comment">// the pattern starts in the text.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; find_pattern(<span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern, <span class="keyword">const</span> <span class="built_in">string</span>&amp; text) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = pattern.size();</span><br><span class="line">  <span class="keyword">int</span> m = text.size();</span><br><span class="line">  <span class="built_in">string</span> t = pattern + <span class="string">"$"</span> + text;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(m + n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); ++i)&#123;</span><br><span class="line">      <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; t[j] != t[i]) j = prefix[j<span class="number">-1</span>];</span><br><span class="line">      <span class="keyword">if</span>(t[i] == t[j])&#123;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          j = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prefix[i] = j;</span><br><span class="line">      <span class="keyword">if</span>(i &gt; n &amp;&amp; prefix[i] == n) </span><br><span class="line">        result.push_back(i<span class="number">-2</span>*n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> pattern, text;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; pattern;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; text;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = find_pattern(pattern, text);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, result[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Problem-Construct-the-Suffix-Array-of-a-Long-String"><a href="#2-Problem-Construct-the-Suffix-Array-of-a-Long-String" class="headerlink" title="2 Problem: Construct the Suffix Array of a Long String"></a>2 Problem: Construct the Suffix Array of a Long String</h3><p>The goal in this problem is to construct the suffix array of a given string again, but this time for a longer<br>string. This will require you to implement an efficient algorithm.</p><ul><li><strong>Task</strong>. Construct the suffix array of a string.</li><li><strong>Input Format</strong>. A string Text ending with a “$” symbol.<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>对后缀数组的建立，我们之前讲过一种方法即为建立后缀树，然后再进行DFS遍历即可，时间复杂度为O(n^2),显然不能满足题目要求。</li><li>利用讲义中给出的算法来实现即可。其中有两个非常重要的概念要将讲一下，count sort和 classfiy操作。<br><img src="https://mike-box.github.io/images/164-2.png" alt="2"></li><li>排序的时候利用倍增原理来确定顺序，非常牛的一种思路来解决该问题，发明这个算法的人一定很聪明。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Build suffix array of the string text and</span></span><br><span class="line"><span class="comment">// return a vector result of the same length as the text</span></span><br><span class="line"><span class="comment">// such that the value result[i] is the index (0-based)</span></span><br><span class="line"><span class="comment">// in text where the i-th lexicographically smallest</span></span><br><span class="line"><span class="comment">// suffix of text starts.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SortCharacters(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : text)&#123;</span><br><span class="line">        count[c]++;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        count[text[i]]--;</span><br><span class="line">        order[count[text[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ComputeCharClasses(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; order)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n,<span class="number">0</span>);</span><br><span class="line">    res[order[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[order[i]] != text[order[i<span class="number">-1</span>]])&#123;</span><br><span class="line">            res[order[i]] = res[order[i<span class="number">-1</span>]]+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[order[i]] = res[order[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SortDoubled(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; order,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; classfiy)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(n,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newOrder(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[classfiy[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> start = (order[i]-len+n)%n;</span><br><span class="line">        <span class="keyword">int</span> cl = classfiy[start];</span><br><span class="line">        count[cl]--;</span><br><span class="line">        newOrder[count[cl]] = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; UpdateClasses(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; newOrder,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; classfiy,<span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = newOrder.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newClassfiy(n,<span class="number">0</span>);</span><br><span class="line">    newClassfiy[newOrder[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = newOrder[i];</span><br><span class="line">        <span class="keyword">int</span> prev = newOrder[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> mid = curr + len;</span><br><span class="line">        <span class="keyword">int</span> midPrev = (prev + len)%n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classfiy[curr] != classfiy[prev] || </span><br><span class="line">           classfiy[mid] != classfiy[midPrev])&#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newClassfiy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; BuildSuffixArray(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text) &#123;</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order = SortCharacters(text);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; classfiy = ComputeCharClasses(text,order);</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l &lt; n)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;order[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;classfiy[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      order = SortDoubled(text,l,order,classfiy);</span><br><span class="line">      classfiy = UpdateClasses(order,classfiy,l);</span><br><span class="line">      l = l&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> text;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; text;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix_array = BuildSuffixArray(text);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; suffix_array.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; suffix_array[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Problem-Pattern-Matching-with-the-Suffix-Array"><a href="#3-Problem-Pattern-Matching-with-the-Suffix-Array" class="headerlink" title="3 Problem: Pattern Matching with the Suffix Array"></a>3 Problem: Pattern Matching with the Suffix Array</h3>In this problem, we will let you use the suffix array to solve the Multiple Pattern Matching Problem.</li></ol><ul><li><strong>Task</strong>. Find all occurrences of a given collection of patterns in a string.</li><li><strong>Input Format</strong>. The first line contains a string Text). The second line specifies an integer 𝑛. The last line gives a collection of 𝑛 strings Patterns = {𝑝1, . . . , 𝑝𝑛} separated by spaces.<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>思路对应先通过倍增算法，求出后缀数组。</li><li>利用二分查找算法，查找对大于等于字符串的左边界，查找小于等于字符串的右边界，最终即为左右边界之间的数组。</li><li>算法还是非常经典的算法，需要认真思考和揣摩。<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SortCharacters(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : text)&#123;</span><br><span class="line">        count[c]++;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        count[text[i]]--;</span><br><span class="line">        order[count[text[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ComputeCharClasses(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; order)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n,<span class="number">0</span>);</span><br><span class="line">    res[order[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[order[i]] != text[order[i<span class="number">-1</span>]])&#123;</span><br><span class="line">            res[order[i]] = res[order[i<span class="number">-1</span>]]+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[order[i]] = res[order[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SortDoubled(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; order,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; classfiy)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(n,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newOrder(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[classfiy[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> start = (order[i]-len+n)%n;</span><br><span class="line">        <span class="keyword">int</span> cl = classfiy[start];</span><br><span class="line">        count[cl]--;</span><br><span class="line">        newOrder[count[cl]] = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; UpdateClasses(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; newOrder,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; classfiy,<span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = newOrder.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newClassfiy(n,<span class="number">0</span>);</span><br><span class="line">    newClassfiy[newOrder[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = newOrder[i];</span><br><span class="line">        <span class="keyword">int</span> prev = newOrder[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> mid = curr + len;</span><br><span class="line">        <span class="keyword">int</span> midPrev = (prev + len)%n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classfiy[curr] != classfiy[prev] || </span><br><span class="line">           classfiy[mid] != classfiy[midPrev])&#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newClassfiy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; BuildSuffixArray(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text) &#123;</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order = SortCharacters(text);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; classfiy = ComputeCharClasses(text,order);</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l &lt; n)&#123;</span><br><span class="line">      order = SortDoubled(text,l,order,classfiy);</span><br><span class="line">      classfiy = UpdateClasses(order,classfiy,l);</span><br><span class="line">      l = l&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindOccurrences(<span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern, <span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; suffix_array) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line">  <span class="keyword">int</span> m = pattern.size();</span><br><span class="line">  <span class="built_in">string</span> key = text + text;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> r = n;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write your code here</span></span><br><span class="line">  <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(pattern &gt; key.substr(suffix_array[mid],m))&#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          r = mid;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start = l;</span><br><span class="line">  r = n;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(pattern &lt;  key.substr(suffix_array[mid],m))&#123;</span><br><span class="line">          r = mid;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  end = r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; end; ++i)&#123;</span><br><span class="line">      result.push_back(suffix_array[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">100001</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">  <span class="built_in">string</span> text = buffer;</span><br><span class="line">  text += <span class="string">'$'</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix_array = BuildSuffixArray(text);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pattern_count;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pattern_count);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; occurs(text.length(), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pattern_index = <span class="number">0</span>; pattern_index &lt; pattern_count; ++pattern_index) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">    <span class="built_in">string</span> pattern = buffer;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; occurrences = FindOccurrences(pattern, text, suffix_array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; occurrences.size(); ++j) &#123;</span><br><span class="line">      occurs[occurrences[j]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; occurs.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (occurs[i]) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Advanced-Problem-Construct-the-Suffix-Tree-from-the-Suffix-Array"><a href="#4-Advanced-Problem-Construct-the-Suffix-Tree-from-the-Suffix-Array" class="headerlink" title="4 Advanced Problem: Construct the Suffix Tree from the Suffix Array"></a>4 Advanced Problem: Construct the Suffix Tree from the Suffix Array</h3><p>SuffixTree(Text) can be constructed in linear time from SuffixArray(Text) by using the longest common<br>prefix (LCP) array of Text, LCP(Text), which stores the length of the longest common prefix shared by<br>consecutive lexicographically ordered suffixes of Text. For example,<br>LCP(“panamabananas$”) = (0, 1, 1, 3, 3, 1, 0, 0, 0, 2, 2, 0, 0).</p><ul><li><strong>Task</strong>. Construct a suffix tree from the suffix array and LCP array of a string.</li><li><strong>Input Format</strong>. The first line contains a string Text ending with a “$” symbol, the second line contains<br>SuffixArray(Text) as a list of |Text| integers separated by spaces, the last line contains LCP(Text) as<br>a list of |Text| − 1 integers separated by spaces.<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>这个题目真心难，当时恨不得看了一个星期才看懂该算法，题目的本意即为从叶子节点往上建造树。</li><li>每次保存上次建树的叶子节点，比较当前叶子节点与后缀之间的最长前缀。如果长度为0则直接创建新的叶子节点。</li><li>这个题目解释起来太复杂了，需要仔细的画图示意才能对这个算法有深入的了解，最坑的是刚开始递归太深，导致一直报<code>sig 12</code>的错误，找不到原因，后来在论坛上问，才知道原来是利用dfs求边时导致递归太深，堆栈溢出的问题，后来终于解决了这个题目，感觉时我做的时间最长的题目了。<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data structure to store edges of a suffix tree.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="comment">// The ending node of this edge.</span></span><br><span class="line">  <span class="keyword">int</span> node;</span><br><span class="line">  <span class="comment">// Starting position of the substring of the text </span></span><br><span class="line">  <span class="comment">// corresponding to the label of this edge.</span></span><br><span class="line">  <span class="keyword">int</span> start;</span><br><span class="line">  <span class="comment">// Position right after the end of the substring of the text </span></span><br><span class="line">  <span class="comment">// corresponding to the label of this edge.</span></span><br><span class="line">  <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">  Edge(<span class="keyword">int</span> node_, <span class="keyword">int</span> start_, <span class="keyword">int</span> end_) : node(node_), start(start_), end(end_) &#123;&#125;</span><br><span class="line">  Edge(<span class="keyword">const</span> Edge&amp; e) : node(e.node), start(e.start), end(e.end) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixTreeNode</span>&#123;</span></span><br><span class="line">   SuffixTreeNode * parent;</span><br><span class="line">   <span class="built_in">map</span>&lt;<span class="keyword">char</span>,SuffixTreeNode*&gt; child;</span><br><span class="line">   <span class="keyword">int</span> depth;</span><br><span class="line">   <span class="keyword">int</span> start;</span><br><span class="line">   <span class="keyword">int</span> end;</span><br><span class="line">   SuffixTreeNode()&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;depth = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;start = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;end = <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build suffix tree of the string text given its suffix array suffix_array</span></span><br><span class="line"><span class="comment">// and LCP array lcp_array. Return the tree as a mapping from a node ID</span></span><br><span class="line"><span class="comment">// to the vector of all outgoing edges of the corresponding node. The edges in the</span></span><br><span class="line"><span class="comment">// vector must be sorted in the ascending order by the first character of the edge label.</span></span><br><span class="line"><span class="comment">// Root must have node ID = 0, and all other node IDs must be different</span></span><br><span class="line"><span class="comment">// nonnegative integers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example, if text = "ACACAA$", an edge with label "$" from root to a node with ID 1</span></span><br><span class="line"><span class="comment">// must be represented by Edge(1, 6, 7). This edge must be present in the vector tree[0]</span></span><br><span class="line"><span class="comment">// (corresponding to the root node), and it should be the first edge in the vector </span></span><br><span class="line"><span class="comment">// (because it has the smallest first character of all edges outgoing from the root).</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(SuffixTreeNode * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;child.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;SuffixTreeNode *&gt; s;</span><br><span class="line">    <span class="built_in">stack</span>&lt;SuffixTreeNode *&gt; child;</span><br><span class="line"></span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        SuffixTreeNode * curr = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curr-&gt;parent) <span class="built_in">cout</span>&lt;&lt;curr-&gt;start&lt;&lt;<span class="string">" "</span>&lt;&lt;curr-&gt;end+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : curr-&gt;child)&#123;</span><br><span class="line">            child.push(v.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!child.empty())&#123;</span><br><span class="line">            s.push(child.top());</span><br><span class="line">            child.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SuffixTreeNode * <span class="title">CreateNewLeaf</span><span class="params">(SuffixTreeNode * node,<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> suffix)</span></span>&#123;</span><br><span class="line">    SuffixTreeNode * leaf = <span class="keyword">new</span> SuffixTreeNode();</span><br><span class="line">    leaf-&gt;parent = node;</span><br><span class="line">    leaf-&gt;depth = text.size()-suffix;</span><br><span class="line">    leaf-&gt;start = suffix + node-&gt;depth;</span><br><span class="line">    leaf-&gt;end = text.size()<span class="number">-1</span>;</span><br><span class="line">    node-&gt;child[text[leaf-&gt;start]] = leaf;</span><br><span class="line">    <span class="keyword">return</span> leaf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SuffixTreeNode * <span class="title">BreakEdge</span><span class="params">(SuffixTreeNode * node,<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> start,<span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> startChar = text[start];</span><br><span class="line">    <span class="keyword">char</span> midChar = text[start + offset];</span><br><span class="line">    SuffixTreeNode * midNode = <span class="keyword">new</span> SuffixTreeNode();</span><br><span class="line">    midNode-&gt;parent = node;</span><br><span class="line">    midNode-&gt;depth = node-&gt;depth + offset;</span><br><span class="line">    midNode-&gt;start = start;</span><br><span class="line">    midNode-&gt;end = start + offset - <span class="number">1</span>;</span><br><span class="line">    midNode-&gt;child[midChar] = node-&gt;child[startChar];</span><br><span class="line">    node-&gt;child[startChar]-&gt;parent = midNode;</span><br><span class="line">    node-&gt;child[startChar]-&gt;start += offset;</span><br><span class="line">    node-&gt;child[startChar] = midNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> midNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">realseSuffixTree</span><span class="params">(SuffixTreeNode * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;child.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : root-&gt;child)&#123;</span><br><span class="line">        realseSuffixTree(v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SuffixTreeFromSuffixArray</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; suffix_array,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lcp_array,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line">  SuffixTreeNode * root = <span class="keyword">new</span> SuffixTreeNode();</span><br><span class="line">  root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">  root-&gt;depth = <span class="number">0</span>;</span><br><span class="line">  root-&gt;start = <span class="number">0</span>;</span><br><span class="line">  root-&gt;end = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> lcpPrev = <span class="number">0</span>;</span><br><span class="line">  SuffixTreeNode * currNode = root;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> suffix = suffix_array[i];</span><br><span class="line">      <span class="keyword">while</span>(currNode-&gt;depth &gt; lcpPrev)&#123;</span><br><span class="line">          currNode = currNode-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(currNode-&gt;depth == lcpPrev)&#123;</span><br><span class="line">          currNode = CreateNewLeaf(currNode,text,suffix);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">int</span> start = suffix_array[i<span class="number">-1</span>] + currNode-&gt;depth;</span><br><span class="line">          <span class="keyword">int</span> offset = lcpPrev - currNode-&gt;depth;</span><br><span class="line">          <span class="comment">/*break from the edge*/</span></span><br><span class="line">          SuffixTreeNode * midNode =  BreakEdge(currNode,text,start,offset);</span><br><span class="line">          <span class="comment">/*add new leaf node*/</span></span><br><span class="line">          currNode = CreateNewLeaf(midNode,text,suffix);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(i &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">          lcpPrev = lcp_array[i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">200001</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">  <span class="built_in">string</span> text = buffer;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix_array(text.length());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;suffix_array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lcp_array(text.length() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; text.length(); ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;lcp_array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Build the suffix tree and get a mapping from </span></span><br><span class="line">  <span class="comment">// suffix tree node ID to the list of outgoing Edges.</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;text&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  SuffixTreeFromSuffixArray(suffix_array, lcp_array, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>仔细回想一下自己本科时候学的算法水平真的很差了，那么基础和简单的东西都没有好好学，那个时候有大把的时间去好好学习，好好思考，却被自己荒废了。确实值得自己去反思一下原因。</p><ul><li>个人主观原因： 对自己要求放松，再加上外界环境的放松，很难对自己有所提高。而自己年轻时的不珍惜时间，不珍惜机会导致中年危机，我想也是自己咎由自取。</li><li>外界客观原因： 想想读书时，本科老师很多水平真的不行，绝大部分科研不行，也没有工业界的经验，绝大部分老师都是照本宣科来讲课本，对于计算这门实践性这么强的科目，没有实践基本上相当于白学。想想本来老师讲的算法和数据结构根本就没有完整的实现过，对数据的理解和 算法的深入远远不够。我想当年专业课老师们也对我们这群差生也很无语了。</li><li>观念的原因： 想想当年总觉得自己辛辛苦苦的读完大学就该享受了，却并没有对这个世界和这个社会有真正的认识，只是着眼于眼前。当然那个时候互联网也没有现在这么发达，不像现在网上随处可以学习的公开课和开源代码供自己参考，当年可是找本最新的教科书都很难。<br>絮絮叨叨了这么多，不管怎么样，努力学习，努力提升自己，不要随周围环境随波逐流，不要迷失自己，不要忘了自己初心，不要忘了自己的责任。虽然爬坡的过程很艰难，但是前方的光明依然在等着你。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithmic-On-Strings&quot;&gt;&lt;a href=&quot;#Algorithmic-On-Strings&quot; class=&quot;headerlink&quot; title=&quot;Algorithmic On Strings&quot;&gt;&lt;/a&gt;Algorithmic On Strings&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，这个课程是关于字符串相关算法，这个课程算法的部分题目非常的&lt;code&gt;tricky&lt;/code&gt;,对于我这种智商普通人的来说，真心好多题目想了好几天才能够想出来，特别是关于后缀树的部分，还有后缀数组的部分，想了很长时间才把问题独立的想明白，我想独立思考的问题才是自己最大的收获。对于特别需要独立思考的问题，适当建议对于卡到壳的时候，一定要先放一放，去外面散步或者多运动，只有这样利用自己的发散思维就能把问题解决出来，仔细思考一下这种思考模式，在《learning how to learn》课程中学到的知识应用到这些科学知识，真的是非常有用。&lt;br&gt;课程《Algorithmic On Strings》学习完了，这部分的课程难度特别是后缀式和后缀数组相关的知识真心非常的难，好多题目非常的&lt;code&gt;trikly&lt;/code&gt;，最后得分是&lt;code&gt;100&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/ESEG2K7DRVHP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Algorithms on Strings&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20Strings&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Algorithmic On Strings》" scheme="http://yoursite.com/tags/%E3%80%8AAlgorithmic-On-Strings%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 190周周赛</title>
    <link href="http://yoursite.com/2020/05/24/163/"/>
    <id>http://yoursite.com/2020/05/24/163/</id>
    <published>2020-05-24T04:46:56.440Z</published>
    <updated>2020-05-24T04:58:01.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="190周周赛"><a href="#190周周赛" class="headerlink" title="190周周赛"></a>190周周赛</h1><p>本周周赛的题目出奇的简单，我这种渣渣水平都能在半个小时全部搞定。</p><h2 id="5416-检查单词是否为句中其他单词的前缀"><a href="#5416-检查单词是否为句中其他单词的前缀" class="headerlink" title="5416. 检查单词是否为句中其他单词的前缀"></a>5416. 检查单词是否为句中其他单词的前缀</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>sentence</code>作为句子并指定检索词为 <code>searchWord</code>，其中句子由若干用 单个空格 分隔的单词组成。</p><p>请你检查检索词 <code>searchWord</code>是否为句子<code>sentence</code>中任意单词的前缀。</p><a id="more"></a><ul><li>如果<code>searchWord</code>是某一个单词的前缀，则返回句子<code>sentence</code> 中该单词所对应的下标（下标从 1 开始）。</li><li>如果 <code>searchWord</code>是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。</li><li>如果<code>searchWord</code> 不是任何单词的前缀，则返回 -1 。</li><li>字符串 S 的 「前缀」是 S 的任何前导连续子字符串。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = <span class="string">"i love eating burger"</span>, searchWord = <span class="string">"burg"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：<span class="string">"burg"</span> 是 <span class="string">"burger"</span> 的前缀，而 <span class="string">"burger"</span> 是句子中第 <span class="number">4</span> 个单词。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = <span class="string">"this problem is an easy problem"</span>, searchWord = <span class="string">"pro"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="string">"pro"</span> 是 <span class="string">"problem"</span> 的前缀，而 <span class="string">"problem"</span> 是句子中第 <span class="number">2</span> 个也是第 <span class="number">6</span> 个单词，但是应该返回最小下标 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence</span> = <span class="string">"i am tired"</span>, <span class="attr">searchWord</span> = <span class="string">"you"</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：<span class="string">"you"</span> 不是句子中任何单词的前缀。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence</span> = <span class="string">"i use triple pillow"</span>, <span class="attr">searchWord</span> = <span class="string">"pill"</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence</span> = <span class="string">"hello from the other side"</span>, <span class="attr">searchWord</span> = <span class="string">"they"</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 100</code></li><li><code>1 &lt;= searchWord.length &lt;= 10</code></li><li><code>sentence</code>由小写英文字母和空格组成。</li><li><code>searchWord</code>由小写英文字母组成。</li><li>前缀就是紧密附着于词根的语素，中间不能插入其它成分，并且它的位置是固定的——-位于词根之前。（引用自 前缀_百度百科 ）</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接判断</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>送分题，当然想用技巧的话可以搞KMP之类的。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPrefixOfWord</span><span class="params">(self, sentence: str, searchWord: str)</span> -&gt; int:</span></span><br><span class="line">        words = sentence.split()</span><br><span class="line">        m = len(searchWord)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">            <span class="keyword">if</span> len(words[i]) &gt;= m <span class="keyword">and</span> words[i][:m] == searchWord:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5417-定长子串中元音的最大数目"><a href="#5417-定长子串中元音的最大数目" class="headerlink" title="5417. 定长子串中元音的最大数目"></a>5417. 定长子串中元音的最大数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你字符串<code>s</code>和整数 <code>k</code> 。<br>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。<br>英文中的 元音字母 为<code>（a, e, i, o, u）</code>。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abciiidef"</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：子字符串 <span class="string">"iii"</span> 包含 <span class="number">3</span> 个元音字母。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aeiou"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：任意长度为 <span class="number">2</span> 的子字符串都包含 <span class="number">2</span> 个元音字母。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="string">"lee"</span>、<span class="string">"eet"</span> 和 <span class="string">"ode"</span> 都包含 <span class="number">2</span> 个元音字母。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"rhythms"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串 s 中不含任何元音字母。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"tryhard"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li>s 由小写英文字母组成</li><li><code>1 &lt;= k &lt;= s.length</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>送分题，滑动窗口，窗口大小为K.判定窗口内的元音字母。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'a'</span>||c == <span class="string">'o'</span>||c == <span class="string">'e'</span>||c == <span class="string">'i'</span>||c == <span class="string">'u'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;  </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isVowel(s[i]))&#123;</span><br><span class="line">                cnt[s[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt)&#123;</span><br><span class="line">                    curr += x.second;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(curr,res);</span><br><span class="line">                <span class="keyword">if</span>(isVowel(s[i-k+<span class="number">1</span>]))&#123;</span><br><span class="line">                    cnt[s[i-k+<span class="number">1</span>]]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5418-二叉树中的伪回文路径"><a href="#5418-二叉树中的伪回文路径" class="headerlink" title="5418. 二叉树中的伪回文路径"></a>5418. 二叉树中的伪回文路径</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p>请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：上图为给定的二叉树。总共有 <span class="number">3</span> 条从根到叶子的路径：红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 和路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 。</span><br><span class="line">     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 存在回文排列 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 存在回文排列 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span> </span><br><span class="line">解释：上图为给定二叉树。总共有 <span class="number">3</span> 条从根到叶子的路径：绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] ，路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>] 和路径 [<span class="number">2</span>,<span class="number">1</span>] 。</span><br><span class="line">     这些路径中只有绿色路径是伪回文路径，因为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 存在回文排列 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>给定二叉树的节点数目在 1 到 10^5 之间。</li><li>节点值在 1 到 9 之间。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们通过DFS，统计每条从根节点到叶子节点的路径上的数字个数。</li><li>如果路径上的数字有1个以上的数字的数量为奇数，则该路径不能组成回文数。</li><li>题目实际上可以稍微加大点难度，去掉数字大小的限制，这样的话这个题目难度就稍微大了点。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cnt[root-&gt;val]++;</span><br><span class="line">        <span class="keyword">if</span>(cnt[root-&gt;val]%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            cnt.erase(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.size() &lt;= <span class="number">1</span>) res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            dfs(root-&gt;left,cnt,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            dfs(root-&gt;right,cnt,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        dfs(root,cnt,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5419-两个子序列的最大点积"><a href="#5419-两个子序列的最大点积" class="headerlink" title="5419. 两个子序列的最大点积"></a>5419. 两个子序列的最大点积</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你两个数组 <code>nums1</code>和 <code>nums2</code> 。</p><p>请你返回 <code>nums1</code>和 <code>nums2</code>中两个长度相同的 非空 子序列的最大点积。</p><p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code> 是 <code>[1,2,3,4,5]</code>的一个子序列而 <code>[1,5,3]</code> 不是。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">5</span>], nums2 = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">-6</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：从 nums1 中得到子序列 [<span class="number">2</span>,<span class="number">-2</span>] ，从 nums2 中得到子序列 [<span class="number">3</span>,<span class="number">-6</span>] 。</span><br><span class="line">它们的点积为 (<span class="number">2</span>*<span class="number">3</span> + (<span class="number">-2</span>)*(<span class="number">-6</span>)) = <span class="number">18</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">3</span>,<span class="number">-2</span>], nums2 = [<span class="number">2</span>,<span class="number">-6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">解释：从 nums1 中得到子序列 [<span class="number">3</span>] ，从 nums2 中得到子序列 [<span class="number">7</span>] 。</span><br><span class="line">它们的点积为 (<span class="number">3</span>*<span class="number">7</span>) = <span class="number">21</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">-1</span>,<span class="number">-1</span>], nums2 = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：从 nums1 中得到子序列 [<span class="number">-1</span>] ，从 nums2 中得到子序列 [<span class="number">1</span>] 。</span><br><span class="line">它们的点积为 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li><li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 100</code></li></ul><p>定义两个数列 $a = [a_{1},a_{2},a_{3},a_{4}…a_{n}]$ 与 $b = [b_{1},b_{2},b_{3},b_{4}…b_{n}]$的点积为：</p><script type="math/tex; mode=display">a.b = \sum_{i=1}^{n}a_{i}b_{i} = a_{1}b_{1} + a_{2}b_{2} + a_{3}b_{3} + ...+ a_{n}b_{n}</script><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  DP</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的DP，根LCS问题几乎是一样的，稍微复杂点的要注意处理负数的边界问题。</li><li>dp[i][j]表示数列1到索引<code>i</code>处，数列2到索引<code>j</code>处的点积最大值，dp的递推公式如下：<script type="math/tex; mode=display">dp[i][j] = max\left\{\begin{aligned}a_{i}b_{i} + dp[i-1][j-1] \\dp[i-1][j] \\dp[i][j-1] \\a_{i}b_{i} \\\end{aligned}\right.</script></li><li>基本上代码10行就可以搞定。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j] = nums1[i<span class="number">-1</span>]*nums2[j<span class="number">-1</span>];</span><br><span class="line">                dp[i][j] = max(dp[i][j],nums1[i<span class="number">-1</span>]*nums2[j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">1</span>) dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">1</span>) dp[i][j] = max(dp[i][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;190周周赛&quot;&gt;&lt;a href=&quot;#190周周赛&quot; class=&quot;headerlink&quot; title=&quot;190周周赛&quot;&gt;&lt;/a&gt;190周周赛&lt;/h1&gt;&lt;p&gt;本周周赛的题目出奇的简单，我这种渣渣水平都能在半个小时全部搞定。&lt;/p&gt;&lt;h2 id=&quot;5416-检查单词是否为句中其他单词的前缀&quot;&gt;&lt;a href=&quot;#5416-检查单词是否为句中其他单词的前缀&quot; class=&quot;headerlink&quot; title=&quot;5416. 检查单词是否为句中其他单词的前缀&quot;&gt;&lt;/a&gt;5416. 检查单词是否为句中其他单词的前缀&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;sentence&lt;/code&gt;作为句子并指定检索词为 &lt;code&gt;searchWord&lt;/code&gt;，其中句子由若干用 单个空格 分隔的单词组成。&lt;/p&gt;&lt;p&gt;请你检查检索词 &lt;code&gt;searchWord&lt;/code&gt;是否为句子&lt;code&gt;sentence&lt;/code&gt;中任意单词的前缀。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 189周周赛</title>
    <link href="http://yoursite.com/2020/05/18/162/"/>
    <id>http://yoursite.com/2020/05/18/162/</id>
    <published>2020-05-18T09:02:46.654Z</published>
    <updated>2020-05-18T09:05:53.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="189周周赛"><a href="#189周周赛" class="headerlink" title="189周周赛"></a>189周周赛</h1><p>还是周赛质量稍微高一些。</p><h2 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time"></a>1450. Number of Students Doing Homework at a Given Time</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given two integer arrays startTime and endTime and given an integer queryTime.</p><a id="more"></a><p>The ith student started doing their homework at the time startTime[i] and finished it at time <code>endTime[i]</code>.</p><p>Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval <code>[startTime[i], endTime[i]]</code> inclusive.</p><p>Example 1:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], endTime = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>], queryTime = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: We have <span class="number">3</span> students <span class="keyword">where</span>:</span><br><span class="line">The <span class="keyword">first</span> student started doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">1</span> <span class="keyword">and</span> finished <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">3</span> <span class="keyword">and</span> wasn't doing anything <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">4.</span></span><br><span class="line">The <span class="keyword">second</span> student started doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">2</span> <span class="keyword">and</span> finished <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">2</span> <span class="keyword">and</span> also wasn't doing anything <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">4.</span></span><br><span class="line">The <span class="keyword">third</span> student started doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">3</span> <span class="keyword">and</span> finished <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">7</span> <span class="keyword">and</span> was <span class="keyword">the</span> only student doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">4</span>], endTime = [<span class="number">4</span>], queryTime = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The only student was doing their homework at the queryTime.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">4</span>], endTime = [<span class="number">4</span>], queryTime = <span class="number">5</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], endTime = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], queryTime = <span class="number">7</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>Example 5:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], endTime = [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>], queryTime = <span class="number">5</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li><code>startTime.length == endTime.length</code></li><li><code>1 &lt;= startTime.length &lt;= 100</code></li><li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li><li><code>1 &lt;= queryTime &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接判断或者二分查找</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中的数据量非常小，我们直接判断每个区间是否包含<code>querytime</code>即可，O(n)时间复杂度内即可完成，比较简单。</li><li>另有一种比较方便的算法，可以用来计算多个<code>query</code>，可以在O(1)或者O(lgn)时间复杂度内获取多个<code>query</code>的次数。类似于左右括号匹配的办法。我们将所有的<code>startTime</code>在坐标上以<code>(</code>表示，将所有的<code>endTime</code>以<code>)</code>表示，我们遇到左括号则进行加1操作，遇到右括号则进行减1操作。</li><li>根据2的解法其实很简单，我们将所有的<code>startTime</code>和<code>endTime</code>进行排序，我们查找小于等于<code>querytime</code>的<code>startTime</code>有l个，我们查找小于<code>querytime</code>的<code>endTime</code>有r个，在此区间的则总共有<code>l - r</code>。<br><img src="https://mike-box.github.io/images/163-1.png" alt="1"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Declare Array of maximum given constraint size to</span></span><br><span class="line">        <span class="comment">// store all the overlapping intervals at any time.</span></span><br><span class="line">        <span class="comment">// Initially no intervals overlap so initialised by 0.</span></span><br><span class="line">        <span class="keyword">int</span> overlap_intervals[<span class="number">1002</span>];</span><br><span class="line">        <span class="built_in">memset</span>(overlap_intervals, <span class="number">0</span>, <span class="keyword">sizeof</span>(overlap_intervals));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For every index in start time </span></span><br><span class="line">        <span class="comment">// increment the index in array by 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : startTime) </span><br><span class="line">            overlap_intervals[i] += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Since the intervals also contains the ending points so</span></span><br><span class="line">        <span class="comment">// decrement will work at index i+1.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : endTime) </span><br><span class="line">            overlap_intervals[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Find the overlaps by using prefix sum technique</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++) </span><br><span class="line">            overlap_intervals[i+<span class="number">1</span>] += overlap_intervals[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// return the overlaps at the given query time.</span></span><br><span class="line">        <span class="keyword">return</span> overlap_intervals[queryTime];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        sort(startTime.begin(),startTime.end());</span><br><span class="line">        sort(endTime.begin(),endTime.end());</span><br><span class="line">        <span class="keyword">int</span> l = upper_bound(startTime.begin(),startTime.end(),queryTime) - startTime.begin();</span><br><span class="line">        <span class="keyword">int</span> r = lower_bound(endTime.begin(),endTime.end(),queryTime) - endTime.begin();</span><br><span class="line">        <span class="keyword">return</span> l - r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1451-Rearrange-Words-in-a-Sentence"><a href="#1451-Rearrange-Words-in-a-Sentence" class="headerlink" title="1451. Rearrange Words in a Sentence"></a>1451. Rearrange Words in a Sentence</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a sentence <code>text</code> (A sentence is a string of space-separated words) in the following format:</p><ul><li>First letter is in upper case.</li><li>Each word in <code>text</code> are separated by a single space.</li></ul><p>Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.</p><p>Return the new text following the format shown above.</p><p>Example 1:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="keyword">text</span> = <span class="string">"Leetcode is cool"</span></span><br><span class="line">Output: <span class="string">"Is cool leetcode"</span></span><br><span class="line">Explanation: There are <span class="number">3</span> <span class="keyword">words</span>, <span class="string">"Leetcode"</span> <span class="keyword">of</span> <span class="built_in">length</span> <span class="number">8</span>, <span class="string">"is"</span> <span class="keyword">of</span> <span class="built_in">length</span> <span class="number">2</span> <span class="keyword">and</span> <span class="string">"cool"</span> <span class="keyword">of</span> <span class="built_in">length</span> <span class="number">4.</span></span><br><span class="line">Output is ordered <span class="keyword">by</span> <span class="built_in">length</span> <span class="keyword">and</span> <span class="keyword">the</span> <span class="built_in">new</span> <span class="keyword">first</span> <span class="built_in">word</span> starts <span class="keyword">with</span> capital letter.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="type">text</span> = <span class="string">"Keep calm and code on"</span></span><br><span class="line">Output: <span class="string">"On and keep calm code"</span></span><br><span class="line">Explanation: Output <span class="literal">is</span> ordered <span class="keyword">as</span> follows:</span><br><span class="line"><span class="string">"On"</span> <span class="number">2</span> letters.</span><br><span class="line"><span class="string">"and"</span> <span class="number">3</span> letters.</span><br><span class="line"><span class="string">"keep"</span> <span class="number">4</span> letters <span class="keyword">in</span> <span class="keyword">case</span> <span class="keyword">of</span> tie <span class="keyword">order</span> <span class="keyword">by</span><span class="built_in"> position</span> <span class="keyword">in</span> original <span class="type">text</span>.</span><br><span class="line"><span class="string">"calm"</span> <span class="number">4</span> letters.</span><br><span class="line"><span class="string">"code"</span> <span class="number">4</span> letters.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = "To <span class="keyword">be</span> <span class="keyword">or</span> <span class="keyword">not</span> to <span class="keyword">be</span>"</span><br><span class="line">Output: "To <span class="keyword">be</span> <span class="keyword">or</span> to <span class="keyword">be</span> <span class="keyword">not</span>"</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li>text begins with a capital letter and then contains lowercase letters and single space between words.</li><li><code>1 &lt;= text.length &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/rearrange-words-in-a-sentence/" target="_blank" rel="noopener">https://leetcode.com/problems/rearrange-words-in-a-sentence/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这种题目特别无聊，就是直接暴力即可，没有一点技巧可言。</li><li>先分词，然后对所有的单词按照长度进行<code>稳定</code>排序，保证单词的顺序与原来保持一致。</li><li>再重写句子，然后将首字母改成大写。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; sv,<span class="keyword">const</span> <span class="keyword">char</span> flag = <span class="string">' '</span>)</span> </span>&#123;</span><br><span class="line">        sv.clear();</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getline(iss, temp, flag)) &#123;</span><br><span class="line">            sv.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first.size() == b.first.size()) <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        <span class="keyword">return</span> a.first.size() &lt; b.first.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">lower</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">upper</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">'a'</span>&amp;&amp; c &lt;= <span class="string">'z'</span>)||(c &gt;= <span class="string">'A'</span>&amp;&amp; c &lt;= <span class="string">'Z'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">arrangeWords</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        </span><br><span class="line">        text[<span class="number">0</span>] = lower(text[<span class="number">0</span>]);</span><br><span class="line">        split(text,words,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i)&#123;</span><br><span class="line">            arr.push_back(make_pair(words[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),cmp);</span><br><span class="line">        res += arr[<span class="number">0</span>].first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">           res += <span class="string">' '</span> + arr[i].first;</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isAlpha(res[<span class="number">0</span>]))&#123;</span><br><span class="line">            res[<span class="number">0</span>] = upper(res[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List"><a href="#1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List" class="headerlink" title="1452. People Whose List of Favorite Companies Is Not a Subset of Another List"></a>1452. People Whose List of Favorite Companies Is Not a Subset of Another List</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given the array favoriteCompanies where <code>favoriteCompanies[i]</code> is the list of favorites companies for the ith person (indexed from 0).</p><p>Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.</p><p>Example 1:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: favoriteCompanies = [[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>],[<span class="string">"google"</span>,<span class="string">"microsoft"</span>],[<span class="string">"google"</span>,<span class="string">"facebook"</span>],[<span class="string">"google"</span>],[<span class="string">"amazon"</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>] </span><br><span class="line"><span class="symbol">Explanation</span>: </span><br><span class="line"><span class="symbol">Person</span> with index=<span class="number">2</span> has favoriteCompanies[<span class="number">2</span>]=[<span class="string">"google"</span>,<span class="string">"facebook"</span>] which is a subset of favoriteCompanies[<span class="number">0</span>]=[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>] corresponding to the person with index <span class="number">0.</span> </span><br><span class="line"><span class="symbol">Person</span> with index=<span class="number">3</span> has favoriteCompanies[<span class="number">3</span>]=[<span class="string">"google"</span>] which is a subset of favoriteCompanies[<span class="number">0</span>]=[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>] and favoriteCompanies[<span class="number">1</span>]=[<span class="string">"google"</span>,<span class="string">"microsoft"</span>]. </span><br><span class="line"><span class="symbol">Other</span> lists of favorite companies are not a subset of another list, therefore, the answer is [<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>].</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: favoriteCompanies = [[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>],[<span class="string">"leetcode"</span>,<span class="string">"amazon"</span>],[<span class="string">"facebook"</span>,<span class="string">"google"</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">0</span>,<span class="number">1</span>] </span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">In</span> this case favoriteCompanies[<span class="number">2</span>]=[<span class="string">"facebook"</span>,<span class="string">"google"</span>] is a subset of favoriteCompanies[<span class="number">0</span>]=[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>], therefore, the answer is [<span class="number">0</span>,<span class="number">1</span>].</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: favoriteCompanies = [[<span class="string">"leetcode"</span>],[<span class="string">"google"</span>],[<span class="string">"facebook"</span>],[<span class="string">"amazon"</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li><code>1 &lt;= favoriteCompanies.length &lt;= 100</code></li><li><code>1 &lt;= favoriteCompanies[i].length &lt;= 500</code></li><li><code>1 &lt;= favoriteCompanies[i][j].length &lt;= 20</code></li><li>All strings in <code>favoriteCompanies[i]</code> are distinct.</li><li>All lists of favorite companies are distinct, that is, If we sort alphabetically each list then <code>favoriteCompanies[i] != favoriteCompanies[j]</code>.</li><li>All strings consist of lowercase English letters only.</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/" target="_blank" rel="noopener">https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目也是直接暴力即可，稍微用点技巧的是可以将字符串改用hash来存储，直接暴力两层循环即可。</li><li>难点在于如何判断两个<code>list</code>存在包含关系，稍微用点技巧，用hash或者双指针均可，即可在O(m)得时间复杂度完成判别。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = a.size();</span><br><span class="line">        <span class="keyword">int</span> n = b.size();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; peopleIndexes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">            sort(A[i].begin(),A[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isContain = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(contain(A[i],A[j]))&#123;</span><br><span class="line">                    isContain = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isContain) res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard"><a href="#1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard" class="headerlink" title="1453. Maximum Number of Darts Inside of a Circular Dartboard"></a>1453. Maximum Number of Darts Inside of a Circular Dartboard</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of points on a 2D plane.<br>Return the maximum number of points that are within or lie on <code>any</code> circular dartboard of radius r.</p><p>Example 1:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">-2</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">-2</span>]], r = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Circle dartboard with center <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">0</span>) <span class="keyword">and</span> radius = <span class="number">2</span> contain all points.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">-3</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">9</span>],[<span class="number">7</span>,<span class="number">8</span>]], r = <span class="number">5</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: Circle dartboard with center <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">4</span>) <span class="keyword">and</span> radius = <span class="number">5</span> contain all points except the point (<span class="number">7</span>,<span class="number">8</span>).</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">-2</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">-2</span>]], r = <span class="number">1</span></span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>]], r = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li><code>1 &lt;= points.length &lt;= 100</code></li><li><code>points[i].length == 2</code></li><li><code>-10^4 &lt;= points[i][0], points[i][1] &lt;= 10^4</code></li><li><code>1 &lt;= r &lt;= 5000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学问题</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>遇到这种图论或者数学问题果真不会解答，直接参考答案。<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Enumerate all combinations <span class="keyword">of</span> <span class="number">2</span> points,</span><br><span class="line">find <span class="keyword">the</span> circle going <span class="keyword">through</span> them <span class="keyword">with</span> radius = r.</span><br><span class="line"></span><br><span class="line">Use this circumcenter <span class="keyword">as</span> <span class="keyword">the</span> center <span class="keyword">of</span> circle,</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">count</span> how many points inside.</span><br><span class="line"></span><br><span class="line">Also explained <span class="keyword">by</span> Alexandre C:</span><br><span class="line">Basic observations :</span><br><span class="line"></span><br><span class="line">    I assume <span class="keyword">the</span> radius <span class="keyword">is</span> one,</span><br><span class="line">    <span class="keyword">since</span> <span class="keyword">it</span> doesn't change anything.</span><br><span class="line">    <span class="keyword">given</span> any two points,</span><br><span class="line">    there exists <span class="keyword">at</span> most two unit circles <span class="keyword">on</span> which they lie.</span><br><span class="line">    <span class="keyword">given</span> a solution circle <span class="keyword">to</span> your problem,</span><br><span class="line">    you can move <span class="keyword">it</span> <span class="keyword">until</span> <span class="keyword">it</span> <span class="keyword">contains</span> two points <span class="keyword">of</span> your <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">while</span> keeping <span class="keyword">the</span> same <span class="built_in">number</span> <span class="keyword">of</span> points <span class="keyword">of</span> your <span class="keyword">set</span> inside <span class="keyword">it</span>.</span><br><span class="line"></span><br><span class="line">The algorithm <span class="keyword">is</span> <span class="keyword">then</span>:</span><br><span class="line"></span><br><span class="line">    For each pair <span class="keyword">of</span> points,</span><br><span class="line">    <span class="keyword">if</span> their distance <span class="keyword">is</span> &lt; <span class="number">2</span>,</span><br><span class="line">    compute <span class="keyword">the</span> two unit circles C1 <span class="keyword">and</span> C2 <span class="keyword">that</span> pass <span class="keyword">through</span> them.</span><br><span class="line">    Compute <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> points <span class="keyword">of</span> your <span class="keyword">set</span> inside C1 <span class="keyword">and</span> C2</span><br><span class="line">    Take <span class="keyword">the</span> max.</span><br></pre></td></tr></table></figure></li><li>涉及到图论中的相关数学知识，还是没有学过。如果一个圆 C 能覆盖点集 S，当S包含两个及以上数量的点时，我们可以将园进行平移移动 C 找到一个 C’，使得 C’ 也能覆盖 S，且至少有两个点在 C’ 上。这个证明就很复杂了，感兴趣的还是看看数学定理吧。<br><img src="https://mike-box.github.io/images/163-2.png" alt="2"></li><li>现在我们已经知道园上两点的坐标和园的半径，求圆心。根据学过的解析几何，很容易将圆心的坐标求出来。实际圆心可能由两种情况，如图所示的A,B两点为可能的圆心。<br><img src="https://mike-box.github.io/images/163-4.png" alt="3"></li><li>又把解析几何稍微复习了一下，上面使一些递推公式，稍微复杂点，大意就是起点坐标加上单位向量乘以长度。推公式还是非常有意思的。<script type="math/tex; mode=display">(x^{'},y^{'}) = (x,y) + (x_{d},y_{d})*h</script></li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1 = points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y1 = points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> x2 = points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y2 = points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">double</span> d = <span class="built_in">sqrt</span>((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));</span><br><span class="line">                <span class="keyword">if</span>(d &gt; r*<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">double</span> x0 = (x1+x2)/<span class="number">2.0</span> + (y2 - y1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                <span class="keyword">double</span> y0 = (y1+y2)/<span class="number">2.0</span> - (x2 - x1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = points[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = points[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>((x0-x)*(x0-x) + (y0-y)*(y0-y) &lt;= r*r + <span class="number">0.00001</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res,count);</span><br><span class="line">                x0 = (x1+x2)/<span class="number">2.0</span> - (y2 - y1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                y0 = (y1+y2)/<span class="number">2.0</span> + (x2 - x1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = points[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = points[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>((x0-x)*(x0-x) + (y0-y)*(y0-y) &lt;= r*r + <span class="number">0.00001</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;189周周赛&quot;&gt;&lt;a href=&quot;#189周周赛&quot; class=&quot;headerlink&quot; title=&quot;189周周赛&quot;&gt;&lt;/a&gt;189周周赛&lt;/h1&gt;&lt;p&gt;还是周赛质量稍微高一些。&lt;/p&gt;&lt;h2 id=&quot;1450-Number-of-Students-Doing-Homework-at-a-Given-Time&quot;&gt;&lt;a href=&quot;#1450-Number-of-Students-Doing-Homework-at-a-Given-Time&quot; class=&quot;headerlink&quot; title=&quot;1450. Number of Students Doing Homework at a Given Time&quot;&gt;&lt;/a&gt;1450. Number of Students Doing Homework at a Given Time&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given two integer arrays startTime and endTime and given an integer queryTime.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 26周双周赛</title>
    <link href="http://yoursite.com/2020/05/17/161/"/>
    <id>http://yoursite.com/2020/05/17/161/</id>
    <published>2020-05-16T16:09:54.635Z</published>
    <updated>2020-05-16T16:10:00.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="26周双周赛"><a href="#26周双周赛" class="headerlink" title="26周双周赛"></a>26周双周赛</h1><p>前三题非常简单，最后一题稍微复杂点。</p><h2 id="5396-连续字符"><a href="#5396-连续字符" class="headerlink" title="5396. 连续字符"></a>5396. 连续字符</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。</p><p>请你返回字符串的能量。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子字符串 <span class="string">"ee"</span> 长度为 <span class="number">2</span> ，只包含字符 'e' 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abbcccddddeeeeedcba"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：子字符串 <span class="string">"eeeee"</span> 长度为 <span class="number">5</span> ，只包含字符 'e' 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"triplepillooooow"</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"hooraaaaaaaaaaay"</span></span><br><span class="line">输出：<span class="number">11</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"tourist"</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li>s 只包含小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/consecutive-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/consecutive-characters/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力滑动窗口统计相同的字符数目即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPower</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">char</span> curr = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == curr)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = max(res,count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                curr = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res,count);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5397-最简分数"><a href="#5397-最简分数" class="headerlink" title="5397. 最简分数"></a>5397. 最简分数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>，请你返回所有 <code>0</code>到 <code>1</code> 之间（不包括 0 和 1）满足分母小于等于  <code>n</code>的 最简 分数 。分数可以以 任意 顺序返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：[<span class="string">"1/2"</span>]</span><br><span class="line">解释：<span class="string">"1/2"</span> 是唯一一个分母小于等于 <span class="number">2</span> 的最简分数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"1/2"</span>,<span class="string">"1/3"</span>,<span class="string">"2/3"</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">4</span></span><br><span class="line">输出：[<span class="string">"1/2"</span>,<span class="string">"1/3"</span>,<span class="string">"1/4"</span>,<span class="string">"2/3"</span>,<span class="string">"3/4"</span>]</span><br><span class="line">解释：<span class="string">"2/4"</span> 不是最简分数，因为它可以化简为 <span class="string">"1/2"</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 100</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/simplified-fractions/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/simplified-fractions/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中的<code>n</code>最大只有100，所以根本就不用技巧了，直接暴力求出所有可能的分数，然后化简分数，去掉重复的数即可。</li><li>去重的方法有很多种，我这里用的hash。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; simplifiedFractions(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; count;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> g = __gcd(i,j);</span><br><span class="line">                <span class="keyword">int</span> x = i/g;</span><br><span class="line">                <span class="keyword">int</span> y = j/g;</span><br><span class="line">                <span class="built_in">string</span> s = to_string(x) + <span class="string">"/"</span> + to_string(y);</span><br><span class="line">                count.insert(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : count)&#123;</span><br><span class="line">            res.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5398-统计二叉树中好节点的数目"><a href="#5398-统计二叉树中好节点的数目" class="headerlink" title="5398. 统计二叉树中好节点的数目"></a>5398. 统计二叉树中好节点的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵根为 <code>root</code> 的二叉树，请你返回二叉树中好节点的数目。</p><p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：图中蓝色节点为好节点。</span><br><span class="line">根节点 (<span class="number">3</span>) 永远是个好节点。</span><br><span class="line">节点 <span class="number">4</span> -&gt; (<span class="number">3</span>,<span class="number">4</span>) 是路径中的最大值。</span><br><span class="line">节点 <span class="number">5</span> -&gt; (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) 是路径中的最大值。</span><br><span class="line">节点 <span class="number">3</span> -&gt; (<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>) 是路径中的最大值。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：节点 <span class="number">2</span> -&gt; (<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>) 不是好节点，因为 <span class="string">"3"</span> 比它大。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：根节点是好节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>二叉树中节点数目范围是<code>[1, 10^5]</code>。</li><li>每个节点权值的范围是 <code>[-10^4, 10^4]</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/count-good-nodes-in-binary-tree/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目咋一看貌似很复杂，实际一分析非常简单，直接DFS搞定。</li><li>DFS时每次传输从根节点到该节点路劲上的最大值，判断当前的节点的值是否大于等于路径的最大值即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="keyword">int</span> maxCurr,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt;= maxCurr)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxCurr = max(root-&gt;val,maxCurr);</span><br><span class="line">        dfs(root-&gt;left,maxCurr,res);</span><br><span class="line">        dfs(root-&gt;right,maxCurr,res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        dfs(root,INT_MIN,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5399-数位成本和为目标值的最大数字"><a href="#5399-数位成本和为目标值的最大数字" class="headerlink" title="5399. 数位成本和为目标值的最大数字"></a>5399. 数位成本和为目标值的最大数字</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code>。请你返回满足如下规则可以得到的 最大 整数：</p><ul><li>给当前结果添加一个数位<code>（i + 1）</code>的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li><li>总成本必须恰好等于 <code>target</code>。</li><li>添加的数位中没有数字 0 。</li></ul><p>由于答案可能会很大，请你以字符串形式返回。</p><p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>], target = <span class="number">9</span></span><br><span class="line">输出：<span class="string">"7772"</span></span><br><span class="line">解释：添加数位 '<span class="number">7</span>' 的成本为 <span class="number">2</span> ，添加数位 '<span class="number">2</span>' 的成本为 <span class="number">3</span> 。所以 <span class="string">"7772"</span> 的代价为 <span class="number">2</span>*<span class="number">3</span>+ <span class="number">3</span>*<span class="number">1</span> = <span class="number">9</span> 。 <span class="string">"997"</span> 也是满足要求的数字，但 <span class="string">"7772"</span> 是较大的数字。</span><br><span class="line"> 数字     成本</span><br><span class="line">  <span class="number">1</span>  -&gt;   <span class="number">4</span></span><br><span class="line">  <span class="number">2</span>  -&gt;   <span class="number">3</span></span><br><span class="line">  <span class="number">3</span>  -&gt;   <span class="number">2</span></span><br><span class="line">  <span class="number">4</span>  -&gt;   <span class="number">5</span></span><br><span class="line">  <span class="number">5</span>  -&gt;   <span class="number">6</span></span><br><span class="line">  <span class="number">6</span>  -&gt;   <span class="number">7</span></span><br><span class="line">  <span class="number">7</span>  -&gt;   <span class="number">2</span></span><br><span class="line">  <span class="number">8</span>  -&gt;   <span class="number">5</span></span><br><span class="line">  <span class="number">9</span>  -&gt;   <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">8</span>], target = <span class="number">12</span></span><br><span class="line">输出：<span class="string">"85"</span></span><br><span class="line">解释：添加数位 '<span class="number">8</span>' 的成本是 <span class="number">7</span> ，添加数位 '<span class="number">5</span>' 的成本是 <span class="number">5</span> 。<span class="string">"85"</span> 的成本为 <span class="number">7</span> + <span class="number">5</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>], target = <span class="number">5</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">解释：总成本是 target 的条件下，无法生成任何整数。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>], target = <span class="number">47</span></span><br><span class="line">输出：<span class="string">"32211"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>cost.length == 9</code></li><li><code>1 &lt;= cost[i] &lt;= 5000</code></li><li><code>1 &lt;= target &lt;= 5000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/form-largest-integer-with-digits-that-add-up-to-target/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/form-largest-integer-with-digits-that-add-up-to-target/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  0-1背包问题</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的0-1背包问题，给定的重量下，有无数的货物，如何取货物使得背包的价值最大。</li><li>在这里背包的重量即为<code>target</code>,每个货物的重量即为<code>cost</code>,价值即为组成的数。</li><li>稍微复杂点的数如何表示，假设我们直接用字符串来表示已经取得货物的价值时，肯定会出现内存超出或者超时的问题，仔细分析一下，我们用一个数据统计已经取得所有数目<code>1~9</code>的个数。每次进行价值比较时，我们首先比较数字的个数，如果数字的个数相同，则比较数目的大小即可，具体可以参考代码。</li><li>直接dp即可。<script type="math/tex; mode=display">dp[i] = max(dp[i],dp[i-cost[j]] + j)</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnta = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cntb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            cnta += a[i];</span><br><span class="line">            cntb += b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnta &gt; cntb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnta &lt; cntb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(b[i] &gt; a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">generNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i]; ++j)&#123;</span><br><span class="line">                res += to_string(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(target+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>,<span class="number">-1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">9</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= cost[j<span class="number">-1</span>] &amp;&amp; valid(dp[i-cost[j<span class="number">-1</span>]]))&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev = dp[i-cost[j<span class="number">-1</span>]];</span><br><span class="line">                    prev[j]++;</span><br><span class="line">                    <span class="keyword">if</span>(!valid(dp[i])||compare(prev,dp[i]))&#123;</span><br><span class="line">                        dp[i] = prev;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!valid(dp[target])) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> generNum(dp[target]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;26周双周赛&quot;&gt;&lt;a href=&quot;#26周双周赛&quot; class=&quot;headerlink&quot; title=&quot;26周双周赛&quot;&gt;&lt;/a&gt;26周双周赛&lt;/h1&gt;&lt;p&gt;前三题非常简单，最后一题稍微复杂点。&lt;/p&gt;&lt;h2 id=&quot;5396-连续字符&quot;&gt;&lt;a href=&quot;#5396-连续字符&quot; class=&quot;headerlink&quot; title=&quot;5396. 连续字符&quot;&gt;&lt;/a&gt;5396. 连续字符&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。&lt;/p&gt;&lt;p&gt;请你返回字符串的能量。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：子字符串 &lt;span class=&quot;string&quot;&gt;&quot;ee&quot;&lt;/span&gt; 长度为 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; ，只包含字符 &#39;e&#39; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;abbcccddddeeeeedcba&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：子字符串 &lt;span class=&quot;string&quot;&gt;&quot;eeeee&quot;&lt;/span&gt; 长度为 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; ，只包含字符 &#39;e&#39; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;triplepillooooow&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;hooraaaaaaaaaaay&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 5：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;tourist&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 算法课程《Algorithms on Graphs》</title>
    <link href="http://yoursite.com/2020/05/10/160/"/>
    <id>http://yoursite.com/2020/05/10/160/</id>
    <published>2020-05-10T12:09:15.322Z</published>
    <updated>2020-05-10T12:09:20.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithmic-Graphs"><a href="#Algorithmic-Graphs" class="headerlink" title="Algorithmic Graphs"></a>Algorithmic Graphs</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，已经把第二部分课程《Algorithmic Toolbox》学习完了，图的前5章比较简单，除了有几道题目稍微比较<code>trikly</code>以外，其余的都是比较容易的题目。得分是<code>100</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/TS4US3YKWDB6" target="_blank" rel="noopener">Algorithms on Graphs</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20graphs" target="_blank" rel="noopener">source code</a><br>总的来说，这个课程比另外两个课程简单一些，当然还有最后一节图的高级应用，还是稍微复杂一些，目前正在学习中。</p><a id="more"></a><h2 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h2><h3 id="1-Problem-Finding-an-Exit-from-a-Maze"><a href="#1-Problem-Finding-an-Exit-from-a-Maze" class="headerlink" title="1. Problem: Finding an Exit from a Maze"></a>1. Problem: Finding an Exit from a Maze</h3><p>A maze is a rectangular grid of cells with walls between some of adjacent cells.<br>You would like to check whether there is a path from a given cell to a given<br>exit from a maze where an exit is also a cell that lies on the border of the maze<br>(in the example shown to the right there are two exits: one on the left border<br>and one on the right border). For this, you represent the maze as an undirected<br>graph: vertices of the graph are cells of the maze, two vertices are connected by<br>an undirected edge if they are adjacent and there is no wall between them. Then,<br>to check whether there is a path between two given cells in the maze, it suffices to<br>check that there is a path between the corresponding two vertices in the graph.<br><strong>Task</strong>. Given an undirected graph and two distinct vertices 𝑢 and 𝑣, check if there is a path between 𝑢 and 𝑣.<br><strong>Input Format</strong>. An undirected graph with 𝑛 vertices and 𝑚 edges. The next line contains two vertices 𝑢<br>and 𝑣 of the graph.<br><strong>Constraints</strong>. 2 ≤ 𝑛 ≤ 103; 1 ≤ 𝑚 ≤ 103; 1 ≤ 𝑢, 𝑣 ≤ 𝑛; 𝑢 ̸= 𝑣.<br><strong>Output Format</strong>. Output 1 if there is a path between 𝑢 and 𝑣 and 0 otherwise.</p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> BFS</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>最基本的BFS路径搜索<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;adj, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">  visit.insert(x);</span><br><span class="line">  qu.push(x);</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line">      <span class="keyword">if</span>(curr == y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">          <span class="keyword">if</span>(visit.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">          qu.push(v);</span><br><span class="line">          visit.insert(v);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; reach(adj, x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Problem-Adding-Exits-to-a-Maze"><a href="#2-Problem-Adding-Exits-to-a-Maze" class="headerlink" title="2 Problem: Adding Exits to a Maze"></a>2 Problem: Adding Exits to a Maze</h3><p><strong>Task</strong>. Given an undirected graph with 𝑛 vertices and 𝑚 edges, compute the number of connected components in it.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 103.<br><strong>Output Format</strong>. Output the number of connected components.</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.最基本的查找图的连通单元，用BFS或者并查集实现均可。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_components</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(visit.count(i)) <span class="keyword">continue</span>;</span><br><span class="line">      qu.push(i);</span><br><span class="line">      visit.insert(i);</span><br><span class="line">      res++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">          <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">          qu.pop();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">              <span class="keyword">if</span>(visit.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">              qu.push(v);</span><br><span class="line">              visit.insert(v);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_components(adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><p>第一题比较简单</p><h3 id="2-Determining-an-Order-of-Courses"><a href="#2-Determining-an-Order-of-Courses" class="headerlink" title="2. Determining an Order of Courses"></a>2. Determining an Order of Courses</h3><p><strong>Task</strong>. Compute a topological ordering of a given directed acyclic graph (DAG) with 𝑛 vertices and 𝑚 edges.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105, 0 ≤ 𝑚 ≤ 105. The given graph is guaranteed to be acyclic.<br><strong>Output Format</strong>. Output any topological ordering of its vertices. (Many DAGs have more than just one topological ordering. You may output any of them.)</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>很直接的拓扑排序<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;used, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;order, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; toposort(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; used(adj.size(), <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(adj.size(),<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  <span class="comment">//write your code here  </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">          indegree[adj[i][j]]++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">          qu.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">      order.push_back(curr);</span><br><span class="line">      qu.pop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">          indegree[v]--;</span><br><span class="line">          <span class="keyword">if</span>(indegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">              qu.push(v);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order = toposort(adj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; order.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; order[i] + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Advanced-Problem-Checking-Whether-Any-Intersection-in-a-City"><a href="#3-Advanced-Problem-Checking-Whether-Any-Intersection-in-a-City" class="headerlink" title="3. Advanced Problem: Checking Whether Any Intersection in a City"></a>3. Advanced Problem: Checking Whether Any Intersection in a City</h3><p><strong>Task</strong>. Compute the number of strongly connected components of a given directed graph with 𝑛 vertices and<br>𝑚 edges.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 104, 0 ≤ 𝑚 ≤ 104.<br><strong>Output Format</strong>. Output the number of strongly connected components.</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>求有向图的连通分量，SCC算法。先用DFS遍历图，并且将图的节点保存到栈中，然后每次从栈中弹出一个元素，DFS遍历遍历逆向图即可，得到SCC分量。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; adj,<span class="keyword">int</span> curr,<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp; s,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">        visit[v] = <span class="literal">true</span>;</span><br><span class="line">        dfs1(adj,v,s,visit);</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(curr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; adj,<span class="keyword">int</span> curr,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">        visit[v] = <span class="literal">true</span>;</span><br><span class="line">        dfs2(adj,v,visit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_strongly_connected_components</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; adj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = adj.size();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; post;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reverseAdj(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit1(n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit2(n,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">            reverseAdj[adj[i][j]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit1[i]) <span class="keyword">continue</span>;</span><br><span class="line">        visit1[i] = <span class="literal">true</span>;</span><br><span class="line">        dfs1(adj,i,post,visit1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!post.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = post.top();</span><br><span class="line">        post.pop();</span><br><span class="line">        <span class="keyword">if</span>(visit2[curr]) <span class="keyword">continue</span>;</span><br><span class="line">        visit2[curr] = <span class="literal">true</span>;</span><br><span class="line">        result++;</span><br><span class="line">        dfs2(reverseAdj,curr,visit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_strongly_connected_components(adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week-3-Paths-in-Graphs"><a href="#week-3-Paths-in-Graphs" class="headerlink" title="week 3 Paths in Graphs"></a>week 3 Paths in Graphs</h2><p>dijistra求最短距离</p><h3 id="1-Problem-Computing-the-Minimum-Number-of-Flight-Segments"><a href="#1-Problem-Computing-the-Minimum-Number-of-Flight-Segments" class="headerlink" title="1. Problem: Computing the Minimum Number of Flight Segments"></a>1. Problem: Computing the Minimum Number of Flight Segments</h3><p><strong>Task</strong>. Given an undirected graph with 𝑛 vertices and 𝑚 edges and two vertices 𝑢 and 𝑣, compute the length of a shortest path between 𝑢 and 𝑣 (that is, the minimum number of edges in a path from 𝑢 to 𝑣).<br><strong>Input Format</strong>. A graph is given in the standard format. The next line contains two vertices 𝑢 and 𝑣.<br><strong>Constraints</strong>. 2 ≤ 𝑛 ≤ 105, 0 ≤ 𝑚 ≤ 105, 𝑢 ̸= 𝑣, 1 ≤ 𝑢, 𝑣 ≤ 𝑛.<br><strong>Output Format</strong>. Output the minimum number of edges in a path from 𝑢 to 𝑣, or −1 if there is no path.</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>BFS遍历图，求最短路径。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line"></span><br><span class="line">  qu.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">          qu.pop();</span><br><span class="line">          <span class="keyword">if</span>(curr == t) <span class="keyword">return</span> step;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">              <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">              qu.push(v);</span><br><span class="line">              visit[v] = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      step++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> s, t;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  s--, t--;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance(adj, s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Problem-Checking-whether-a-Graph-is-Bipartite"><a href="#2-Problem-Checking-whether-a-Graph-is-Bipartite" class="headerlink" title="2. Problem: Checking whether a Graph is Bipartite"></a>2. Problem: Checking whether a Graph is Bipartite</h3><p><strong>Task</strong>. Given an undirected graph with 𝑛 vertices and 𝑚 edges, check whether it is bipartite.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105, 0 ≤ 𝑚 ≤ 105.<br><strong>Output Format</strong>. Output 1 if the graph is bipartite and 0 otherwise.</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>BFS遍历即可，非常简单，leetcode也有原题。<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> WHITE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BLACK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; color(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  qu.push(make_pair(<span class="number">0</span>,WHITE));</span><br><span class="line">  visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  color[<span class="number">0</span>] = WHITE;</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      pii curr = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr.first])&#123;</span><br><span class="line">          <span class="keyword">if</span>(visit[v])&#123;</span><br><span class="line">              <span class="keyword">if</span>(color[curr.first] == color[v]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          qu.push(make_pair(v,!curr.second));</span><br><span class="line">          visit[v] = <span class="literal">true</span>;</span><br><span class="line">          color[v] = !curr.second;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bipartite(adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Paths-in-Graphs"><a href="#week4-Paths-in-Graphs" class="headerlink" title="week4: Paths in Graphs"></a>week4: Paths in Graphs</h2><p>这章主要是dijistra算法和bellman ford算法</p><h3 id="Problem-Detecting-Anomalies-in-Currency-Exchange-Rates"><a href="#Problem-Detecting-Anomalies-in-Currency-Exchange-Rates" class="headerlink" title="Problem: Detecting Anomalies in Currency Exchange Rates"></a>Problem: Detecting Anomalies in Currency Exchange Rates</h3><p><strong>Task</strong>. Given an directed graph with possibly negative edge weights and with 𝑛 vertices and 𝑚 edges, check<br>whether it contains a cycle of negative weight.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 104, edge weights are integers of absolute value at most 103.<br><strong>Output Format</strong>. Output 1 if the graph contains a cycle of negative weight and 0 otherwise.</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol><li>直接用dijistra算法求最短距离即可<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::priority_queue;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;cost, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code her</span></span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,INT_MAX);</span><br><span class="line">  <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line"></span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  qu.push(make_pair(s,<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      pii curr = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[curr.first].size(); ++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> v = adj[curr.first][i];</span><br><span class="line">          <span class="keyword">int</span> w = cost[curr.first][i];</span><br><span class="line">          <span class="keyword">if</span>((curr.second + w) &lt; dist[v])&#123;</span><br><span class="line">              dist[v] = curr.second + w;</span><br><span class="line">              qu.push(make_pair(v,dist[v]));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    cost[x - <span class="number">1</span>].push_back(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> s, t;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  s--, t--;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance(adj, cost, s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Problem-Detecting-Anomalies-in-Currency-Exchange-Rates"><a href="#2-Problem-Detecting-Anomalies-in-Currency-Exchange-Rates" class="headerlink" title="2. Problem: Detecting Anomalies in Currency Exchange Rates"></a>2. Problem: Detecting Anomalies in Currency Exchange Rates</h3><p><strong>Task</strong>. Given an directed graph with possibly negative edge weights and with 𝑛 vertices and 𝑚 edges, check<br>whether it contains a cycle of negative weight.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 104, edge weights are integers of absolute value at most 103.<br><strong>Output Format</strong>. Output 1 if the graph contains a cycle of negative weight and 0 otherwise.</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ol><li>求图中是否有和为负的有向环，直接BF算法。先进行<code>v-1</code>次循环对边进行叠加，再进行一次循环进行迭代，经过V次循环后，如果发现仍有边可以迭代，则认为此时该图中存在负的有向环。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Edge(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;u = u;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">relax</span><span class="params">(Edge &amp; e,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; dist,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; parent)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negative_cycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = adj.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent(n,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check edges*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">            edges.push_back(Edge(i,adj[i][j],cost[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bell-man */</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.size(); ++j)&#123;</span><br><span class="line">          <span class="keyword">int</span> u = edges[j].u;</span><br><span class="line">          <span class="keyword">int</span> v = edges[j].v;</span><br><span class="line">          <span class="keyword">int</span> w = edges[j].weight;</span><br><span class="line">          <span class="keyword">if</span>(dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">              dist[v] = w + dist[u];</span><br><span class="line">              parent[v] = u;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check cycle*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edges[i].u;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i].v;</span><br><span class="line">        <span class="keyword">int</span> w = edges[i].weight;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;u&lt;&lt;":"&lt;&lt;v&lt;&lt;" ="&lt;&lt;w&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    cost[x - <span class="number">1</span>].push_back(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; negative_cycle(adj, cost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Advanced-Problem-Exchanging-Money-Optimally"><a href="#3-Advanced-Problem-Exchanging-Money-Optimally" class="headerlink" title="3. Advanced Problem: Exchanging Money Optimally"></a>3. Advanced Problem: Exchanging Money Optimally</h3><strong>Task</strong>. Given an directed graph with possibly negative edge weights and with 𝑛 vertices and 𝑚 edges as well as its vertex 𝑠, compute the length of shortest paths from 𝑠 to all other vertices of the graph.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 104, 1 ≤ 𝑠 ≤ 𝑛, edge weights are integers of absolute value at most 109.<br><strong>Output Format</strong>. For all vertices 𝑖 from 1 to 𝑛 output the following on a separate line:<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4></li><li>这个题目也比较简单，<code>bellman-ford</code>算法，先进行V次迭代后，将所有还可继续迭代的节点入队列，然后用BFS算法，将所有这些可迭代的点遍历，所有可以达到的点，都认为不存在最小值。<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::priority_queue;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Edge(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;u = u;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shortest_paths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;cost, <span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;distance, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;reachable, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;shortest)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = adj.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dist(n,INT_MAX);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent(n,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check edges*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">            edges.push_back(Edge(i,adj[i][j],cost[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bell-man */</span></span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.size(); ++j)&#123;</span><br><span class="line">          <span class="keyword">int</span> u = edges[j].u;</span><br><span class="line">          <span class="keyword">int</span> v = edges[j].v;</span><br><span class="line">          <span class="keyword">int</span> w = edges[j].weight;</span><br><span class="line">          <span class="keyword">if</span>(dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">              dist[v] = w + dist[u];</span><br><span class="line">              parent[v] = u;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check cycle*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> u = edges[i].u;</span><br><span class="line">      <span class="keyword">int</span> v = edges[i].v;</span><br><span class="line">      <span class="keyword">int</span> w = edges[i].weight;</span><br><span class="line">      <span class="comment">// get all relaxed node</span></span><br><span class="line">      <span class="keyword">if</span>(dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">          visit.insert(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : visit)&#123;</span><br><span class="line">        qu.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">            qu.push(v);</span><br><span class="line">            visit.insert(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check answer*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i] == INT_MAX)&#123;</span><br><span class="line">            reachable[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reachable[i] = <span class="number">1</span>;</span><br><span class="line">            distance[i] = dist[i];</span><br><span class="line">            <span class="keyword">if</span>(visit.count(i)) shortest[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    cost[x - <span class="number">1</span>].push_back(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">  s--;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; distance(n, <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;::max());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reachable(n, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortest(n, <span class="number">1</span>);</span><br><span class="line">  shortest_paths(adj, cost, s, distance, reachable, shortest);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reachable[i]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!shortest[i]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week5-Dynamic-Programming-1"><a href="#week5-Dynamic-Programming-1" class="headerlink" title="week5:Dynamic Programming 1"></a>week5:Dynamic Programming 1</h2><p>本章为动态规划，比较简单。前面4道题目都非常简单，最后一题稍微难点。</p><h3 id="Problem-Building-Roads-to-Connect-Cities"><a href="#Problem-Building-Roads-to-Connect-Cities" class="headerlink" title="Problem: Building Roads to Connect Cities"></a>Problem: Building Roads to Connect Cities</h3><p><strong>Task</strong>. Given 𝑛 points on a plane, connect them with segments of minimum total length such that there is a<br>path between any two points. Recall that the length of a segment with endpoints (𝑥1, 𝑦1) and (𝑥2, 𝑦2)<br>is equal to<br>√︀<br>(𝑥1 − 𝑥2)2 + (𝑦1 − 𝑦2)2.<br><strong>Input Format</strong>. The first line contains the number 𝑛 of points. Each of the following 𝑛 lines defines a point<br>(𝑥𝑖, 𝑦𝑖).<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 200; −103 ≤ 𝑥𝑖, 𝑦𝑖 ≤ 103 are integers. All points are pairwise different, no three<br>points lie on the same line.<br><strong>Output Format</strong>. Output the minimum total length of segments. The absolute value of the difference<br>between the answer of your program and the optimal value should be at most 10−6. To ensure this,<br>output your answer with at least seven digits after the decimal point (otherwise your answer, while<br>being computed correctly, can turn out to be wrong because of rounding issues).</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><ol><li>典型的<code>kruskal</code>最小生成树，求最短距离。</li><li>重点考察对并查集的应用，<code>kruskal</code> 算法中常用的求最短距离。<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> d)&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">      <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">      <span class="keyword">this</span>-&gt;d = d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">        x = f[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">    <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">    <span class="keyword">if</span>(x1 == y1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    f[x1] = y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">minimum_distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">  priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> distance = [&amp;](<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x[p1]-x[p2],<span class="number">2</span>) + <span class="built_in">pow</span>(y[p1]-y[p2],<span class="number">2</span>));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      f[i] = i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">          pq.push(Node(i,j,distance(i,j)));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">      Node curr = pq.top();</span><br><span class="line">      pq.pop();</span><br><span class="line">      <span class="keyword">int</span> x = curr.x;</span><br><span class="line">      <span class="keyword">int</span> y = curr.y;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(find(f,x) == find(f,y)) <span class="keyword">continue</span>;</span><br><span class="line">      uni(f,x,y);</span><br><span class="line">      result += curr.d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(n), y(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">10</span>) &lt;&lt; minimum_distance(x, y) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Partitioning-Souvenirs"><a href="#2-Partitioning-Souvenirs" class="headerlink" title="2 Partitioning Souvenirs"></a>2 Partitioning Souvenirs</h3><p><strong>Task</strong>. Given 𝑛 points on a plane and an integer 𝑘, compute the largest possible value of 𝑑 such that the<br>given points can be partitioned into 𝑘 non-empty subsets in such a way that the distance between any<br>two points from different subsets is at least 𝑑.<br><strong>Input Format</strong>. The first line contains the number 𝑛 of points. Each of the following 𝑛 lines defines a point<br>(𝑥𝑖, 𝑦𝑖). The last line contains the number 𝑘 of clusters.<br><strong>Constraints</strong>. 2 ≤ 𝑘 ≤ 𝑛 ≤ 200; −103 ≤ 𝑥𝑖, 𝑦𝑖 ≤ 103 are integers. All points are pairwise different.<br><strong>Output Format</strong>. Output the largest value of 𝑑. The absolute value of the difference between the answer of<br>your program and the optimal value should be at most 10−6. To ensure this, output your answer with<br>at least seven digits after the decimal point (otherwise your answer, while being computed correctly,<br>can turn out to be wrong because of rounding issues).</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ol><li>典型的<code>kruskal</code>算法的变种，求最短距离时进行集合合并。</li><li>当合并的单元到达<code>k</code>时，求出最长满足要求的边即可。<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> distance;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Node(<span class="keyword">double</span> d,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;distance = d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=f[x]) x = f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">    <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">    f[x1] = y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.distance &gt; b.distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countCluster</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.size(); ++i)&#123;</span><br><span class="line">        visit.insert(find(f,i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)visit.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">clustering</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> d = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="keyword">int</span> count = n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">  priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      f[i] = i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">          <span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x[i]-x[j],<span class="number">2</span>) + <span class="built_in">pow</span>(y[i]-y[j],<span class="number">2</span>));</span><br><span class="line">          pq.push(Node(d,i,j));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(!pq.empty() &amp;&amp; count &gt;= k)&#123;</span><br><span class="line">      Node curr = pq.top();</span><br><span class="line">      pq.pop();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> x = curr.x;</span><br><span class="line">      <span class="keyword">int</span> y = curr.y;</span><br><span class="line">      <span class="keyword">if</span>(find(f,x) != find(f,y))&#123;</span><br><span class="line">          uni(f,x,y);</span><br><span class="line">          count--;   </span><br><span class="line">      &#125;</span><br><span class="line">      d = max(d,curr.distance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(n), y(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">10</span>) &lt;&lt; clustering(x, y, k) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithmic-Graphs&quot;&gt;&lt;a href=&quot;#Algorithmic-Graphs&quot; class=&quot;headerlink&quot; title=&quot;Algorithmic Graphs&quot;&gt;&lt;/a&gt;Algorithmic Graphs&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，已经把第二部分课程《Algorithmic Toolbox》学习完了，图的前5章比较简单，除了有几道题目稍微比较&lt;code&gt;trikly&lt;/code&gt;以外，其余的都是比较容易的题目。得分是&lt;code&gt;100&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/TS4US3YKWDB6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Algorithms on Graphs&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20graphs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;br&gt;总的来说，这个课程比另外两个课程简单一些，当然还有最后一节图的高级应用，还是稍微复杂一些，目前正在学习中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Algorithms on Graphs》" scheme="http://yoursite.com/tags/%E3%80%8AAlgorithms-on-Graphs%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 181周比赛</title>
    <link href="http://yoursite.com/2020/05/10/159/"/>
    <id>http://yoursite.com/2020/05/10/159/</id>
    <published>2020-05-10T09:31:20.124Z</published>
    <updated>2020-05-10T09:31:26.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="181周比赛"><a href="#181周比赛" class="headerlink" title="181周比赛"></a>181周比赛</h1><p>周赛的题目质量果真非常高。</p><h2 id="5404-用栈操作构建数组"><a href="#5404-用栈操作构建数组" class="headerlink" title="5404. 用栈操作构建数组"></a>5404. 用栈操作构建数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个目标数组 <code>target</code>和一个整数 <code>n</code>。每次迭代，需要从  <code>list = {1,2,3..., n}</code> 中依序读取一个数字。</p><p>请使用下述操作来构建目标数组 <code>target</code> ：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Push：从 </span>list 中读取一个新元素， 并将其推入数组中。</span><br><span class="line"><span class="keyword">Pop：删除数组中的最后一个元素。</span></span><br><span class="line"><span class="keyword">如果目标数组构建完成，就停止读取更多元素。</span></span><br></pre></td></tr></table></figure><br>题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。</p><a id="more"></a><p>请返回构建目标数组所用的操作序列。</p><p>题目数据保证答案是唯一的。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">3</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Push"</span>,<span class="string">"Pop"</span>,<span class="string">"Push"</span>]</span><br><span class="line">解释： </span><br><span class="line">读取 <span class="number">1</span> 并自动推入数组 -&gt; [<span class="number">1</span>]</span><br><span class="line">读取 <span class="number">2</span> 并自动推入数组，然后删除它 -&gt; [<span class="number">1</span>]</span><br><span class="line">读取 <span class="number">3</span> 并自动推入数组 -&gt; [<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Push"</span>,<span class="string">"Push"</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Push"</span>]</span><br><span class="line">解释：只需要读取前 <span class="number">2</span> 个数字就可以停止。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Pop"</span>,<span class="string">"Push"</span>,<span class="string">"Push"</span>,<span class="string">"Push"</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><pre><code>1 &lt;= target.length &lt;= 1001 &lt;= target[i] &lt;= 1001 &lt;= n &lt;= 100target 是严格递增的</code></pre><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/build-an-array-with-stack-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/build-an-array-with-stack-operations</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>记录当前的最大值，如果发现当前的值小于序列的值，则进行”push”和“pop”双操作。</li><li>如果当前的值等于序列的值，则只进行<code>push</code>操作即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; buildArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; target[i])&#123;</span><br><span class="line">                res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                res.push_back(<span class="string">"Pop"</span>);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start == target[i])&#123;</span><br><span class="line">                res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5405-形成两个异或相等数组的三元组数目"><a href="#5405-形成两个异或相等数组的三元组数目" class="headerlink" title="5405. 形成两个异或相等数组的三元组数目"></a>5405. 形成两个异或相等数组的三元组数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组<code>arr</code> 。</p><p>现需要从数组中取三个下标 <code>i、j</code>和 k ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p><p><code>a</code>和 <code>b</code>定义如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = arr[i]<span class="regexp"> ^</span> arr[i + <span class="number">1</span>]<span class="regexp"> ^</span> ...<span class="regexp"> ^</span> arr[j - <span class="number">1</span>]</span><br><span class="line">b = arr[j]<span class="regexp"> ^</span> arr[j + <span class="number">1</span>]<span class="regexp"> ^</span> ...<span class="regexp"> ^</span> arr[k]</span><br></pre></td></tr></table></figure><br>注意：^ 表示 按位异或 操作。</p><p>请返回能够令 <code>a == b</code> 成立的三元组<code>(i, j , k)</code> 的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：满足题意的三元组分别是 (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>), (<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) 以及 (<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">17</span>,<span class="number">22</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>&lt;= arr.length &lt;= <span class="number">300</span></span><br><span class="line"><span class="symbol">1 </span>&lt;= arr[i] &lt;= <span class="number">10</span>^<span class="number">8</span></span><br></pre></td></tr></table></figure><br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学运算</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们可以数学运算公式如下：<script type="math/tex; mode=display">xor(i,j) = arr[i]\bigoplus arr[i+1]\bigoplus arr[i+2]\bigoplus arr[i+3]\bigoplus arr[i+4]\bigoplus arr[i+5]\bigoplus... arr[j]\bigoplus</script>我们知道假如<script type="math/tex; mode=display">a \bigoplus b = 0</script>则一定是可以得到<strong>a == b</strong>.</li><li>实际过程中，我们可以按照如下将<code>xor(i,j) = 0</code>按照如下来分解：<script type="math/tex; mode=display">xor(i,j) = \left\{\begin{aligned}xor(i,i)\bigoplus xor(i+1,j) = 0 \\xor(i,i+1)\bigoplus xor(i+2,j)  = 0\\xor(i,i+2)\bigoplus xor(i+3,j)  = 0\\...                           \\xor(i,j-2)\bigoplus xor(j-1,j) = 0 \\xor(i,j-1)\bigoplus xor(j,j) = 0 \\\end{aligned}\right.</script>按照我们的推算则应该有如下等式成立：<script type="math/tex; mode=display">\left\{\begin{aligned}xor(i,i) ==  xor(i+1,j) \\xor(i,i+1) ==  xor(i+2,j) \\xor(i,i+2) ==  xor(i+3,j) \\...                           \\xor(i,j-2) == xor(j-1,j)  \\xor(i,j-1) == xor(j,j)  \\\end{aligned}\right.</script>因此总共有<code>j-i</code>种组合满足题目要求。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mask(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            mask[i+<span class="number">1</span>] = mask[i]^arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = arr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                curr = curr^arr[j];</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">                    res += j - i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5406-收集树上所有苹果的最少时间"><a href="#5406-收集树上所有苹果的最少时间" class="headerlink" title="5406. 收集树上所有苹果的最少时间"></a>5406. 收集树上所有苹果的最少时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵有 n 个节点的无向树，节点编号为 0 到 n-1 ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 节点 0 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p><p>无向树的边由<code>edges</code> 给出，其中 <code>edges[i] = [fromi, toi]</code>，表示有一条边连接 <code>from</code>和<code>toi</code>。除此以外，还有一个布尔数组 <code>hasApple</code>，其中 <code>hasApple[i] = true</code>代表节点<code>i</code>有一个苹果，否则，节点<code>i</code>没有苹果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], hasApple = [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">输出：<span class="number">8</span> </span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], hasApple = [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], hasApple = [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n-1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= fromi, toi &lt;= n-1</code></li><li><code>fromi &lt; toi</code></li><li><code>hasApple.length == n</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们知道每次从根节点下去取孩子节点的苹果时，都会有两步上下操作，因此我们每次判断发现本次的当前节点的孩子节点的子树有苹果存在时，则将路径+2.</li><li>采用DFS即可，我们每次返回子树是否有苹果，如果有苹果存在，则加2.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; apples,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> hasapple = <span class="literal">false</span>;        </span><br><span class="line">        <span class="keyword">if</span>(apples[curr]) hasapple = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(v,tree,apples,res))&#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                hasapple = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasapple;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tree;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            tree[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>,tree,hasApple,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5407-切披萨的方案数"><a href="#5407-切披萨的方案数" class="headerlink" title="5407. 切披萨的方案数"></a>5407. 切披萨的方案数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>rows x cols</code>大小的矩形披萨和一个整数 k ，矩形包含两种字符：<code>&#39;A&#39;</code>（表示苹果）和 ‘.’ （表示空白格子）。你需要切披萨 <code>k-1</code>次，得到 <code>k</code> 块披萨并送给别人。</p><p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p><p>请你返回确保每一块披萨包含 至少 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 <code>10^9 + 7</code>取余的结果。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pizza = [<span class="string">"A.."</span>,<span class="string">"AAA"</span>,<span class="string">"..."</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pizza = [<span class="string">"A.."</span>,<span class="string">"AA."</span>,<span class="string">"..."</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pizza = [<span class="string">"A.."</span>,<span class="string">"A.."</span>,<span class="string">"..."</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= rows, cols &lt;= <span class="number">50</span></span><br><span class="line">rows == pizza.length</span><br><span class="line">cols == pizza[i].length</span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= <span class="number">10</span></span><br><span class="line">pizza 只包含字符 <span class="string">'A'</span> 和 <span class="string">'.'</span> 。</span><br></pre></td></tr></table></figure></p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  DP</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>设递推公式<code>dp[i][j][k]</code>代表从左上定点<code>(i,j)</code>与右下顶点<code>(m,n)</code>组成的矩形，切分<code>k</code>次的方案数，很容易想到递推公式:<script type="math/tex; mode=display">dp[x][y][k] = \left\{\begin{aligned}\sum_{i=x+1}^{m-1}dp[i][y][k-1] \qquad if(sum[x][y] - sum[i][y] > 0) \\\sum_{j=y+1}^{n-1}dp[x][j][k-1] \qquad if(sum[x][y] - sum[x][j] > 0) \\\end{aligned}\right.</script></li><li><code>sum</code>代表后缀和，<code>sum[i][j]</code>代表从<code>(i,j)</code>到<code>(m,n)</code>组成的矩形中苹果的总数目。<script type="math/tex; mode=display">sum[x][y] = \sum_{i=x}^{m}\sum_{j=y}^{n}matrix[i][j]</script><script type="math/tex; mode=display">sum[x][y] = sum[x][y+1] + sum[x+1][y] - sum[x+1][y+1] + matrix[x][y]</script>题目其实仔细分析下来挺简单的，就是写的时候稍微复杂点。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pizza.size();</span><br><span class="line">        <span class="keyword">int</span> n = pizza[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[M][M][k];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sum(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*prefix sum*/</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="keyword">sizeof</span>(dp),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                sum[i][j] = sum[i+<span class="number">1</span>][j] + sum[i][j+<span class="number">1</span>] - sum[i+<span class="number">1</span>][j+<span class="number">1</span>] + (pizza[i][j] == <span class="string">'A'</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(sum[i][j] &gt; <span class="number">0</span>) dp[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; k; ++s)&#123;</span><br><span class="line">                    <span class="comment">/*cut row*/</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t = i+<span class="number">1</span>; t &lt; m; ++t)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum[i][j] - sum[t][j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][s] = (dp[i][j][s] + dp[t][j][s<span class="number">-1</span>])%mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*cut col*/</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t = j+<span class="number">1</span>; t &lt; n; ++t)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum[i][j] - sum[i][t] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][s] = (dp[i][j][s] + dp[i][t][s<span class="number">-1</span>])%mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;181周比赛&quot;&gt;&lt;a href=&quot;#181周比赛&quot; class=&quot;headerlink&quot; title=&quot;181周比赛&quot;&gt;&lt;/a&gt;181周比赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量果真非常高。&lt;/p&gt;&lt;h2 id=&quot;5404-用栈操作构建数组&quot;&gt;&lt;a href=&quot;#5404-用栈操作构建数组&quot; class=&quot;headerlink&quot; title=&quot;5404. 用栈操作构建数组&quot;&gt;&lt;/a&gt;5404. 用栈操作构建数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个目标数组 &lt;code&gt;target&lt;/code&gt;和一个整数 &lt;code&gt;n&lt;/code&gt;。每次迭代，需要从  &lt;code&gt;list = {1,2,3..., n}&lt;/code&gt; 中依序读取一个数字。&lt;/p&gt;&lt;p&gt;请使用下述操作来构建目标数组 &lt;code&gt;target&lt;/code&gt; ：&lt;br&gt;&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Push：从 &lt;/span&gt;list 中读取一个新元素， 并将其推入数组中。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Pop：删除数组中的最后一个元素。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;如果目标数组构建完成，就停止读取更多元素。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
